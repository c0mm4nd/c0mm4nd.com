<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>具有同态值的比特币 bitcoins with homomorphic value</title>
    <url>/post/bitcoins-with-homomorphic-value/</url>
    <content><![CDATA[<p><a href="https://bitcointalk.org/index.php?topic=305791.0" target="_blank" rel="noopener">原文链接</a></p>
<p>我已经不停地研究了几个月，因为它本身似乎是一个有趣的结构，是支付隐私的另一个不同的方面（例如，从用户的角度来看，或者如果我们希望商业实体能够从可审计但对商业敏感的信息中获取信息， 使用智能合约），而且除了可以直接使用以外，它还可以实现一些我们尚未想到的功能，或者可以提高ZeroCoin之类想法的效率（我不知道如何使用，但似乎与之相关 ）。</p>
<span id="more"></span>

<p>出发点是，据我们所知可以进行加法同态加密（additively homomorphic encryption），并且还存在基于小于的零知识证明（即下文ZK小于证明）。 （证明$E(a)+ E(b)&#x3D; E(a+b)$还不够，您还必须证明攻击者在此过程中没有将n加到他的余额上，因为加法是除n的模）。计算小于2的幂的效率更高，但是通过组合可以得到任意值（毕竟，所有值都可以从2的幂范围构建而成）。</p>
<p>这两个（同态加和ZK小于证明）均基于已建立的保守加密假设，但是小于的通用ZKP很大（数字签名大小的证明数量与log(v)成比例，其中$v&#x3D;\log_2(n \div vmax)+1&#x3D;\log_2(n)-\log_2(vmax)+1$，因此在比特币中$\log_2(n)&#x3D;256$，vmax取决于编码，但有2100万BTC小于$2^{51}$聪。 而且可能还很慢，因为它涉及验证v签名。</p>
<p>本来我以为这会变得缓慢而笨拙（有点像零币），所以我一直在讨论是否以及直到找到可行的有效方法为止。 贝里·斯科恩马克斯（Berry Schoenmakers）的效率也比ZKP差（他从来没有费心写过论文，natch）。 但是，在我看来，这是基于为Schnorr组选择非标准p＆q的更非标准的假设，并且也不适用于椭圆曲线，因此对ECDSA无效（仅对Schnorr（DSA是其变体））。</p>
<p>但是最后我认为我看到了比特币使用和验证硬币值的缺失步骤，您只需要证明每个硬币的两个最高有效位为0，并使用设置$vmax&lt;2^{254}$的编码即可（即提高比特币精度） 从51位到254位，私密密钥超出&lt;$2^{51}$聪之外的次要有效位，即提供203位安全性的编码，高于提供128位安全性的P256的ECDSA的安全性。</p>
<p>因此，最终有了一种不费吹灰之力的方式来处理EC-Schnorr签名，每个输入和输出的成本仅为2 ECS信号（成本和大小与ECDSA相同），其中#input &lt; 4和#output &lt; 4 。 对于#input &gt; 3，您还需要显示例如$ZKPoK \{ (a+b+c, d): a+b+c &lt; 2^{254}, d &lt; 2^{254} \}$，如果#output&gt; 3，则显示相同。 因此，2个$k + 2\log_3(k)$签名用于k个输入或输出。 （3因为$2^{254} \times 3 &lt; n$但$2^{254} \times 4 &gt; n$。）</p>
<p>顺便说一句，在ECDSA IMO上使用ECS是有充分的理由的，IMO仍然较为保守和简单，而且DSA都基于此。因为它更简单（没有* k ^ -1步骤），所以它更灵活并且轻松地支持多方签名（n of n）甚至阈值签名（k of n），从而允许在一个ECS签名的空间内进行多重签名（甚至不公开其存在）在n的k中，也没有k或n的偶数），有一些论点认为ECS在关于哈希属性的假设中比ECDSA更安全。要使用ECDSA进行多方访问是一个研究主题，即使多方DSA也非常复杂，并且取决于同构加密实例的安全性，该同等加密实例的大小足以容纳涉及q的幂的临时结果，例如具有大密钥的paillier密码系统和偶数阈值DSA。更复杂的Damgard-Jurik扩展了Paillier方案。 ECS的灵活性使其在许多方面都具有更大的灵活性，例如，基于表示问题（这是对Pederson承诺的一种概括，其本身是schnorr的一种概括）的零知识选择性披露和品牌证书的盲目认证功能。使用Brands证书进行智能合约可以做很多事情，通过使用布尔公式的ZK证明等来保留依赖智能合约的人的属性的隐私。</p>
<p>同样，为每个值额外签名的成本，您甚至可以拥有无条件的值保密性。 （即，一个假设的功能强大的实体能够以最小的努力执行离散日志，仍然无法告诉您您支付了多少钱）。 这是因为像OTP一样，所有可能的值都是同等可能的，例如，在pederson承诺，两个基点G, H然后$xG+yH$存在x和y的所有可能值的n个可能解（其中x是密钥，y是一个可以证明事情的价值）。 强大的对手只能解决并找到所有可能性，但您公开记录的ZKP并不会显示您知道哪个x值，也不会显示您转移的y。</p>
<p>目前将发布更多的加密级别细节，也许还会发布基于openSSL的实现。</p>
<p>亚当</p>
<hr>
<p>因此，如果您假设x知识的ZK证明存在（语法$x_i$是x的第i位，即LSB从0开始），那么$ZKPoK\{(x): x_i &#x3D; 0\}$可以检查两个通过使用$ZKPoK{(x): x_{255} &#x3D; 0 \And x_{254} &#x3D; 0}$，有效位为0。</p>
<p>该证明适用于某些组中的值，我们使用schnorr组的EC实例（例如DSA，相同的键，参数，但签名更简单； DSA是Schnorr签名变体，与原始AFAIK相比没有任何优点，而我提到了许多缺点）在OP中）。因此，我们将调用值x，其中前两位必须为0 $x_{255} &#x3D; x_{254} &#x3D; 0$，并且$x_{253 … x202}$是以“聪”为单位的值（与现有精度相同）以及剩下的值$x_{201..x0}$是私钥。</p>
<p>xG将是公共的，并且也是币的公钥（与现有的比特币地址的公钥略有不同）。现在人们可以验证加密的输入值(A，B)等于加密的输出值(X，C)和费用f，其中X是加密支出，C是加密更改，而f是费用，因为$A &#x3D; aG$和$A + B &#x3D; X + C + fG$，因为$aG + bG &#x3D; xG + cG + fG$。这将强制$a + b \mod n &#x3D; x + c + f \mod n$。发送者必须包括$ZKPoK\{(a，b): a_{255} &#x3D; a_{254} &#x3D; 0\}$。发送者还必须加密x并将其发送给接收者，以便他依次花钱时可以证明有关它的信息。 f是公开的，因为任何人都必须能够通过采矿活动将其收集并附加到其地址上。</p>
<p>当接收者花费xG时，他将不得不类似地证明$x_{255} &#x3D; x_{254} &#x3D; 0$。</p>
<p>我们需要两位的原因是因为n不是2的幂。为简单起见，我们说$n &#x3D; 250$。现在假设$a &#x3D; 3$，$b &#x3D; 1$，但是我们必须加n来防止欺诈，因为$a + b + n &#x3D; 254$，$(a + b + n) \mod n &#x3D; 4$，且$x &#x3D; 127，c &#x3D; 126，f &#x3D; 1$，因此仅检查最高位1可以通过n由于$a + b + n &#x3D; (x + c + f) \mod n$即$3 + 1 &#x3D; (127 + 126 + 1) \mod 250$就能伪造价值。攻击者在没有使用$msb \neq 0$的任何值的情况下将其值增加了250（减去1手续费）。如果我们证明前两位为0，则最多可以防止3次输入攻击。 （因为$3 * 64 &lt;250$；但4次输入不行，因为$4 * 64&gt; 250$）。因此，对于3个以上的输入，我们还证明了3元表达式树中的每个中间计算也具有两个msbits &#x3D; 0。例如Z(x)是$ZKPoK\{(x): x_{255} &#x3D; 0和x_{254} &#x3D; 0\}$的简写，Z(a)，Z(b)，Z(c)，Z(a + b + c)，Z(d)，Z(e)，Z(f)，Z(d + e + f)，Z(g)，Z(h)，Z(i)，Z(g + h + i)，Z((a + b + c)+(d + e + f)+(g + h + i))，因此正如我提到的，对于k个输入，必须有$k + log_3(k)$对证明（对，因为有一个对$x_{255} &#x3D; 0$，$x_{254} &#x3D; 1$）。</p>
<p>最后请注意，证明知识是一种签名，因此原则上您可以在得到他人认可的情况下向他人支付现有余额，而不是将值的控制权转移到新地址。也就是说，说您的收款人已经有余额y，并且您想为他们添加x，然后向他们透露x（通过为他们的公钥加密），然后他们就可以添加，因此您可以用以下方式替换硬币地址：现有余额以节省签名和密钥。</p>
<p>例如$ZKPoK[Y]\{(a，b，x，y，c), f：a + b &#x3D; x + c + f \And Z(a) \And Z(b) \And Z(y）\}, E(x) $</p>
<p>其中[Y]表示与PoK结合的某些信息的辅助签名。因此，发件人绑定了他的X支出，表示可以将其添加到现有余额Y中（发件人不知道y）。</p>
<p>现在，区块验证将允许接收者将其余额替换为$Y’&#x3D; Y + X &#x3D;(x + y)G$。当发送方为接收方加密值x时，他现在可以进行转账。</p>
<p>通过将污点作为环转移的一种方式花在一些其他用户身上，也可以实现污染混合（尽管在规模上并不便宜）。 （环签名是一种方案，您可以在未经其许可的情况下将其他签名者隐含为签名的可能的发起者，其中发起者希望在可能的作者中隐藏其身份）。因此，这有点像coinjoin，但是您不需要其他用户的积极协作。如果E（值）是脱链的（例如，直接发送给接收者），则接收者可能会甚至可能无法使用额外的值，如果他不知道尘埃值（他只能通过参考先前的余额来拒绝它），但这并不能证明他仍然可以保留它-很难证明它是否定的。）我们可以选择将其附加到链上（以一定的大小代价），甚至可以加密，并带有证明收件人可以解密的证据。 （很容易证明$xG &#x3D; xH$，其中$H &#x3D; yG$，证明者不知道y，因此EC Egamal可以提供可证明的可解密值，在这种情况下，该软件可以合并硬币并阻止所有者使用较早版本）。</p>
<p>（尘埃是一个现在被认为很小的值，但是由于$x_{202..0}$由发送方随机分配，并且没有DL能力就无法计算，因此必须将其传达给接收方，以使其具有价值。）</p>
<p>通过开采，原始硬币的已知价值为25个比特币（且无尘），但是接收者仍然可以安全地使用它，而无需人们通过保留尘埃作为零钱来消除其当前余额（他可能永远不会花掉，因为它实际上是可忽略的小数的nano satoshi值）。</p>
<hr>
<p><em>验证节点如何将输入和输出值相加以确定费用？ 这是我唯一不清楚的部分。 网络不需要知道$输出总和-输入总和$吗？</em></p>
<p>与当前不同，您将必须明确传达费用，并让其作为输入与输出的总和进行验证。 （在我的第二篇文章中显示了f的通信，而输入a，b和输出x（支出）和c（更改）是加密形式的，但是可以证明A + B &#x3D; X + C + fG。</p>
<p>亚当</p>
<hr>
<p><em>您打算如何证明高两位为零？ 我认为没有人知道如何对小于，位提取或mod x之类的内容进行有效的ZK证明。 有通用的ZK方案，例如Pinocchio和TinyRAM，但它们很昂贵。 你有什么考虑？</em></p>
<p>是的，给我一个机会我会实现这个。</p>
<p>小于1的现有ZKP使用0或1的证明作为构建基块（这就是为什么它们效率低下，它们根据范围执行了数十次）。 即，为了证明$x \leq 5 &#x3D; 101b$的模数，对于n &#x3D; 257（一个9位素数）的说明，他们证明$x &#x3D; 000000101b$，首先证明$x &lt;100b$，方法是证明前6位为0，然后通过证明$xG-4G$的前8位为0来证明$xG-4G &#x3D; 01b \leq 1$。</p>
<p>亚当</p>
<p>我认为，Brands PhD论文&#x2F;MIT新闻书“重新思考公共密钥基础结构”的第3章提供了说明&#x2F;脚注&#x2F;参考，可以免费下载。 它的一个组成部分是ZK范围证明或ZK小于证明。</p>
<p><a href="http://www.credentica.com/the_mit_pressbook.html" target="_blank" rel="noopener">http://www.credentica.com/the_mit_pressbook.html</a></p>
<p>有空的话，我将其写出来。 （暂离一段时间）。</p>
<p>亚当</p>
]]></content>
      <tags>
        <tag>bitcointalk</tag>
        <tag>bitcoin</tag>
        <tag>crypto</tag>
        <tag>autonomy</tag>
        <tag>done</tag>
      </tags>
  </entry>
  <entry>
    <title>Wasm Runtime的创作: Build Wasm Runtime</title>
    <url>/post/build-wasm-runtime/</url>
    <content><![CDATA[<p>因为NGIN的contract系统也就是智能合约上需要嵌入的wasm engine支持fee cost on opcode(instr)，因此需要从wasmtime迁移到其他引擎。</p>
<p>虽然说找到了<a href="https://github.com/perlin-network/life" target="_blank" rel="noopener">life</a>完全符合我们的需要，但毕竟是人家的项目而且在host func嵌入的方面不如wasmtime顺手。</p>
<p>既然是从头做起(from scratch)的项目，那么再多做个wasm runtime应该也不过分。</p>
<span id="more"></span>

<h2 id="Compilation-x2F-Execution-modes"><a href="#Compilation-x2F-Execution-modes" class="headerlink" title="Compilation&#x2F;Execution modes"></a>Compilation&#x2F;Execution modes</h2><p>从<a href="https://github.com/appcypher/awesome-wasm-runtimes" target="_blank" rel="noopener">awesome-wasm-runtimes</a>的项目介绍里可以看到life的编译&#x2F;执行模式是Interpreted，而wasmtime是JIT。</p>
<p>其实还有个叫AOT的，像Lucet这个引擎就是用的AOT。</p>
<p>Interpreted顾名思义就是被“解释”，就类似脚本语言那样一句一句地输入并执行。换句话说就是引擎会读取源码或IR（介于高级语言和二进制机器码之间的中间表达，比如bytecode，wasm binary可以认为是IR）并立即把这些语句执行掉。</p>
<p>JIT一边读取源代码或IR，一边对已读取内容飞速编译再执行，即在执行时编译。可以认为是JIT是对内容与当前执行环境做了优化之后再进行执行。</p>
<p>AOT则接近gcc这种编译器。AOT在程序执行之前进行完整编译。</p>
<p>所以很明显JIT引擎在优化后很容易比Interpreted快很多，wagon和wasmtime，wasmer的<a href="https://github.com/wasmerio/wasmer-go#benchmarks" target="_blank" rel="noopener">速度根本没法比</a>(虽然也有语言速度上差距)。但是从wasmtime的issue记录来看负优化也不是没有。</p>
<p>因此从当前目标来看其实我们只需要先完成一个解释器，然后再通过编写compiler去对内容再做优化（JIT）。</p>
<h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>这里我们选择的是<a href="https://www.w3.org/TR/wasm-core-1/" target="_blank" rel="noopener">w3c的wasm标准</a>，也就是version1。</p>
<p>其中的Values，Modules等内容在别的wasm内容中也提过了所以不多说。</p>
<p>最为关键的在于如何将一个Module给实例化为Instance且通过Call一个mainFunc的方式跑起来。</p>
<h2 id="Compile-x2F-Interpret"><a href="#Compile-x2F-Interpret" class="headerlink" title="Compile&#x2F;Interpret"></a>Compile&#x2F;Interpret</h2><p>本质上就是需要将wasm解释为机械码然后跑起来。</p>
<p>在将module实力化之前，我们需要对module中内容进行解析，构建出一个索引空间，用来快速访问我们需要的内容（其实也就function，global，table，memory）。这个内容也可能是外部module提供的，因此也需要提供externModules。</p>
]]></content>
      <tags>
        <tag>wasm</tag>
        <tag>wasi</tag>
        <tag>runtime</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>chain confirm time</title>
    <url>/post/chain-confirm-time/</url>
    <content><![CDATA[<p>汇总一些<em>实践上</em>各链上交易的确认时间</p>
<span id="more"></span>

<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在对链上数据进行多线程录入(即同步到数据库)的过程中,这些确认时间可以作为线程数以防止出现对账户之类状态的deadlock</p>
<h2 id="确认数"><a href="#确认数" class="headerlink" title="确认数"></a>确认数</h2><table>
<thead>
<tr>
<th align="left">链</th>
<th align="right">确认数(交易后区块高度)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BTC</td>
<td align="right">4</td>
</tr>
<tr>
<td align="left">ETH</td>
<td align="right">20</td>
</tr>
<tr>
<td align="left">LTC</td>
<td align="right">12</td>
</tr>
<tr>
<td align="left">XMR</td>
<td align="right">15</td>
</tr>
<tr>
<td align="left">EOS</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">XRP</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">SOL</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">LSK</td>
<td align="right">303</td>
</tr>
<tr>
<td align="left">DOT</td>
<td align="right">25</td>
</tr>
<tr>
<td align="left">FIL</td>
<td align="right">200</td>
</tr>
<tr>
<td align="left">TRON</td>
<td align="right">20</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>表中为实践上的确认数,必大于理论上确认数(例如,ETH理论为7,为设计时预计的5min)</p>
<p>实际的确认时间&#x3D;确认数 * 预计区块时间</p>
<p>预计区块时间可以在源码或Wiki里找到</p>
<p>Token的确认时间&#x3D;Token所在链的交易确认时间</p>
<p>有些家大业大有矿池的交易所(如OK,币安),为了提高客户体验,会减少BTC等”利益一致”币的确认时间</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://support.kraken.com/hc/en-us/articles/203325283-Cryptocurrency-deposit-processing-times" target="_blank" rel="noopener">kraken交易所</a><br><a href="https://www.reddit.com/r/ethereum/comments/4eplsv/how_many_confirms_is_considered_safe_in_ethereum/" target="_blank" rel="noopener">How many confirms is considered ‘safe’ in Ethereum?</a><br><a href="https://developers.circle.com/docs/confirmations" target="_blank" rel="noopener">Circle钱包</a><br><a href="https://www.okex.com/support/hc/en-us/articles/360000205532-Token-Confirmation-Requirements-Blockchain-Explorers" target="_blank" rel="noopener">OKEX交易所</a></p>
]]></content>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitcontracts: Supporting Smart Contracts in Legacy Blockchains</title>
    <url>/post/bitcontracts/</url>
    <content><![CDATA[<h1 id="Bitcontracts：传统区块链上支持智能合约"><a href="#Bitcontracts：传统区块链上支持智能合约" class="headerlink" title="Bitcontracts：传统区块链上支持智能合约"></a>Bitcontracts：传统区块链上支持智能合约</h1><p><strong>摘要：</strong>在本文中，我们提出了 Bitcontracts，这是一种新颖的解决方案，可以在未修改的传统加密货币（如原生不支持合约的比特币）之上安全高效地执行通用智能合约。我们解决方案的出发点是一个链下执行模型，其中合约的发行者指定一组服务提供商来执行合约的代码。如果法定数量的服务提供商报告相同的结果，并且客户可以自由选择他们信任和使用哪些此类合约，则合约的执行结果被接受。本文的主要技术贡献是如何在不修改底层区块链的情况下安全高效地实现这样的信任模型。我们还确定了区块链系统必须支持的一组通用属性，以便可以安全地添加富有表现力的智能合约，并根据这些标准分析流行的现有区块链。</p>
<span id="more"></span>

<h2 id="I-引言"><a href="#I-引言" class="headerlink" title="I. 引言"></a>I. 引言</h2><p>由以太坊 [48] 等系统推广的智能合约允许在没有受信任的第三方的情况下实现几乎任意的业务逻辑。智能合约是代码和执行结果记录在链上的程序。典型的合约使合约参与者能够将资金加载到由合约代码控制的地址或帐户，该代码定义了稍后如何将加载的资金从合约中移出。</p>
<p>将合约添加到货币中。虽然智能合约的概念已经显示出巨大的前景，但许多当前流行的加密货币，例如比特币 [36]、莱特币、瑞波币 [2] 或<br>Stellar [3]，本身不支持它们。因此，调查是否可以将合同执行功能添加到此类区块链变得很重要。由于这样的区块链平台已经吸引了大量的投资、用户和开发者，通常最好通过合约执行来扩展这些平台，而不是尝试将现有用户、资产和投资迁移到其他平台。</p>
<p>使用新的合约执行能力扩展现有区块链的另一个原因是，即使某些现有平台支持合约，但可以在这些系统上实施的合约类型可能会受到严重限制。例如，以太坊使用图灵完备的编程语言，但由于内置区块 gas 限制，可以实现为合约的计算复杂度非常有限</p>
<p>在本文中，我们的主要目标是设计一种解决方案，将富有表现力的智能合约执行支持作为子系统添加到现有的传统区块链系统中。我们解决方案的主要用途是增强像比特币这样没有内置智能合约功能的系统。次要用途是扩展像以太坊这样支持合约但对允许计算的复杂度有严重限制的平台的合约执行能力</p>
<p><strong>之前的工作</strong>。最近的研究探索了为区块链添加合约执行功能的不同方法。例如，Arbitrum [25] 和 ACE [50] 使用链下执行模型，其中合约发行者指定一组负责执行合约并将结果传达回链的经理。 Hyperledger Fabric [5] 在具有执行-订单-验证架构的许可设置中使用类似的模型，在该架构中，交易在排序之前执行。这种解决方案的主要缺点是它们是专门构建的新系统，因此在不修改底层区块链的情况下，此类系统无法部署在遗留系统上。</p>
<p>另一个提案 FastKitten [16] 依赖于飞地执行和抵押品，但仅支持仅限于已知参与者的短期合约。此外，这样的系统不能容忍飞地妥协。最近发现的攻击 [11]、[45]、[29]、[13]、[44] 表明 TEE 妥协是一个相关的威胁。我们在第 II-B 节中更详细地讨论了先前解决方案的局限性。</p>
<p><strong>我们的解决方案</strong>。在本文中，我们提出了一个新的系统，称为<br>Bitcontracts 为传统加密货币添加了富有表现力的智能合约执行功能，而不需要对传统系统进行协议更改，并克服了以前解决方案的主要限制</p>
<p>我们解决方案的起点是一个链下执行模型，类似于之前的系统，如 Arbitrum、ACE 或 Fabric。在 Bitcontracts 中，合约发行者指定一组执行合约代码的服务提供者。指定的执行集与合约代码一起记录在链上，合约参与者可以自由选择是否接受该集。与要求所有服务提供商就执行结果达成一致（如 Arbitrum 中所做的那样）或完全信任执行环境（如 FastKitten 中所要求的）不同，我们利用了类似于 ACE 的更灵活的基于仲裁的信任模型，其中执行结果当 n 个服务提供商中的 t 个报告相同的结果时被接受。这样的模型可以提供强大的安全性（最多 t-1 个服务提供商可能会受到损害）和良好的可用性（最多 n-t 个服务提供商可能没有响应）。</p>
<p>我们解决的主要技术挑战是如何安全高效地实现这种信任模型，而不需要对底层的传统区块链平台进行任何修改。为了实现这一点，Bitcontracts 利用了以下两个想法。我们的第一个观察是，通过将每个合约的状态存储在链上，服务提供者可以保持无状态，这降低了协议的复杂性并简化了部署，因为服务提供者不需要彼此通信并且不必运行昂贵的（在通信条款）共识协议，以就合同的当前状态达成一致，这使我们的解决方案高效。我们的第二个观察是，通过将每个执行结果的有效性绑定到链的最新有效状态，我们可以启用任意仲裁大小并防止竞争条件，即对手为影响同一合约的不同执行结果获得两个可接受的仲裁。由于这些观察，Bitcontracts 没有实例化新的共识协议。相反，Bitcontracts 是有目的地设计的，它通过利用底层遗留区块链的现有共识协议来保证执行完整性和可序列化性。我们使用执行顺序模型来做到这一点，该模型确保（在排序时）只有可序列化的交易才能包含在链中。这是与 Hyperledger Fabric 的 order-execute-validate 架构的一个关键区别，它需要一个额外的验证步骤，如果没有协议更改，则无法将其改装到传统区块链中。我们在第 II-B 节中更详细地讨论了这一点。</p>
<p>Bitcontracts 不需要更改底层的传统区块链，只要它支持四个通用属性。第一个属性是辅助存储，用于在链上存储合约状态。通过将数据编码为遗留事务，可以实现辅助存储。第二种是集体授权，大多数区块链都支持作为多重签名交易。第三个是状态依赖，它确保我们的解决方案中的可序列化。所有基于 UTXO 的系统都隐式支持状态依赖性，并且可以在大多数基于帐户的系统中明确强制执行。第四个属性是事务原子性，它使合约能够安全地执行复杂的操作。</p>
<p>我们分析了流行的加密货币，包括比特币、莱特币、Zcash、以太坊、Ripple 和 Stellar，并表明大多数流行的区块链部署都支持这些属性。在少数情况下，当缺少其中一个属性时，我们会解释如何轻松添加它们。</p>
<p>最后，我们从三个方面分析Bitcontracts 。首先，我们解释了如何在像 Bitcontracts 这样的解决方案中通过执行费用和订阅模型等标准手段来激励合约执行。其次，我们证明了 Bitcontracts 在我们选择的灵活信任模型下提供了强大的安全性和活性保证。第三，我们实现了一个 Bitcontracts 原型，它在未修改的比特币和其他传统加密货币之上运行 Python 合约，并表明所涉及的交易费用很小（例如，每次调用合约只需几美分）。我们还通过从 13 万个以太坊区块中抓取数据并利用 100 个最受欢迎的以太坊合约中的合约调用交易来评估Bitcontracts 与以太坊的交易规模和成本。我们得出的结论是，在 Bitcontracts 中运行流行的智能合约是实用的——而且通常比在以太坊中更便宜。</p>
<p><strong>贡献和路线图</strong>。 总而言之，在本文中，我们做出了以下贡献：</p>
<ul>
<li>新解决方案：我们提出Bitcontracts，在未经修改的传统加密货币上实现安全、高效和富有表现力的智能合约（第三和第四部分）。</li>
<li>需求分析：我们确定区块链需要提供的最小属性集以允许表达智能合约并基于此标准分析现有区块链（第 V 部分）。</li>
<li>Bitcontracts 分析：我们解释了如何在Bitcontracts 中添加激励措施（第六部分）； 我们证明了 Bitcontracts 提供了安全性和活跃性（第 VII 节）； 我们提供与比特币兼容的 Bitcontracts 实现（第 VIII 节）； 我们评估了 Bitcontracts 在流行区块链平台上的执行成本，并分析了 Bitcontracts 中执行流行的现实世界智能合约的成本（第 IX 节）。</li>
</ul>
<h2 id="II-问题陈述"><a href="#II-问题陈述" class="headerlink" title="II. 问题陈述"></a>II. 问题陈述</h2><p>在本节中，我们激励我们的工作并解释以前解决方案的局限性。</p>
<h3 id="A-动机"><a href="#A-动机" class="headerlink" title="A. 动机"></a>A. 动机</h3><p>区块链技术吸引了大量的商业兴趣，主要集中在智能合约及其应用上（有关简要背景，请参阅附录 A）。</p>
<p>存在部署智能合约的三个基本选项：第一个是使用现有的区块链平台，如提供内置合约支持的以太坊。二是打造新的区块链平台。第三个选项——我们在本文中研究的——是将合约执行能力改造为现有的和未修改的遗留区块链。</p>
<p>使用新的合约执行功能增强现有平台的原因有很多。</p>
<p>第一个原因是像比特币这样的平台已经聚集了大量的投资和用户群。例如，在撰写本文时（2020 年 6 月），比特币的市值占整个区块链市场的一半以上 [1]。将所有投资资金和现有用户迁移到新平台既昂贵又复杂。</p>
<p>第二个原因是成功推出一个新的区块链平台很难。一个功能齐全的区块链平台需要一个完整的生态系统，包括开发者、工具、矿工、投资者、用户、客户等。从头开始引导所有这些非常昂贵并且可能会失败。</p>
<p>第三个原因是现有的支持智能合约的区块链平台对可以实现的计算类型有很大的限制。例如，以太坊的 gas 限制将合约限制为非常简单和简短的计算。在许多商业用例中，运行比以太坊目前允许的更复杂的计算是可取的。</p>
<p>第四，现有的智能合约平台基于专用（通常是利基）编程语言。比如以太坊在实践中需要使用 Solidity 或者 Vyper hat 可以编译成 EVM 字节码1。大多数开发人员更熟悉 Python 或 Java 等通用语言。如果开发人员可以使用他们最喜欢的编程语言来编写智能合约，并且如果可以在不同的智能合约平台上重复使用相同的合约代码，他们就会受益。</p>
<p>鉴于这些原因，我们在本文中的主要目标是为现有的传统区块链添加富有表现力的智能合约执行功能，其次要目标是使开发人员能够使用他们喜欢的编程语言编写合约。</p>
<p>我们专注于启用以太坊风格的智能合约，这可能是“智能合约”一词最常见的定义。在附录 A 中，我们讨论了以太坊风​​格的智能合约与其他类型的链上计算（例如对私有数据进行操作的计算）的比较。</p>
<h3 id="B-先前解决方案的局限性"><a href="#B-先前解决方案的局限性" class="headerlink" title="B. 先前解决方案的局限性"></a>B. 先前解决方案的局限性</h3><p><strong>侧链执行</strong>。使用附加功能扩展传统货币的一种已知方法是使用侧链。存在一些针对不同用例的侧链机制建议。例如，Liquid [19] 旨在实现快速资产转移，但不提供富有表现力的智能合约。 Rootstock (RSK) [30] 使用基于与比特币价值挂钩的自有货币 (RBTC) 的侧链为比特币启用智能合约。这是通过仅在先前在多重签名条件下将相同数量的 BTC 锁定到一组阈值可信方时才发行一定数量的 RBTC 来实现的。然后可以在 RSK 侧链上运行智能合约并使用 RBTC 执行付款。侧链——无论其目的如何——通常需要对一组固定的各方（甚至单个受信方）进行信任 [41]，而不是允许合约参与者在每个合约的基础上接受信任假设。这意味着只有用户信任同一组参与者的合约才能在同一侧链上共存，并且不同链上的合约之间不可能进行交互。另外，就使用而言，侧链相当于将资金转移到一个单独的区块链系统中，除了（通常）两个系统的货币之间的汇率是固定的。想要在侧链上使用合约的用户首先需要将资金转移到侧链并等待足够的确认通过才能使用合约。执行后，如果他们想将资金保留在主链上，则需要将资金移回主链。单个合约执行总共需要五笔交易（主链和侧链各两笔用于来回移动资金，另外一笔用于合同执行）。</p>
<p><strong>链下执行</strong>。另一种方法是在几个选定的执行节点中运行链下合约代码。 Arbitrum [25]、ACE [50] 和 Yoda [17] 遵循这种方法。在 Arbitrum 中，合约发行者指定一组负责执行合约的“经理”。一旦合约调用完成，管理人员将执行结果发送给矿工，只有当所有管理人员报告相同的执行结果时，矿工才会接受（否则系统将退回到昂贵的争议解决协议）。由于合约的执行与共识过程脱钩，ACE、Arbitrum 和 Yoda 等系统可以在不减慢共识过程的情况下执行复杂的合约。然而，此类解决方案的主要缺点是它们需要对矿工进行更改，因此如果不对区块链协议进行修改，则此类解决方案无法部署到传统区块链。</p>
<p>状态通道 [33]、[21]、[22]、[32] 构成了另一种将智能合约的链上执行移出链的方法。然而，这种结构需要依赖于链上执行的回退机制和加入程序。因此，状态通道仅限于已经支持表达性智能合约的区块链.</p>
<p><strong>执行顺序验证模型</strong>。链下执行的一个特定变体是 Hyperledger Fabric [5] 中使用的执行-订单-验证模型。 Fabric 是一种流行的许可区块链系统，其中一组特定于合同的背书人独立于共识过程执行交易。已执行的交易被发送到排序服务，该服务在它们上建立总顺序并将它们组装成包含合约执行的读取集和写入集（即状态更改）的块。之后，区块被广播给节点（粗略地说，节点对应于矿工等系统参与者）。为了确保交易的可序列化性，Fabric 需要一个验证步骤，在该步骤中，对于每个交易，对等点顺序检查存储在交易读取集中的值，并检查它们是否仍然与其本地分类帐当前状态中的值相同。否则，交易无效并且不会应用其状态更改。</p>
<p>这种验证步骤对于确保 Fabric 中的可序列化性是必要的。由于背书者在订购之前执行交易，因此他们根据最新提交的状态执行它们。也就是说，背书人可能大致同时收到两笔交易，TxA 和 TxB，并因此基于相同的状态执行。考虑一个简单的例子，假设合约包含一个状态变量 x（在两个交易执行之前 x &#x3D; 0）并且两个交易都将这个值加一。两个读&#x2F;写集现在都包含 x &#x3D; 0 的读取和 x &#x3D; 1 的写入<br>背书。例如，在 TxB 之前对 TxA 进行排序之后，我们对 TxB 写入 x &#x3D; 1，而不是写入 x &#x3D; 2，因为在顺序执行 TxA 和 TxB 时应该如此。验证步骤通过使 TxB 无效来解决这个问题。</p>
<p>执行-订单-验证模型适用于区块链系统的新部署，其中基本协议可以规定所有对等方（即矿工等系统参与者）执行交易验证。我们在本文中的目标是添加智能合约执行功能，作为在未修改的传统加密货币之上运行的子系统。在这方面，execute-order-validate 模型不适合这样的子系统，因为如果 read-&#x2F;writesets 验证仅由子系统参与者执行，那么子系统中的转账与转账规则不一致在传统加密货币中。</p>
<p>我们用一个例子来说明这个问题。再次考虑同一块中的两个冲突事务，TxA 和 TxB。假设交易是由运行在未修改比特币之上的子系统创建的。现在考虑在执行这两个交易之前，合约有 1 个硬币的余额，TxB 将此硬币发送给其他方。给定执行顺序验证模型，即使 TxB 已包含在块中，子系统参与者也将使其无效。也就是说，从子系统的角度来看<br>参与者，合约仍然有 1 个硬币的余额，可以在未来的交易中使用。但是，传统加密货币的所有参与者都将遵守比特币协议，并且不会使此交易无效。因此，从他们的角度来看，与合约关联的账户余额为 0。子系统的客户端发送的任何会导致合约余额减少的交易，将因此被这些其他方拒绝，包括矿工，即使它们在子系统内是有效的。</p>
<p><strong>飞地执行Enclaved execution</strong>（內飛地enclave：意指某個國家境內有塊土地，其主權屬於另外一個國家，則該地區稱為此國家的內飛地）。下一个已知的方法是将合约执行外包到 SGX enclave 等可信执行环境 (TEE) 中。 Ekiden [14] 是一个遵循这种方法的示例系统。这种解决方案的主要问题是，如果对手破坏了执行合约的飞地，他可以任意破坏其完整性，例如窃取所有合约控制的资金。最近对 SGX 侧信道 [11]、[45]、[29] 和微架构攻击 [13]、[44] 的研究表明，TEE 妥协是一种应考虑的实际威胁。</p>
<p><strong>区块链多方计算</strong>。最近的研究还探讨了如何在区块链上运行安全多方计算 (MPC)。此类工作的主要目标是提高现有 MPC 协议的公平性，而不是将合约执行添加到传统区块链中，但此类方案也可以被视为特定类型的智能合约。</p>
<p>在 MPC 中，一组参与方提供私人输入并共同评估对它们的功能。一个常见的挑战是恶意方一旦学习到函数输出就可以停止参与，并阻止其他方学习输出从而违反公平。 Cleve [15] 的一个不可能的结果证明，没有诚实的多数，任何 MPC 协议都不可能是公平的。最近的研究表明，使用区块链可以在一定程度上缓解这种公平性问题。 Andrychowicz 等人。是第一个展示如何在比特币上实施公平的 2 方彩票 [6]。这个结果被扩展到 n 方彩票 [9]、玩扑克 [28] 和其他 MPC 协议 [26]。在这种方案中，每一方都必须在区块链上存入一笔存款。如果参与者停止参与，他将失去他的存款（即，这些系统创建了针对违反公平的货币激励措施，但不能完全阻止它）。</p>
<p>如果将此类 MPC 协议视为智能合约，则它们有几个功能限制。首先，这些解决方案是针对非常具体的计算而定制的，并且很难将相同的想法扩展到任意业务合同和应用程序。其次，必须提前知道所有合约参与者和合约期限，这对于以太坊等系统中的许多智能合约而言并非如此。第三，其中一些解决方案需要对底层区块链进行修改，例如向脚本语言添加新指令 [28]。</p>
<p><strong>飞地多方计算</strong>。最近一项名为 FastKitten [16] 的工作结合了 Ekiden [14] 和基于区块链的 MPC [6]、[9]、[28]、[26] 的技术，以在未修改的比特币之上实现类似合约的计算。与 Ekiden 类似，FastKitten 也使用 SGX 飞地来执行智能合约。与 MPC 计划类似，所有参与者都必须在执行前在合约中存入保证金。此外，TEE 的运营商必须缴纳一笔等于所有用户押金总和的押金。如果协议失败（因为一个用户行为不端），除了行为不端之外的所有各方都会收回他们的初始存款。</p>
<p>从功能的角度来看，FastKitten 与 MPC 方案存在相同的问题（合约必须有固定的参与者和有限的生命周期），因此 FastKitten 启用的合约比以太坊中的限制要多得多，以太坊允许无限的生命周期和动态参与者列表。 FastKitten 也存在安全问题。一个例子是多个参与者串通的攻击。例如，如果从执行到最后一轮，很明显 Bob 和 Charlie 将失去他们所有的押金给 Alice，那么前两个可以串通以致 Bob 停止发送消息。虽然 Bob 仍然会失去他的存款，但 Charlie 将收回他的全部抵押品，而 Alice 被骗了她的收益。因此，FastKitten 中的智能合约在恶意行为下并不能完全自我执行。最后，FastKitten 很容易受到类似于 Ekiden 的 TEE 攻击。</p>
<h2 id="III-Bitcontracts-概述"><a href="#III-Bitcontracts-概述" class="headerlink" title="III. Bitcontracts 概述"></a>III. Bitcontracts 概述</h2><p>在本节中，我们概述了我们的解决方案 Bitcontracts。首先，我们描述我们的执行模型并讨论实现它的挑战。之后，我们解释了Bitcontracts 的主要思想，并定义了区块链必须提供的共同属性来支持它。</p>
<h3 id="A-执行和信任模型"><a href="#A-执行和信任模型" class="headerlink" title="A. 执行和信任模型"></a>A. 执行和信任模型</h3><p>我们工作的出发点是一个链下执行模型，其中合约的执行与共识过程分离。一个明显的方法是在几个服务提供商之间分配信任，这样一个人共同信任一组服务提供商，就像在 Arbitrum [25]、Fabric [5] 或 ACE [50] 等系统中所做的那样。这种模式中的服务提供商可以是信誉良好的公司或非营利组织。在 Bitcontracts 中，我们也遵循这种方法。</p>
<p>但是，与 Arbitrum 的所有服务提供商必须一致同意合约执行结果不同，我们采用了类似于 ACE 和 Fabric 的<em>更灵活的信任模型</em>，其中合约创建者可以选择每个合约可接受的执行结果的要求。即，合约的创建者选择由 n 个服务提供者和所需授权阈值 t 组成的集合  $\mathcal{E}$。如果提交结果的交易至少得到了执行集  $\mathcal{E}$ 的 t 个成员的授权，则由合约调用引起的状态转换被认为是有效的。同意 $\mathcal{E}$ 中少于 t 个成员是恶意的假设。注意，为了同时保证安全和活跃， $\mathcal{E}$ 中的大多数服务提供者需要诚实，即使阈值 t 较低。否则，恶意多数可能会签署错误的结果（如果 $t ≤ n&#x2F;2$）或违反活性（如果 $t &gt; n&#x2F;2$）。</p>
<p>然而，可以自由选择 t 以便能够优先考虑安全性或活性仍然是有价值的。这种模型允许根据用例的要求灵活使用。例如，如果需要强完整性，但高可用性并不重要，则可以选择一个大的 $\mathcal{E}$，t 接近 $n &#x3D; \abs{\mathcal{E}}$。另一方面，如果选择  $\mathcal{E}$ 使得所有成员都是可信的并且需要高可用性，则可以选择一个低阈值，例如 t &#x3D; 1。预期长期处于活动状态的合约可以指定条件替换合同本身中的服务提供者，如 [50] 中所述。</p>
<p>我们的信任模型稍微修改了智能合约系统的典型信任假设。 在以太坊中，智能合约的规范由其代码定义（参见附录 A）。 在我们的系统中，规范还包括一组服务提供者和阈值。 重要的是，所有用户决定他们是否信任并同意此规范。 他们可以通过自己执行尽职调查或信任其他方为他们执行尽职调查来做出这个决定，类似于检查以太坊中合约代码的可信度，但他们不需要信任合约创建者。 最后，也和以太坊类似，他们只需要信任自己参与的合约的规范，不受其他合约执行的影响。 例如，如果一个合约的执行集遭到破坏，其他合约仍然是安全的。</p>
<h3 id="B-挑战"><a href="#B-挑战" class="headerlink" title="B. 挑战"></a>B. 挑战</h3><p>我们解决的主要技术挑战是如何安全有效地实现上述执行和信任模型，以便在传统区块链上执行合约。 接下来，我们讨论为什么简单的解决方案不能解决问题。</p>
<p>在哪里存储状态？我们首先考虑合约状态的存储。第一个可能的选择是将每个合约的状态存储在服务提供商的链外。由于我们基于仲裁的执行授权，并非每个服务提供商都需要参与每个合约调用，因此某些服务提供商可能没有合约的最新状态。因此，在这种方法中，服务提供者需要在他们之间运行共识协议，以确保合约状态的一致性。这是一个代价高昂的过程，给服务提供者增加了不必要的开销，并且会限制仲裁的大小，因为在给定 n 个服务提供者的情况下，它需要超过 $\frac{2}{3}n$。虽然可以通过将当前状态的哈希存储在区块链上来简化共识过程（从而部分利用区块链共识），但服务提供商仍然需要确保他们所有人都拥有最新状态。如果系统应该能够在同一个区块中包含涉及同一个合约的多个交易，它们仍然需要确保一致性，从而进行协调以确保它们最终不会处于不同的状态。</p>
<p>第二种选择是将每个合约的状态存储在链上，即将其发布在底层加密货币的区块链上。该选项利用了底层加密货币的共识机制，而不是要求服务提供者需要单独运行昂贵且复杂的^2共识协议，并确保各方都可以访问最新状态。这也允许客户端单独验证每个执行结果的正确性。将完整状态存储在链上的另一个优点是服务提供者本身可以保持完全无状态，不需要与其他服务提供者或区块链通信，即他们只需要与客户端通信，不需要持久存储合约状态。</p>
<p>如何保证一致性？似乎将状态存储在区块链上足以确保服务提供商之间的一致性，从而确保他们执行的智能合约的完整性，但事实并非如此。我们用一个简单的示例攻击来说明这一点。</p>
<p>假设一个理想化的区块链，其中交易无法重组，并且每个创建的区块都是最终区块。还假设合约的发行者将授权阈值设置为 t &#x3D; 2 3 n 并且对手控制了 1 3 n 个服务提供商。对手向两组不同的诚实服务提供者触发了两个不同的合同调用，每组大小为 1 3 n。两组都根据存储在链上的合约的当前状态授权合约调用。然后，攻击者向他控制的 1 3 n 个服务提供商授权两个合约调用，因此两个合约调用都具有所需的 t &#x3D; 2 3 n 个授权。然后，对手发布更新合约状态的第一个执行结果，例如，将资金转出合约。在那之后，<br>对手发布第二个执行结果，该结果根据之前的陈旧状态更新合约的状态，这意味着第一个合约调用的结果将被恢复，除了它们的副作用（例如汇款）。</p>
<p>这个问题的一个简单解决方案是要求阈值 t 必须始终足够大以防止这种攻击，即 t &gt; 2 3 n。这个简单的解决方案有两个问题。首先，它阻止了应该使用低阈值以获得最佳可用性的部署。其次，它不会阻止上述区块链中的攻击，因为临时分叉是可能的（例如，所有基于 PoW 共识的旧区块链）。</p>
<p>在 Fabric 和 ACE（它们具有与 Bitcontracts 类似的信任模型并利用链下执行）中，这个问题以不同的方式解决。 ACE 使用 order-execute-commit 模型，而 Fabric 使用 execute-order-validate 方法。因此，两个系统在订购交易后都需要额外的步骤。但是，如第 II-B 部分所述，在传统加密货币中进行排序会产生副作用，例如汇款，因此需要在排序阶段之前或期间解决潜在的不一致问题。因此，我们面临的挑战之一是如何确保子系统（增加合约执行功能）和传统加密货币中的交易可串行化，而无需在订购后执行额外步骤。换句话说，我们的解决方案需要与执行顺序架构兼容。</p>
<h4 id="C-Bitcontracts概述"><a href="#C-Bitcontracts概述" class="headerlink" title="C. Bitcontracts概述"></a>C. Bitcontracts概述</h4><p>接下来，我们解释了 Bitcontracts 背后的主要思想，并介绍了启用它的传统加密货币所需的属性 (1-4)。 图 1 显示了概览。</p>
<p><strong>现有的区块链系统</strong>。 Bitcontracts 使用智能合约扩展现有的区块链系统。现有实体，例如区块链客户端和矿工（或权益证明系统中的利益相关者），以及 P2P 基础设施与 Bitcontracts 无关，因此不需要修改。 </p>
<p><strong>Bitcontracts 客户端</strong>是智能合约的参与者和创建者。他们连接到区块链的 P2P 网络和他们参与的合同的服务提供商。Bitcontracts 客户端可以通过创建一个交易来创建智能合约，该交易为合约设置初始状态和初始资金，并指定负责的服务提供商并将此交易广播到区块链 P2P 网络。</p>
<p><strong>服务供应商</strong>。一组称为提供者集 (P) 的服务提供者，可以执行智能合约。服务提供者是无状态的，不一定需要连接到区块链。服务提供者根据给定的状态从客户端获取执行合约的请求，执行该合约并将结果发送回客户端。每个提供者创建一个密钥对，用于在初始化时接收和发送交易并发布公钥。这可以通过多种方式完成；提供商可以将其发布在区块链上，他可以在某些公开网站上访问，或者他可以直接将其发送给客户端。</p>
<h3 id="B-合约部署"><a href="#B-合约部署" class="headerlink" title="B. 合约部署"></a>B. 合约部署</h3><p>我们系统中的智能合约由一段用任意语言编写的代码、一些资金和作为键值存储存储在区块链上的合约状态组成，它允许在合约执行期间轻松检索状态。智能合约账户可以看作是由一群可以共同授权交易的服务提供商管理的账户。</p>
<p>为了部署智能合约，客户端选择一个任意大小为 n 的执行子集 E⊆P 和一个 t-out-of-n 信任模型，该模型描述了集合 E 中的哪些提供商 t 必须证明智能合约执行的正确性。请注意，该集合对于合约执行结果是集体信任的，因此所选的服务提供者通常是已知（而非匿名）实体。负责执行合同的一组服务提供者是合同规范的一部分，因此特定于合同而不是交易。客户端然后创建一个交易 Tx，其接收者是一个由 E 共同管理的新账户，即 E 的大小为 t 的子集可以授权来自该账户的交易。例如，在基于 UTXO 的货币中，这将对应于 t-out-of-n 多签输出。除了进入合约账户的任何初始资金外，该交易还包含合约代码的散列、其初始状态的散列以及其辅助存储中的初始状态本身。这是在使用“append_data”接口广播之前由客户端添加到事务中的。然后，客户端广播交易并将代码提供给应该能够与智能合约交互的任何其他方。如果合约应该是公开的，他甚至可以在合约创建交易中发布合约代码。或者，他可以在一些公开网站上发布。</p>
<h3 id="C-合同执行"><a href="#C-合同执行" class="headerlink" title="C. 合同执行"></a>C. 合同执行</h3><p>要执行智能合约，客户端必须联系合约执行集合 E 中的 n 个供应商中的至少 t 个来执行智能合约。如果联系的提供者之一没有回应，他需要联系另外一个。合约调用和执行的时序图如图 2 所示。</p>
<p>1 客户端首先通过浏览合约过去的交易并从存储在其中的所有状态更改组合状态，从区块链中获取合约的当前状态。这不需要每次都完全重复；客户端可以持续更新他们的本地状态，或者他们甚至可以依赖为他们提供最新状态的服务（他们可以使用存储在最近交易中的状态哈希来检查），类似于当前的轻量级区块链客户端。</p>
<p>2 向每个联系的提供商，客户端然后发送当前状态、之前的合约交易 $Tx_{prev}$、智能合约代码、智能合约执行的任何输入以及从客户端向智能合约发送资金所需的任何信息（例如来自客户端的 UTXO）。服务提供者也可以存储代码，但这里描述的设计允许服务提供者完全无状态。</p>
<p>3 每个提供者 Pk 然后如下进行</p>
<p>i) 提供者计算合约代码的哈希值，使用 read_data 接口从 $Tx_{prev}$ 检索合约代码的哈希值并比较两个值。如果值匹配，他继续，否则他中止。</p>
<p>(ii) 提供者对状态执行相同的操作，即他从 $Tx_{prev}$ 检索状态散列，将其与从客户端接收到的状态的计算散列进行比较，如果值不匹配则中止。</p>
<p>(iii) 给定状态、参数和附加输入，提供者执行智能合约。这个合约的执行可以改变合约的状态，并且可以发起资金转移到其他地址。</p>
<p>(iv) 服务提供者创建一个原始交易 $Tx$ 并使用 Tx.require_previous($Tx_{prev}$.id) 使其依赖于先前的交易。<br>(v) 提供者对新状态进行散列，并使用 append_data 接口将合约代码的散列和状态散列附加到交易中。</p>
<p>(vi) 提供者计算从先前状态到新状态的状态更改列表，序列化此列表并使用 append_data 接口将其附加到事务存储中。</p>
<p>(vii) 如果智能合约从客户端收到资金或执行导致资金转移到另一个地址，服务提供者使用 add_transfer 接口将转移添加到交易 Tx。</p>
<p>(viii) 最后，服务提供者 Pk 在交易上创建一个签名为 σPk &#x3D; sign(Tx)，并将交易和签名发送回客户端。</p>
<p>4 客户端从每个提供商 Pk 接收交易 $Tx$ 以及签名 σPk。 由于合约执行是确定性的，每个提供者都会创建相同的交易并为其提供签名。 客户端然后从所有接收到的签名 σP1,…,σPt 组装多方签名 Σ。 如果客户向合约发送资金（或提供资金支付费用），他还提供<br>他自己在 $Tx$ 上的签名 σC。</p>
<p>5 最后，客户端广播签名的交易（Tx,Σ,σC），它可以被包含在区块链中。</p>
<h3 id="D-合约依赖"><a href="#D-合约依赖" class="headerlink" title="D. 合约依赖"></a>D. 合约依赖</h3><p>对于调用其他智能合约的合约，我们需要<br>确保 (i) 整个调用（包括子调用）以原子方式执行，以及 (ii) 在给定每个合约的所选信任模型的情况下保证执行完整性。这要求所有合约的状态更改都通过由每个涉及的智能合约的执行集的法定人数签署的交易（或原子执行的交易序列）来提交。为了使用子调用执行合约调用，客户端首先在本地运行合约调用以确定涉及的合约集，然后将所有涉及的合约的状态、最新交易和代码，连同合约调用的输入。然后，服务提供者执行上面第 IV-C 节中列出的相同步骤，检查每个涉及的合约的代码和状态哈希并执行完整的调用链。由于生成的交易只有在满足所有相关合约的多重签名条件时才能包含在链中，因此这确保了只有在达到所有法定人数时才应用所有状态更改。</p>
<h3 id="E-预言机的使用"><a href="#E-预言机的使用" class="headerlink" title="E. 预言机的使用"></a>E. 预言机的使用</h3><p>由于这种方式，Bitcontracts 被构建，服务提供商可以在许多用例中本地充当预言机，因为合约代码可以直接连接到外部网站或数据源。例如，如果 Alice 和 Bob 建立了一个合约来赌除夕是否会下雨，并且他们都信任相同的天气数据提要，那么他们可以编写一个合约，在其中锁定一些资金，例如：使用 https 直接访问此提要，检查新年前夜的天气数据是否可用，然后支付给赌注的赢家。然后，投注的获胜者可以在元旦调用该合同。由于访问此提要并检查是否下雨的结果应该与执行此操作的诚实服务提供者无关，因此不需要外部预言机。</p>
<h2 id="V-属性分析"><a href="#V-属性分析" class="headerlink" title="V. 属性分析"></a>V. 属性分析</h2><p>在本节中，我们分析流行的区块链系统并解释它们如何提供 Bitcontracts 所需的属性。 表 I 总结了我们的分析。</p>
<h3 id="A-任意数据的存储"><a href="#A-任意数据的存储" class="headerlink" title="A. 任意数据的存储"></a>A. 任意数据的存储</h3><p>一些基于账户的加密货币，例如 Stellar 和 Ripple，提供了存储任意数据的显式机制。 其他人，如以太坊和 EOS，通过他们的智能合约系统支持这一点，因为任意数据可以简单地作为参数发送到合约调用。 在 Ripple 中，使用将数据添加到交易的 Memos 字段支持这一点，而 Stellar 允许使用 Manage Data 操作（op）写入帐户的键值存储。</p>
<p>大多数比特币分叉币支持仅使用 OP_RETURN 指令存储数据的特定输出。 这允许每个事务仅存储少量数据，因为每个事务最多可以使用使用此指令的一个输出。 对于支持比特币脚本的货币，存在几种解决方法，允许在每个交易中存储更多数据，并有一些开销 [42]。 我们在第 VIII-B 节中解释了其中之一。 通常，任意数据通常可以存储在为地址保留的交易字段中，因为地址通常类似于随机字符串并且没有可以检查的约束。 例如，在门罗币中，要在交易中存储超过 32 字节的数据（可以存储为支付 ID），必须创建虚拟输出，将数据存储在隐身地址的字段中。 然而，这有相当大的开销，因为它需要为每 32 字节数据提供 2kB [40] 的范围证明。</p>
<h3 id="B-多方授权"><a href="#B-多方授权" class="headerlink" title="B. 多方授权"></a>B. 多方授权</h3><p>通常需要多方授权机制，例如对于来自公司的钱包，以提高安全性，因此通常支持加密货币。大多数基于 UTXO 的加密货币，例如 Litecoin、Zcash 和 Dash，都是比特币协议的分支，并且还支持比特币脚本，可以实现多重签名。请注意，本文中的“多重签名”是指需要多方单独签名的交易授权。它不是指通常需要签名者之间的协议来共同产生一个单一签名的多重签名方案。尽管 Cardano 不是比特币的分叉，但它也支持脚本并允许多重签名。 Stellar 和 Ripple（使用账户模型）以不同的方式实现多重签名，但仍然支持它们，而以太坊和 EOS 已经支持可以而且必须用于实现多方授权的表达性智能合约。</p>
<p>Monero 是一个特例，因为它不明确支持多重签名帐户（我咋记得是有multisig的？？？）。相反，必须通过在多方之间拆分密钥并运行交互式签名协议来创建多方签名。此外，它们在软件中没有得到很好的支持，这使得它们创建起来很麻烦 [4]、[31]。虽然这足以与我们的系统兼容，但它需要服务提供者之间进行交互，而不仅仅是与客户端通信。</p>
<h3 id="C-状态相关交易有效性"><a href="#C-状态相关交易有效性" class="headerlink" title="C. 状态相关交易有效性"></a>C. 状态相关交易有效性</h3><p>在 UTXO 模型中，状态相关的交易有效性是该模型的隐含结果，因为交易的输入必须是先前交易的未花费输出，这使得交易的有效性直接依赖于先前的交易。因此，所有基于 UTXO 的加密货币都支持此属性。</p>
<p>在基于账户的加密货币中，必须明确支持此类策略。例如，在 Ripple 中就是这种情况，它提供了一种特殊机制，允许在交易的 AccountTxnID 字段中指定来自帐户的前一交易的哈希值。如果此值是该帐户的最新交易的哈希值，则该交易只会被分类帐接受。 Stellar 中没有这样的机制，但可以很容易地以相同的方式添加，以支持 Bitcontracts。作为另一种可能性，状态相关的交易有效性可以在现有的智能合约系统中实现，就像以太坊和 EOS 的情况一样，通过创建一个智能合约来存储最近的状态哈希，并且只有在之前的状态被引用时才接受状态更新更新对应于存储的值</p>
<h3 id="D-原子性事务"><a href="#D-原子性事务" class="headerlink" title="D. 原子性事务"></a>D. 原子性事务</h3><p>与状态相关的交易有效性一样，所有基于 UTXO 的加密货币都支持原子交易作为模型的隐含结果：交易必须支持多个输入和输出，否则交易不可能有可变金额。在支持智能合约的货币中，例如以太坊和 EOS，这再次通过智能合约系统得到支持。</p>
<p>Stellar 允许向交易添加多笔付款。如果付款来自与发送账户不同的来源，则相应的账户也需要签署交易。 Ripple 本身不支持具有多个源和目的地的原子交易，但可以轻松添加本地支持，类似于 Stellar。即使没有本地支持，也可以使用 PathJoin 协议 [35] 在 Ripple 之上添加一种形式的原子支付。然而，为了使用这个协议来确保交易原子性，服务提供者需要相互交互并且需要跟踪分类帐状态。</p>
<h2 id="VI、奖励"><a href="#VI、奖励" class="headerlink" title="VI、奖励"></a>VI、奖励</h2><p>第 IV 节中描述的 Bitcontracts 规范隐含地假设服务提供商将执行客户端事务。在本节中，我们将解释如何激励交易执行以及如何保护服务提供商和客户免受彼此的侵害。我们专注于已成为激励区块链系统工作的常见方式的交易费，但我们强调，服务提供商也可以通过其他（链下）方式获得激励，例如类似于云计算服务的订阅费。</p>
<p>除了通过交易费用增加的明确激励之外，不当行为也会通过声誉损失而隐含地被抑制，因为客户通常会选择已知的、有信誉的实体而不是匿名方。 Bitcontracts 提供了不可否认的不当行为证据，例如签署错误的状态转换，这会损害服务的声誉。但是，明确的负面激励措施，例如对不当行为的经济处罚，需要通过某种形式的受信任方来执行。在没有原生智能合约的遗留系统中，这样的可信方是不可用的。负激励可以在 Bitcontracts 合约本身内实施，但不会很有用，因为它们将依赖于不被违反的信任模型（在这种情况下，不当行为没有任何好处）。</p>
<p>如图 1 所示，Bitcontracts 支持服务提供商与区块链完全断开的部署。在这种部署中，激励必须在链下处理（例如，订阅模型）。当使用交易费用等链上激励机制时，服务提供商需要能够检查区块链。</p>
<p><strong>引入手续费</strong>。将手续费直接应用于 Bitcontracts 系统如下。在调用 Bitcontracts 合约时（第 IV-C 部分的第 2 步），客户指定他愿意支付给服务提供商的费用。客户包括用于向合同调用请求分别为每个服务提供商支付此费用的资金。如果服务提供商发现包含的交易费用可以接受，他们就会执行合约调用，将客户资金支付的费用包含在同一笔交易中，并将签名结果返回给客户（步骤 3 和 4）。通过签署 Bitcontracts 交易并将其发布在传统区块链上（步骤 5），费用的所有权有效地从客户转移到服务提供商。</p>
<p>这种费用机制部署简单且高效，因为它不会为合约调用处理增加额外的延迟。但是，它有两个小缺点。第一个缺点是恶意客户端无法签署和发布最终交易（即跳过第 5 步），从而导致服务提供商执行无偿合约调用。客户不会从这种不当行为中获得任何好处，因此理性的客户没有动机像这样滥用服务提供商。与其他 DoS 和资源耗尽攻击类似，服务提供商可以通过已知机制来保护自己，例如在负载繁重的时候要求客户解决密码难题 [20]、[24]、[7] 或通过要求总体上略高的费用来补偿偶尔的无偿执行工作。</p>
<p>第二个缺点是，一些服务商可以选择“搭便车（free-ride）”而不执行呼叫，希望其他服务商完成工作并获得报酬。这个缺点可以通过合约创建者来解决，他们可以选择信誉良好的实体作为服务提供商。</p>
<p><strong>关于公平性</strong>。理想的交易费用机制将提供服务提供商和客户之间的公平性。服务提供商只有在保证收取费用的情况下才会执行合约调用执行工作。客户只有在知道服务提供商将执行并签署合同呼叫时才会付款。这个问题接近公平交换的概念 [38]，其中卖方只有在保证收到匹配付款时才会向买方发布产品，例如某些计算的输出。</p>
<p>不幸的是，由于两个主要原因，现有的公平交易协议不适用于我们的环境。首先，现有的与遗留链兼容的公平交换协议，如零知识或有支付（ZKCP）[8]、[47]、[12] 保护像计算结果一样的数字“产品”，但它们不保护任务计算本身。因此，如果我们采用现有的 ZKCP 协议之一，恶意客户端仍然可以将无偿工作强加给服务提供商。其次，现有的公平交易协议通常考虑一个单一买家的一对一设置，而我们的执行模型有 n 个卖家（即 n 个服务提供商）。</p>
<p>因为公平交换的经典概念不适用于我们的环境，所以我们的目标略有不同。我们的目标是为服务提供商提供执行激励，同时保护他们免受恶意客户的侵害（尽可能）。更准确地说，应该激励服务提供者快速执行交易，不鼓励搭便车，并且客户不应该在不支付费用的情况下将执行工作强加给服务提供者。</p>
<p><strong>激励机制示例</strong>。接下来，我们将描述实现这些目标的示例激励机制。客户将交易费用支付给由服务提供商共同控制的 t-out-of-n 多重签名账户。这种支付可以在链上完成（或者在客户端经常与智能合约交互的情况下通过支付渠道）。服务提供商然后在执行合同之前检查他们是否收到了付款。如果是这种情况，他们会照常进行。</p>
<p>在某个固定的时间间隔（例如，一个月）之后，服务提供商从他们的多重签名帐户中共同创建一个交易，该交易根据带有签名的合约交易（出现在链上）的数量的比例向每个服务提供商支付份额来自相应的服务提供商。由于服务提供者在执行合约调用之前检查他们是否收到了付款，因此保证他们是集体支付，并且由于少于 t 的服务提供者可能是恶意的，因此保证根据服务提供商参与的合同交易。这也激励了服务提供商的快速响应，因为他们更有可能被包含在链上，并且显然不鼓励搭便车。</p>
<p>这样的示例激励机制有两个小缺点。首先，它略微增加了合同调用处理延迟，因为服务提供商需要等到他们收到付款后才能执行合同。其次，恶意客户端仍然可以通过选择性地选择将哪些签名包含在最终交易中来偏爱某些服务提供商。我们认为，为计算工作的一个买方和法定数量的卖方提供完美公平的激励机制的发展是一个有趣的开放问题，超出了本文的范围（并且可能具有独立利益）。</p>
<h2 id="VII-安全分析"><a href="#VII-安全分析" class="headerlink" title="VII. 安全分析"></a>VII. 安全分析</h2><p>在本节中，我们从安全性和活性保证方面分析Bitcontracts 。</p>
<p><strong>安全</strong>。 像 Bitcontracts 这样的合约执行系统需要提供的主要安全或保障条件是每个合约都被正确执行。 如果出现在链中的对该合约的所有调用都是可序列化的，并且每个调用都提供基于所有调用序列化之前的调用结果状态的控制流完整性，我们就说系统为特定合约提供了执行正确性。 基于这个定义，我们提出以下主张：</p>
<p><strong>声明 1.</strong> 给定合约A 的规范，它定义了一个由 $n_A$个服务提供者和仲裁大小 $t_A$ 组成的执行集  $\mathcal{E}_A$，以下成立：如果来自 $\mathcal{E}$的服务提供者少于 $t_A$ 个被破坏，则合约提供执行正确性，即可序列化性 和控制流完整性。</p>
<p><strong>证明</strong>。 我们考虑以下情况：</p>
<ol>
<li><p>正确的客户输入。假设客户端提供的合约代码和状态是正确的，所有诚实的服务提供者只会在包含的状态转换正确的情况下签署交易，即新的状态是智能合约执行的正确结果，给定他们收到的状态作为输入。因此，如果少于 $t_A$ 的服务提供者受到损害，则包含错误状态转换的交易无法获得合约 A 的法定人数，因此无法提交到区块链，即我们具有基于客户端提供的状态的执行完整性。</p>
</li>
<li><p>客户提供的虚假先前状态或合同。对于这种情况，我们假设客户端提供了正确的先前交易 $Tx_{prev}$。尽管我们从上面知道状态转换本身必须是正确的，但它们基于客户端提供的状态和合约代码。因此，客户端可以发送伪造状态作为输入状态。但是，导致此状态的先前交易 $Tx_{prev}$ 包含状态和合约的哈希值。服务提供者检查所提供的状态和合约是否与这些散列对应，如果不是这种情况，则中止，即基于不匹配状态或合约代码的状态转换无法达到 A 的法定人数。</p>
</li>
<li><p>客户提供的虚假或过时的先前交易。以上并未考虑到客户端也可能提供伪造或过时的先前交易 $Tx_{prev}$。即使没有攻击，交易也可能过时，因为两个客户端几乎同时调用合约。然而，我们的系统需要确保没有基于这种过时状态的状态转换被提交到链，以防止竞争条件，特别是 TOCTOU 漏洞。在对结果交易 $Tx$ 进行签名并将其发送回客户端之前，服务提供商会在 $Tx_{prev}$ 上确定新交易 $Tx$ 的有效性，即只有当 $Tx_{prev}$ 提交到区块链时才会接受 Tx，并且它是最近的交易合约账户。这确保即使基于过时（或虚假）先前交易的交易可能达到法定人数，也无法提交到区块链，因为未满足矿工检查的有效性标准。</p>
</li>
</ol>
<p>因此，具有法定人数签名的交易必须提供控制流完整性，直接引用单个有效的先前状态，并且如果它被接受到链中，则是唯一引用此状态的此类交易，从而确保唯一的序列化。由于涉及多个合约的合约调用需要每个涉及合约的法定人数，并且最终交易的有效性基于所有涉及合约的先前状态，因此上述适用于所有合约调用，而与它们是否涉及其他合约无关，并且独立于客户端行为，即即使客户端行为不端或与恶意服务提供商勾结。</p>
<p>最后，我们注意到我们的系统对未参与合约的各方没有任何安全影响，即使该合约具有恶意的法定人数。这直接源于 Bitcontracts 不会更改底层加密货币的协议这一事实。</p>
<p><strong>活性</strong>。像 Bitcontracts 这样的系统应该确保的主要活跃条件是，来自诚实客户的每笔交易都不会与另一笔交易（即包含相同合约并基于相同状态的交易）发生冲突，并且可以提交给区块链。基于这个定义，我们提出以下主张：</p>
<p><strong>声明 2</strong>. 给定来自诚实用户的合约调用 T，涉及 k 个合约 $C_i (1 \leq i \leq k)$，该合约定义了具有法定人数 ti 的执行集 $\mathcal{E}{C_i}$，以下成立：如果合约调用与其他合约调用不冲突，并且一个诚实的合约调用在 ECi 中可以达到大小为 ti 的法定人数（对于所有 1 ≤ i ≤ k），事务 T 的活性得到保证，即 T 最终将被执行和提交。</p>
<p><strong>证明</strong>。由于客户端是诚实的，他最终将合约调用发送给 ECi 中至少 ti 个诚实且可达的服务提供商（对于所有 1 ≤i ≤k），他们执行合约调用并将结果返回给客户端。一旦客户端收到足够的响应（即每个合约的法定人数），他就会为基础加密货币组装和广播交易。由于没有冲突的交易，这笔交易最终会被提交到链上。</p>
<h2 id="VIII-实现"><a href="#VIII-实现" class="headerlink" title="VIII. 实现"></a>VIII. 实现</h2><p>在本节中，我们将描述一个用于创建和运行智能合约的 Bitcontracts Python 库，该库可与支持第 III-D 节中列出的要求的任意加密货币的后端实现一起使用。 我们还描述了与比特币脚本兼容的加密货币的 Bitcontracts 后端。</p>
<h3 id="A-Python-库"><a href="#A-Python-库" class="headerlink" title="A. Python 库"></a>A. Python 库</h3><p>我们的 Python 库提供了一个基类，所有智能合约类都必须从该基类派生出来。一旦部署，智能合约就是一个序列化存储在区块链上的对象。当合约在服务提供者上运行时，库（在检查代码和状态哈希后）首先根据客户端提供的状态重新实例化合约对象，然后使用客户端在此对象上指定的方法调用提供的输入。一旦方法终止，库会创建一个从前一个状态到新状态的状态更改列表，将它们序列化，并将它们存储在一个事务中，然后服务提供者签署该事务。</p>
<p>该库还提供了智能合约的 API。在我们的原型中，此 API 仅限于基本功能，例如获取智能合约余额、创建资金转移或调用其他智能合约，以及允许将函数声明为私有的装饰器（即只能由该函数的其他函数调用）合同）或公开（即任何人都可以调用）。附录 B 中显示了一个示例合约及其执行的分步说明。 其他 API 功能，例如可以轻松添加一些原语，例如获取调用者身份。以太坊支持的其他功能，例如检索当前区块哈希或矿工身份，需要底层加密货币的支持，并且不能为比特币添加。</p>
<p>对于智能合约的执行，设置了单独的执行环境。在我们的原型中，这是目前一个简单的子流程。但是，在生产环境中，合约执行需要在沙盒环境中执行，例如通过在 Docker 容器中运行代码，因为服务提供者不信任合约代码。为确保所有合约调用都能达到服务提供者的法定人数，应采取措施确保合约代码的确定性执行，例如通过控制沙箱可用的随机源和禁止多线程。</p>
<h3 id="B-基于类比特币数字货币的实例化"><a href="#B-基于类比特币数字货币的实例化" class="headerlink" title="B. 基于类比特币数字货币的实例化"></a>B. 基于类比特币数字货币的实例化</h3><p>基于 UTXO 的加密货币中的交易由多个输入和多个输出组成（稍后可以再次成为交易的输入）。由合约部署和不同调用产生的三个交易链如图 3 所示。使用 Bitcontracts 执行合约产生的交易具有以下描述的组件。</p>
<p><strong>合同输入</strong>。合约输入是先前合约调用的输出。我们在下面更详细地描述它。合约创建交易没有任何合约输入。</p>
<p><strong>客户端输入</strong>。任何 Bitcontracts 交易都可以有零个或多个客户端输入。这些输入用于向合约发送资金。</p>
<p><strong>合约输出</strong>。此输出保存智能合约的余额，并由指定多重签名条件的比特币脚本锁定。我们使用 P2SH 输出和包含 m-out-of-n-multisig 条件的赎回脚本。参数 m 和 n 以及其中包含的公钥由智能合约的创建者选择，并由供应商在整个调用过程中维护。比特币和相关加密货币的标准交易规则允许在此类赎回脚本中 n ≤ 15（这有效地将执行集的最大大小限制为 |E|&#x3D; 15）。赎回脚本还包含代码的哈希值和智能合约当前状态的哈希值。这些值被推送到堆栈并丢弃，因此不需要额外的努力来赎回余额输出。他们仍然必须包括在内，s.t.提供商可以根据其中包含的哈希检查与先前交易一起收到的智能合约的代码和状态。</p>
<p><strong>状态输出</strong>。这些输出保存了合约调用的状态变化，即在此执行期间更改的状态中的所有变量。状态更改存储为从变量名称到其新值的键值映射。使用比特币的 OP_RETURN 操作码，最多 80 个字节可以存储在标记为不可赎回的输出中，即不存储在比特币客户端的 UTXO 集中。然而，由于比特币交易传播规则，每笔交易只允许一个 OP_RETURN 输出，这是相当有限的。</p>
<p>已知有几种解决此限制的方法，Sward 等人对此进行了讨论。 [42]。我们的实现使用带有三个包含我们数据的假公钥的多重签名输出。比特币允许在标准多重签名输出（即非 P2SH）中最多存储三个公钥（每个 65 字节），这允许存储 195 个字节，每个输出的开销为 15 个字节。通过连续排列状态输出，数据恢复是直截了当的，并且不会产生额外的开销来指定数据位置。比特币的最大交易大小为 100KB，我们可以存储多达 92KB 的状态更新。请注意，虽然这限制了合约初始化时存在的命名合约字段的数量，但状态大小本身不受限制，例如使用列表或字典的合约可以增长到任意大小。</p>
<p><strong>客户端输出</strong>。这些产出支付给客户的钱。它们可以是智能合约的支出，也可以是使用大于客户打算发送给合约的价值的输入更改客户的输出。</p>
<p>为了创建智能合约，客户使用他的一个或多个 UTXO 作为交易的输入，该交易具有带有初始合约资金的合约输出、包含初始状态的状态输出和客户端输出，例如客户端的更改输出。在左侧的图 3 中，我们展示了一个示例交易，其中 Bob 创建并资助了一个 Bitcontracts 合约。</p>
<p>要调用智能合约，客户端首先必须组装合约状态。他通过迭代合约交易并应用每个交易的状态更新来做到这一点。请注意，这甚至可以使用轻量级客户端来完成，即客户端不需要下载底层加密货币的完整链。状态组装完成后，他通过联系服务提供商来调用智能合约，如第 IV-C 部分所述和图 2 所示。服务提供商执行所需的检查（例如匹配合约和状态哈希），执行合约，然后组装交易。交易再次包含如上所述的合约输出、包含状态变化的状态输出和潜在的客户端输出。中间的图 3 显示了一个示例，其中 Charlie 向智能合约发送了一些资金，这导致向 Alice 和 Bob 支付款项，并向 Charlie 返还一些零钱。</p>
<p>智能合约调用可能包括对其他智能合约的子调用。在这种情况下，客户端向服务提供商提供所有涉及的智能合约所需的所有信息，并从所有执行集联系必要的服务提供商（参见第 IV-D 部分）。服务提供者如上所述执行合约，并在组装交易时确保合约和状态输出按合约出现在调用链中的顺序排序。例如，在图 3 合约的最后一笔交易中<br>B 被合约 A 调用，因此合约 A 的输出列在最前面。</p>
<h2 id="IX。评估"><a href="#IX。评估" class="headerlink" title="IX。评估"></a>IX。评估</h2><p>在本节中，我们首先评估在流行的传统区块链平台上运行的 Bitcontracts（第 IX-A 节）。之后，我们在 Bitcontracts 之上评估流行的现实世界智能合约的存储和成本（第 IX-B 节）。</p>
<h3 id="A-传统加密货币的Bitcontracts"><a href="#A-传统加密货币的Bitcontracts" class="headerlink" title="A. 传统加密货币的Bitcontracts"></a>A. 传统加密货币的Bitcontracts</h3><p>对于我们的第一次评估，我们考虑在 6 种流行的传统加密货币（比特币、比特币现金、莱特币、达世币、狗狗币、Zcash）上运行 Bitcontracts，并比较数据更改的成本以及数据量方面的吞吐量改为以太坊。以太坊遵循大致相似的资源管理模型，其中交易费用取决于计算复杂性和状态变化存储。我们还单独讨论了其他系统（例如 EOS）中执行不同费用模型的智能合约的成本。</p>
<p><strong>可扩展性</strong>。如上所述，比特币和相关加密货币的多重签名功能使执行设置达到|E|&#x3D; 15 个服务提供商的规模。</p>
<p><strong>密钥管理开销</strong>。服务提供商的密钥管理开销在存储、计算和通信方面很低。每个服务提供商只需要存储一个私钥，他可以将其用于他负责的所有合同。每个服务提供者只需为每个合约执行生成一个签名，服务提供者之间不需要通信。</p>
<p><strong>计算</strong>。我们工作的主要焦点是合约调用，其计算类似于今天在以太坊中看到的计算，即以毫秒为单位。然而，没有什么可以限制系统运行更复杂的合约，类似于 ACE [50]、Arbitrum [25] 或 Yoda [17] 支持的合约。我们不提供智能合约执行速度的详细评估，因为合约调用只是 Python 程序执行，因此测量它们的执行速度不会提供任何新的见解，并且合约执行的成本主要由链上存储主导费用描述如下。</p>
<p>为了说明这一点，我们将以太坊合约中快速排序的执行成本与在 AWS t2.micro 实例上执行类似的 Python 实现的成本进行了比较。为了对 2048 个整数元素进行排序，以太坊实现需要 650 万气体（接近区块气体限制），成本约为 59 美元（基于 2020-06-08 的费用价格），而在 t2.micro 实例上， Python 实现的执行时间不到 6 毫秒，这对应于不到 3 美元·10−7 美元的有效总执行成本，如果我们假设这在最大大小为 15 的执行集中的每个服务提供者上执行（当然，这并不意味着在实践中费用会这么低，因为服务提供商需要盈利，因此实践中的费用将由市场决定并且难以预测，但它表明在Bitcontracts 中执行通常很便宜）</p>
<p><strong>通信</strong>。通信成本低，因为每次调用只需要查询每个涉及的服务提供商（最大 |E| &#x3D; 15）及其响应。客户端从服务提供商收到响应之前的延迟包括一个 Internet 往返时间加上数据传输所需的时间，这取决于状态更改的大小。对于大多数合约，对于状态变化很多的合约，这将是几毫秒或最多几秒的数量级。我们不会通过实验来评估这一点，因为互联网通信延迟已经在其他地方进行了广泛的研究。区块中交易确认的延迟与底层区块链中其他交易的延迟相同（例如在比特币中平均为 10 分钟）。请注意，与其他交易一样，Bitcontracts 合约调用也可以基于未确认的交易执行，即同一合约的多个 Bitcontracts 交易可以包含在同一个区块中。</p>
<p><strong>存储成本</strong>。 Bitcontracts 的第一个有趣的评估指标是其存储成本。在表二中，我们首先展示了流行区块链平台中当前的交易费用（下一个区块包含截至 2020 年 6 月 8 日）以供参考。之后，我们展示了相同区块链平台每 KB 状态变化的 Bitcontracts 存储成本。从表中可以看出，Bitcontracts 带来的存储成本开销非常小。</p>
<p>我们还将比特合约的存储成本与以太坊进行了比较。从表 II 中可以看出，存储 1KB 数据的以太坊合约的成本在 1.44 美元（如果没有值从零变为非零）和 5.75 美元（如果所有更改的值都从零变为非零）之间，这不不包括任何计算。与此相比，Bitcontracts 的链上存储费用要小得多（0.80 美元或更少）。</p>
<p><strong>最大存储量</strong>。第二个相关评估指标是每个事务可以存储的最大数据量（即状态变化）。表二显示，在比特币、比特币现金、莱特币、达世币和狗狗币中，每 210 字节输出可以存储 195 字节，因此每笔交易的最大存储量限制为最多 92KB，因为它们的标准规则不会传播交易大于 100KB。在 Zcash 中，最大交易大小仅为<br>受最大块大小 (2MB) 的限制，允许每个事务最多存储 1.86MB 的数据。我们注意到，这些限制并不限制合约状态的整体大小，而只是限制每次合约调用的状态更改次数。此外，这些限制还受到交易其他部分的影响。例如，如果一笔交易有大量的客户端输入或输出，则数据存储的限制会相应减少。</p>
<p>相比之下，从表 II 中可以看出，在给定当前区块 gas 限制的情况下，当前的以太坊合约在一笔交易中只能在 16 到 63 KB 的存储空间之间变化（取决于值是否设置为从零到非零）。这样的交易将完全填满一个区块。在以太坊上使用比特合约可以增加这个限制。由于 Bitcontracts 不需要将状态转换存储在存储中，只需要它们在交易中可见，它们可以简单地作为交易数据发送，这需要更少的气体，因此理论上允许存储高达 625KB 的数据每个交易。在实践中，这会稍微少一些，具体取决于仲裁大小和由此产生的签名验证成本。</p>
<p><strong>吞吐量</strong>。 Bitcontracts 的另一个有意义的评估指标是吞吐量。我们通过测量系统每秒可以处理的状态更新数据量来评估吞吐量。该吞吐量值取决于区块间隔和底层区块链平台每个区块的最大存储量。如表二所示，就可能的更改数据量而言，在原生不支持合约的传统平台上使用 Bitcontracts 执行智能合约与以太坊的吞吐量相比具有优势。</p>
<p><strong>不同收费模式下的成本</strong>。一些加密货币，例如 EOS，遵循不同的收费模式。 EOS 股权基金的参与者不是直接为计算和状态变化付费，即他们将它们锁定一段时间，作为回报，他们可以使用与其抵押资金成比例的一小部分计算和带宽资源。因此，交易的主要成本来自不使用质押资金的机会成本。存储（在 EOS 中称为“RAM”）是购买的（并且可以交易），但与以太坊和比特合约不同，因为参与者不为状态变化付费，而是为拥有 RAM 付费。 EOS 中 1KB 存储的成本为 0.15 美元（截至 2020 年 6 月 8 日），这比在 Bitcontracts 中新分配存储（比特币除外）的成本更高，但更改已分配的存储是免费的。</p>
<h3 id="B-Bitcontracts上流行的以太坊合约"><a href="#B-Bitcontracts上流行的以太坊合约" class="headerlink" title="B. Bitcontracts上流行的以太坊合约"></a>B. Bitcontracts上流行的以太坊合约</h3><p>在评估的第二部分中，我们分析了流行的现实世界智能合约的存储要求和交易成本，如果它们是在 Bitcontracts 中执行的。我们通过爬取以太坊区块链数周（2020 年 10 月&#x2F;11 月）获得了我们的评估数据集，并从 13 万个区块中收集了智能合约执行数据，我们从中提取了最受欢迎的 100 个合约的所有交易的交易信息（基于交易数数）。这产生了一个包含 1000 万个合约调用交易的数据集。对于每笔交易，我们收集了状态变化的数量和大小、涉及的合约数量、收到资金的客户数量和以太坊天然气成本。<br>然后，我们使用此信息来计算由 Bitcontracts 中潜在的类似合约执行所产生的交易规模，并根据此规模，计算不同链（例如比特币）上的成本。 Bitcontracts 中的合约交易规模取决于所涉及合约的数量、其执行集的规模、从合约中获得资金的客户数量以及状态输出的数量和规模（参见第 VIII-B 部分），这是从状态更改的数量和更改的存储大小得出的。这允许直接计算结果交易的规模和成本。</p>
<p><strong>交易规模</strong>。图 4 显示了在 Bitcontracts 中执行合约调用与执行大小为 5 和仲裁大小为 3 的合约调用时产生的交易大小的比较。 Bitcontracts 中交易的交易大小分布显示在左侧的大小分布旁边以太坊中的相同交易。<br>Bitcontracts 中的交易大小中位数为 693 字节，仅约为具有一个输入和两个输出（226 字节）的基本比特币交易的 3 倍。比特合约中的交易通常比以太坊中的交易大（其交易大小中位数为 174 字节），这是预期的，因为基于法定人数的链下执行需要交易中的额外签名，并为每个涉及的合约增加一些额外的开销，即合同输入和输出。图 4 右侧比较了 Bitcontracts 和 Ethereum 之间的交易数据大小。在比特合约中，交易数据大小包括状态变化输出。在以太坊中，交易数据大小由交易输入组成，例如函数参数。我们的分析表明，基本成本（很大程度上独立于执行的合约）占交易规模的大部分，并且在链上存储状态变化并不是规模差异的主要贡献者。实际上，与以太坊相比，Bitcontracts 中的大多数交易中的交易数据更小，数据大小中位数分别为 39 字节和 68 字节，因为函数参数等输入不需要存储在 Bitcontracts 中。这表明，与其输入参数的大小相比，许多合约仅更改了少量存储数据。</p>
<p><strong>吞吐量</strong>。 仅考虑合约执行（即不包括纯货币转移），根据收集的交易数据，如果在比特币上运行，Bitcontracts 可以支持每秒 1.8 笔交易（tps）的吞吐量，在 Litecoin 上运行时为 7.0 tps，在 Litecoin 上运行时为 9.6 tps 比特币现金（前两个有，后一个没有 SegWit）。 以太坊，对于同一组交易，支持 10.2 tps 的吞吐量，这表明 Bitcontracts 可以在传统加密货币（莱特币和比特币现金）之上实现合约调用的吞吐量与通过 专门为支持智能合约而构建的平台。 比特币之上的 Bitcontracts 的吞吐量较低，但这是意料之中的，因为即使对于平均 3.7 tps 的正常交易，比特币的吞吐量也更加有限。</p>
<p><strong>交易成本</strong>。图 5 显示了我们收集的 100 个最流行合约的合约调用集中交易的交易成本（以美元为单位）。该图比较了在比特币、莱特币和比特币现金之上的比特合约中这些交易的成本与以太坊中相同交易的成本（基于 2020 年 6 月 8 日的交易费用数据）。我们看到比特币上的 Bitcontracts 的交易成本分布（中位成本 0.35 美元）与以太坊中相同交易的成本分布（中位成本 0.51 美元）具有相似的范围，同时在其他传统加密货币（例如莱特币）之上执行它们（ LTC) 或比特币现金 (BCH) 便宜得多（中位数分别为 0.03 美元和 0.004 美元）。请注意，这是链上交易成本，即不包括服务提供商费用。然而，如第 IX-A 节所述，计算时间（以及因此执行费用）相对便宜，并且链上交易费用可能是主要的成本因素。</p>
<h2 id="X、结论"><a href="#X、结论" class="headerlink" title="X、结论"></a>X、结论</h2><p>在本文中，我们介绍了一个新系统 Bitcontracts，它使用以太坊风格的智能合约扩展了比特币等传统区块链，而无需更改基本协议。 Bitcontracts 通过使用基于仲裁的信任模型在服务提供商中执行智能合约并利用底层区块链的共识协议来实现这一点。 比特合约只需要底层区块链提供四个基本属性——大多数流行的区块链系统都支持这些属性。 我们的实施和评估表明，在传统区块链之上运行智能合约在实践中是可行且具有成本效益的。</p>
<p>[WIP] TODO: 尚未插入图片及整理排版与通读</p>
]]></content>
  </entry>
  <entry>
    <title>Bulletproof: 适用于机密交易及更多方面的简短证明</title>
    <url>/post/bulletproof-paper/</url>
    <content><![CDATA[<p>基于区块链的加密货币通过维护全球分布式但同步的分类账区块链来实现点对点电子价值转移。任何独立的观察者都可以验证区块链的当前状态以及分类帐上所有交易的有效性。在比特币中，这项创新要求交易的所有细节都是公开的：发送方、接收方和转账金额。一般来说，我们将支付的隐私分为两个属性：（1）匿名性，在交易中隐藏发送者和接收者的身份；（2）保密性，隐藏转移的金额。虽然比特币通过比特币地址与现实世界身份的不可链接性提供了一些弱匿名性，但它缺乏任何机密性。这对比特币来说是一个严重的限制，对于许多用例来说可能是禁止的。如果这意味着他们的工资发布在公共区块链上，员工是否愿意以比特币获得他们的工资？</p>
<p>为了解决交易金额的保密问题，Maxwell [Max16] 引入了机密交易（CT），其中涉及的每笔交易金额都使用对金额的承诺隐藏起来，不让公众看到。这种方法似乎阻止了区块链的公开验证；观察者无法再检查交易输入的总和是否大于交易输出的总和，以及所有交易值是否为正。这可以通过在每笔交易中包含机密交易有效性的零知识证明来解决。</p>
<p>当前关于 CT 零知识证明 [PBF] 的提议要么大得令人望而却步，要么需要可信的设置。两者都不是可取的。虽然可以使用简洁的零知识证明 (SNARK) [BSCG13,GGPR13]，但它们需要可信设置，这意味着每个人都需要相信设置已正确执行。人们可以通过使用 STARK [BSBTHR18] 来避免可信设置，但由此产生的范围证明虽然渐近有效，但实际上比目前提出的解决方案还要大。</p>
<p>如本文所述，没有可信设置的简短非交互式零知识证明在加密货币领域有许多应用。在证明通过网络传输或长期存储的任何分布式系统中，简短证明了总体成本的降低。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们首先讨论 Bulletproofs 的几个应用程序以及特定于这些应用程序的相关工作。 其他相关工作在第 1.3 节中讨论。</p>
<h3 id="机密交易和-Mimblewimble"><a href="#机密交易和-Mimblewimble" class="headerlink" title="机密交易和 Mimblewimble"></a>机密交易和 Mimblewimble</h3><p>比特币和其他类似的加密货币使用基于交易输出的系统，其中每笔交易完全花费之前未花费交易的输出。 这些未花费的交易输出称为 UTXO。<br>比特币允许将单个 UTXO 用于许多不同的输出，每个输出都与不同的地址相关联。 要花费一个 UTXO，用户必须提供一个签名，或者更准确地说是一个 scriptSig，使交易 SCRIPT 能够评估为真 [BMC&#96;15]。<br>除了 scriptSig 的有效性外，矿工还验证交易是否花费了之前未花费的输出，并且输入的总和大于输出的总和</p>
<p>Maxwell [Max16] 引入了“机密交易”的概念，其中交易中的输入和输出金额隐藏在 Pedersen 承诺中 [P<code>91]。  为了实现公开验证，交易包含一个零知识证明，即提交输入的总和大于提交输出的总和，并且所有输出都是正的，即它们位于区间 $[0, 2^n]$， 其中 $2^n$ 远小于组大小。  当前所有机密交易的实现 [Max16, MP15, PBF</code>, NM&#96;16] 都使用提交值的range proof范围证明，其中证明大小在 n 中是线性的。<br>这些范围证明是机密交易规模的主要贡献者。 在当前的实现中 [Max16]，只有两个输出和 32 位精度的机密交易是 5.4 KB 字节，其中 5 KB 分配给范围证明。<br>即使最近进行了优化，范围证明仍将占用 3.8 KB。</p>
<p>我们在第 6 节中展示了 Bulletproofs 大大改进了这一点，即使对于单个范围证明，同时以边际额外成本（64 字节）将范围证明精度加倍。<br>logarithmic proof对数证明的大小还使证明者能够聚合多个范围证明，例如对于具有多个输出的交易，转换为一个简短的证明。<br>使用 Bulletproofs，$m$ 范围证明只是单个范围证明上的 $O(log(m))$ 附加群元素。这对于当前形式的机密交易已经很有用，因为大多数比特币交易都有两个或多个输出。<br>它还提供了一个有趣的机会，可以将来自不同方的多个范围证明聚合为一个证明，例如在 CoinJoin 交易中需要的证明 [Max13]。<br>在 4.5 节中，我们提出了一个简单有效的 MPC 协议，该协议允许多个用户使用单个聚合范围证明生成单个交易。<br>用户不必向任何其他参与者透露他们的机密交易价值。</p>
<p>机密交易实现可用于侧链 [PBF<code>]、私有区块链 [And17] 和流行的注重隐私的加密货币 Monero [NM</code>16]。 所有这些实现都将受益于 Bulletproofs。<br>在撰写本文时，比特币拥有来自 2200 万笔交易的大约 5000 万个 UTXO（参见 statoshi.info）。 使用比特币的 52 位表示，可以覆盖从 1 satoshi 到 2100 万比特币的所有值，这导致使用当前系统的范围证明数据大约为 160GB。<br>使用聚合的 Bulletproofs，所有 UTXO 的范围证明将需要不到 17GB，大小减少约 10 倍</p>
<h4 id="Mimblewimble"><a href="#Mimblewimble" class="headerlink" title="Mimblewimble"></a>Mimblewimble</h4><p>最近，有人提议对机密交易进行改进，称为 Mimblewimble [Jed16,Poe]，可进一步节省成本。</p>
<p>Jedusor [Jed16] 意识到 Pedersen 对 0 的承诺可以被视为 ECDSA 公钥，并且对于有效的机密交易，输出、输入和交易费用之间的差异必须为 0。因此，构建机密交易的证明者可以签名以输出和输入的差异作为公钥的交易。这一小改动消除了对 scriptSig 的需求，极大地简化了机密交易的结构。<br>Poelstra [Poe] 进一步完善和改进了 Mimblewimble，并表明这些改进可以实现一个大大简化的区块链，其中所有花费的交易都可以被修剪，新节点可以有效地验证整个区块链，而无需下载任何旧的和花费的交易。<br>随着进一步优化，这会导致高度压缩的区块链。它仅包含一小部分区块头以及剩余的未花费交易输出和随附的范围证明以及每笔交易不可修剪的 32 字节。 Mimblewimble 还允许在将交易发送到区块链之前进行聚合。</p>
<p>Mimblewimble 区块链随着 UTXO 集的大小而增长。<br>使用 Bulletproofs，它只会随着具有未花费输出的交易数量而增长，这远小于 UTXO 集的大小。<br>总体而言，Bulletproofs 不仅可以替代机密交易中的范围证明，而且还可以帮助 Mimblewimble 成为一个实用的方案，其区块链比当前的比特币区块链小得多。</p>
<h3 id="Provisions-协议"><a href="#Provisions-协议" class="headerlink" title="Provisions 协议"></a>Provisions 协议</h3><p>Dagher et al. [DBB&#96;15] 引入了 Provisions 协议，该协议允许比特币交易所证明它们具有偿付能力，而无需透露任何额外信息。<br>该协议主要依靠范围证明来防止交易所插入带有负余额的假账户。<br>这些占用超过 13GB 的范围证明是为具有 200 万客户的大型交易所提供近 18GB 证明大小的主要贡献者。<br>样张大小实际上与客户数量呈线性关系。<br>由于在该协议中，一方（交易所）必须同时构建多个范围证明，因此第 4.3 节中的通用 Bulletproofs 协议是 Provisions 中使用的 NIZK 证明的自然替代品。<br>使用第 6 节中列出的证明大小，我们获得范围证明在我们的协议中将占用不到 2 KB。<br>此外，证明的其他部分可以使用第 5 节中的协议进行类似压缩。<br>然后证明将由每个客户的一个承诺主导，大小为 62 MB。这大约比目前实施的规定小 300 倍。</p>
<h4 id="可验证洗牌-verifiable-shuffle"><a href="#可验证洗牌-verifiable-shuffle" class="headerlink" title="可验证洗牌 verifiable shuffle"></a>可验证洗牌 verifiable shuffle</h4><p>考虑两个提交值列表 $x_1,…,x_n$ 和 $y_1,…,y_n$ 。目的是证明第二个列表是第一个列表的排列。<br>这个问题称为<strong>可验证洗牌 verifiable shuffle</strong>。<br>它在投票 [FS01,Nef01]、混合网络 [Cha82] 和偿付能力证明 [DBB&#96;15] 中有许多应用。<br>Neff [Nef01] 给出了可验证 shuffle 的实际实现，后来对其进行了改进 [Gro03,GI08a]。 Neff [Nef01] 给出了可验证 shuffle 的实际实现，后来对其进行了改进 [Gro03,GI08a]。<br>目前最有效的 shuffle [BG12] 的大小为 $O(\sqrt{n})$。</p>
<p>Bulletproofs 可用于创建大小为 $O(\log{n})$ 的可验证洗牌。<br>这两个commitment列表作为第 5 节中电路协议的输入。<br>回路可以通过对两个列表进行排序然后检查它们是否相等来实现混洗。<br>排序回路可以使用 $O(n\cdot\log{n})$ 乘法来实现，这意味着证明大小将仅为 Oplogpnqq。<br>这比以前提出的协议小得多。<br>鉴于 Bulletproofs 的具体效率，使用 Bulletproofs 进行可验证的 shuffle 在实践中将非常有效。<br>构建证明并验证它只需要$n$的线性时间。</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>企业视角下的区块链: Chain on Enterprise View</title>
    <url>/post/chain-on-enterprise-view/</url>
    <content><![CDATA[<h2 id="区块链归类"><a href="#区块链归类" class="headerlink" title="区块链归类"></a>区块链归类</h2><p>出于方便理解和技术分类，我们倾向于在面向企业的介绍中将区块链描述为一种一种高度专业化的数据库。当然从最底层来看也确实是如此。</p>
<p>我们可以简单分类一下</p>
<pre class="mermaid">graph LR
    数据库 --> 中心化数据库
    数据库 --> 分布式数据库
    分布式数据库 --> 分布式账簿
    分布式账簿 --> 区块链</pre>
<p>对于集中式数据库，您必须信任单个数据库——并不需要达成共识。</p>
<p>对于分布式数据库，信任概念开始成为关注的重点。在分布式数据库中，您可以拥有一个受信任的容错数据库网络。</p>
<p>在分布式数据库中，存在分布式账簿，通常意味着宽松的信任保证。它们可以使彼此之间不完全信任的各方达成共识。</p>
<p>最后，我们的主人公，区块链，是分布式账簿的子类。</p>
<span id="more"></span>

<h3 id="中心化数据库"><a href="#中心化数据库" class="headerlink" title="中心化数据库"></a>中心化数据库</h3><p>需要注意的是，尽管“分布式”的定义，即分布式和中心化之间的差异，在数据库分类特别是在区块链领域下可能存在争议。在此，我们通常是指其策略和空间分布。</p>
<p>例如，我们可能将组织的数据库系统称为集中式数据库系统，因为它们都由一个实体运营——因此在策略上是集中的。就空间分布而言，我们可以有一个“中央”数据库或在地理上集中或分散的多个数据库。</p>
<p>为了更好地理解这一点，让我们回到大多数人都熟悉的数据库形式，即中心化数据库。<br>中心化数据库的地理位置，存储和维护集中式数据库（例如单个密码服务器）集中在一处，一个中央实体处理所有请求和数据处理。<br>这样的优点包括：设计简单，即时数据更新，成本效益，和最小的冗余。</p>
<p>但是，集中式数据库也有许多固有的缺点：它们容易触及瓶颈，缺少多个用户对同一组数据的同时写访问权限，并作为单点故障。</p>
<h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分布式数据库由相互信任的节点组组成，并合作维护整个系统的一致视图。因为不再存在单点故障，所以系统更具容错能力，并且可以通过在所有节点之间平均分配负载来处理更多需求。</p>
<p>但是，分布式数据库还会带来更高的复杂性、冗余性，更多成本和以及暴露更多的故障点。那只是维护分布式的开销。</p>
<p>分布式数据库的一种特定类型是分布式分类帐，其中包含节点由可能互不信任的不同实体运营。</p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>尽管存在许多针对分布式账本的共识机制，在其记录保存中实现区块链，共识协议被称为区块链。<br>回想一下我们的比特币和加密货币课程，区块链不支持分布式信息共享。<br>正如我们已经看到的，存在许多形式的分布式数据库，它们允许分布式没有区块链的信息共享。<br>相反，区块链的唯一性在于其分布式记录保存和去中心化价值交换。</p>
<p>与传统数据库相比，区块链系统独特地能够消除需求集中管理者，并允许网络中的非信任方彼此互动。</p>
<p>区块链还可以根据其架构以及信任和访问进行分类典型用户拥有的权限。</p>
<p>通常，所有区块链可以分为公共链或许可链。</p>
<p>公共区块链是最广泛和最知名的区块链类型。例如两种最受欢迎​​的加密货币，比特币和以太坊。</p>
<p>世界上每个人都可以读取公共区块链，可以提出对他们的协议，并可以参与他们的共识机制。<br>这使得公共区块链在提供去中心化和审查制度方面具有优势抵抗性。<br>与使用这些公共区块链平台相关的网络效应导致增加应用程序开发。<br>例如，在以太坊之上构建了数千个DApp，并且通常少于每个专用平台100个。<br>但是，由于公共区块链是开放的，并且每个人都可以访问，它们限制了可以直接存储在区块链上的信息类型。<br>不应将敏感和私人数据（即病历，SSN，私钥）放在纯文本中的区块链。<br>此外，公共区块链固有地在不受信任的环境中运行。<br>信任不再放在人员和组织中，而是放在整个系统背后的数学和代码中。</p>
<h3 id="许可链"><a href="#许可链" class="headerlink" title="许可链"></a>许可链</h3><p>不同于完全不受信任的公共区块链，我们拥有所谓的许可分类账或许可区块链。</p>
<p>在许可的区块链类别中，既有完全私有的区块链，其中权限集中到一个实体，也有联盟或联合区块链，其中权限由中央实体组控制。</p>
<p>在许可的区块链中，写入权限仅限于一个中央实体或实体联盟，并且读取权限可能也可能不受限制。<br>许可的区块链使组织可以自行决定更改区块链的规则，允许进行更便宜的交易，提供更大的隐私并减轻传统的基于共识的攻击的风险。</p>
<p>与传统的公共区块链不同，获得许可的区块链不具有（公开）开放和不信任的特性。<br>但是，在企业环境中，可以使用许可的区块链来解决松散链接的组件之间的协调问题。<br>尽管区块链仍处于起步阶段，但许多科技巨头已经开始表现出兴趣。</p>
<p>例如，Microsoft最近发布了Blockchain Workbench，它是Azure平台上的一组工具，供使用分布式分类帐技术的开发人员使用。<br>Workbench旨在通过建立基础结构来简化公司在基于Azure的区块链之上构建应用程序的过程，以便开发人员可以专注于应用程序的逻辑。</p>
<p>Hyperledger是一个由IBM和Linux Foundation牵头的区块链财团，它召集各行各业的公司共同努力进行开发。<br>该项目的目标是开发一个高度模块化和可配置的企业区块链平台，以供企业客户定制其自己的区块链解决方案。<br>Hyperledger当前专注于解决供应链，医疗保健和财务方面的问题。<br>沃尔玛（Walmart）和雀巢（Nestle）等公司已使用Hyperledger跟踪其供应链中的食物交付。</p>
<p>以太坊企业联盟是一个在以太坊社区内的组织，希望扩大以太坊对企业的影响。<br>它是由150多家财富500强公司和初创公司以及机构和政府组成的财团，为试图建立企业区块链的公司提供标准框架<br>使用以太坊作为其基础层。</p>
<p>尽管企业正在朝着区块链的方向发展，但是对于整个区块链技术仍然存在不同的观点和看法–当然，这完全取决于您要与之交谈的受众。</p>
<p>有些人可能是比特币最大化主义者，他们相信比特币和区块链的最初愿景，并且鄙视企业区块链，以将政治集中化与区块链的去中心化初始愿景</p>
<p>还有人说企业区块链很烂。<br>不同背景的不同人倾向于有这种共同意见。</p>
<p>比特币最大化主义者可能不喜欢最初为避开区块链而创建的公司对区块链的使用。<br>这些人可能会真正提倡使用加密货币。</p>
<p>同时，也许那些在传统行业有更多经验的人可能也会说<br>企业区块链很烂，但是由于他们理解并喜欢更传统的政治集中式云解决方案。<br>工业界也可能有那些知道分离加密货币和区块链的人。</p>
<p>有些人甚至对区块链在每个企业用例中都有用的看法过于乐观。</p>
<p>最后，还有一些受过高等教育的人，他们认识到区块链技术适用性的优缺点。</p>
<p>区块链可以很酷，但是只能以非常特殊的方式。</p>
<p>人们误以为企业区块链总是有用的。<br>一些用例具有根本性缺陷–通常与区块链和分布式分类帐技术的核心优势和优势不符。<br>这些用例并不能保证使用区块链，也许可以通过集中式或分布式数据库来解决，但不能使用区块链。<br>这也是一个误解，认为区块链比某些集中式解决方案更有效。</p>
<p>这种误解可以从许多不同的角度来解决。<br>问题是：我们如何定义效率？<br>如果我们在谈论计算效率，那么我们已经知道区块链是高度冗余的，因此计算效率不高。<br>毕竟，当您可能只写一对（如果不是一对）时，为什么还要写可能遍布世界的成千上万个节点。</p>
<p>另一方面，可以进一步分析效率，这是在考虑分散和可扩展性之间的权衡问题。<br>同样，也可能有人说区块链很便宜。<br>通常，区块链的维护和开发成本很高，因为这主要是社区的努力。</p>
<p>最后，另一个误解可能是，如果企业用例已经决定使用区块链，他们可能会认为他们应该只是构建自己的区块链，而不是使用现有基础架构。<br>建立自己的区块链并不像人们期望的那么简单。<br>过去，许多项目的确只是分叉了比特币区块链的代码库。<br>但是如今，现有的区块链开发框架已被证明是成功且安全的。</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链缩放研究</title>
    <url>/post/chain-scaling/</url>
    <content><![CDATA[<p>原文自edX上伯克利大学课程Blockchain Technology。本文是对课程内部分内容的总结与修改。</p>
<p>虽然现在的公链生态已经获得成功，但是其反受繁荣现状的掣肘。尤其是比特币和以太坊，存在严重的可扩展性问题。从其成为能够支持全球规模交易量的全球网络的目标来看，目前两者都在交易吞吐量(tps)方面表现不佳。</p>
<p>从根本上讲，扩展解决方案可以增加交易量或减少交易时间。这也是理所当然的，因为可缩放性是按区块链可实现的tps（每秒交易量）衡量的。</p>
<p>展望未来，我们可以通过两种方式对区块链扩展解决方案进行分类。首先是与传统的云架构缩放级别（水平，垂直和对角线）进行粗略的比较。其次，存在特定于区块链的缩放分类：第1层（在链上）和第2层（在链外）。</p>
<span id="more"></span>

<h2 id="纵向缩放"><a href="#纵向缩放" class="headerlink" title="纵向缩放"></a>纵向缩放</h2><p>正常情况下，tps算法如下</p>
<p>$$tps &#x3D; BlockSize\times AvgTxSize\div BlockTime$$</p>
<p>因此我们可以给出如下几种优化方案</p>
<h3 id="减少区块时间"><a href="#减少区块时间" class="headerlink" title="减少区块时间"></a>减少区块时间</h3><p>我们不能简单地减少区块时间，因为那样会导致自然产生的分叉率更高，从而降低了系统安全性。因为在减少块时间的同时，网络中广播新区块的时间是依旧不变的。</p>
<p>以太坊一直通过采用GHOST（Greedy Heaviest Observed SubTree，贪婪的最高权重的被观测子树）协议来解决这个问题。使用GHOST协议，矿工并不会简单地同意最长的链条（比特币方案），而是“重量”最大的链条。这个“重量”是由一条链的长度和其叔块数计算得出的一个值。</p>
<h3 id="增加区块大小（容量）"><a href="#增加区块大小（容量）" class="headerlink" title="增加区块大小（容量）"></a>增加区块大小（容量）</h3><p>增加区块大小能够改善区块链的TPS。因为一个区块可以包含更多交易，也将降低交易费用。</p>
<p>但是，与减少块时间一样，增加大小存在一些副作用。一方面，增加块大小将意味着很难分叉，并且根据社区的不同，这可能不是令人愉快的体验（BCH）。这也将使区块链总体积以更快的速度增长，这也是减少区块时间的难题。最后，增加块大小很可能不是一次性解决方案，因为可伸缩性提升只是线性的。将来可能需要再次增加块大小，从而引发“滑坡”式的争论。</p>
<h3 id="减少交易体积"><a href="#减少交易体积" class="headerlink" title="减少交易体积"></a>减少交易体积</h3><p>隔离见证（SegWit）是对比特币的升级，可将交易签名从交易内部移至交易结束时的单独结构，称为隔离见证。对于非隔离见证节点，这将减少有效交易规模，因为它们不知道读入隔离见证。</p>
<p>非隔离见证节点将看到没有签名的交易，但会将交易标记为有效。另一方面，SegWit节点将知道读入隔离的见证人，并使用签名对其进行验证。</p>
<p>SegWit最初旨在解决比特币中的交易延展性。它还使用软分叉来实现，并导致较小的区块链大小。但是，SegWit只是线性可伸缩性的一次提升。</p>
<p>递归SNARKs也可以减小事务大小。与其将交易本身存储在区块链中，我们可以存储证明这些交易确实发生的证据，以及谁拥有多少加密货币的最终资产负债表。这通过减小事务大小来提高效率，并且还因为机器可以在几毫秒内验证证明。但是，当前，为了生成这些样式的证明，需要可信的环境设置。在实践中，生成证明非常昂贵。</p>
<h2 id="链下纵向缩放"><a href="#链下纵向缩放" class="headerlink" title="链下纵向缩放"></a>链下纵向缩放</h2><p>考虑到区块链的速度限制了它的可扩展性，我们可以考虑完全消除链上成本更高的操作，仅在需要全局真相时才发布。</p>
<h3 id="闪电网络-amp-雷电网络"><a href="#闪电网络-amp-雷电网络" class="headerlink" title="闪电网络&amp;雷电网络"></a>闪电网络&amp;雷电网络</h3><p>可以使用HTLC（哈希时间锁定合同）来实现比特币中的支付渠道，并且可以将交易从主要的比特币区块链转移到侧链。</p>
<p>如果Alice和Bob经常进行交易，那么对于Alice和Bob来说，建立一个私人支付渠道是很有意义的，他们在这里进行链下交易。 仅当他们想结清最终余额时，他们才会回发到主区块链。 这样一来，Alice和Bob仍然可以像往常一样进行交易，但是主区块链只需要存储Alice和Bob的初始余额和期末余额。</p>
<p>比特币闪电网络的根本思想是建立一个“支付渠道”网络，如图所示</p>
<pre class="mermaid">graphLR
    Alice --- Bob
    Alice --- David
    Bob --- Eva
    Bob ---  Fiona
    
    David --- Eva

    Eva --- Fiona
    Fiona --- Charlie
    Eva --- Charlie</pre>

<p>在上图中，只要存在通过支付渠道网络从Alice到Charlie的路径，Alice就可以立即向Charlie付款，而无需直接面向Charlie付款。</p>
<p>以太坊在工作中有一个类似的可扩展性解决方案，适当命名为雷电网络(Raiden)。</p>
<p>付款渠道和付款渠道网络将使我们无需进行很多交易，将付款委托给简单的簿记。由于主区块链仅在支付渠道中看到各方的开始和结束余额，因此我们可以使大部分交易保持脱链状态：将比特币从不到10的tps扩展到潜在的数十万tps。</p>
<p>但是这种方式依然存在一些问题：必须锁定资金才能启动支付渠道；集中到中心辐射型(hub-and-spoke)拓扑的支付渠道网络的集中化问题。</p>
<h2 id="横向缩放"><a href="#横向缩放" class="headerlink" title="横向缩放"></a>横向缩放</h2><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片是一种数据库扩展策略，可将一个完整的数据库分为多个“分片”，每个分片数据库都包含来自原始数据库的子集的数据，该原始数据库的子集是原始数据库。相同的想法可以应用于区块链，并且目前是以太坊研究的活跃领域之一。</p>
<p>将分片应用至区块链意味着并非每个节点都跟踪每个区块。这是第一层横向缩放解决方案。我们可以有多个并行运行的区块链，每个区块包含所有交易的子集。当前正在研究的问题包括分片式区块链系统中各个节点的分类（例如，看到单个分片的节点与看到所有分片的节点），跨分片通信以及针对单分片接管的防御措施。</p>
<h3 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h3><p>侧链的想法是，可以出于不同目的创建多个侧链，以插入主链，从而有效减少主链上的流量。</p>
<p>其本质是将hash分散在多个链上，因此存在安全隐患。</p>
<h2 id="高级缩放及其通用化"><a href="#高级缩放及其通用化" class="headerlink" title="高级缩放及其通用化"></a>高级缩放及其通用化</h2><h3 id="Plasma"><a href="#Plasma" class="headerlink" title="Plasma"></a>Plasma</h3><p>以太坊的Plasma可视为一种对角线缩放解决方案，因为它可以通过实施侧链实现横向缩放，并通过Tendermint和替代共识机制提高速度来实现纵向缩放。链下交易的安全性源自根链，根链是系统内真实性的主要来源。</p>
<p>FourState是一个由伯克利成员组成的区块链组成的团队，它使用Cosmos SDK编写了Plasma的实现，从而实现了更大的灵活性和可扩展性。</p>
<p>区块链从上到下有3个主要的抽象层：</p>
<ul>
<li>应用层：处理事务并更新系统状态</li>
<li>共识层：确保整个网络都同意交易和数据库更新</li>
<li>网络层：确保所有节点在合理的时间内获得更新</li>
</ul>
<p>Tendermint项目的目的是提供网络和共识层，以便可以在其之上构建任意应用程序。Tendermint是Cosmos网络的共识“引擎”，旨在使区块链具有互操作性和可扩展性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表总结了我们已了解的缩放解决方案，并按2种不同的方法进行了分类。第1层和第2层指定解决方案是在链上还是链外构建。解决方案也可以横向或纵向缩放。</p>
<table>
<thead>
<tr>
<th>\</th>
<th>纵向</th>
<th>横向</th>
</tr>
</thead>
<tbody><tr>
<td>第二层</td>
<td>1. 支付通道<br>2. 闪电网络<br>3. 雷电网络<br>4. Plasma</td>
<td>1. 侧链<br>2. Plasma<br>3. Cosmos</td>
</tr>
<tr>
<td>第一层</td>
<td>1. 区块时间，大小<br>2. GHOST<br>3. SegWit(2x)<br>4. 递归SNARKS<br>5. 其他架构、共识</td>
<td>1. 分片</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>blockchain</tag>
        <tag>edx</tag>
        <tag>scaling</tag>
        <tag>tps</tag>
      </tags>
  </entry>
  <entry>
    <title>Crunchbeats: Spear and Shield</title>
    <url>/post/churchbeats-spear&amp;shield/</url>
    <content><![CDATA[<p>Crunchbeats项目是针对<a href="https://www.crunchbase.com/" target="_blank" rel="noopener">crunchbase</a>的公开数据采集项目</p>
<span id="more"></span>

<h2 id="Spear-0x01"><a href="#Spear-0x01" class="headerlink" title="Spear 0x01"></a>Spear 0x01</h2><p>由于crunchbase并没有提供任何company&#x2F;organisation index，而且categories也是仅面向Pro(氪金)用户的search。因此，作为数据采集，我们首先需要一份可用的索引来引导具体的采集任务。</p>
<p>清单是利用了一个非常trick的方式来获取的。首先我们已经知道，org_name有意义的（即会被fuzz search注意的）也就0-9a-z这31个字符。然后在instant search的api里，结果虽然只给至多15个，但是实际总数也会暴露在response里。因此可以通过穷举来获取一份总org_name清单。</p>
<h2 id="Shield-0x01"><a href="#Shield-0x01" class="headerlink" title="Shield 0x01"></a>Shield 0x01</h2><p>当然按照其他情况来说，全站下载也是个不错的方法。但是在crunchbase里，有如下几个因素导致此方案不可行。首先就是无法判断是否已经全网下载。下载任务结束并不意味着全部下载完成，很可能只是陷入站内url闭环回路。没有一份清单而爬取数据只会徒增成本，招ban。</p>
<h2 id="Shield-0x02"><a href="#Shield-0x02" class="headerlink" title="Shield 0x02"></a>Shield 0x02</h2><p>效率低下。crunchbase包含了public界面，pro可见界面，try pro可见界面，而除了org以外还有industry，group等其他模块，因此全站下载下载到的资源可用率极低。</p>
<h2 id="Shield-0x03"><a href="#Shield-0x03" class="headerlink" title="Shield 0x03"></a>Shield 0x03</h2><p>crunchbase使用了cloudflare，在cookie里可以看到这个__cfdid</p>
<pre><code>Cookies Search Results: __cfduid
About this cookie:
Cookie associated with sites using CloudFlare, used to speed up page load times. According to CloudFlare it is used to override any security restrictions based on the IP address the visitor is coming from. It does not contain any user identification information.
</code></pre>
<p>虽然quora上说是distil提供的 <a href="https://www.quora.com/How-do-you-crawl-Crunchbase-and-bypass-the-bot-protection" target="_blank" rel="noopener">https://www.quora.com/How-do-you-crawl-Crunchbase-and-bypass-the-bot-protection</a></p>
<p>反正就是会有看脸的bot检测，具体是让你press and hold一个button，然后再看脸让你通过。</p>
<h2 id="Spear-0x02"><a href="#Spear-0x02" class="headerlink" title="Spear 0x02"></a>Spear 0x02</h2><p>我最开始想的其实是走bypass bot detection。毕竟以前绕cf找源站的文章看的有点多，<a href="https://www.anquanke.com/post/id/183238" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183238</a></p>
<p>但是当时对无CDN加持下的origin IP能否直接國内访问十分怀疑，因此没有实现。</p>
<h2 id="Spear-0x03"><a href="#Spear-0x03" class="headerlink" title="Spear 0x03"></a>Spear 0x03</h2><p>后来选择的还是和对方硬碰硬。可以发现人家不管你登陆没登陆，过量的请求就会ban。至于sleep，少量sleep等于没睡，长时间sleep等于没干活。</p>
<p>因此就决定展开proxy池，咬牙花了点重金（几十块）买了proxy的服务。</p>
<h2 id="Shield-0x04"><a href="#Shield-0x04" class="headerlink" title="Shield 0x04"></a>Shield 0x04</h2><p>但是proxy在cf和gfw面前真的很脆弱。几千几万个proxy中只有数个能访问网站（经过墙），然后在网站面前被cf揍死。</p>
<h2 id="Spear-0x04"><a href="#Spear-0x04" class="headerlink" title="Spear 0x04"></a>Spear 0x04</h2><p>因为一开始是requests进行的网络请求，全都是python也就不处理任何js，遇到challenge就停下来让人手摇解禁。效率就很低。为了效率，尝试了利用selenium(webdriver)来处理请求。首先的确利用chrome+firefox的自动challenge可以降低被ban的几率，但是和requests比起来真的是太慢了……尤其是在笔记本上，换句话说就是出师未捷身先死了。</p>
<h2 id="Spear-0x05"><a href="#Spear-0x05" class="headerlink" title="Spear 0x05"></a>Spear 0x05</h2><p>后来通过手里闲置的几台tx云学生机</p>
<h2 id="WIP"><a href="#WIP" class="headerlink" title="[WIP]"></a>[WIP]</h2><h2 id="New-solution"><a href="#New-solution" class="headerlink" title="New solution"></a>New solution</h2><p>New solution to overcome the ip blacklist: Vultr&#x2F;GCP&#x2F;AWS &#x3D;&gt; unlimited new machine&#x2F;ip with low fee</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>crunchbase</tag>
        <tag>spider</tag>
        <tag>data gathering</tag>
      </tags>
  </entry>
  <entry>
    <title>CoinJoin: Bitcoin privacy for the real world</title>
    <url>/post/coinjoin/</url>
    <content><![CDATA[<p>比特币通常被宣传为隐私工具，但比特币中的唯一隐私性来自匿名地址，该匿名地址易销毁，但是通过地址重复使用，“污点”分析，跟踪付款，监控节点IP地址，网络爬虫以及许多其他机制很容易使该隐私性受到破坏。一旦破坏了这种隐私，很难恢复，有些情况下恢复成本也很高。</p>
<p>传统银行业务默认提供大量隐私保护。您的亲人看不到您正在购买节育措施剥夺他们未来的孙子孙女；您的雇主无法从薪水中获悉您支持的公益；贼人们也无法看到您最近的购买或判断您是如何富有的人，他们无法锁定目标并欺骗您。对于个人和企业而言，比特币的隐私性不足会是一个首要的切实的不利因素。</p>
<p>即使用户通过切换到BIP32地址链上来避免地址重复使用，当他们进行较大的交易时，他们仍然会因旧币和过去的付款而失去隐私。</p>
<p>隐私错误也会造成外部成本：您可能有良好的保护隐私行为，但是当您与不这样做的人（例如使用<a href="https://en.bitcoin.it/wiki/Green_address" target="_blank" rel="noopener">“绿色地址”</a>的人）进行交易时，您和每个与他交易的人一样都会被迫失去一些隐私性。隐私性的缺失也给比特币带来了严重的系统风险：如果降级了的隐私性允许人们汇集中心化的列表甄别好坏币，则当您真诚接受的硬币后来未被其他人兑现时，您就会发现比特币上币与币之间的可替代性遭到破坏，并且其去中心性也伴随着人们被迫给他们自己的币实施流行的黑名单。</p>
<p>这条消息描述了比特币用户可以用来显着改善其隐私性的交易方式，我一直称其为CoinJoin。它不涉及比特币协议的任何更改，并且几年前至今也有数次使用，但是似乎尚未得到广泛的理解。</p>
<p>我首先在一个异想天开的帖子中公开地描述了这种交易方式——“全盘污染！”——通过这个着重讨论了这些交易的一个特定副作用，并期望人们会自己看到其余的含义。</p>
<p>往往清晰击败含蓄，甚至理解该想法的人也有一些本可以被解答的问题。因此，这个帖子就是为此而写。</p>
<span id="more"></span>

<h1 id="CoinJoin-现实世界的比特币隐私"><a href="#CoinJoin-现实世界的比特币隐私" class="headerlink" title="CoinJoin:现实世界的比特币隐私"></a>CoinJoin:现实世界的比特币隐私</h1><p>这个想法很简单，首先要有一些简单的背景知识：</p>
<img src="/post/coinjoin/tx.png" class="">

<p>比特币交易消耗一个或多个输入(Input)并创建具有指定值的一个或多个输出(Output)。</p>
<p>每个输入都是过去交易的输出。对于每个输入，都有一个不同的签名（scriptsig），该签名是根据过去使用的输出（scriptpubkey）中指定的规则创建的。</p>
<p>比特币系统负责确保签名正确，输入存在且可支配，并且输出值的总和小于或等于输入值的总和（任何超出部分都将作为支付给矿工的费用包括交易）。</p>
<p>通常，一笔交易会花费很多投入，以便获得足够的价值来支付其预期的付款，通常还会创建一个额外的“更改”输出，以接收未花费（和非费用）的超额费用。</p>
<p>不需要使用的输入的scriptpubkey相同。也就是说，不要求将其支付到同一地址。而且，实际上当正确使用比特币支付一次性付款时，没有一个会是相同的。</p>
<p>在考虑比特币所有权的历史时，可以将从多个不同的scriptpubkey花费的交易视为它们的所有权共同加入，并做出一个假设：除非有共同方控制这些地址，否则该交易又如何从多个地址花费？</p>
<p>在图中，“交易2”花费了分配给1A1和1C3的硬币。那么1A1和1C3就一定是同一方吗？</p>
<p>这个假设是不正确的。单个交易中的用法并不能证明是通用控制（尽管目前看来很有意义），这就是使CoinJoin成为可能的原因：</p>
<p>交易事务内部的每个输入的签名彼此完全独立。这意味着比特币用户可能会同意要花费的一组输入，要支付的一组输出，然后分别单独签署交易并随后合并其签名。在提供所有签名之前，该交易是无效的，并且不会被网络接受，并且没有人会签名不符合他们喜好的交易。</p>
<p>为了使用它来增加隐私，N个用户将同意一个统一的输出大小，并提供至少等于该大小的输入。如果某些用户提供的输入超出目标，则该交易将具有该大小的N个输出，并可能有N个更多的更改输出。所有人都会签署交易，然后可以传输交易。任何时候都没有被盗的风险。</p>
<p>在图示中，“交易2”的输入来自1A1和1C3。假设我们相信1A1是用于Alice的地址，而1C3是用于Charlie的地址。 Alice和Charlie中的哪一个拥有1D和1E的输出？</p>
<p>这个想法也可以更随意地使用。当您要付款时，找到也要付款并共同付款的其他人。这样做并不会增加太多隐私，但是实际上会使您的交易更小，从而在网络上更轻松（费用更低）；额外的隐私更是一种增益。</p>
<p>这样的交易在外部来看与通过常规使用创建的交易没有区别。因此，如果这些交易变得很普遍，它们甚至可以改善不使用它们的人的隐私，因为不再将输入共同参与作为通用控制的有力证据。</p>
<p>这个想法可能有很多变种，并且可以与变种共存，因为该想法不需要更改比特币系统。百花齐放：我们可以在实现这一目标的方式上有多种选择，并学到最好的方法。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><em>是否不需要tor或其他东西来阻止所有人分析每个人的IP？</em></p>
<p>任何希望隐藏用户地址的交易隐私系统都应以某种匿名网络开始。 没什么两样。 幸运的是，像Tor，I2P，Bitmessage和Freenet这样的网络都已经存在，并且可以全部用于此目的。 （但是，Freenet会导致交易非常缓慢）</p>
<p>但是，加强“污点分析”并缩小交易规模甚至不需要用户彼此私密。 因此，即使没有类似tor之类的，也不会比常规交易更糟糕。</p>
<p><em>用户是否不了解哪些输入与哪些输出匹配？</em></p>
<p>在用户使用基于tor的IRC之类的最简单的可能实现方式中，是的。下一个最简单的实现是，用户将其输入和输出信息发送到某些集合点服务器上，然后服务器创建交易并要求人们对其进行签名。服务器学习了映射，但其他人都没有，服务器仍然无法窃取硬币。</p>
<p>在甚至服务器都不学习映射的情况下，也可能有更复杂的实现。</p>
<p>例如。使用chaum盲签名：用户连接并提供输入（和更改地址）以及他们希望私人硬币进入的地址的密码盲版本；服务器对令牌进行签名并返回它们。用户匿名重新连接，取消隐藏其输出地址，然后将其返回给服务器。服务器可以看到所有输出均已由其签名，因此所有输出都必须来自有效参与者。后来人们重新连接并签名。</p>
<p>类似的事情可以通过各种零知识证明系统来完成。</p>
<p><em>完全隐私的版本是否需要一台服务器？ 如果关机了怎么办？</em></p>
<p>不是。在所有用户都充当盲签名服务器的情况下，可以通过分散方式实现相同的隐私。 最终需要n^2个签名，并且通常很难创建分布式系统。 我不知道是否有理由去辛辛苦苦做出具有完全保密性的完全分布式版本，但是这肯定是可能的。</p>
<p><em>DoS（拒绝服务）攻击如何？ 即使交易有效，有人也不能拒绝签名吗？</em></p>
<p>是的，这可以通过两种不同的方式受到DoS的攻击：有人可以拒绝签署有效的联合交易，或者有人可以在联合交易完成之前从联合交易中花费其输入。</p>
<p>但是，如果所有签名都没有在一定期限内到来，或者创建了冲突的交易，则您可以轻松地离开恶意方，然后重试。使用自动过程，任何重试对于用户都是不可见的。因此，唯一真正的风险是持久的DoS攻击者。</p>
<p>在非分散（或分散但非参与者专有）的情况下，对DoS攻击者获得一定的免疫力是很容易的：如果某人未签名输入，则在以后的回合中将该输入列入黑名单。然后，他们自然会受到创建更多已确认比特币交易的能力的限制。</p>
<p>在分散式系统中获得DoS抵抗力要困难得多，因为很难确定哪个用户实际上违反了规则。一种解决方案是让用户在零知识证明系统下执行其活动，因此您可以确定哪个用户是骗子，然后同意忽略他们。</p>
<p>在所有情况下，您都可以通过工作证明，保真度绑定或其他稀缺资源使用来补充反DoS机制。但是我怀疑，随着实际攻击的发生，最好适应这种攻击，因为我们不必事先针对所有用户都采用单一的安全机制。我还认为，错误的输入排除可以为入门提供足够的保护。</p>
<p><em>匿名集大小是否不受一次交易中可以拥有多少方的限制？</em></p>
<p>不完全是。显然，单个交易的匿名集大小受其参与方数量的限制。交易规模的限制以及失败（重试）的风险意味着真正庞大的联合交易是不明智的。但是，由于这些交易价格便宜，因此可以联合的交易数量没有限制。</p>
<p>特别是，如果您可以建立每个事务有m个参与者的事务，则可以创建一个m*3事务序列，该序列构成一个三阶段交换网络，该网络允许m^2个最终输出中的任何一个来自m^2个原始输入（例如，使用32个交易的三个阶段，每个输入有32个输入，每个1024个用户可以加入96个交易）。这允许匿名集设置为任何大小，仅受参与限制。</p>
<p>实际上，我希望大多数用户只希望防止闲的蛋疼的朋友（和小偷）进入他们的财务生活，并恢复由于地址重用等不良做法而丢失的一些隐私。这些用户可能只通过一次通行证就会感到满意；其他人将只是机会性地进行操作，而其他人则可能会努力实现许多通行证和重要的匿名设置。所有人都可以共存。</p>
<p><em>与ZeroCoin相比如何？</em></p>
<p>作为一个密码学和计算机科学的极客，我对Zerocoin感到非常兴奋：其背后的技术令人着迷并且非常重要。但是，作为比特币用户和开发人员，推广它作为改善隐私的解决方案令我感到失望。</p>
<p>Zerocoin有很多严重的局限性：</p>
<ul>
<li>它使用最先进的加密技术，这可能是不安全的，并且相对较少的人可以理解（例如，与ECDSA相比）。</li>
<li>它会产生较大的签名（20 KB），这些签名会使区块链膨胀（如果将其填充到外部存储中会产生风险）。</li>
<li>它需要一个受信方来启动其累加器。如果该组织作弊，他们可以偷硬币。 （也许可以通过更先进的加密技术修复。）</li>
<li>验证非常慢（在快速CPU上每秒可以处理约2tx），这是在比特币中部署的主要障碍，因为每个完整节点都必须验证每笔交易。</li>
<li>大笔交易和缓慢的验证也意味着昂贵的交易，这将减少匿名集的大小，并可能使零散地关注随机性的公众无法使用ZC。</li>
<li>使用永久增长且无修剪的累加器。实际上，这意味着我们需要定期切换累加器以减小工作集大小，从而减小匿名集大小。如果未预先设置累加器的范围，则可能会造成大的UTXO膨胀问题。</li>
</ul>
<p>随着时间的流逝，随着数学和软件工程的改善，其中一些事情可能会显着改善。</p>
<p>但最重要的是：<strong>Zerocoin要求对比特币协议进行软分叉更改</strong>，所有完整节点都必须采用此更改，这会将比特币提交到Zerocoin协议的特定版本。这不可能很快发生——可能不会在几年内发生，特别是考虑到有很大的潜力可以进一步改进算法以降低成本。这将在政治上引起争议，因为一些开发人员和比特币业务非常担心过度与“匿名”相关联。网络范围内的规则更改有点像自杀协议：我们不应该也不要轻视它们。</p>
<p><strong>CoinJoin交易从今天开始就可以工作</strong>，从比特币的第一天开始就开始运作。 它们与正常交易没有区别，因此无法阻止或抑制，除非可以阻止其他任何比特币交易。</p>
<p>（顺便说一句：ZeroCoin可能在去中心化CoinJoin中以比特币的形式在外部使用，以一种抵御DoS攻击的方式使用户相互不可见。这将使ZeroCoin在实时交锋中成熟，而无需承担成本或承诺网络范围内的特点协议。）</p>
<p>我可以通过CoinJoin为ZeroCoin提出的主要论点是，它可能会提供更大的匿名集，这超出了我的加密极客的愿望。 但是由于ZC的性能和扩展限制，以及使用CoinJoin构造分类网络事务的可能性，或者仅具有使用数百个CoinJoin事务以及一项ZeroCoin事务所需的存储和处理能力的能力，我不知道实际上哪个会 在实践中产生更大的匿名集。 例如。 要加入1024个用户，仅ZeroCoin兑换将涉及20k * 1024字节的数据，而对于32个32位联合交易的完整三阶段联合来说，该数据不到3％。 尽管ZeroCoin匿名集可以更轻松地跨越更大的时间范围。</p>
<p>CoinJoin交易的匿名集很容易足够大，普通用户可以重新获得他们的一些临时隐私，这就是我认为最有趣的事情。</p>
<p><em>这与CoinWitness相比如何？</em></p>
<p>CoinWitness甚至比Zerocoin更超前复杂，它还具有许多改善隐私性的弱点：新颖的加密技术，计算成本以及需要软分叉的巨大缺点，并且现阶段不可用。 如果它不仅仅用作隐私工具，还可能具有一些扩展优势。 但这确实是解决该问题的过度手段，并且不会在任何真正的时间推出。</p>
<p><em>听起来不错！ 它在哪里？</em></p>
<p>麻烦之处：尚无现成的，易于使用的软件来执行此操作。您可以使用bitcoin-qt和原始交易API手动进行交易，就像我们在“富含污点”线程中所做的那样，但是要使之成为现实，我们需要易于使用的自动化工具。</p>
<p>卢克（Luke）编写了一些协议的草图，该协议将允许通过常规比特币网络建立联合交易。</p>
<p>Bitcoin-qt RPC系统为此类系统的参与者提供了编写辅助小程序所需的一切（包括锁定txout的功能，以防止它们被从其下方花费掉）。但是，如今有如此多的用户使用可监视他们的集中式网络钱包这一事实最终将限制这些工具的用户群。</p>
<p>就我个人而言，我大部分的编码大脑能力都花在了其他事情上，这些事情对我来说更重要。而且我可以在比特币上剩余的钱都花在了更多的核心和安全性上—如果我很快处理与钱包相关的任何事情，那可能会改善硬币选择的隐私行为……但此外：</p>
<p>建立此功能的任何人都将被指控进行犯罪活动，无论是否有任何实际的犯罪分子使用此行为，都无关紧要：犯罪活动会成为头条新闻。作为比特币核心开发人员，已经可以填补我这种指控的名额，尤其是我什至没有付钱的风险名额。笑脸</p>
<p>实际上，真正的犯罪分子即使有丝毫线索也不需要CoinJoin：他们有能力以普通用户无法获得的方式购买隐私，这只是他们（通常是利润丰厚的）业务的成本。</p>
<p>Joe-criminal可以外出购买120％PPS采矿来获得全新的硬币，或者通过一系列半伪造的高现金流量赌博企业来赚钱，以减少50％的费用，他们可以负担寻找并与之交互的成本这些卑鄙的服务…乔和简·多伊？他们的名字在blockchain.info的跑马灯上。对于他们来说，这似乎不太好，但是如果修复它的成本很高，他们根本不会，因为修复它的成本是非常具体的，而且损失的成本或投机性是遥不可及的。他们可能只需要放弃比特币，而转而使用几乎完全私人的东西：现金…普通用户需要有效且廉价的隐私才能完全帮助他们。</p>
<p>我知道制作这样的工具并不适合许多比特币企业的快速致富模式，但是重要性是显而易见的，并且最简单的版本不需要非常深入的技术指导。我认为，改善人们隐私的“政治”风险是您应该认真考虑的真实风险，但是在这些部分附近，我看到人们在一些风险非常高的东西上贴上自己的名字。我希望“全盘污染”的话题足以激发社区的某些行动，但是也许会。</p>
<p>因此，应该反过来，我问你：它在哪里？</p>
<p><a href="https://bitcointalk.org/index.php?topic=279249.0" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <tags>
        <tag>bitcointalk</tag>
        <tag>bitcoin</tag>
        <tag>done</tag>
        <tag>coinjoin</tag>
        <tag>privacy</tag>
      </tags>
  </entry>
  <entry>
    <title>Design of Contracts</title>
    <url>/post/design-of-contracts/</url>
    <content><![CDATA[<p>说实话其实一开始压根没想做合约，就只是想做个chain。</p>
<p>但是后来发现你不做DAPP你的chain都没人看，那些做coin的也都在往DAPP靠。就有种被逼上梁山的感觉。不过还好现在有个去华山的路（WASM），可以考虑上了华山再往梁山飞。</p>
<p>其实我也不算是第一个选择华山飞梁山的，cosmos和eth2.0也选，不过人家有现成地图，我只能凭感觉乱飘。而且我们不是一个山头起飞的，他们选了更早被人发现的山头（wasmer），我选了个看起来粗大(?)一点的新山头（wasmtime）。</p>
<span id="more"></span>

<p>不瞎扯了，下面就开始分析对于合约的设计。</p>
<p>做ethereum开发的都知道Solidity，因此需求也是从这个上面靠拢。不过由于现在主要支持wasm的语言C和RUST都是比较成熟的所以直接就选择他们对具体功能开干。</p>
<p>+-x÷是都没有问题，问题在于和链的互动，和rpc的互动，以及事件的侦听。</p>
<h1 id="ngVM"><a href="#ngVM" class="headerlink" title="ngVM"></a>ngVM</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>上传至链上的wasm需要为<a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md" target="_blank" rel="noopener">binary格式</a></p>
<h3 id="数据类型-data-type"><a href="#数据类型-data-type" class="headerlink" title="数据类型 data type"></a>数据类型 data type</h3><ul>
<li>i32: 返回code，&gt;0为正常，&lt;&#x3D;异常 </li>
<li>i64: 指针</li>
<li>u64: 账户</li>
<li>bytes: 底层mem</li>
</ul>
<h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>wasm只能import在ngVMI中指定的接口。</p>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>在Debug环境里提供一系列print的接口</p>
<h3 id="Exports"><a href="#Exports" class="headerlink" title="Exports"></a>Exports</h3><p>合同必须完全具有两个export：</p>
<ul>
<li><code>memory</code>: 可供EEI写入的共享内存空间。</li>
<li><code>main</code>: 没有参数和结果值的函数。</li>
</ul>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>导出为<code>main</code>的方法将由NGIN内部VM Manager执行。</p>
<p>如果成功执行，则正常返回。</p>
<p>如果由于故障而需要中止，则返回error，避免panic。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>如果执行wasm代码触发了wasm异常，则执行将失败并终止。</p>
<h2 id="接口-ngVMI-NGIN-VM-Interface"><a href="#接口-ngVMI-NGIN-VM-Interface" class="headerlink" title="接口(ngVMI: NGIN VM Interface)"></a>接口(ngVMI: NGIN VM Interface)</h2><p>WIP</p>
<h3 id="log-debug-msg-ptr-i64-msg-len-i64"><a href="#log-debug-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::debug(msg_ptr i64, msg_len i64)"></a>log::debug(msg_ptr i64, msg_len i64)</h3><h3 id="log-info-msg-ptr-i64-msg-len-i64"><a href="#log-info-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::info(msg_ptr i64, msg_len i64)"></a>log::info(msg_ptr i64, msg_len i64)</h3><h3 id="log-error-msg-ptr-i64-msg-len-i64"><a href="#log-error-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::error(msg_ptr i64, msg_len i64)"></a>log::error(msg_ptr i64, msg_len i64)</h3><h3 id="log-warn-msg-ptr-i64-msg-len-i64"><a href="#log-warn-msg-ptr-i64-msg-len-i64" class="headerlink" title="log::warn(msg_ptr i64, msg_len i64)"></a>log::warn(msg_ptr i64, msg_len i64)</h3><p>打印输出，默认关闭。</p>
<h3 id="account-get-host-gt-num-i64"><a href="#account-get-host-gt-num-i64" class="headerlink" title="account::get_host() -&gt; num i64"></a>account::get_host() -&gt; num i64</h3><p>获取vm自身account num(uint64)</p>
<h3 id="account-get-owner-size-account-num-uint64-gt-owner-ptr-i64"><a href="#account-get-owner-size-account-num-uint64-gt-owner-ptr-i64" class="headerlink" title="account::get_owner_size(account_num uint64) -&gt; owner_ptr i64"></a>account::get_owner_size(account_num uint64) -&gt; owner_ptr i64</h3><p>获取vm自身owner’s address的长度（当前肯定是35）</p>
<h3 id="account-get-owner-account-num-uint64-ptr-uint32-gt-owner-ptr-i64"><a href="#account-get-owner-account-num-uint64-ptr-uint32-gt-owner-ptr-i64" class="headerlink" title="account::get_owner(account_num uint64, ptr uint32) -&gt; owner_ptr i64"></a>account::get_owner(account_num uint64, ptr uint32) -&gt; owner_ptr i64</h3><p>获取vm自身owner’s address (length &#x3D; 35 bytes)，并将其写入ptr指针处。返回值为成功写入的字节数。</p>
<h3 id="account-get-contract-len-ptr-i64-gt-contract-ptr-i64"><a href="#account-get-contract-len-ptr-i64-gt-contract-ptr-i64" class="headerlink" title="account::get_contract(len_ptr i64) -&gt; contract_ptr i64"></a>account::get_contract(len_ptr i64) -&gt; contract_ptr i64</h3><p>已删除</p>
<p>原：获取vm自身合约代码</p>
<p>现：由于获取全部二进制内容毫无意义，而且会占用较多内存，所以废弃此内容。<br><del>作为替代，将来提供get_contract_hash函数来帮助开发者做对线上内容的快速double check。</del><br>不能在内容里对内容hash……</p>
<p>如果是需要读取其他account下的contract内容，暂时感觉也没必要。</p>
<h3 id="account-get-context-account-num-u64-ptr-u32-gt-u32"><a href="#account-get-context-account-num-u64-ptr-u32-gt-u32" class="headerlink" title="account::get_context(account_num u64, ptr u32) -&gt; u32"></a>account::get_context(account_num u64, ptr u32) -&gt; u32</h3><p>获取可持续存储内容</p>
<p>可持续存储读取</p>
<h3 id="context-alloc-len-u64"><a href="#context-alloc-len-u64" class="headerlink" title="context::alloc(len: u64)"></a>context::alloc(len: u64)</h3><p>为可持续存储分配空间<br>&#x2F;&#x2F;TODO: 收费</p>
<h3 id="context-write-src-ptr-i64-dst-ptr-i64-len-u64"><a href="#context-write-src-ptr-i64-dst-ptr-i64-len-u64" class="headerlink" title="context::write(src_ptr: i64, dst_ptr: i64, len: u64)"></a>context::write(src_ptr: i64, dst_ptr: i64, len: u64)</h3><p>可持续存储写入</p>
<h3 id="coin-transfer-to-u64-value-ptr-i64-gt-i32"><a href="#coin-transfer-to-u64-value-ptr-i64-gt-i32" class="headerlink" title="coin::transfer(to: u64, value_ptr: i64) -&gt; i32"></a>coin::transfer(to: u64, value_ptr: i64) -&gt; i32</h3><p>类似于eth里的<code>seller.send(price)</code></p>
<p>原来叫create_transaction，表示由wasm_vm主动创建一个事务tx让chain通过处理tx方式修改state</p>
<p>通过此函数，vm能够提供例如bank&#x2F;token的基础资金转移功能。</p>
<p>但是遇到一个之前忽略掉的问题——从vm里发出的交易该怎么sign？</p>
<p>根据ETH的方法，调用都会被算为是由tx的call触发，因此这些变化都是由原tx负责。</p>
<p>换句话说，变动的只有state，并不会出现由contract主动触发的tx。</p>
<p>因此这个tx摆在这里就不合适了，因为vm里的操作都是直接作用于state</p>
<p>所以这里就不应该使用transaction or tx来称呼这个操作，而用transfer来简化这个函数。</p>
<p>假如to的account不存在，那个需要触发trap</p>
<h3 id="tx-get-convener-gt-num-u64"><a href="#tx-get-convener-gt-num-u64" class="headerlink" title="tx::get_convener() -&gt; num u64"></a>tx::get_convener() -&gt; num u64</h3><p>获取transaction的convener</p>
<h3 id="tx-get-participants-len-gt-len-u64"><a href="#tx-get-participants-len-gt-len-u64" class="headerlink" title="tx::get_participants_len() -&gt; len u64"></a>tx::get_participants_len() -&gt; len u64</h3><p>获取transaction的参与人数量</p>
<h3 id="tx-get-participant-index-u64-gt-account-ptr-i64"><a href="#tx-get-participant-index-u64-gt-account-ptr-i64" class="headerlink" title="tx::get_participant(index: u64) -&gt; account_ptr i64"></a>tx::get_participant(index: u64) -&gt; account_ptr i64</h3><p>获取transaction的参与人，需要用account namespace的api处理</p>
<h3 id="tx-get-values-len-gt-len-u64"><a href="#tx-get-values-len-gt-len-u64" class="headerlink" title="tx::get_values_len() -&gt; len u64"></a>tx::get_values_len() -&gt; len u64</h3><p>获取transaction的参与人数量</p>
<h3 id="tx-get-value-index-u64-gt-value-ptr-i64"><a href="#tx-get-value-index-u64-gt-value-ptr-i64" class="headerlink" title="tx::get_value(index: u64) -&gt; value_ptr i64"></a>tx::get_value(index: u64) -&gt; value_ptr i64</h3><p>获取transacation的对应value(uint256)</p>
<h3 id="state-get-balance-addr-i64-gt-balance-ptr-i64"><a href="#state-get-balance-addr-i64-gt-balance-ptr-i64" class="headerlink" title="state::get_balance(addr: i64) -&gt; balance_ptr i64"></a>state::get_balance(addr: i64) -&gt; balance_ptr i64</h3><p>balance 长度 8*4 &#x3D; 24 </p>
<h3 id="state-get-owner-num-u64-gt-addr-ptr-i64"><a href="#state-get-owner-num-u64-gt-addr-ptr-i64" class="headerlink" title="state::get_owner(num: u64) -&gt; addr_ptr i64"></a>state::get_owner(num: u64) -&gt; addr_ptr i64</h3><p>addr 长度 33</p>
<h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><p>Assign &amp; Append tx</p>
<h2 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h2><p>WASM的发布分为两种: Web or Wasm.</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>任何ngcore节点能够作为http server提供http服务(单页面)，端口为52528。默认关闭，通过Flag打开</p>
<p>例如 <a href="http://app.ngin.sh:52528/#10086/path1/path2" target="_blank" rel="noopener">http://app.ngin.sh:52528/#10086/path1/path2</a></p>
<p>服务运营者可以通过nginx反代限制app为</p>
<p><a href="https://app.mydomain.com/path1/path2?param1=1&amp;params2=2" target="_blank" rel="noopener">https://app.mydomain.com/path1/path2?param1=1&amp;params2=2</a></p>
<p>发布Web应用需要将wasm binary写入Contract字段。在访问时会自动将字段作为文件拉取，并且通过导出的main函数进行执行</p>
<h3 id="Wasm"><a href="#Wasm" class="headerlink" title="Wasm"></a>Wasm</h3><p>Wasm可以作为网站后端运行，也可以纯提供链上事务或者作为其他Wasi运行库</p>
<p>Wasm要求Contract为wasm binary.</p>
<h2 id="当前遇到的问题"><a href="#当前遇到的问题" class="headerlink" title="当前遇到的问题"></a>当前遇到的问题</h2><h3 id="Infinite-loop"><a href="#Infinite-loop" class="headerlink" title="Infinite loop"></a>Infinite loop</h3><p>当前使用wasmtime，无法在运行前拦截vm中infinite loop</p>
<p>当loop执行，就会导致全网主机阻塞在处理该vm对应的tx上</p>
<p>感觉该看一下wasm的opcode</p>
<h3 id="Fee-charging"><a href="#Fee-charging" class="headerlink" title="Fee charging"></a>Fee charging</h3><p>由于wasmtime只提供封闭的ffi，因此无法将opcode与fee进行挂钩</p>
<p>这里可以理解为我们需要自己写一个ngin专用的wasm runtime</p>
<p>找材料的时候发现了perlin-network的一个wasm方案，<a href="https://github.com/perlin-network/life" target="_blank" rel="noopener">life</a>.</p>
<p>钱多好办事哈，人家自己也折腾了个chain daemon叫<a href="https://github.com/perlin-network/wavelet" target="_blank" rel="noopener">wavelet</a>，意思是小波浪</p>
<p>life里加gas是在compile时候，对每个Block做totalCost的计算（递增1，即每个instruction费用为1），然后给每个block的code前面都加上一个add_gas的instruction。</p>
<p>当然这个add_gas的ins当前还没用，也不知道他们准备加点啥。</p>
<p>compile是将wasm binary转换为host上的一个module，他们的api应该是参考的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile" target="_blank" rel="noopener">js interface</a></p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>NGIN</tag>
        <tag>contract</tag>
      </tags>
  </entry>
  <entry>
    <title>Detection of Encrypted Cryptomining Malware Connections With Machine and Deep Learning</title>
    <url>/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/</url>
    <content><![CDATA[<h1 id="使用机器学习与深度学习对恶意加密货币挖矿软件加密连接的检测"><a href="#使用机器学习与深度学习对恶意加密货币挖矿软件加密连接的检测" class="headerlink" title="使用机器学习与深度学习对恶意加密货币挖矿软件加密连接的检测"></a>使用机器学习与深度学习对恶意加密货币挖矿软件加密连接的检测</h1><p>简介：</p>
<p>如今，恶意软件已成为一个流行问题。在利用受害者计算机资源的攻击中，一种常见的攻击与数字货币加密所需的大量计算资源有关。网络犯罪分子从受害者那里窃取计算机资源，将这些资源与他们从中受益的加密货币矿池相关联。这项研究工作的重点是提供一种解决方案，仅通过被动网络监控来检测此类滥用的加密货币挖矿活动。为此，我们确定了一组新的高度相关的网络流特征，与一组丰富的机器和深度学习模型联合使用，用于实时加密挖掘流检测。我们为训练和测试机器和深度学习模型部署了一个复杂而真实的加密挖掘场景，其中客户端与互联网上的真实服务器交互并使用加密连接。进行了一组完整的实验以证明，将这些信息量丰富的特征与复杂的机器学习模型相结合，即使流量被加密，也可以在线路上以电信级的精度和准确度检测到加密攻击。</p>
<p><strong>索引术语</strong>： 加密挖矿检测、恶意软件检测、加密劫持检测、加密货币挖掘、网络流量测量、加密流量分类、机器学习、深度学习。</p>
<span id="more"></span>

<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>恶意软件是基于一个简单概念的流行问题：利用受害者的计算机资源。纵观最近的历史，恶意软件的演变提供了更大的弹性和多功能性来实现多个目标：拒绝服务 (DoS)、敏感数据盗窃、他人之间非法活动的匿名性。但总的来说，主要动机是经济。恶意软件家族开发了各种各样的技术来获利，从简单的 DoS 威胁勒索到复杂的银行木马，期望最终获得一些信托资金。在这种不可阻挡的演变 [1] 中，网络犯罪分子寻找新模式以获取快速利润。数字货币非常适合这种策略。</p>
<p>比特币 [2] 是第一个基于区块链的去中心化数字货币。任何拥有足够计算能力的人都可以参与并获利，进行加密计算来为区块链做出贡献。作为这种计算的结果，使用完全相同的加密货币提供了可变奖励。这通常被称为加密挖掘。不幸的是，独立的加密货币挖矿不再有利可图，解决方案是使用称为挖矿池的新型服务关联多台计算机（或机器人）。这些安排提供了与参与者使用特定协议提供的计算资源成比例的挖矿奖励的百分比（参见第 III 节）。如今，多种加密货币已经诞生和消亡[3]，为挖矿提供了多种有利可图的生态系统。确切地说，作为这种生态系统扩散的一部分，一些加密货币产生了对专用硬件 (ASIC) 设备的反对，改变了算法 [4]、[5] 使它们变得无用，并再次打开了通过正常计算机挖掘获利的机会。</p>
<p>网络犯罪分子可以通过两种主要方法填充他们的加密货币钱包。 首先，通过利用勒索软件恶意软件家族来加密受害者的数据并使用无法追踪的加密货币接收付款，以便让受害者恢复加密信息。 第二种选择包括使用僵尸网络或在浏览器中执行非法进程（加密劫持），在未经受害者同意的情况下，将受害者的计算机资源秘密添加到抗 ASIC 的矿池中，并为犯罪分子的利益花费计算资源。 第一个具有引起当局关注的内在风险，取决于受害者的支付意愿，但也带来了准时的大好处。 相反，第二种方法可以长时间运行，产生不断增加的收益 [6]。</p>
<p>我们研究的重点是<strong>第二种方法</strong>，它为行业提供了一种检测网络上的加密挖矿活动的解决方案。 挖矿流量通常被加密以避免检测，僵尸网络可以使用私有代理 IP 来聚合和伪装挖矿池。</p>
<p>众所周知，如今越来越多的流量被加密（&gt; 80%），因为许多网络协议（例如 TLS、SSH、QUIC、VPN）都采用了加密。此外，关注隐私问题的政府正在对电信提供商访问用户数据或检查数据包有效载荷施加限制。在这种情况下，我们提出了一种新的方法来检测网络上的加密挖掘活动（图 1），即使它是加密的，基于通过机器和深度学习技术分析挖掘客户端的网络行为，而不是经典的深度数据包和有效载荷检查技术或矿池域名识别。我们建议应用受监督的机器和深度学习技术，这些技术将排除使用 IP 地址、端口号或应用程序级别信息等可能包含个人和敏感用户数据的输入特征。此外，在机器学习模型的训练和测试阶段，加密流量将被广泛使用，因为这种类型的流量将在不久的将来变得普遍。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/mining.png" class="">
<p>图 1. 分析网络行为以检测隐藏活动</p>
<p>由于多种原因，我们选择门罗币（XMR）作为本研究的加密货币挖矿协议。首先，Monero 是迄今为止地下市场网络犯罪分子最喜欢的加密货币 [6]。其次，Monero 开发人员公开承诺将 ASIC 排除在挖矿生态系统之外，并且所需的资源量很少（例如 RandomX 算法 [5] 中的轻型模式，只需要 256 MiB 的共享内存），增加了恶意软件对其的采用家庭。最后，门罗币对 CPU 挖掘的偏好使得在 GPU 或 ASIC 设备方面对标准客户端的实验更加现实。我们在一个受控但现实的环境中证明，仔细的特征选择对于在存在加密货币流的交通场景中使用机器和深度学习模型获得良好的检测性能至关重要。我们使用从网络流量低点获得的两组不同的统计特征来比较机器学习性能。第一组是使用 Tstat 工具提取的，这是一种众所周知的被动嗅探器，能够在网络和传输级别提供每个流的统计信息，第二组来自 IETF 标准 NetFlow&#x2F;IPFIX 指标，这些指标在行业中广泛使用.据我们所知，我们的研究工作是第一个利用 Tstat 获得的特征作为监督机器学习算法的输入的提议。我们证明了第一组比第二组提供了更多的信息，这意味着，独立于所使用的机器学习模型，预测更稳定、准确和精确。此外，我们表明复杂模型（例如随机森林和完全连接的深度神经网络）能够以比简单模型（例如决策树和逻辑回归）显着更高的精度、准确度和稳定性来检测加密流量活动，即使流量是加密。最后，我们得出结论，如本文中提出的那样，复杂的机器学习模型使用 Tstat 获得的一组详尽特征作为输入，以工业部署所需的准确度、精确度和稳定性识别加密货币流量。</p>
<h2 id="二、贡献"><a href="#二、贡献" class="headerlink" title="二、贡献"></a>二、贡献</h2><p>通过网络检测加密挖掘恶意软件仍处于起步阶段，据我们所知，只有一项研究工作 [7] 解决了这个问题，但假设了一个相当不切实际的场景，其中 i) 不考虑加密流量, ii) 只提出了一组简化的传统机器学习模型，并且 iii) 一组稍微没有信息的特征被用作输入。因此，当在我们的受控环境中重现实验时，获得的性能与电信行业的预期相差甚远。为了超越当前提案的局限性，我们的实验工作提出了以下新颖性：</p>
<ul>
<li><p>一个复杂而真实的挖矿场景，用于训练和测试用于挖矿流检测的机器学习模型。该场景由典型的 Internet 应用程序（例如 Web 浏览、多媒体、通过共享文件夹访问文件）和与分布在 Internet 上的真实挖矿服务器池交互的加密客户端组成。这种受控设置允许生成真实的网络流量，即使流量被加密，也可以 100% 的精度自动收集和标记。标记的流量将用于训练和测试机器学习模型，用于满足电信行业严格要求的加密货币流检测。我们的实验设置与现有作品的一个显着特征是除了非加密连接之外还使用加密连接。如今，越来越多的应用程序对其通信进行加密，其内容的识别对机器学习分类器，尤其是密码挖掘检测器提出了额外的挑战。</p>
</li>
<li><p>提议将一组新的信息丰富的特征用作实时密码挖掘流检测的输入。这些功能源自 Tstat 生成的一组取证统计数据，该工具旨在从网络数据包跟踪中生成每个连接的统计数据。我们修改了 Tstat 工具以导出一组实时流特征，以输入到 ML 分类器以进行密码挖掘检测。在我们的实验中，我们证明了当网络流量被加密时，与使用标准特征相比，使用提议的新特征集显着提高了 ML 性能。</p>
</li>
<li><p>一套完整的实验表明，即使流量被加密，也可以使用派生的 Tstat 特征和复杂的机器学习模型，以电信级的精度和准确度在线路上检测到加密攻击</p>
</li>
</ul>
<h2 id="三、加密货币和加密挖掘协议"><a href="#三、加密货币和加密挖掘协议" class="headerlink" title="三、加密货币和加密挖掘协议"></a>三、加密货币和加密挖掘协议</h2><p>加密货币可以定义为数字交换媒体，基于使用加密原语来规范新加密货币单位的发行和验证交易。中本聪 [2] 在开创性论文中介绍了第一个也是最广泛使用的加密货币比特币 (BTC)。加密货币是完全去中心化的，没有控制权，这是 P2P 文件共享网络的共同特征。交易的验证基于分布式账本，通过区块链（一种不可变的共享数据结构 [8]）实现。当使用加密货币时，相关交易被添加到区块链中。然后，加密货币用户（称为矿工）可以通过计算密集型加密过程（通常称为挖矿）验证新区块，即一组交易，以防止不公平地使用加密货币（例如双重支出）。鼓励矿工通过奖励（即新的加密货币单位）参与交易验证。然而，验证过程的高度复杂性使得获得此类奖励仅适用于专用硬件 (ASIC) 所有者。矿池试图克服这一限制，协调不同矿工的工作和资源，他们通过网络共享计算能力。用于在矿池参与者之间分配挖矿过程的最广泛协议称为 Stratum [9]，并且已首先用于 Slushpool 矿池 [10]。</p>
<p>图 2 所示的 Stratum 协议指定了矿池服务器与其参与者之间的双向通信通道，消息编码遵循 JSON-RPC 2.0 规范 [11]。下面，我们将简要描述典型的 Stratum 协议流程。首先，客户端可以发起（或恢复）与矿池服务器的会话，调用服务器上的订阅RPC方法，在请求中指定客户端将使用的挖矿软件来解决服务器随后将发送给的挑战客户端。需要注意的是，一个矿池用户在挖矿过程中可能会使用多个设备（Stratum 术语中的 Worker）。因此，客户端还需要授权服务器向每个工人发送挑战，通过为每个工人调用服务器上的授权 RPC 方法，将其用户名和密码发送到服务器（图 2 中的步骤 1）。然后，服务器可以向工作人员发送挑战，向他们调用提交 RPC 方法（图 2 中的步骤 2）。如果工作人员找到了挖矿挑战的解决方案，他可以通过调用提交 RPC 方法将其发送到服务器（图 2 中的步骤 3）。在验证解决方案的正确性后，服务器可以向解决挑战的工作人员以及其他试图解决问题的工作人员发送新的挑战，再次调用他们的提交 RPC 方法。 Stratum 消息可以以加密形式发送，例如将它们嵌入到 TLS 帧中 [12]。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/stratum.png" class="">
<p>图 2. Stratum协议涉及的消息流。上图在TCP连接中运行，通过TLS会话的Botton图</p>
<h2 id="四、-相关工作"><a href="#四、-相关工作" class="headerlink" title="四、 相关工作"></a>四、 相关工作</h2><p>尽管是当今工业场景中的热门话题，但在当前的科学文献中，对加密采矿活动的检测却鲜有研究。 大多数当前最先进的工作主要集中在通过分析目标节点的行为来检测在受害者身上运行的加密挖掘或加密劫持软件模块。 尝试检测 Stratum 或其他加密挖矿协议的作品更少。</p>
<h3 id="A-加密流量的识别"><a href="#A-加密流量的识别" class="headerlink" title="A. 加密流量的识别"></a>A. 加密流量的识别</h3><p>很少有研究工作专注于通过查看网络流量来检测密码挖掘活动。与我们的研究最接近的工作是由 Muñoz 等人提出的。在 [7]。在这项工作中，作者评估了四种不同的机器学习技术（SVM、朴素贝叶斯、CART 和 C4.5 决策树），以识别应用非 DPI（深度数据包检测）方法的非加密加密矿层流。他们得出的结论是，可以识别用于挖掘五种不同加密货币（比特币、比特币现金、DogeCoin、莱特币和门罗币）的非加密 Stratum 连接。此外，作者表明，一些机器学习模型（例如 CART 决策树）能够准确地区分这些加密货币挖掘流与正常流量，并对正在挖掘的加密货币进行分类。我们研究与这项工作的<strong>主要区别</strong>在于（a）我们提出了更复杂的模型（随机森林和完全连接的神经网络）来检测加密活动，这显着提高了预测的稳定性、精度和准确性，（b）与 Muñoz 等人的方法相比，我们的研究中还考虑了加密流量，以评估现实场景中的机器学习性能，并且 (c) 我们使用了由 Tstat 工具派生的 51 个特征的更多信息集，这些特征产生了明显更好的效果结果比 Muñoz 等人采用的方法要好。仅利用来自 NetFlow&#x2F;IPFIX 指标的 8 个功能。在我们设置的现实场景中比较这两个提议的结果，可以观察到，使用具有 Netflow 特征的更简单的机器学习算法，如 [7]，在机器学习预测中会产生不稳定和较差的性能。另一方面，当复杂的机器学习模型与更多信息特征结合使用时，如我们工作中提出的那样，可以获得高性能、稳健和稳定的预测。</p>
<p>斯威丹等人。 [13] 提出了一组更传统的方法来检测并最终阻止加密挖掘连接。 作者提出了一种名为 MDPS（挖矿检测和预防系统）的架构，用于丢弃由浏览器（例如 CoinHive、Crypto-Loot）生成的非加密挖矿流。 他们的方法基于部署代理，对连接执行 DPI 检查以拒绝任何可疑流量，当矿工加密他们的通信时，这是相当无效的。</p>
<h3 id="B-加密软件模块的识别"><a href="#B-加密软件模块的识别" class="headerlink" title="B. 加密软件模块的识别"></a>B. 加密软件模块的识别</h3><p>检测加密挖矿进程的大部分工作都使用安装在主机上（通常在浏览器内）的某种监控代理，该代理持续监控系统资源，并在检测到一些奇怪的行为时做出反应。</p>
<p>在 Konoth 等人的工作中。 [14]，作者提出了一种方法，能够通过静态分析网页中的 WebAssembly 代码来检测浏览器内的加密活动。密码挖掘基于计算多个散列值，并且这些函数具有特殊的模式（例如，长序列的 XOR 指令或使用各种加密原语函数），可以通过分析汇编操作码找到这些模式。作者提出了 MineSweeper，该组件可以分析网页加载的所有 WebAssembly 指令，并在模式分析显示加载了潜在的加密矿工时做出相应反应。代码的分析不是由机器学习技术执行的，但作者手动调查了最常见的浏览器中的矿工，并在他们的工具中硬编码了他们的模式。</p>
<p>卡林等人。 [15] 使用动态方法来检测浏览器中的加密矿工。他们的方法利用通过调试器 (OllyDbg) 启动浏览器 (FireFox) 收集的跟踪（发送到 CPU 的指令列表）。然后对这些跟踪中指令的操作码进行计数，然后将此整数向量用作随机森林分类器的输入特征。他们的机器学习模型经过训练能够区分：加密脚本、停用的加密脚本（没有开始挖掘函数调用的文件）、规范脚本（不是与加密相关的文件）和规范注入脚本（规范脚本的武器化版本，但注入了一些加密挖掘脚本）。他们的方法能够在每个类别上获得近 100% 的准确率。</p>
<p>刘等人。 [16] 修改了 Chrome 浏览器的内核，以包含名为 BMDetector 的矿工检测组件。该组件分析浏览器的堆内存和堆栈跟踪，并将它们发送到 LSTM（长短期内存）循环神经网络，该网络执行两类的实际分类：挖掘和非挖掘脚本。</p>
<p>Kharraz 等人也考虑了其他机器学习模型。 [17] 通过分析浏览器行为来识别加密劫持网站。他们的监控代理 Outguard 不断检查浏览器加载和执行的脚本，计算简单的数字特征并将它们发送到经过训练的机器学习模型以检测加密脚本。它们的功能包括脚本使用了多少并行任务、是否请求了 WebAssembly 或创建了多少 WebSocket。他们测试了随机森林和 SVM（支持向量机），并通过实验发现 SVM 获得了最好的结果。</p>
<h2 id="五、问题设定"><a href="#五、问题设定" class="headerlink" title="五、问题设定"></a>五、问题设定</h2><p>受害者通常不会将此类攻击视为问题，主要是因为没有直接的经济损失或赎金。识别加密货币开采时产生的流量（在所谓的加密挖掘过程中）对公司和最终用户都有用。首先，公司可能有兴趣检测在其公司网络上交换的层加密信息，因为他们可以指出一个或多个员工正在使用公司资源（例如公司拥有的设备、电力）来挖掘加密货币，从而获得非法经济收益损害公司财务。第二种情况是关于加密劫持的令人担忧的威胁，它危及最终用户和公司。网络犯罪分子正在了解加密挖掘的经济潜力，因此，他们传播恶意软件，在成功感染目标设备后，隐藏在受害者设备上运行的加密挖掘过程。加密挖掘，尤其是在不受限制的情况下，可能对最终用户设备的性能、移动设备的电池持续时间极为不利，并可能导致此类设备的使用寿命缩短。此外，加密劫持相关流量的识别可用作受监控设备的入侵指标 (IoC)，即使负责的恶意软件尚未包含在反恶意软件应用程序数据库中。</p>
<p>因此，基于网络流量分析检测和阻止加密挖矿活动可以消除以前对 IT 资源的影响，并阻止使用非法加密通信。首先，因为无法进行通信，挖矿过程停止消耗资源。其次，因为如果无法使用网络订购或收集计算交易，则不会产生奖励。</p>
<p>为了准确和精确地检测网络上不同类型的挖矿活动，我们提出了一个受控的网络环境，使用真实的客户端和服务器来生成与正常流量（网上冲浪、视频和音频流、云存储、文件传输、电子邮件和 P2P 等）通过专用网络并通过住宅宽带接入共享互联网连接。正常流量客户端与位于专用网络和 Internet 中的服务器交互。 Cryptomining 客户端连接到 Internet 中的真实矿池。作为迄今为止网络犯罪分子最喜欢的加密货币，门罗币被选为我们实验的加密货币。选择了两个不同的 Monero 客户端来提供 Stratum 协议的实现多样性，这是迄今为止最广泛用于在矿池之间分配挖矿过程的协议。客户端虚拟机中的 CPU 和内存在普通用户计算机的范围内分配，没有任何专用硬件（如 GPU 或 ASIC）的支持，并且相同的约束应用于服务器虚拟机配置。我们为所有客户端和服务器配置了建立普通或加密连接的能力。特别是，加密客户端连接到支持两种类型的网络连接的矿池。</p>
<p>最后，我们提供了通过物理交换机中的端口镜像功能来捕获和复制穿越受控网络环境的所有网络流量的能力。通过这种方式，所有捕获的流量都可以被标记和存储以用于训练有监督的机器学习模型或直接用于测试目的。收集的数据包使用众所周知的 5 元组分组为流：<strong>IP 目标、IP 源、端口目标、端口源和传输协议</strong>。在机器学习模型的训练阶段，每次新数据包到达时，都会生成一组流统计信息（特征）并与数据集中的相应标签一起存储，用于训练或测试目的。在生产环境中，特征从流中提取并输入到先前训练的机器学习模型中，以概率值的形式预测流类型（例如加密或正常流）。</p>
<h2 id="六、机器学习模型"><a href="#六、机器学习模型" class="headerlink" title="六、机器学习模型"></a>六、机器学习模型</h2><p>为了找到性能最佳的模型，我们考虑了不同的监督机器和深度学习分类器，以利用它们各自的特定特征。鉴于我们不假设要输入到模型的特征之间的时间或空间关系，我们决定使用基于全连接神经网络 (FCNN) 的深度学习架构。此外，我们还考虑了其他几种著名的机器学习算法，例如逻辑回归模型 [18]、[19]、分类和回归决策树（CART [20] 和 C4.5 [21]）和随机森林 [22] ]。</p>
<p>Logistic 回归模型本质上是一种分类算法，它允许对仅具有两个可能值之一的二元结果进行建模。有几项工作建议将该技术应用于基于协议的 Internet 流量分类（[23]、[24]）。</p>
<p>分类和回归树 (CART) [20] 和 C4.5 算法 [21] 是决策树模型，能够根据从离散和连续特征推断出的规则树将数据分类为不同的类别。这些模型允许根据树的结果叶子的概率对输入特征向量进行分类，给出属于特定类别的概率。</p>
<p>随机森林 (RF) 模型 [22] 结合了几个决策树（特别是 CART 树），通过引导程序聚合（装袋）和每棵树的随机选择特征，使用多数投票过程产生更准确的分类。 RF 模型因其非线性分类能力、效率和鲁棒性而被广泛使用（[25]、[26]）。</p>
<p>全连接神经网络 (FCNN) 模型 [27]、[28]，也称为多层感知器，是一种前馈神经网络，它将节点组织成层，加权连接从一层到下一层前馈。输入向量从输入层通过隐藏层向输出层传播，以便将输入映射到输出向量。 FCNN 模型已成功用于从大量数据中识别复杂模式的广泛问题和领域。特别是在 [29] 中，它被用来检测网络流量上的 DDoS 攻击。</p>
<h2 id="七、-我们的方法"><a href="#七、-我们的方法" class="headerlink" title="七、 我们的方法"></a>七、 我们的方法</h2><p>我们的目标是将加密挖矿流量与常规互联网流量区分开来，后者是由网络连接、电子邮件传输、流媒体视频、云服务之间的数据传输等组成的各种流。 为了实现这一目标，我们使用<strong>图 3</strong> 中描述的工作流程来生成合适的数据集并训练一组机器和深度学习模型。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/workflow.png" class="">
<p>图 3. 我们的训练工作流。</p>
<p>任何基于机器学习的过程的第一步都是生成高质量的数据集。我们使用 Mouseworld [30]，一个基于 NFV 的受控基础设施，在其上设置和部署加密攻击场景，该场景将产生我们的实验流量。我们安装了一系列虚拟机，一些矿工连接到互联网来产生加密和非加密的 Stratum 流，并使用各种其他方法来收集常规流量<br>（例如 HTTP&#x2F;HTTPS 流、多媒体流）。 TCP 流由流量分析工具 Tstat 的修改版本捕获和分析，以便实时提取从多个连接统计数据中提取的一组特征，这些特征用作我们机器学习模型的输入特征。然后，我们在一个名为 Tagger 的特殊 Mouseworld 内部组件中添加了一个临时代码，以自动为每个 TCP 流实例分配一个二进制标签（0：正常流量连接，1：加密连接）。被标记后，我们使用这些样本来训练和测试各种机器学习模型。然而，在实际模型训练之前，我们执行特征选择阶段以提高模型的准确性，并执行超参数优化步骤以搜索最佳模型配置。为了验证我们的模型的质量，我们使用了与图 3 中描述的方法类似的方法，通过使用 Mouseworld 作为我们的网络基础设施，以便根据需要多次生成各种新的和现实的流量样本，以进行分类我们的机器学习模型。值得注意的是，ML 模型训练是在单独的环境中完成的，在该环境中，可以使用专门的 GPU 卡来加速深度神经网络的训练过程。</p>
<p>以下段落更详细地描述了我们如何构建数据集以及我们如何训练我们的模型，而第 VIII 节包含我们的实验结果。</p>
<h3 id="A-数据集创建"><a href="#A-数据集创建" class="headerlink" title="A. 数据集创建"></a>A. 数据集创建</h3><p>如前所述，我们网络基础设施的基础是 Mouseworld 实验室，这是一个在 Telefonica 研发场所设置的受控环境，用于运行实验，允许以受控方式部署复杂的网络场景并生成真实的标记数据集，用于训练受监督的 ML 组件并验证有监督和无监督的解决方案。 Mouseworld Lab 提供了一种启动客户端和服务器的方法，即使它们在 Internet 上与 Mouseworld 之外的客户端和服务器交互，也可以收集它们产生的流量，并最终在没有操作员干预的情况下为该流量添加标签。该环境部署在支持 NFV 的架构上，在协调器 (NFVO) 的管理下，根据需要扩展 ETSI NFV MANO 堆栈。</p>
<p>图 4 显示了 Mouseworld Lab 的详细图片，该实验室由在管道中交互的四个模块组成：启动器、数据收集器、特征提取器和标记器。 </p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/mouseworld.png" class="">
<p>图 4. Telefonica研发场所的MouseWorld实验室。</p>
<p>Launcher 协调 Mouseworld 环境并运行实验，以生成不仅跨越 Mouseworld 内部网络而且跨越 Internet 的真实网络流量。该组件允许通过运行安装在一批 Linux 虚拟机中的真实客户端来产生三种基本类型的常规流量：网络、视频和文件托管（例如 Dropbox、OwnCloud）。此外，Launcher 还可以管理临时虚拟机，例如我们在研究工作中设置的包含 Monero 矿工的虚拟机，它还可以运行会话以使用 Ixia Breakingpoint 生成一组互补 Internet 协议的网络流量，一种商业工具，可以生成复杂的合成流量模式。</p>
<p>数据收集器模块收集单个实验生成的所有数据包。特征提取模块根据源和目的IP地址&#x2F;端口号和传输协议的经典五元组将收集到的数据包分组为流，并调用外部模块获取每个流的特征集。在我们的实验中，我们使用了 Tstat 工具的修改版本，以便从流统计中得出一组标准 Netflow 功能以及我们对一组高信息功能的建议。修改后的 Tstat 不仅像在原始 Tstat 中那样在连接结束时以取证模式获取流特征，而且在不同的时刻实时获取流特征，这使我们能够训练和测试机器学习组件，即使只传输了流的几个数据包，也能识别加密流。</p>
<p>最后，Tagger 在每个实验执行期间使用 Launcher 输出的外部和日志信息自动为每个流添加标签，无需人工干预。由于流标记高度依赖于机器学习任务，因此该组件只是必须为每种类型的场景开发的 ad-hoc 标记器的简单包装。在我们的实验中，我们使用矿工（客户端）和加密服务器池的 IP 地址和端口对该组件进行了编码，以便将加密流与包含正常流量的其余流区分开来。请注意，标签仅用于训练和测试机器学习模型，当它们在生产环境中运行时不需要标签来生成预测。</p>
<p>Mouseworld 中部署的基础设施和配置如下所述。我们部署了 30 个虚拟机来生成常规流量（即 Web、视频和共享文件夹流）。 Web 和视频请求是使用 Chrome 无头浏览器生成的，共享文件夹（即文件托管）请求是使用 Dropbox 和 OwnCloud 的特定客户端生成的。使用指定了每种类型请求频率的配置文件，从客户端随机生成 Web、视频和共享文件夹请求。这些请求被随机发送到内部 Mouseworld 服务器和位于 Internet 上的外部服务器。值得注意的是，所有服务都生成了加密（例如 HTTPS 请求）和非加密（例如 HTTP 请求）流量请求。此外，IXIA BreakingPoint 工具还被配置为生成和注入各种 Internet 网络服务（Web、多媒体、共享文件夹、电子邮件和 P2P）的合成模式。 BreakingPoint 生成的流量也被配置为由加密和非加密流组成。</p>
<p>此外，我们还创建了三个加密挖掘 Linux 虚拟机。我们在所有三个虚拟机中都安装了 xmr-stak [31] 和 xmrig [32]，并将它们配置为使用加密和非加密的 Stratum 连接。我们使用所有这些客户端来挖掘 Monero [33] (XMR) 加密货币，通常用于非法目的 [6]。加密客户端使用默认设置通过非加密 TCP 和加密 TLS 连接与公共矿池连接。每个矿工每小时被强制断开连接并重新连接，以模拟新的矿池连接。</p>
<p>我们设计了四个实验，将 Launcher 和 BreakingPoint 工具与不同的加密客户端和协议相结合。每个实验运行一小时，平均数据包速率约为每秒 1000 个数据包，生成数据集，其中包含 800 万个 TCP 流，其中 4000 个与 Stratum 相关。特别是：</p>
<ul>
<li><p>在实验 1 中，BreakingPoint 工具与两个使用 TLS 加密连接的 xmr-stak 客户端和一个仅建立非加密 TCP 连接的 xmrig 客户端一起运行。</p>
</li>
<li><p>在实验 2 中，运行在 Mouseworld 虚拟机中的真实客户端启动以与位于 Internet 和 Mouseworld 内部网络中的服务器进行交互； 此外还部署了一个使用 TLS 加密连接的 xmr-stak 客户端和两个使用非加密 TCP 连接的 xmrig 客户端；</p>
</li>
<li><p>在实验 3 中，启动了真实客户端与两个使用 TLS 加密连接的 xmr-stak 客户端和一个仅建立非加密 TCP 连接的 xmrig 客户端的组合。</p>
</li>
<li><p>最后，在实验 4 中，BreakingPoint 工具与一个使用 TLS 加密连接的 xmr-stak 客户端和两个使用非加密流的 xmrig 客户端一起运行。</p>
</li>
</ul>
<p>为训练和测试目的，将获得的四个数据集分成两个独立的子集。具体来说，将实验 1 和 4 的数据集加入 DS1（训练）数据集，并将实验 2 和 3 中收集的其他两个数据集合并到 DS2（测试）数据集。通过这种方式，可以认为 DS1 和 DS2 具有相同的性质，因为它们包含相似百分比的加密和非加密流量、互联网服务类型和加密挖掘协议流。值得注意的是，挖矿协议产生的流量与正常流量相比较小，在所有数据集中都会出现挖矿流量与正常流量的不平衡（1：5000），这带来了额外的挑战用于训练 ML 分类器。<br>DS1 数据集（1600 万个示例）被打乱并分成两组，用于超参数优化的训练 (85%) 和验证 (15%)。 DS2 数据集（1600 万个示例）仅用于最终测试目的。</p>
<h3 id="B-模型训练"><a href="#B-模型训练" class="headerlink" title="B. 模型训练"></a>B. 模型训练</h3><p>对于我们的每个数据集，正确训练和测试 ML 模型的第一步是特征选择阶段。传统上，流量分类技术的深度数据包检测技术通过端口号检测或数据包有效载荷内容的解释来获取特征。然而，由于普遍使用加密方法来封装数据包内容（包括 TCP 或 UDP 端口号）以及政府越来越多地引入隐私法规以限制对数据包有效载荷数据的访问，这些技术往往受到越来越多的限制。为了克服这些限制，最近的机器和深度学习技术使用流描述作为机器学习模型的输入。这些描述由一组特征组成，这些特征是从外部可观察的流量属性获得的统计数据，例如每个流的持续时间和流量、数据包间到达时间、数据包大小和字节配置文件 [34]。</p>
<p>选择信息丰富的判别特征是在不同任务（如分类）中有效机器学习算法的关键步骤。特别是，机器学习分类器的性能不仅取决于模型之间的差异及其具体配置，还取决于输入特征的选择。如今，研究和工业界对一套可靠的功能没有达成强烈的共识，这些功能可以在所有场景中与机器学习一起表现良好。尽管如此，基于基于时间的统计特征（例如流的数据包的大小和数据包间时间，或数据包标头或有效载荷中字节分布的熵）的提议正在获得动力（[35]，[36]）。</p>
<p>在过去几年中，网络流量分析正面临与新的、更复杂和未知的流量入侵相关的新挑战。特别是，要确定一组足够的特征来帮助获得稳定且高性能的机器学习模型以用于新场景（例如加密矿流检测）并不容易。出于这个原因，我们决定比较两组不同的特征，目的是确定它们对机器学习性能的影响，并证明使用更多信息特征，可以获得机器学习性能的显着提高。两组特征都不是专门为加密攻击量身定制的，因为它们反映了网络流的参数，因此它们可以用于其他网络流量场景（例如网络流量分类）。由于我们的目标是检测网络上的加密攻击，因此使用流特征进行流（例如 TCP 连接）识别似乎是合适的方法。</p>
<p>表 1. Tstat中选择的特征（所有特征可见<a href="http://tstat.polito.it/measure.shtml%EF%BC%89" target="_blank" rel="noopener">http://tstat.polito.it/measure.shtml）</a></p>
<table>
<thead>
<tr>
<th>C-&gt;S</th>
<th>S-&gt;C</th>
<th>Name</th>
<th>Metric(就是单位)</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>17</td>
<td>packets</td>
<td>-</td>
<td>从客户端&#x2F;服务器上保留的数据包总数</td>
</tr>
<tr>
<td>5</td>
<td>19</td>
<td>ACK sent</td>
<td>-</td>
<td>ACK字段设为1后的段数</td>
</tr>
<tr>
<td>6</td>
<td>20</td>
<td>PURE ACK sent</td>
<td>-</td>
<td>ACK字段设为1且无data后的segment数</td>
</tr>
<tr>
<td>7</td>
<td>21</td>
<td>unique bytes</td>
<td>bytes</td>
<td>在payload中发送的字节数</td>
</tr>
<tr>
<td>8</td>
<td>22</td>
<td>data pkts</td>
<td>-</td>
<td>payload的段数</td>
</tr>
<tr>
<td>9</td>
<td>23</td>
<td>data bytes</td>
<td>bytes</td>
<td>在payload中传输的字节数，包括重传retransmission</td>
</tr>
<tr>
<td>31</td>
<td>-</td>
<td>Completion time</td>
<td>ms</td>
<td>自第一个到最后一个数据包的数据流持续时间</td>
</tr>
<tr>
<td>32</td>
<td>-</td>
<td>C first payload</td>
<td>ms</td>
<td>客户端上，自第一个数据流段后至第一个带payload数据段</td>
</tr>
<tr>
<td>33</td>
<td>-</td>
<td>S first payload</td>
<td>ms</td>
<td>服务器上，自第一个数据流段后至第一个带payload数据段</td>
</tr>
<tr>
<td>34</td>
<td>-</td>
<td>C last payload</td>
<td>ms</td>
<td>客户端上，自第一个数据流段后至最后一个带payload数据段</td>
</tr>
<tr>
<td>35</td>
<td>-</td>
<td>S last payload</td>
<td>ms</td>
<td>服务器上，自第一个数据流段后至最后一个带payload数据段</td>
</tr>
<tr>
<td>36</td>
<td>-</td>
<td>C first ack</td>
<td>ms</td>
<td>客户端上，自第一个数据流段后至第一个ACK（不带SYN）数据段</td>
</tr>
<tr>
<td>37</td>
<td>-</td>
<td>S first ack</td>
<td>ms</td>
<td>服务器上，自第一个数据流段后至第一个ACK（不带SYN）数据段</td>
</tr>
<tr>
<td>45</td>
<td>52</td>
<td>Average rtt</td>
<td>ms</td>
<td>平均RTT计算测量数据段和相应的ACK之间经过的时间</td>
</tr>
<tr>
<td>46</td>
<td>53</td>
<td>rtt min</td>
<td>ms</td>
<td>在连接寿命期间观察到的最小RTT</td>
</tr>
<tr>
<td>47</td>
<td>54</td>
<td>rtt max</td>
<td>ms</td>
<td>在连接寿命期间观察到的最大RTT</td>
</tr>
<tr>
<td>48</td>
<td>55</td>
<td>Stdev rtt</td>
<td>ms</td>
<td>RTT的标准差</td>
</tr>
<tr>
<td>49</td>
<td>56</td>
<td>rtt count</td>
<td>-</td>
<td>有效的RTT观察数</td>
</tr>
<tr>
<td>50</td>
<td>57</td>
<td>ttl_min</td>
<td>-</td>
<td>最短存活时间TTL</td>
</tr>
<tr>
<td>51</td>
<td>58</td>
<td>ttl_max</td>
<td>-</td>
<td>最长存活时间TTL</td>
</tr>
<tr>
<td>65</td>
<td>88</td>
<td>RFC1323 ws</td>
<td>0&#x2F;1</td>
<td>发送窗口缩放(window scale)选项</td>
</tr>
<tr>
<td>66</td>
<td>89</td>
<td>window scale</td>
<td>-</td>
<td>经协商的缩放值[比例因子]</td>
</tr>
<tr>
<td>67</td>
<td>90</td>
<td>SACK req</td>
<td>0&#x2F;1</td>
<td>SACK option set</td>
</tr>
<tr>
<td>68</td>
<td>91</td>
<td>SACK sent</td>
<td>-</td>
<td>SACK消息发送的数量</td>
</tr>
<tr>
<td>70</td>
<td>93</td>
<td>MSS</td>
<td>bytes</td>
<td>声明的MSS</td>
</tr>
<tr>
<td>71</td>
<td>94</td>
<td>max seg size</td>
<td>bytes</td>
<td>观测到的最大段大小</td>
</tr>
<tr>
<td>72</td>
<td>95</td>
<td>min seg size</td>
<td>bytes</td>
<td>观测到的最小段大小</td>
</tr>
<tr>
<td>73</td>
<td>96</td>
<td>win max</td>
<td>bytes</td>
<td>声明的最小接收者窗口(已经通过窗口比例因子进行缩放)</td>
</tr>
<tr>
<td>74</td>
<td>97</td>
<td>win min</td>
<td>bytes</td>
<td>声明的最大接收者窗口(已经通过窗口比例因子进行缩放)</td>
</tr>
</tbody></table>
<p>第一组 51 个特征被提议作为我们工作的一个新贡献，并且来自 Tstat 工具统计数据的一个子集。这些特征的集合在表 1 中有详细说明，其中 CS 代表客户端到服务器和 SC 服务器-到客户端的流量。 Tstat 工具 [37] 允许从传输层和应用层提取大量分类统计信息，并且不是为任何特定类型的网络流量或应用程序量身定制的</p>
<p>考虑到不检查数据包有效载荷的初始假设，我们不会使用 IP 地址或端口号或从应用层数据的统计数据得出的特征。此外，为了推导出这组特征，我们使用以下标准选择了 Tstat 统计数据：首先，我们没有考虑 Tstat 统计数据在不同时刻显示所有连接的恒定值，因为它们不包含任何信息（例如 c_rst_cnt、s_rst_cnt、c_isint、s_isint）。其次，我们对数据应用线性相关分析，以识别和删除高度相关的变量。在这种情况下，我们在使用此标准丢弃 Tstat 统计数据时采用了相当保守的方法，因为相关性分析仅显示变量之间的线性相关性，而神经网络往往会发现变量之间有趣的非线性关系。因此，我们没有使用此标准删除任何 Tstat 统计数据，以便为所有机器学习模型，特别是神经网络模型提供机会发现特征之间的非线性关系。最后，我们应用我们之前在网络和协议方面的专业知识来丢弃对机器学习应用无益的 Tstat 统计信息。特别是net_dup（网络数据包重复次数）、reordering（观察到的数据包重新排序次数）、rtx_RTO（由于超时到期重传的段数）和rtx_FR（由于快速重传而重传的段数，三个dup- ack）等被删除，因为它们代表了特定时间段内出现的网络流量拥塞情况的统计数据，而其他时间可能不会出现。    </p>
<p>此外，作为双重检查机制，我们在使用随机森林模型训练模型后获得特征重要性值，我们观察到几乎所有特征的值范围为 0.12 到 0.01，除了 s_tm_opt（服务器发送的时间戳选项）显示一个非常小的值 0.0000184。这个结果强调没有任何特征子集比其他特征更重要，相反，所有选定的 Tstat 派生特征都有助于复杂模型的高性能。值得注意的是，当使用深度神经网络时，特征重要性不能那么容易获得，因此，推荐的方法是将所有输入特征提供给神经网络，让优化算法自己找到哪些特征信息量最大.关于神经网络决策的可解释性和可解释性及其与输入特征的关系是目前正在研究的主题，我们决定保留初始 51 个 Tstat 派生特征作为所有机器学习模型的输入，以便在相同的条件。</p>
<p>第二组功能将源自 IETF 标准 NetFlow&#x2F;IPFIX 指标。最近在 [7] 中提出了这组八个特征，用于使用机器学习检测加密挖掘活动。这些派生特征是：</p>
<ul>
<li>入站和出站数据包&#x2F;秒；</li>
<li>入站和出站比特&#x2F;秒；</li>
<li>入站和出站位&#x2F;数据包；</li>
<li>比特入站&#x2F;比特出站比率；</li>
<li>数据包入站&#x2F;数据包出站比率。</li>
</ul>
<p>因此，我们用三组特征评估了我们的机器学习模型：</p>
<ul>
<li>在场景A 中，使用了NetFlow&#x2F;IPFIX 指标；</li>
<li>在场景 B 中，仅使用了从 Tstat 统计得出的特征；</li>
<li>最后，在场景 C 中，Tstat 派生和 NetFlow&#x2F;IPFIX 功能共同使用。</li>
</ul>
<p>在特征选择阶段之后，我们执行超参数优化阶段，以找到最佳超参数以实现高度准确的模型。优化超参数被认为是构建机器学习模型中最棘手的部分之一，因为在构建模型时通过简单地猜测和测试这些值的几种组合几乎不可能获得最佳参数。另一方面，尝试一组超参数的所有值组合是不可扩展的，因为要测试的组合数量随着超参数的数量和每个超参数中要测试的值的范围呈指数增长。有几种启发式方法可以帮助找到这些最佳超参数，随机搜索是最流行和最有效的方法之一。顾名思义，评估的超参数组合是从超参数多维网格中随机选择的。</p>
<p>随机搜索的基本策略包括评估每个超参数值组合的验证分数，并将结果与超参数组合一起记录。在搜索结束时，选择产生最高验证分数的超参数，并在所有训练数据集上训练模型。最后，使用该模型对测试数据集进行预测。每次运行随机搜索时，都将超参数空间用作输入，算法会生成超参数值的随机组合以供尝试。除了在超参数空间中的可用值中随机选择下一个值之外，对随机搜索没有任何要求。</p>
<p>在我们的实验中，我们使用随机搜索算法 (RS) 来寻找训练每个模型的超参数值的最佳组合。在对每个模型进行了大量训练并使用了足够多的超参数组合后，我们选择了验证时 F1 分数最高的模型。每个机器学习模型至少使用了几十种不同的组合。在观察到搜索结果稳定后停止随机搜索（即在几次随机搜索迭代后没有出现更好的模型）表 2 显示了我们为每个模型优化的范围和超参数。</p>
<p>表 2. Hyperparameter的值</p>
<table>
<thead>
<tr>
<th>Hyperparameter</th>
<th>模型</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>L2 regularization</td>
<td>LR</td>
<td>($10^{-3}$, 100)</td>
</tr>
<tr>
<td></td>
<td>FCNN</td>
<td>($10^{-6}$, 10)</td>
</tr>
<tr>
<td>Max Depth</td>
<td>CART</td>
<td>(1, 200) or None</td>
</tr>
<tr>
<td></td>
<td>RF</td>
<td>(1, 200) or None</td>
</tr>
<tr>
<td>#Trees</td>
<td>RF</td>
<td>(1, 200)</td>
</tr>
<tr>
<td>Pruning confidence</td>
<td>C4.5</td>
<td>($10^{-2}$, 1.0)</td>
</tr>
<tr>
<td>#Min. instances per tree</td>
<td>C4.5</td>
<td>(2, 200)</td>
</tr>
<tr>
<td>Dropout</td>
<td>FCNN</td>
<td>($10^{-6}$, 0.7)</td>
</tr>
<tr>
<td>Learning rate</td>
<td>FCNN</td>
<td>($10^{-5}$, 1.0)</td>
</tr>
<tr>
<td>Class weight</td>
<td>FCNN</td>
<td>(1, 5)</td>
</tr>
<tr>
<td>#Layers</td>
<td>FCNN</td>
<td>(1, 5)</td>
</tr>
<tr>
<td>#Units per layer</td>
<td>FCNN</td>
<td>(1, 1000)</td>
</tr>
</tbody></table>
<p>在运行随机搜索之前，我们对基于全连接神经网络 (FCNN) 架构的不同深度学习模型进行了一些初步评估。我们使用前向旁路连接和批量归一化在 FCNN 中使用多达 10 个隐藏层运行这些初步评估，以避免梯度消失。据观察，使用大量层（例如 8 到 10）并没有产生比我们使用较少层（2 到 4）训练 FCNN 时更好的值。因此，在随机搜索过程中，我们将 FCNN 层的搜索范围从 1 层减少到 5 层。因此，我们训练并测试了浅（1-2 个隐藏层）和深（3-5 个隐藏层）全连接神经网络</p>
<p>请注意，类权重超参数的定义是为了管理加密挖掘用例上下文中数据集的不平衡性质。如前所述，正常连接与加密挖掘连接的比率约为 5,000，这对训练过程的最终结果产生负面影响。因此，在 FCNN 模型的训练过程中尝试了该参数的不同值，以调节优化算法的行为。随机森林和逻辑回归是使用 Scikit-learn 库实现进行训练的，其中 classweigth 参数试图解决这个问题。此外，FCNN 模型使用整流线性单元 (ReLU) 作为激活函数，因此没有对该参数进行超参数搜索。</p>
<h2 id="八、实验结果"><a href="#八、实验结果" class="headerlink" title="八、实验结果"></a>八、实验结果</h2><p>我们进行了一组实验，以评估多种机器和深度学习模型检测加密货币流并将其与正常流量连接区分开来的性能。在实验开始时定义了两个互补的目标。首先，为了证明复杂的机器学习模型（例如深度神经网络）比简单的模型表现更好，其次，为了表明与之前的特征相比，我们提出的 Tstat 特征集（表 1）显着提高了这些模型的性能提案。作为更简单模型的代表，我们选择了 [7] 中提出的 ML 模型（SVM、朴素贝叶斯和 CART 以及 C4.5 树），目的是在更现实的场景中将它们的结果与复杂的深度学习模型进行比较，如部署在我们的实验。此外，选择随机森林是因为它被广泛认为是性能最好的 ML 技术之一，而逻辑回归是一种极其简单的方法的代表。在接下来的段落中，我们将描述通过使用第 VII 节中详述的数据集创建和模型训练程序获得的结果。</p>
<h3 id="A-机器学习设置"><a href="#A-机器学习设置" class="headerlink" title="A. 机器学习设置"></a>A. 机器学习设置</h3><p>我们的目标问题旨在预测加密矿流并将它们与其他网络流区分开来。因此，这个问题被建模为一个分类器，其中预期输出是一个二进制值：1 对应于分类器识别的加密连接，而 0 分配给其余的连接。</p>
<p>为了能够准确地对这两种类型的连接进行分类，我们基于先前在第六节中介绍的分类器训练和测试机器深度学习分类器。特别是，我们评估了全连接神经网络 (FCNN) 并与传统机器学习技术进行了比较，例如逻辑回归 (LR)、CART 和 C4.5 决策树 (CART, C4.5) 和随机森林 (RF)。值得注意的是，在初步实验中，我们将 SVM 和朴素贝叶斯分类器包含在要评估的机器学习技术集中。然而，我们观察到，与 CART 和 C4.5 树相比，这两种技术都表现不佳。因此，朴素贝叶斯和 SVM 被排除在我们与其他模型的实验比较之外。此外，仅使用一小部分训练数据集（1600 万个示例的 1&#x2F;100），SVM 训练时间就需要两天时间。从表 6 中可以看出，其余模型在最坏的情况下使用整个数据集（1600 万个示例）训练模型的时间不超过 40 分钟。</p>
<p>我们使用了第 VII-B 节中详述的训练程序，对于每个模型，应用了以下步骤：1）执行特征选择阶段； 2) 在超参数空间上运行随机搜索，并使用获得的超参数组合训练模型； 3) 在验证集上使用 F1-score 对性能最好的模型进行排名； 4）在测试（DS2）数据集上测试最佳模型。<br>为了在验证和测试中对获得的结果进行比较和排名，我们计算了一组广泛用于分类问题的质量指标（[38]，[39]）：准确率、宏观和微观版本的精度、召回率和 F1 分数和混淆矩阵。此外，计算了曲线下的 ROC 和 P-R 面积 (AUC)，并绘制了它们相应的曲线。这些指标使我们能够衡量我们的模型在一组异构互联网连接中识别和检测加密货币流的质量</p>
<p>使用著名的 scikit-learn 库中可用的 Python 代码版本训练传统机器学习模型（LR、CART 和 RF）。由于在 scikit-learn 库中没有可用的 C4.5 实现，我们使用了 Weka 工具 [40] 中包含的 C4.5 的 J48 版本。深度学习模型 (FCNN) 是在 Python 中使用 Keras 框架 [41] 在 Tensorflow [42] 上实现的，以利用 GPU 加速。所有神经网络都使用 Adam 优化器 [27] 进行训练，以最大限度地减少交叉熵损失。在这种情况下，训练过程由一系列训练迭代组成。每次训练迭代包括 5 个 epoch，在每次迭代结束时，F1 分数在验证集上计算并用作提前停止标准（即在 10 次迭代后验证指标没有增强，训练过程停止）。无论如何，训练在 500 次迭代后停止。另外请注意，在训练 FCNN 时，将少量训练数据 (15%) 留出并用于在训练过程中提前停止 epoch 数，从而避免过度拟合和局部最小停滞。</p>
<h3 id="B-模型的结果和比较分析"><a href="#B-模型的结果和比较分析" class="headerlink" title="B. 模型的结果和比较分析"></a>B. 模型的结果和比较分析</h3><p>使用之前描述的随机搜索程序和 DS1 数据集，我们针对每个场景 A、B 和 C 训练和验证了 LR、CART、C4.5 和 RF 的 15 个模型组合以及 FCNN 的 74 个模型组合。让神经网络模型有更多的超参数 ，需要更多的超参数组合才能找到大量具有良好性能的模型。</p>
<p>方案 A、B 和 C 获得的结果分别显示在表 3、4 和 5 中。 在这些表中，每一列都显示了测试数据集 (DS2) 上每个模型（FCNN、RF、CART、C4.5 和 LR）的最佳代表的测试结果。 使用它们在验证数据集中的排名结果在所有模型组合中选择每个模型的最佳代表。 每个模型的代表都通过其超参数的摘要进行标识，包括架构细节，使用紧凑符号进行描述，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1/75 FCNN</span><br><span class="line">[722, 847, 710]</span><br><span class="line">0.001500, 0.000002</span><br><span class="line">0.000012, 2;</span><br><span class="line">F1 (macro) 0.9886)</span><br></pre></td></tr></table></figure>

<p>应用的命名法如下：</p>
<ul>
<li>（第1行）<code>#X/Y modelName</code>：<br>X 和Y 分别表示模型在测试排名中的位置和训练的模型组合总数。 回想一下，表格中显示的模型始终是验证的最佳模型。 因此，接近 1 的数字 X 表示在验证阶段获得良好性能的模型在使用不同的 DS2 数据集进行测试时表现一致。 因此，如果模型在验证的顶级模型中选择，我们可以对模型组合在实时生产场景中的性能充满信心。</li>
<li>FCNN 模型添加以下值：<ul>
<li>（第 2 行）描述神经网络架构的值列表：[X0, X1, . . . , 习, . . . , Xn] 其中 n 是层数，Xi 是层 i 中的单元数。</li>
<li>（第 3 行和第 4 行）Dropout、L2 正则化值、Adam 学习率和类权重值（即加密流类相对于表 2 中定义的正常流量类的权重）。</li>
</ul>
</li>
<li>随机森林模型包括：<ul>
<li>trees的数量</li>
<li>trees的最大depth limit。</li>
</ul>
</li>
<li>逻辑回归模型显示应用的正则化系数。</li>
<li>CART 模型指示树木的最大深度。</li>
<li>C4.5 模型包括 置信值 (C) 和两个最流行分支中的最小实例数 (M)。</li>
<li>（最后行）所有模型都显示了在验证中获得的 F1 分数（宏观）值。</li>
</ul>
<p>表 3. 场景A：使用NetFlow特征选择方法基于验证数据集的最佳模型的测试数据集（DS2 DataSet）的总体结果。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/table3.png" class="">

<p>表 4. 场景B：使用TSTAT功能选择方法基于验证数据集的最佳模型的测试数据集（DS2 DataSet）的总体结果</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/table4.png" class="">

<p>表 5. 场景C：基于使用NetFlow和TSTAT功能选择方法基于验证数据集的最佳模型的测试数据集（DS2 DataSet）的总体结果。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/table5.png" class="">

<p>表 3、4 和 5 显示了每个模型在测试数据集上计算的质量指标。 F1-score、Precision 和 Recall 宏值与 Accuracy、RoC 和 P-R 曲线下面积（AUC ROC 和 AUC P-R）一起呈现。 最后一行显示了混淆矩阵，其中 cyptomining 连接的值被分解为两个数字，以便更好地分析。 SSL值代表数字<br>加密的加密流和 NoSSL 代表未加密的流。</p>
<p>从全局来看，可以观察到：</p>
<p>a) 复杂模型（深度神经网络FCNN、随机森林和 C4.5）在所有场景中都比简单的策略（CART 和 LR）获得更好的结果；<br>b) 在场景 B 中获得了最好的结果，它建议利用 Tstat 特征作为机器学习模型的输入。 此外，结合使用 Tstat 和 NetFlow 功能的场景 C，与仅使用 Tstat 功能（场景 B）相比，没有获得任何可观察到的优势。</p>
<p>随机森林 (RF) 和 C4.5 是仅有的模型，即使在场景 A 的上下文中也能获得不错的结果。使用较少表达的特征集（NetFlow 特征），RF 获得了令人满意的 F1 分数值 0.9724，然而比在场景 B 和 C 中获得的结果差（0.9964 和 0.9957）。与 CART 决策树等更简单的方法相比，RF 的卓越性能是通过使用增强技术来解释的，该技术使其更能抵抗噪声等问题 [22]。可以观察到，在场景 A 中，77 个正常流量流被归类为加密（误报），但在场景 B 和 C 中只有 31 个和 25 个。然而，在场景 A 中产生了 393 个误报（未检测到的加密流），这是场景 B 和 C（33 和 50）中观察到的假阴性数量的 10 倍以上。这意味着仅使用 Netflow 功能，RF 无法检测到的加密流数量是使用 Tstat 功能（场景 B 和 C）时未检测到的加密流数量的 10 倍。关于这项工作的主要目标之一是提供机器学习方法来准确检测尽可能多的（恶意软件）加密流，这一结果表明，仅使用 Netflow 特征（场景 A）的 ML 模型似乎无法达到其目的与使用 Tstat 特征的 ML 模型相比（场景 B 和 C）。使用少量估计器（在 25 到 100 棵树之间）和适度的树深度限制（在 40 到 200 之间，一种没有深度限制的情况下）获得了 RF 的最佳结果。最好的 C4.5 模型获得了几乎相同的 F1 分数和混淆矩阵值，因此，我们可以得出结论，它们在三种情况下的性能大致相同。</p>
<p>FCNN 深度模型在场景 B 和 C 中的执行范围与 RF 相似，分别获得了 0.9902 和 0.9910 的 F1 分数（宏）值，并且误报和误报的数字大致相等。从架构的角度来看，为了获得最佳性能，只需要三个隐藏层，每层大约有 700-800 个神经元。然而，FCNN 在使用 NetFlow 功能时产生了非常糟糕的结果（场景 A）。最佳配置仅实现了 0.6387 的 F1 分数值，这表明相对于为该类别检测到的真阳性 (727)，出现了大量的加密类别 (3697) 假阳性。此外，请注意，在 RF (393) 的情况下，误报的数量要小得多。我们推测，现有的类不平衡以及 Netflow 特征的中等质量不允许 NN 优化算法以相似的比例减少假阴性和阳性的数量并增加加密类的真阳性。</p>
<p>在所有三种情况下，CART 模型在训练中的 F1 值（0.9739、0.9975 和 0.9963）都比在测试中（0.8970、0.6767 和 0.6762）要高，这清楚地表明这些模型倾向于过度拟合训练数据集。此外，在场景 A 和场景 B 和 C 中分别观察到极高数量的假阴性（1338）和假阳性（16032 和 16055）。因此，我们不鼓励在生产环境中使用 CART 来检测加密流，因为这些模型在所有场景中都表现出缺乏泛化性以及大量误报和误报。有趣的是，当场景 A 中仅使用 Netflow 功能时，这些模型的泛化效果似乎稍好一些（测试中的 F1 分数为 0.8970）。我们推测场景 A 中使用的 Netflow 特征在训练期间提供的信息少于 Tstat 特征，因此，由此产生的过拟合没有场景 B 和 C 中那么严重。</p>
<p>逻辑回归模型只能使用 Tstat 特征（场景 B 和 C）正确训练，分别获得 0.9805 和 0.9789 的可观 F1 分数值。然而，在场景 A 中，LR 模型无法识别任何加密流，因为所有流都被归类为正常流量。场景 B 和 C 的混淆矩阵显示比 RF 和 FCNN 更多的假阳性和阴性。这一事实可能会排除这些简单模型在网络安全场景中的使用，在这些场景中，减少误报和误报至关重要。值得注意的是，使用显着的正则化，当使用 Tstat 特征（场景 B 和 C）时，该模型比 CART 模型的泛化效果要好得多。</p>
<p>关于测试数据集中加密 (SSL) 与非加密 (NoSSL) 加密连接的比率约为 2:1 - 数字可以在表 3、4 和 5 左下角的混淆矩阵单元格中找到 -场景 A 中 SSL 网络流量的误报比例是原始比例的两倍多：这个比例在 RF 中约为 7:1，在 C4.5 中为 6.5:1，在 CART 中为 10:1，在 FCNN 中为 4:1 .对于逻辑回归，此值无关紧要，因为模型无法对任何内容进行分类，因为所有流量都被预测为 0 类（正常流量）。当在场景 B 和 C 中使用 Tstat 特征时，随机森林和 CART 模型的加密流中误报的 SSL&#x2F;NoSSL 比率为 2:1，C4.5 为 3:1，FCNN 模型约为 3:1，4 :1 用于逻辑回归模型，这清楚地表明 Tstat 功能有助于一致地识别加密流，即使它们被加密。</p>
<p>图 6 和图 7 清楚地表明，当使用 Tstat 特征时，RF C4.5 和 FCNN 模型在 ROC 和 PR 曲线中的决策函数表现出非常好的可分离性值，因为它们在 ROC&#x2F;PR 曲线下的面积对于 RF 均高于 0.99 FCNN 和 C4,5 为 0.98。请注意，正如我们在实验中考虑的那样，P-R 曲线往往对不平衡分布相当敏感。在这种情况下，可以在 P-R 图中观察到，在 AUC 值为 0.6 且曲线形状非常接近对角线的情况下，CART 树无法实现良好的可分离性行为。值得注意的是，当使用 Netflow 特征时（图 VIII-B），只有 RF 和 C4.5 显示出不错的可分离性结果，相反，FCNN 产生了高度不稳定的行为，如左侧突然变为零的 PR 曲线所示右边是由于精度达到非常接近零的值。造成这种不稳定性的原因是（a）当决策阈值大于或等于 0.6（因此精度也为零）时，真阳性的数量（对于加密挖掘类）变为零，以及（b）假阳性的数量当决策阈值小于 0.5 时，阳性数突然从 86 变为 205,048，即真正的阳性数约为 700（因此，精度大约为零）。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure5.jpg" class="">
<p>图 5. NetFlow方法提取特征下,ROC和P-R基于验证数据集所选择的最佳模型的测试数据集</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure6.jpg" class="">
<p>图 6. TSTAT方法提取特征下,ROC和P-R基于验证数据集所选择的最佳模型的测试数据集</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure7.jpg" class="">
<p>图 7. 组合方法提取特征下,ROC和P-R基于验证数据集所选择的最佳模型的测试数据集</p>
<p>根据这些结果，我们可以得出结论：（a）场景 A 中使用的 Netflow 特征集产生的模型比选择 Tstat 特征作为输入（场景 B 和 C）时的模型准确度低，以及（b）RF，C4.5和 FCNN 模型始终比 CART 和 Logistic 回归等简单模型获得更好的结果。特别是，使用 Tstat 特征和 RF、C4.5 和 FCNN 模型获得了最好的结果。这些模型实现了大约 0.99 的 F1-macro 值，反映出仅产生了极少数的误报和误报——不到加密流总数的 4%。相反，仅使用 Netflow 功能，假阴性的数量是真阳性的三倍，这突出了识别加密流时缺乏准确性。此外，作为漏报出现的 SSL&#x2F;Non_SSL 加密流的比率高于整个加密流集，这反映了这些功能无法精确识别加密 (SSL) 加密流。未来的场景中，越来越多的加密流预计将被加密，这并不意味着只使用这组有限的功能。</p>
<p>最后，值得注意的是，最佳模型的高精度并不是以牺牲长时间的训练为代价的。它是信息丰富的特征（即 Tstat 特征）与复杂机器学习模型的结合，可实现高准确率、精确度和召回率。关于对三个特征集应用相同的训练过程，可以观察到，当我们使用信息量较少的特征（Netflow 特征集）时，性能显着下降。图 8 和图 9 显示了每个模型的训练时间和预测速度（图中绘制了平均值和标准差）。使用英特尔 i5-9400F、2.90 GHz、6 线程 cpu、64 GB RAM 和配备 GTX1080 GPU 的普通 PC 工作站进行训练和测试。可以观察到，对于 1600 万个示例，所有模型的训练时间始终低于 40 分钟，并且往往与输入特征的数量成正比。类似地，预测与模型复杂度成反比，并且使用相同的硬件在每秒数百万的范围内。请注意，C4.5 是使用 Weka 工具中可用的 J48 版本运行的，因此，它的预测性能明显低于其他直接用 Python 编码的模型。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure8.jpg" class="">
<p>图 8. 模型在PC工作站上使用10个随机搜索执行计算的培训时间。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure9.jpg" class="">
<p>图 9. 模型在PC工作站上以10个随机搜索执行计算计算的预测速度。</p>
<h3 id="C-按数据包数量和连接持续时间划分的结果"><a href="#C-按数据包数量和连接持续时间划分的结果" class="headerlink" title="C. 按数据包数量和连接持续时间划分的结果"></a>C. 按数据包数量和连接持续时间划分的结果</h3><p>为了研究模型的预测在流的整个生命周期中的稳定性，我们展示了先前对每个模型和场景进行验证的最佳性能配置的测试结果，这些模型和场景按传输数据包的范围和流持续时间分隔。在图 10 中，我们展示了为测试数据集中包含的网络流计算的测试指标，按传输数据包的范围对流进行分组。通过这种方式，我们可以确定需要传输多少个流数据包，以便能够以特定精度预测流是正常流量还是加密连接。此外，我们在测试数据集中显示了网络流的指标，在图 11 中按以秒为单位测量的时间段对流进行分组。这些指标允许我们估计需要多少秒才能以一定的精度识别流是加密还是正常的连接。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure10.jpg" class="">
<p>图 10. F1（marco）通过数据包范围进行测量的测试。</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/figure11.jpg" class="">
<p>图 11. F1（marco）通过连接持续时间范围进行测量的测试。</p>
<p>图 10 显示了在测试场景 A、B 和 C 的最佳性能模型配置时获得的宏 F1-Score 值。结果按表示从客户端发送到客户端的所有数据包总和的数据包间隔分隔。服务器以及在连接期间从服务器到客户端。请注意，TCP 连接的建立涉及 3 个数据包的传输，而加密的新 SSL 连接的建立涉及至少 4 个附加数据包的传输（不恢复）。因此，实际上不可能识别 SSL 连接是承载少于 7 个数据包的正常流还是加密流。此外，对于未加密的 TCP 连接，我们需要至少 4 个数据包来识别它，因为前三个数据包对所有（加密和非加密）TCP 连接都是通用的。回想一下，作为我们分析的基本假设，我们没有使用 IP 地址或端口作为输入特征。表 6 显示了包含在每个数据包范围内的流的数量，作为绝对值和占总数的百分比，以及落在该区间内的加密流的数量。</p>
<p>表 6. 根据数据包范围分离的 网络流量（总数 与 总数的百分比）数 和 挖矿流量数</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/table6.png" class="">

<p>使用 Netflow 特征分析获得的结果，可以观察到，除了 RF 和 C4.5 需要传输至少 200 个数据包才能获得大于 0.99 的 F1 分数外，这两个模型在任何时间间隔都没有取得好的结果. RF 和 C4.5 模型的这个结果在实践中不是很有用，考虑到与正常流量速率相比，加密流的传输速率极低，因此，从创建到识别加密货币大约需要 30-45 分钟流量精度高（F1 分数为 0.99）。此外，CART 模型表现出显着缺乏稳定性，因为 F1 分数在超过 300 个数据包的流中开始下降。然而，FCNN、C4.5 和 RF 模型中的 F1 分数值显示出单调递增的行为，并且永远不会像 CART 模型那样不稳定。无法使用这些特征训练逻辑回归，因此在所有间隔中始终获得 0.5 的 F1 分数。相反，通过使用 Tstat 特征 FCNN，C4.5 和 RF 在少量数据包（RF 为 10，C4.5 为 75，FCNN 为 75）后获得 1 的 F1 分数（100% 的准确度、精确度和召回率）。 CART 和 LR 在数据包很少的情况下也达到了 1 的 F1 分数，但与前一种情况一样，当数据包数量增加（CART 中的 200 个数据包和 LR 中的 400 个数据包）时，它们会变得不稳定（降低它们的 F1 分数）。在场景 C 中使用组合 Netflow 和 Tstat 特征的结果显示出与场景 B 相似的结果，但在 FCNN 的情况下略有增强，仅用 20 个数据包实现了 F1 分数 1。</p>
<p>图 11 显示了每个模型的 F1 分数（宏观）结果，并按时间间隔分隔。在每个时间间隔中，我们包括自建立以来一直处于活动状态的流，其秒数落在此范围内。因此，相同的流可以在不同的时刻被采样，其特征在同一数据集和不同的时间间隔中出现多次。例如，一个总持续时间为 200 秒的 TCP 连接将在 [0,1]、[1,60]、[60,120] 和 [120,300] 间隔中显示为不同的流发生。表 7 显示了流的总数和百分比，以及每个间隔中出现的加密流的数量。</p>
<p>表 7. 根据连接持续时间范围分离的 网络流量（总数 与 总数的百分比）数 和 挖矿流量数</p>
<img src="/post/detection-of-encrypted-cryptomining-malware-conn-with-ml-and-dl/table7.png" class="">

<p>图 11 中报告的结果与按数据包范围分离结果时获得的结果相似。使用 Netflow 功能时，只有 RF 和 C4.5 模型表现良好，但只有在流持续时间大于 2400 秒时才能获得 0.999 的 F1 分数。请注意，在持续 1200 秒或更长时间的一组流中，加密连接的百分比远大于其余时间间隔，包括存在较短的流（表 7）。这种显着差异可以通过以下事实来解释：加密协议倾向于长时间建立连接，而这在正常流量中并不那么频繁。因此，与其余时间间隔相比，对持久流进行更精确的分类更容易。使用 Tstat 特征，RF 和 C4.5 在 60 秒后获得完美的分类（F1 分数为 1），而 FCNN 需要一些额外的时间（300 秒）。当流动持续时间较长时，CART 和逻辑回归表现出先前评论的不稳定。当在场景 C 中组合这两组特征时，与仅使用 Tstat 特征的模型相比，没有出现显着差异。</p>
<p>根据在按数据包或时间间隔分隔流时获得的结果，我们可以得出结论：（a）使用 Tstat 特征以及在 RF 和 C4.5 模型的情况下，获得了最佳结果（F1 得分为 1）一旦流传输了 10 个数据包或在流创建后仅经过 60 秒，并且 (b) RF、C4.5 和 FCNN 模型即使仅使用 Netflow 特征（即在这些模型中，F1 -score 随着流中传输的数据包数量单调增加。但是，当流中的数据包数量达到 CART 中的 200 个数据包和 LR 中的 400 个数据包时，或者当流中的数据包数量超过 1200 时，CART 和逻辑回归模型表现出不稳定的行为CART 中的秒数和 LR 中的 2400 秒，这可能会妨碍它们在实际生产环境中的使用。</p>
<h2 id="九、结论和未来工作"><a href="#九、结论和未来工作" class="headerlink" title="九、结论和未来工作"></a>九、结论和未来工作</h2><p>我们设计、训练和测试了一组用于检测加密活动的机器和深度学习模型。我们选择了几个复杂的模型，例如深度神经网络、随机森林和 C4.5，以便将它们的性能与已知研究进行比较。作为相对于其他提议的新颖性，并且为了评估现实场景中的机器学习性能，我们的实验中考虑了正常和加密流量的加密和非加密流。作为主要贡献，我们提出了一组从 Tstat 工具统计中派生的信息丰富的新特征，以测试使用信息丰富的特征是否可以提高复杂模型的机器学习性能。我们使用 Tstat 工具为每个流派生了这组 51 个特征，并从 IETF 标准 NetFlow&#x2F;IPFIX 指标中提取了第二组 8 个特征。</p>
<p>我们在 Telefonica 研发场所的 Mouseworld 实验室建立了一个受控的网络环境，使用真实的客户端和服务器来生成与正常流量（网上冲浪、视频和音频流、云存储、文件传输、电子邮件和 P2P）竞争的加密流量的真实实验除其他外）通过具有 Internet 连接的专用网络。 Cryptomining 客户端连接到 Internet 中的真实矿池，Monero 被选为我们实验的加密货币，因为它是迄今为止网络犯罪分子最喜欢的加密货币。 Monero 客户端运行 Stratum 协议，这是用于分发采矿过程的最广泛的协议。不仅为 Stratum 协议而且为其余流量建立了加密和普通连接，以便生成真实的流量跟踪。实验产生的流量被用于两个不同的任务。首先，捕获、标记和存储流量，用于训练监督机器学习模型。后来，流量被实时输入到机器学习模型中以进行测试。配置了三个场景，第一个使用 Netflow 派生特征，第二个仅使用 Tstat 派生特征，最后一个加入两组特征。</p>
<p>最好的结果是使用从 Tstat 派生的特征集获得的，值得注意的是，加入这两组特征（Tstat + Netflow），相对于仅使用 Tstat 特征，我们没有获得任何可观察到的优势。相反，代表技术当前状态的 Netflow 派生特征集在预测中产生了不稳定和不良性能，因此，我们建议工业界在使用机器和深度学习时应采用更详尽的特征以获得预期的性能和稳定性。此外，当随机森林、C4.5 和深度神经网络与 Tstat 特征结合使用时，加密加密连接的检测与普通（非加密）连接的性能相似。另一方面，当使用更简单的机器学习模型或 Netflow 功能时，加密加密流的检测缺乏精度和准确性，这与使用非加密加密流获得的结果成比例地更大。</p>
<p>根据所获得的结果，可以得出结论，我们提出的使用足够详尽的特征作为复杂机器学习模型（例如随机森林、C4.5 或全连接深度神经网络）的输入的提议，允许部署精确、准确和稳定根据行业要求检测加密活动的机制。</p>
<p>未来的工作将通过使用不同的加密协议和加密货币的新实验来扩展当前的研究，这可能意味着设计更复杂的模型来学习新的加密活动模式。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] J. Lewis, The Economic Impact of Cybercrime—No Slowing Down.<br>Santa Clara, CA, USA: McAfee, 2018.<br>[2] S. Nakamoto. (2008). Bitcoin: A Peer-to-Peer Electronic Cash System.<br>[Online]. Available: <a href="https://git.dhimmel.com/bitcoin-whitepaper/" target="_blank" rel="noopener">https://git.dhimmel.com/bitcoin-whitepaper/</a>.<br>[3] Deadcoins. Deadcoins Curated List of Cryptocurrencies and ICOs.<br>Accessed: Feb. 23, 2020. [Online]. Available: <a href="https://deadcoins.com/" target="_blank" rel="noopener">https://deadcoins.com</a><br>[4] L. Ren and S. Devadas, ‘‘Bandwidth hard functions for ASIC resistance,’’ in Theory of Cryptography, (Lecture Notes in Computer Science),<br>vol. 10677. Cham, Switzerland: Springer, 2017, pp. 466–492.<br>[5] GithubRepository, Tevador. (2019). RandomX: Experimental Proof of<br>Work Algorithm Based on Random Code Execution. [Online]. Available:<br><a href="https://github.com/tevador/RandomX" target="_blank" rel="noopener">https://github.com/tevador/RandomX</a><br>[6] S. Pastrana and G. Suarez-Tangil, ‘‘A first look at the crypto-mining<br>malware ecosystem: A decade of unrestricted wealth,’’ in Proc. Internet<br>Meas. Conf., Oct. 2019, pp. 73–86.<br>[7] J. Z. I. Munoz, J. Suarez-Varela, and P. Barlet-Ros, ‘‘Detecting cryptocurrency miners with NetFlow&#x2F;IPFIX network measurements,’’ in Proc. IEEE<br>Int. Symp. Meas. Netw. (M&amp;N), Jul. 2019, pp. 1–6.<br>[8] S. Haber and W. S. Stornetta, ‘‘How to time-stamp a digital document,’’<br>J. Cryptol., vol. 3, no. 2, pp. 99–111, Jan. 1991.<br>[9] Braiins Systems. Stratum V2 | The Next Generation Protocol for<br>Pooled Mining. Accessed: Jan. 23, 2020. [Online]. Available:<br><a href="https://stratumprotocol.org/" target="_blank" rel="noopener">https://stratumprotocol.org/</a><br>[10] Braiins Systems. Stratum Mining Protocol. Accessed: Jan. 23, 2020.<br>[Online]. Available: <a href="https://slushpool.com/help/topic/stratum-protocol/" target="_blank" rel="noopener">https://slushpool.com/help/topic/stratum-protocol/</a><br>[11] JSON-RPC Working Group. JSON-RPC 2.0 Specification. Accessed:<br>Feb. 23, 2020. [Online]. Available: <a href="https://www.jsonrpc.org/specification" target="_blank" rel="noopener">https://www.jsonrpc.org/specification</a><br>[12] R. Recabarren and B. Carbunar, ‘‘Hardening stratum, the bitcoin pool<br>mining protocol,’’ Proc. Privacy Enhancing Technol., vol. 2017, no. 3,<br>pp. 57–74, Jul. 2017.<br>[13] A. Swedan, A. N. Khuffash, O. Othman, and A. Awad, ‘‘Detection and<br>prevention of malicious cryptocurrency mining on Internet-connected<br>devices,’’ in Proc. 2nd Int. Conf. Future Netw. Distrib. Syst. (ICFNDS),<br>2018, pp. 23:1–23:10.<br>[14] R. K. Konoth, E. Vineti, V. Moonsamy, M. Lindorfer, C. Kruegel, H. Bos,<br>and G. Vigna, ‘‘MineSweeper: An in-depth look into drive-by cryptocurrency mining and its defense,’’ in Proc. ACM SIGSAC Conf. Comput.<br>Commun. Secur., Jan. 2018, pp. 1714–1730.<br>[15] D. Carlin, P. OrKane, S. Sezer, and J. Burgess, ‘‘Detecting cryptomining<br>using dynamic analysis,’’ in Proc. 16th Annu. Conf. Privacy, Secur. Trust<br>(PST), Aug. 2018, pp. 1–6.<br>[16] J. Liu, Z. Zhao, X. Cui, Z. Wang, and Q. Liu, ‘‘A novel approach for<br>detecting browser-based silent miner,’’ in Proc. IEEE 3rd Int. Conf. Data<br>Sci. Cyberspace (DSC), Jun. 2018, pp. 490–497.<br>[17] A. Kharraz, Z. Ma, P. Murley, C. Lever, J. Mason, A. Miller, N. Borisov,<br>M. Antonakakis, and M. Bailey, ‘‘Outguard: Detecting in-browser<br>covert cryptocurrency mining in the wild,’’ in Proc. World Wide Web<br>Conf. (WWW), 2019, pp. 840–852.<br>[18] J. Berkson, ‘‘Application of the logistic function to bio-assay,’’ J. Amer.<br>Stat. Assoc., vol. 39, no. 227, pp. 357–365, Sep. 1944.<br>[19] J. Cramer, ‘‘The origins of logistic regression,’’ Tinbergen Inst. Discuss.<br>Papers 02-119&#x2F;4, 2002.<br>[20] D. Steinberg, ‘‘CART: Classification and regression trees,’’ in The Top<br>Ten Algorithms Data Mining, X. Wu and V. Kumar, Eds. London, U.K.:<br>Chapman &amp; Hall, 2009, ch, 10.<br>[21] J. R. Quinlan, C4.5: Programs for Machine Learning. Amsterdam,<br>The Netherlands: Elsevier, 2014.<br>[22] L. Breiman, ‘‘Random forests,’’ Mach. Learn., vol. 45, no. 1, pp. 5–32,<br>2001.<br>[23] T. En-Najjary, G. Urvoy-Keller, M. Pietrzyk, and J.-L. Costeux,<br>‘‘Application-based feature selection for Internet traffic classification,’’ in<br>Proc. 22nd Int. Teletraffic Congr. (lTC), Sep. 2010, pp. 1–8.<br>[24] T. En-Najjary and G. Urvoy-Keller, ‘‘A first look at traffic classification in<br>enterprise networks,’’ in Proc. 6th Int. Wireless Commun. Mobile Comput.<br>Conf. ZZZ (IWCMC), 2010, pp. 764–768.<br>[25] Y. Wang and S.-Z. Yu, ‘‘Machine learned real-time traffic classifiers,’’<br>in Proc. 2nd Int. Symp. Intell. Inf. Technol. Appl., vol. 3, Dec. 2008,<br>pp. 449–454.<br>[26] J. Li, S. Zhang, Y. Xuan, and Y. Sun, ‘‘Identifying skype traffic by random<br>forest,’’ in Proc. Int. Conf. Wireless Commun., Netw. Mobile Comput.,<br>Sep. 2007, pp. 2841–2844<br>[27] D. P. Kingma and J. Ba, ‘‘Adam: A method for stochastic<br>optimization,’’ 2014, arXiv:1412.6980. [Online]. Available:<br><a href="http://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">http://arxiv.org/abs/1412.6980</a><br>[28] D. E. Rumelhart, G. E. Hinton, and R. J. Williams, ‘‘Learning<br>internal representations by error propagation,’’ in Parallel Distributed<br>Processing: Explorations in the Microstructure of Cognition, vol. 1.<br>Cambridge, MA, USA: MIT Press, 1986, pp. 318–362.<br>[29] A. Saied, R. E. Overill, and T. Radzik, ‘‘Detection of known and unknown<br>DDoS attacks using artificial neural networks,’’ Neurocomputing, vol. 172,<br>pp. 385–393, Jan. 2016.<br>[30] A. Pastor, A. Mozo, D. R. Lopez, J. Folgueira, and A. Kapodistria, ‘‘The<br>mouseworld, a security traffic analysis lab based on NFV&#x2F;SDN,’’ in Proc.<br>13th Int. Conf. Availability, Rel. Secur. (ARES), 2018, pp. 57:1–57:6.<br>[31] fireice-uk. FIREICE-UK&#x2F;XMR-STAK: Free Monero RandomX Miner and<br>Unified CryptoNight Miner. Accessed: Dec. 28, 2019. [Online]. Available:<br><a href="https://github.com/fireice-uk/xmr-stak/" target="_blank" rel="noopener">https://github.com/fireice-uk/xmr-stak/</a><br>[32] Xmrig Team. XMRIG&#x2F;XMRIG: RandomX, CryptoNight, AstroBWT and<br>Argon2 CPU&#x2F;GPU Miner. Accessed: Jan. 23, 2020. [Online]. Available:<br><a href="https://github.com/xmrig/xmrig" target="_blank" rel="noopener">https://github.com/xmrig/xmrig</a><br>[33] The Monero Project. Home | Monero-Secure, Private, Untraceable.<br>Accessed: Feb. 23, 2020. [Online]. Available: <a href="https://www.getmonero.org/" target="_blank" rel="noopener">https://www.getmonero.org/</a><br>[34] T. T. T. Nguyen and G. Armitage, ‘‘A survey of techniques for Internet<br>traffic classification using machine learning,’’ IEEE Commun. Surveys<br>Tuts., vol. 10, no. 4, pp. 56–76, 4th Quart., 2008.<br>[35] A. Dainotti, A. Pescape, and K. Claffy, ‘‘Issues and future directions in<br>traffic classification,’’ IEEE Netw., vol. 26, no. 1, pp. 35–40, Jan. 2012.<br>[36] A. Habibi Lashkari, G. Draper Gil, M. S. I. Mamun, and A. A. Ghorbani,<br>‘‘Characterization of tor traffic using time based features,’’ in Proc. 3rd Int.<br>Conf. Inf. Syst. Secur. Privacy, 2017, pp. 253–262.<br>[37] A. Finamore, M. Mellia, M. Meo, M. M. Munafo, P. D. Torino, and<br>D. Rossi, ‘‘Experiences of Internet traffic monitoring with tstat,’’ IEEE<br>Netw., vol. 25, no. 3, pp. 8–14, May 2011.<br>[38] G. Shobha and S. Rangaswamy, ‘‘Machine learning,’’ in Computational<br>Analysis and Understanding of Natural Languages: Principles, Methods and Applications (Handbook of Statistics), vol. 38, V. Gudivada<br>and C. Rao, Eds. Amsterdam, The Netherlands: Elsevier, 2018, ch. 8,<br>pp. 197–228.<br>[39] A. Mozo, I. Segall, U. Margolin, and S. Gomez-Canaval, ‘‘Scalable prediction of service-level events in datacenter infrastructure using deep neural<br>networks,’’ IEEE Access, vol. 7, pp. 179779–179798, 2019.<br>[40] M. Hall, E. Frank, G. Holmes, B. Pfahringer, P. Reutemann, and<br>I. H. Witten, ‘‘The WEKA data mining software: An update,’’ ACM<br>SIGKDD Explor. Newslett., vol. 11, no. 1, pp. 10–18, 2009.<br>[41] F. Chollet. (2015). Keras. [Online]. Available: Available: <a href="https://keras.io/" target="_blank" rel="noopener">https://keras.io</a><br>[42] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin,<br>S. Ghemawat, G. Irving, M. Isard, and M. Kudlur, ‘‘Tensorflow: A system<br>for large-scale machine learning,’’ in Proc. 12th USENIX Symp. Oper. Syst.<br>Design Implement. (OSDI), 2016, pp. 265–283.</p>
]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>cryptomining</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>ECDSA签名及验证</title>
    <url>/post/ecdsa-sign/</url>
    <content><![CDATA[<p>ECDSA私钥是取q为模后得到的整数x。相关标准规定x不得为0。 因此，x是在[1，q-1]范围内的整数。qlen为q的二进制长度。</p>
<p>签名的生成使用了密码学哈希函数H和输入的消息m。消息首先由H处理，产生值H(m)即消息m的hash，它是长度为hlen的二进制序列。通常，选择H使其输出长度hlen大致等于qlen，因为签名方案的总体安全性取决于hlen和qlen之间的最小值；但是，相关标准支持hlen和qlen的所有组合。</p>
<span id="more"></span>

<ol>
<li>使用bits2int变换和额外的模块化约简将H(m)转换为整数模q：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h = bits2int(H(m)) mod q</span><br></pre></td></tr></table></figure>
<p>正如在bit2octets的描述中所指出的那样，额外的模块化缩减只不过是有条件的减法。</p>
<ol start="2">
<li><p>生成称为k的取模q的随机值。 该值不为0。因此，它位于[1，q-1]范围内。在ECDSA中，应通过随机选择来选择k，该选择应以均匀的概率从q-1个可能的值中选择一个值。</p>
</li>
<li><p>根据k和关键参数计算出值r (modulo q)。计算出点kG；其X坐标（定义了E的字段的成员）被转换为整数，该整数以q为模减小，从而得出r。如果r变为零，则应选择一个新的k并再次计算r（这是完全不可能的情况）。</p>
</li>
<li><p>值s (modulo q)的计算如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s =（h + x * r）/ k mod q     </span><br></pre></td></tr></table></figure>

<p>(r, s)就是签名。ECDSA标准本身并未涵盖如何对签名进行编码； 常见的方法是使用DER编码的ASN.1结构（两个INTEGER的SEQUENCE，分别用于r和s），或者作为两个32bytes拼接为一个64bytes。</p>
<p>签名验证过程如下：</p>
<ol>
<li><p>验证 <em>r , s</em> 都处于 [1, n-1] 范围内的整型数，否则验证失败</p>
</li>
<li><p><em>e</em>为消息的hash值</p>
</li>
<li><p>计算<em>z</em></p>
</li>
<li><p>计算参数 <em>w</em> :</p>
<p>$w&#x3D;s^{−1}\ mod\ n$</p>
</li>
<li><p>计算两个参数 <em>u1, u2</em> :</p>
<p>$u_1&#x3D;zw\ mod\ n,\ u_2&#x3D;rw\ mod\ n$</p>
</li>
<li><p>(x1, y1)，如果该点不是同一个曲线上的点，验证失败</p>
<p>$(x_{1}, y_{1}) &#x3D; u_{1} \times G + u_{2} \times Q_{A}$</p>
</li>
<li><p>如果存在下面的恒等式，则验证通过，否则验证失败</p>
<p>$r≡x_1\ mod\ n$</p>
</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>生成不变的sign</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>ECDSA</tag>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>Enabling Cross-Chain Transactions: A Decentralized Cryptocurrency Exchange Protocol</title>
    <url>/post/enabling-x-chain-txs/</url>
    <content><![CDATA[<h1 id="赋能跨链交易：一项分布式的加密货币交易协议"><a href="#赋能跨链交易：一项分布式的加密货币交易协议" class="headerlink" title="赋能跨链交易：一项分布式的加密货币交易协议"></a>赋能跨链交易：一项分布式的加密货币交易协议</h1><img src="/post/enabling-x-chain-txs/image-20211011032455266.png" class="" title="image-20211011032455266">

<p><strong>摘要：</strong>受比特币的启发，市场上出现了多种基于区块链技术的加密货币。由于区块链的特殊结构，传统货币与加密货币之间或不同类型加密货币之间的直接交易被认为是不可能的。<br>通常，不同货币之间的交易是通过一个中心化的第三方平台进行的。但是，它存在单点故障的问题，容易受到攻击，从而影响交易的安全性。在本文中，我们提出了一种分布式加密货币交易方案来解决中心化交易所的问题，可以实现不同类型加密货币之间的安全交易。我们的方案是通过以太坊区块链上的智能合约实现的，并部署在以太坊测试网络上。除了实现单个用户之间的交易，我们的方案还允许多个用户之间的交易。实验结果证明我们方案的成本是可以接受的。</p>
<span id="more"></span>

<h2 id="I-简介"><a href="#I-简介" class="headerlink" title="I. 简介"></a>I. 简介</h2><p>比特币 [1] 是目前最受欢迎的加密货币，自 2009 年部署以来一直运行良好。与传统货币不同，比特币不依赖中央发行人进行管理，而是运行在 P2P（点对点）网络之上，这意味着没有中央机构可以完全控制比特币。<br>它的交易数据并不存储在中央数据库中，而是写入一个名为区块链blockchian的分布式哈希链中。近年来，受比特币的启发，出现了各种基于区块链的加密货币，例如莱特币 [2] 和以太坊 [3]。为了帮助用户管理不同种类的加密货币，最近的一些工作中通常使用基于可信第三方的中心化交换，例如[4]-[8]。</p>
<p>一方面，通过利用不同的区块链技术，不同种类的加密货币被部署在不同的区块链中。 相同货币之间的交易可以通过区块链客户端直接在网络上进行。 但是，部署在不同区块链上的加密货币不能直接相互交易。 此外，如果用户想使用传统货币购买某种加密货币或将其加密货币转换为现金，则用户只能与第三方进行兑换。 在这种情况下，基于可信第三方的交易所是有帮助的，它可以充当中介，帮助用户在不同类型的加密货币之间进行交易。</p>
<p>另一方面，加密货币的所有者通常通过绑定到始终存储在他&#x2F;她的私人设备中的一对密钥的地址来管理他&#x2F;她的资产。 在这种情况下，一旦设备出现故障、丢失甚至被针对加密货币的恶意软件攻击，用户就会遭受财产损失。<br>因此需要一个中央组织来帮助用户管理他们的财产。 中心化交易所扮演着这个角色，它不仅可以作为加密货币交易的平台，还可以为用户提供一个存放财产的地方。 就像银行一样，中心化交易所为用户提供了管理资金和进行交易的便利。 现在世界上有 4,000 多个中心化交易所，例如韩国的 Bithumb [9]，每天交易超过 10 亿美元的加密货币。</p>
<p>中心化交易所虽然为用户交易提供了便利，但也带来了一些安全隐患。 一旦用户将自己的财产存放在一个中心化的交易平台中，就意味着该交易平台是系统的“阿喀琉斯之踵”，可能会导致用户的财产和交易信息被恶意利用。此外，作为中央机构[10]、[11]，总会存在单点故障。 解决这个问题最好的办法是采用分布式加密货币交换方案，这也符合加密货币去中心化的思想。</p>
<p>智能合约（Smart Contract） [12]、[13] 是可以在区块链上部署和执行的代码。 通过智能合约，我们能够实现各种去中心化的应用程序。 目前，以太坊是支持部署智能合约的最大和最受欢迎的区块链平台。用户可以通过交易将他们的智能合约代码发送到以太坊网络，然后由矿工验证并添加到区块链中。保存在区块链中的任何智能合约代码都可以被满足一定条件的用户调用（通过transaction call合约内的方法）。在本文中，我们考虑使用基于以太坊的智能合约来实现一种去中心化的跨加密货币交换方案，该方案可以验证不同用户发送的不同类型的加密货币交易。我们不仅解决单个用户之间的交易，还考虑了多个用户之间进行交易的情况。</p>
<p>在本文中，我们做出了以下主要贡献：</p>
<ul>
<li><p>我们提出了一种基于智能合约的去中心化跨加密货币交换方案，通过随机选择的用户作为中介，可以在单用户和多用户场景下实现任意两种加密货币之间的交易。在多用户场景中，多个用户可以在短时间内发起多次转账，建立的合约可以自动收集这些转账并同时完成这些交易。</p>
</li>
<li><p>在我们的方案中，通过工作量证明（PoW, Proof of Work）和存款证明（Proof of Deposit），随机选择不受信任的自愿用户来组织验证委员会。此外，通过使用智能合约收集验证委员会成员的判断结果，我们的方案可以通过以太坊网络验证任何两种不同类型的加密货币之间的交易。进一步分析表明，我们方案的功能性和事务原子性可以通过选择验证委员会的协议设计来保证。</p>
</li>
<li><p>我们在以太坊测试网络上实施和部署我们提出的方案，并在我们的本地机器上评估合约各部分的运行成本。我们的方案优化了多个用户之间同类型加密货币的执行性能。实验结果表明，我们方案的本地运营成本仅受参与者数量的影响，与每个用户的交易数量无关。我们的跨币种交易方案确保部署成本和执行成本在用户可接受的范围内。</p>
</li>
</ul>
<p>我们论文的其余部分组织如下。<br><strong>第二节</strong>介绍了与我们的方案相关的一系列工作。<br><strong>第三节</strong>中介绍了技术预备知识。<br><strong>第四节</strong>介绍我们的系统和安全模型之后，<br><strong>第五节</strong>详细介绍了我们的交叉加密货币交易方案。<br><strong>第六节</strong>提供了我们方案的安全性分析。<br><strong>第七节</strong>展示了我们方案的详细部署和相关的性能分析。<br><strong>第八节</strong>最后总结了我们的工作。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>在本节中，我们将介绍去中心化加密货币交易方案的现有工作，这些方案旨在解决中心化交易所中的单点故障问题。</p>
<p>Metronome 项目 [14] 提出了一种称为 MTN 的加密货币，可以跨不同的区块链进行交易。 当用户销毁源链上的代币时，他&#x2F;她会收到一份exit收据证明，可在目标区块链上使用来获得其他链上的货币。 但是，Metronome 只能在支持智能合约的区块链中实现，不支持智能合约的加密货币因此无法交换。</p>
<p>KyberNetwork [15] 是一种高度流动的链协议，为目前部署在以太坊上的数字资产和加密货币提供即时交易和赎回服务。在 KyberNetwork 网络中，用户通过与智能合约交互将其代币存储在存储库中。 用户还可以通过由合约或第三方机构创建的存储库访问其他类型的加密货币。 第三方机构创建的存储库中的资金来自资金提供者，储备经理维护存储库，确定汇率，并将比率反馈给 KyberNetwork。 网络中预留实体的添加和删除由 KyberNetwork 运营商负责。 KyberNetwork 依靠区块链中继技术（如 BTCRelay [16]）来实现跨链确认，因此在支持多币种方面存在缺陷。</p>
<p>ERC-20 [17] 是以太坊区块链上代币的标准接口。一些实现，例如 [18]-[21]，试图解决以太坊上的 ERC-20 代币和比特币之间的交易。但这些作品只服务于以太坊上的 ERC-20 代币，具有很大的局限性。<br>Republic [22] 是跨不同区块链的加密货币对之间的去中心化暗池项目。暗池提供了一个隐藏的订单簿，其中金融资产和工具通过建立在多方计算协议上的引擎进行交易和匹配。<br>Dogethereum [23] 是一种运行智能合约的点对点互联网货币，可以将狗狗币（Doge）兑换成等值的以太坊代币，反之亦然。<br>然而，Republic 和 Dogethereum 只提供有限种类的代币和以太坊之间的交换。但是，在我们的方案中，我们在以太坊上使用智能合约通过从中间节点中选择的验证委员会来验证其他类型的加密货币，因此我们的方案能够支持任何类型的加密货币之间的交易。</p>
<p>Cosmos [24] 和 Polkadot [25] 都在努力解决区块链的互操作性，使用 Tendermint [26] 的共识算法。<br>Cosmos 网络中的区块链采用中心辐射模型：处于中心的是“Hub”，它管理着多个称为“Zone”的独立区块链，并跟踪所有区域的状态。每个Zone都有义务通过将新Block信息（即，打包上链的txs）报告回 Hub 来自我持续生产。<br>同样的，维护 Polkadot 网络有四个基本角色：collators、fisherman、nominator 和 validator。 他们构建了一系列通过merkle证明强制执行状态的子区块链。<br>但是这两个作品都只支持与其兼容的区块链网络，并且都需要有新网络发行的新代币，这增加了交易负担。</p>
<p>XCLAIM [27] 是用于实现不受信任和高效的加密货币跨链互换（Swap）的通用框架。 缺点是发行区块链上的货币需要支持某些功能的合约。所以比特币等容量有限的脚本语言不支持这种操作。<br>Tesseract [28] 描述了如何使用可信执行环境 (TEE) 标记现有的加密货币以启用跨链交易，而 TEE 则遭受其自身的安全问题，例如回滚rollback [29] 和侧信道攻击side-channel attacks [30]。</p>
<p>原子跨链交换（ACCS）[31]、[32]基于时间hash锁或签名锁[33]-[36]，实现了安全的跨链交换，但在实用性上存在限制。 这种 ACCS 方案是交互式的，依赖于同步假设。这样，在传输过程中往往会产生较长的等待时间。 与他们的想法不同，我们的协议依赖于弱&#x2F;部分的同步假设，在多个交易参与者的情况下可以取得良好的性能。</p>
<h2 id="III-初步准备"><a href="#III-初步准备" class="headerlink" title="III 初步准备"></a>III 初步准备</h2><h3 id="A-区块链中的共识算法"><a href="#A-区块链中的共识算法" class="headerlink" title="A. 区块链中的共识算法"></a>A. 区块链中的共识算法</h3><p>在区块链系统中，用来保证分布式节点一致性的技术称为共识算法。 目前常用的共识算法主要分为两类。 第一个是基于证明的共识，如 PoW [1]、PoS [37]、DPoS [38]、GHOST [39] 等，它要求用户向网络提交一个难题的解决方案。 只有经过网络验证的节点才能发布区块，这也是加密货币中常用的共识。<br>另一种是解决拜占庭问题的传统分布式网络算法，包括PBFT[40]、[41]、RAFT[42]等。 在授权&#x2F;许可区块链（联盟链）的设计中经常使用传统的分布式网络算法</p>
<h3 id="B-智能合约中的-Gas"><a href="#B-智能合约中的-Gas" class="headerlink" title="B. 智能合约中的 Gas"></a>B. 智能合约中的 Gas</h3><p>使用gas的概念限制了以太坊上部署的智能合约的长度，这也防止了恶意用户故意部署包含无限循环的合约，避免以太坊网络崩溃。Gas 用于衡量智能合约代码中每个步骤的成本。每笔交易都需要包含一个gas限制，即交易消耗的最大gas量，以及用户为每单位gas支付的以太币数量。矿工有权选择先打包哪个交易。支付的交易费用越多，矿工就越有可能打包您的交易，交易得到确认的速度也就越快。 Gas limit 是用户最多需要支付的交易费用，它限制了智能合约不受限制地执行的能力。<br>在本文中，我们将我们的合约部署到基于以太坊的测试网络，测量每笔交易所需的 gas，并根据当前汇率计算真实的部署和运营成本。</p>
<h2 id="IV-系统模型、安全模型和设计目标"><a href="#IV-系统模型、安全模型和设计目标" class="headerlink" title="IV. 系统模型、安全模型和设计目标"></a>IV. 系统模型、安全模型和设计目标</h2><p>文中符号定义</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$A$</td>
<td>交易付款人</td>
</tr>
<tr>
<td>$B$</td>
<td>交易付款人</td>
</tr>
<tr>
<td>$C_1$</td>
<td>交易的第一个中介</td>
</tr>
<tr>
<td>$C_2$</td>
<td>交易的第二个中介</td>
</tr>
<tr>
<td>$coin_1$</td>
<td>付款人所拥有的币</td>
</tr>
<tr>
<td>$coin_2$</td>
<td>接收者所要求的币</td>
</tr>
</tbody></table>
<h3 id="A-系统模型"><a href="#A-系统模型" class="headerlink" title="A. 系统模型"></a>A. 系统模型</h3><p>我们的系统模型中有四个主要组件，详细描述如下：</p>
<ul>
<li>付款人。付款人是想要将加密货币转移给另一个用户的用户。</li>
<li>付款人。收款人是需要转入的用户，但付款人方面没有他&#x2F;她需要的加密货币类型。</li>
<li>中介。中介是拥有以太坊账户和另一种加密货币账户的用户，并在这些账户中拥有足够的财产用于进行交易。中介机构通过智能合约连接付款人和收款人。中介机构需要加入验证委员会才能参与交易验证过程，这将在第 V-D 节中介绍。</li>
<li>区块链。我们方案的每次执行都涉及三个区块链，其中两个区块链支持付款人和收款人分别使用的加密货币。第三个区块链是以太坊区块链，我们的智能合约是在它上面设计和部署的。</li>
</ul>
<p>假设我们在以太坊上部署了智能合约，我们进一步假设所有参与我们计划的用户都需要拥有自己的以太坊账户，并且只需要少量的以太币来支付调用合约的费用。同时，在我们的方案中，付款人&#x2F;收款人不需要有足够的以太币来直接支持他们的交易。对于只需要参与我们方案中的交易的用户，他&#x2F;她可以作为 SPV（简化支付验证）节点加入区块链网络 [1]。我们认为，要找到一个可以同时支持两种加密货币交易所需的两种加密货币的中介并不容易。<br>即使存在这样的中介，我们也可以将其视为我们方案中提到的两个中介。<br>因此，我们使用两个合适的中介，例如 C1 和 C2，分别实现 A 和 B 之间的加密货币交易。此外，每个中介都可以通过钱包、区块链浏览器等工具验证不同种类的加密货币交易。由于需要中介来验证交易，它可以是全节点或 SPV 节点。</p>
<p>在我们的方案中，我们采用弱同步&#x2F;部分同步的时间假设，这意味着保证消息在一定的时间限制后被传递。 在完全异步的网络中，很难区分正常节点和超时传输的恶意节点。<br>因此，在我们的方案中，将在智能合约中设置一个计时器，以防止恶意节点拒绝提供验证结果，从而区分正常节点和传输超时的恶意节点。</p>
<h3 id="B-安全模型"><a href="#B-安全模型" class="headerlink" title="B. 安全模型"></a>B. 安全模型</h3><p>我们系统中的恶意用户可能会设置大量账户作为付款人、收款人或中介，发送大量垃圾交易来破坏我们的计划。所有恶意用户都可能通过欺诈合同来串通以获得额外的利益。 它们可能的恶意行为如下所示。</p>
<ul>
<li>恶意付款人或中间人可能会向合约发送欺骗性消息，而不会进行转账或双重支付。</li>
<li>恶意收款人或中间人可以在收到转账后通过诈骗合同来赚取额外的补偿费用。</li>
<li>参与验证委员会的恶意节点（在第 V-D 节中描述）可能会发布错误信息以破坏共识过程。</li>
</ul>
<p>与恶意节点不同，受信任节点将遵守我们协议的条款来强制执行其行为，以实现跨加密货币交易或通过我们的方案赚取交易费用。 由于验证委员会是通过工作量证明选举产生的，我们假设对于想要加入验证委员会的节点，恶意节点的组合算力在任何时候都应该小于总算力的 1&#x2F;4 .</p>
<p>否则会引入自私挖矿攻击。 这种攻击将使恶意节点更有可能产生更多超过自身算力的区块，从而使他们获得比其在验证委员会中拥有的算力百分比更多的席位。</p>
<h3 id="C-设计目标"><a href="#C-设计目标" class="headerlink" title="C. 设计目标"></a>C. 设计目标</h3><p>我们的目标是在不同类型的加密货币之间设计一个分散的安全传输方案。 具体来说，我们的设计目标包括：</p>
<ul>
<li>去中心化和非pepudiation：我们的方案中不会有任何中心化的第三方。任何参与协议的一方都不能否认自己的行为。任何用户对智能合约的操作都会永久记录在区块链上。</li>
<li>可移植性：在我们的跨链加密货币交易方案中，我们需要支持多种类型的加密货币之间的交易。 换句话说，我们的交易方案不受加密货币类型的限制</li>
<li>公平性：即使我们方案的任何一步失败，我们的方案仍然保证系统正常运行，不会损害任何诚实用户的利益。</li>
<li>稳定性：我们的协议需要能够在安全假设下抵御区块链网络中的常见攻击。</li>
<li>可扩展性：在实际交易场景中，不仅有两个单用户之间的交易，也有多个用户之间的交易。 在我们的方案中，我们需要支持多用户之间的交易，性能需要可以接受。</li>
<li>原子性：在我们的跨区块链交易方案中，如果各方都遵守协议，那么所有的交换都会发生。 然后，没有遵守协议的一方最终会变得更糟，也没有联盟有偏离协议的动机[31]。</li>
<li>安全和活跃：对于共识协议，安全意味着诚实（非拜占庭）节点同意相同的值，活跃意味着交易最终会中止或提交。</li>
</ul>
<h2 id="V-跨币种交易方案"><a href="#V-跨币种交易方案" class="headerlink" title="V 跨币种交易方案"></a>V 跨币种交易方案</h2><p>在本节中，我们首先解释我们的方案如何应用于使用不同加密货币进行交易的两个用户。<br>然后，我们设计了一种安全的验证方法来验证交易是否完成。<br>最后，我们将该方案扩展到多个用户通过不同的加密货币进行交易的场景。</p>
<h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A. 概述"></a>A. 概述</h3><p>在本节中，我们将概述我们的方案，以展示我们如何实现跨不同类型加密货币的交易。我们的方案包括三个阶段：</p>
<ul>
<li>合同部署阶段。<br>这个阶段包括我们方案中涉及的三类合约的部署过程。</li>
<li>交易阶段。<br>该阶段交易的付款人和收款人在中间人的参与下完成跨加密货币交易。在我们的方案中，这个阶段分为单用户交易和多用户交易两种情况。</li>
<li>交易验证阶段。<br>为了验证以太坊智能合约中其他类型加密货币的交易结果，我们在此阶段通过选择验证委员会来验证交易。</li>
</ul>
<p>为了说明方便，我们以比特币和莱特币为例。事实上，我们的方案支持任何类型的加密货币之间的交易。<br>如图 1 所示，为了通过智能合约实现跨加密货币交易，我们需要两个中间人 C1 和 C2，他们可以是网络中的任何人。</p>
<img src="/post/enabling-x-chain-txs/image-20211014011146367.png" class="" title="image-20211014011146367">

<center>图1：方案概述</center>

<p>在合约部署阶段，大量合约部署在网络中。 然后交易发生在交易阶段。中介机构需要分别支持通过比特币和莱特币进行交易。<br>首先，A 将 x 莱特币转移到 C1。 C1收到转账后，将等价的ethers转账给C2，然后C2将y个比特币转账给B。这样，我们就以ether的转账作为桥梁，实现了两个用户之间不同加密货币的转账。 用户作为中介参与我们合约的动机是他&#x2F;她可以通过这个过程获得交易费用。</p>
<p>需要注意的是，以太坊除了以太币的转账，还有比特币和莱特币的转账。 虽然无法通过以太坊智能合约直接验证这两种货币的交易，但我们通过选择一组用户作为验证委员会来提供验证结果来找到解决方案。 在交易验证阶段，合约将整合委员会的判断结果并得出最终结论。 正如工作[43]中总结的那样，没有可信的第三方就不可能进行跨链通信，而由分布式节点组成的验证委员会在我们的方案中扮演着这样的角色。</p>
<p>除了上面提到的单用户交易场景，我们还考虑了多用户交易场景。 在这种情况下，有多个付款人想要将加密货币转移给一个或多个收款人。 我们的合同可以将需要转移相同类型加密货币的付款人与需要不同类型加密货币的收款人结合起来。 我们完整提案的细节将在第 V-C.1 至 V-C.2 节中描述。</p>
<h3 id="B-合约部署阶段"><a href="#B-合约部署阶段" class="headerlink" title="B. 合约部署阶段"></a>B. 合约部署阶段</h3><p>在我们的方案中，使用以太坊的 Solidity 语言编写了三种类型的智能合约。</p>
<ul>
<li>中介合同。 该智能合约主要控制中介的行为，并提供获取中介节点信息的接口。</li>
<li>交易合同。 通过该合约，交易的付款人和收款人在中间人的参与下完成了跨加密货币交易。 并且这个合约提供了一个调用接口，用于输入验证结果。</li>
<li>委员会合同。 该合约用于验证委员会选举，包括 PoW 拼图验证和控制验证委员会的规模，并提供一个接口来验证节点是否是验证委员会的成员。</li>
</ul>
<p>我们合约的主要功能如下。 我们将中介合约表示为 IC，将交易合约表示为 TC，将委员会合约表示为 CC。</p>
<center>表II：智能合约功能</center>

<table>
<thead>
<tr>
<th>智能合约步骤</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IC.Register</td>
<td>中介提供注册信息</td>
</tr>
<tr>
<td>IC.Update</td>
<td>中介更新信息</td>
</tr>
<tr>
<td>CC.Verify_PoW</td>
<td>验证用户是否有资格加入验证组</td>
</tr>
<tr>
<td>TC.Prepare</td>
<td>为交易用户的信息准备</td>
</tr>
<tr>
<td>TC.Deposit</td>
<td>用户提交存款</td>
</tr>
<tr>
<td>TC.Validation</td>
<td>用户的交易验证</td>
</tr>
</tbody></table>
<p>在合约部署阶段，这三类合约在全网大量部署。<br>用户和中介可以自由选择不超过gas limit的合约进行交易。 一旦网络中的交易需求超过合约数量，任何中介也可以进一步部署额外的交易合约和委员会合约。 用户可以在中介合约中查询的中介交易信息包括中介机构部署的合约的交易合约地址。 一个中介可以部署多个合约。 任何中介都可以加入其他合约作为交易所需的两个中介之一。 通过不同合约的交易并行发生，因此网络中的交易合约越多，在固定用户数下交易效率就越高</p>
<h3 id="C-交易阶段"><a href="#C-交易阶段" class="headerlink" title="C. 交易阶段"></a>C. 交易阶段</h3><h4 id="1）单用户交易阶段"><a href="#1）单用户交易阶段" class="headerlink" title="1）单用户交易阶段"></a>1）单用户交易阶段</h4><p>在交易阶段，我们首先介绍单用户交易方案。 单用户交易方案表示参与交易的双方都是个人。 该方案还包括用户与他&#x2F;她自己的货币兑换（例如，Alice 将她的比特币转换为以太币）。 为了清楚起见，我们假设 coin1 和 ether 之间的汇率以及 coin2 和 ether 之间的汇率都是“1”。 在实际场景中，非“1”汇率的问题只需要将汇率乘以相应的放大倍数即可。 单用户交易方案的主要流程如算法1所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 算法1</span><br><span class="line">输入: 双方及中介的账户地址; 交易金额 x; 汇率; 时间阈值 T;</span><br><span class="line"></span><br><span class="line">if 中间人 C1 和 C2 都存入了 Ether</span><br><span class="line">then</span><br><span class="line">    付款人 A 将 x 个 coin1 转给中间人 C1;</span><br><span class="line">    </span><br><span class="line">    if 转账确认成功 then</span><br><span class="line">    	中介C2将xcoin2转给收款人B;</span><br><span class="line">    	</span><br><span class="line">    	if 转账确认成功 then</span><br><span class="line">    		Return 中介C2给自己的押金;</span><br><span class="line">    	else if 超时或确认失败 then</span><br><span class="line">    		将中介C2的押金转给B;</span><br><span class="line">		end</span><br><span class="line">	</span><br><span class="line">		将中介C1的押金转移到C2;</span><br><span class="line"></span><br><span class="line">	else if 超时或确认失败 then</span><br><span class="line">		退还中介C1和C2的押金;</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">else if C1 或 C2 没有在时间 T 内提供存款</span><br><span class="line">then</span><br><span class="line">	Return 存入 C1 或 C2 然后终止;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>在交易开始之前，中介机构将自己支持的加密货币类型和相应的汇率发布到合约中。包括A和B在内的交易双方分别选择合适的中介C1和C2，并将他们的交易信息发布到合约中，例如加密货币类型、交易金额、账户地址等。然后，中介 C1 和 C2 接收双方交易的信息，并通知合约他们选择的用户。然后，他们需要在时间 T 内向合约发送一定数量的押金。 如果任何中介未能在 T 时间内提供押金，合约将退还其他中介的押金并停止协议。中介C2收到付款人A向C1转账成功的消息后，向收款人B转账x币2。否则，如果判断A的转账超时或验证失败，则合约退还C1和C2的押金并终止交易交易。如果最终转账交易成功，C2的押金将退还给自己。否则，如果C2的转账被判断为超时或验证失败，则将中介C2保存在合约中的押金发送给B。最终，中介C2将从C1收到x个ether的存款</p>
<h4 id="2）多用户交易阶段"><a href="#2）多用户交易阶段" class="headerlink" title="2）多用户交易阶段"></a>2）多用户交易阶段</h4><p>在很多情况下，短时间内可能会有多个用户同时进行交易。我们的智能合约旨在支持多个用户参与加密货币转移。在多用户交易阶段，多个用户可以单独选择自己的交易伙伴。合约将结合这些交易信息，汇总转移给同一用户的加密货币数量，以提高交易效率。多用户交易方案的框架如算法2所示。该方案主要用于一组用户相互交易的场景。智能合约首先收集所有付款人 A1、A2、A3 ……An 的信息，并计算出交易金额的总和。中间人 C1 和 C2 收到此信息后，需要选择合适的用户并提交等值的以太币作为押金。如果任何中介未能在 T 时间内提供押金，合约将退还其他中介的押金并停止协议。然后，所有付款人都需要向 C1 支付足够的 coin1。验证委员会的成员需要通过第 V-D 节中描述的方法验证这些转移。转让信息也将记录在合同中。中介 C1 成功收到付款人的转账后，合约计算成功交易的金额，修改 C1 收到的金额，然后将消息发送给 C2。否则，如果任何付款人 Ai 的转账被判断为超时或被验证为失败，则合约将等值金额 A[i] 的押金退还给 C1 和 C2。中介C2最终根据收到的消息将coin2转给每个收款人B1、B2、B3……Bn。否则，如果向收款人 Bi 的转账超时或判定失败，则合约将向 Bi 发送等量的中介 C2 的保证金。最后，合约也会将中介C1剩余的t笔押金发送给C2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 算法2</span><br><span class="line">输入：</span><br><span class="line">	付款人账户地址：A1,A2,A3......An; </span><br><span class="line">	收款人：B1、B2、B3……Bn;</span><br><span class="line">	中介：C1、C2; </span><br><span class="line">	总交易金额：t; </span><br><span class="line">	付款人Ai发送的金额：amountA[i];</span><br><span class="line">	收款人Bi应收到的金额：amountB[i]; </span><br><span class="line">	时间阈值 T;</span><br><span class="line">	</span><br><span class="line">set 数组 amountB 中的每个元素 = 0；</span><br><span class="line"></span><br><span class="line">if 中间人 C1 和 C2 都存入了 Ether</span><br><span class="line">then</span><br><span class="line">	所有付款人 A1,A2 ,A3 ......向中介 C1 转账 coin1;</span><br><span class="line">	</span><br><span class="line">	for i = 1 to n do</span><br><span class="line">		if 付款人Ai转账成功 then</span><br><span class="line">			记录 Ai;</span><br><span class="line">			将Ai值amount_A[i]加到的收款人Bj对应的数组元素amount_B[j]中;</span><br><span class="line">		else if 超时或确认失败 then</span><br><span class="line">			t = t − amountA[i]; </span><br><span class="line">			将等同于amountA[i]的押金转移到C1和C2;</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	中介C2将coin2分别转给收款人B1,B2......Bn;</span><br><span class="line">	for i = 1 to n do</span><br><span class="line">		if The transfer to Bi is successful then</span><br><span class="line">			Record Bi;</span><br><span class="line">			将等同于amountB[i]的C2押金将退还给C2;</span><br><span class="line">		else if Timeout or confirmation fails then</span><br><span class="line">			将等同于amountB[i]的C2押金转移到Bi;</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line"></span><br><span class="line">	将中介C1的剩余数量为t的存款转移到C2;</span><br><span class="line">	</span><br><span class="line">else if C1 或 C2 没有在时间 T 内提供存款 then</span><br><span class="line">	Return the deposit to C1 or C2 then terminate;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h3 id="D-交易验证阶段"><a href="#D-交易验证阶段" class="headerlink" title="D. 交易验证阶段"></a>D. 交易验证阶段</h3><p>中介C1和A之间的转移以及中介C2和B之间的转移有待确认。并且需要将验证结果发送到合约进行下一步。我们不能简单地要求任何用户参与交易验证，因为恶意用户可能会伪装成交易双方。例如，付款人可能会在没有任何实际转账的情况下向合同发送有关成功转账的欺诈性消息。同理，收款人收到货币后可能会发送转账失败的消息。在交易验证阶段，我们设计了一种可靠的方法，通过分散交易验证的权限来解决这个问题。</p>
<p>我们认为系统中有大量的中介，但每个交易进程只需要其中的两个。因此，其余的中间节点可以在我们的方案中用作验证器来验证交易。中介通过参与验证过程赚取费用。我们还要求每个节点在成为中介之前至少参与一次成功的验证过程。我们假设每个中介都有能力通过钱包、区块浏览器和许多其他工具来验证不同类型的加密货币的转移。一般来说，不同类型的加密货币都有自己的确认政策。例如，在比特币中，接收者假设他们的交易是安全的，附加了 6 个区块。</p>
<p>为了防止恶意用户注册多个中介账户来攻击验证过程，我们使用工作量证明（PoW）算法来确定参与验证委员会的中介集。操作由委员会合约完成，算法如算法3所示。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 算法3</span><br><span class="line">输入：</span><br><span class="line">    节点账户: acc;</span><br><span class="line">    随机数: nonce； </span><br><span class="line">    上个hash值: before;</span><br><span class="line">    存款价值: value;</span><br><span class="line"></span><br><span class="line">初始化：</span><br><span class="line">    PoW难度：targer;</span><br><span class="line">    最小存款：deposit_value;</span><br><span class="line">    当前区块哈希：hash_now; </span><br><span class="line">    上次共识时间：time_last; </span><br><span class="line">    账户到委员会成员的Map：isMembers;</span><br><span class="line">    当前委员地址Array：committee_member[w];</span><br><span class="line">    委员人数：w;</span><br><span class="line"></span><br><span class="line">if value ≥ deposit_value &amp;&amp; before == hash_now then</span><br><span class="line">	Record the current moment: now;</span><br><span class="line">	Calculate the hash based on user input:</span><br><span class="line">	h = hash(hash_now||nonce||acc)</span><br><span class="line"></span><br><span class="line">	if target ≥ h &amp;&amp; isMembers [acc] ==  false then</span><br><span class="line">		target = target ∗ 10min / (now−time_last);</span><br><span class="line">		time_last = now;</span><br><span class="line">		isMembers[acc] = true;</span><br><span class="line">		hash_now= h;</span><br><span class="line">		</span><br><span class="line">		if Size of array committeemember is equal to w then</span><br><span class="line">			isMembers[committeemember[0]] = false </span><br><span class="line">			Erase committeemember[0]</span><br><span class="line">		end</span><br><span class="line"></span><br><span class="line">		Add acc to the last part of committee_member;</span><br><span class="line">		</span><br><span class="line">	else</span><br><span class="line">		Termination;</span><br><span class="line">	end</span><br><span class="line">else</span><br><span class="line">	Termination;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>在加入验证委员会之前，受存款证明的启发，每个成功解决工作量证明难题的中介都需要支付一些以太币作为保证金。工作量证明难题要求节点根据前一个区块的哈希值和自己的以太坊账户选择一个随机数，使哈希结果小于目标值。我们设置了工作量证明难题的难度，使得参与委员会的两个中间人中的每一个都需要大约 10 分钟的时间来解决。这样，所有在 10 分钟内产生的交易都将由该委员会的中介进行验证。我们设置委员人数为w，要求同一个账号不能两次加入委员会。如果一个中间节点总是诚实的，它不仅会取回自己的押金，还会从不诚实节点的惩罚中获得奖励，从交易的担保中获得交易费用。因此，作为我们系统中的中间节点是有利可图的。交易验证委员会的构成如图 2 所示。    </p>
<img src="/post/enabling-x-chain-txs/image-20211014011825777.png" class="" title="image-20211014011825777">

<center>图2：交易验证委员会构成</center>

<p>在每笔交易之后，验证委员会中的每个节点都需要验证交易并将自己的验证结果发送到智能合约。智能合约记录这些节点的地址并统计验证结果。然后，验证委员会将对给出冲突验证结果的节点进行分类。我们使用多数规则来确定最终的验证结果。为此，结果与最终结果冲突的节点将被视为不诚实，从而被排除在验证委员会之外。他们的存款将平均分配给诚实的节点。正确的结果将作为下一步的基础<br>的智能合约。对于验证委员会的规模，我们有一个 w 的数量限制。通过强制执行委员会规模，所有中间人的押金都会保留在合约中，直到任何不诚实的节点被排除在验证委员会之外。与计时策略类似，符合委员会规模允许在触发节点排除后将不诚实节点的存款转移到诚实节点。</p>
<h2 id="VI-安全分析"><a href="#VI-安全分析" class="headerlink" title="VI. 安全分析"></a>VI. 安全分析</h2><p>在本章中，我们将对我们的方案进行安全分析，并讨论我们的方案如何减轻或消除一些众所周知的针对区块链的攻击。</p>
<h3 id="A-去中心化和不可否认性"><a href="#A-去中心化和不可否认性" class="headerlink" title="A. 去中心化和不可否认性"></a>A. 去中心化和不可否认性</h3><p>我们的方案完全不需要任何可信第三方的参与，而是通过智能合约和验证委员会以完全分布式的方式保证交易安全。参与协议的中介和验证委员会是通过完全分布式的安全策略来选择的。</p>
<p>在我们的方案中，除了付款人和收款人之外，其他涉及的实体仅包括中介和验证委员会，两者都不是中心化设计。首先，我们方案中需要的两个中介是从众多中介中挑选出来的。攻击者很难提前预测用户将选择和攻击的中介。只要有足够多的中介参与，我们的系统就不会退回到伪中心化系统。另一方面，验证委员会也在一定时间内解决了 PoW 问题的分布式节点中选出。委员会成员会随着时间的推移而变化，委员会成员的可靠性由PoW和保证金保证。因此，我们的协议既不依赖于任何中心化系统，也不回退到伪中心化系统。</p>
<p>而我们的方案也实现了转账执行后的不可否认性。这是因为一旦任何参与者发送或接收交易，该交易将通过智能合约存储在区块链中，不可篡改。并且有一个验证委员会来确保智能合约之外的区块链验证的安全性，因此任何参与者都不能否认自己的行为。</p>
<h3 id="B-可移植性"><a href="#B-可移植性" class="headerlink" title="B. 可移植性"></a>B. 可移植性</h3><p>在我们的跨链加密货币交易方案中，我们支持多种类型的加密货币之间的交易。对于以太坊以外的其他加密货币的交易，我们都采用V-D节所述的方法，通过选择验证委员会来验证交易并将验证结果提供给合约。在协议的验证阶段，验证委员会中可能存在恶意节点，他们可能会提供错误的验证结果来干扰我们协议的执行。</p>
<p>在我们的方案中，验证委员会是通过工作量证明选择的，并要求用户提供足够的押金。而在我们的方案中，这两部分是不可或缺的。一方面，PoW 用于在一段时间内动态选择节点参与验证委员会。如果我们的方案设计为仅依赖于基于存款数量的绝对参与验证委员会的能力，那么用户可以轻松地将其存款分配到不同的账户来参与验证委员会，以及用户在验证委员会中的比例委员会仅与用户的存款有关。这样，拥有大量存款的用户会随着时间的推移积累更多的财富。一旦这种趋势持续下去，使得用户的财富积累足够，仅仅依靠存款证明并不能阻止用户完全掌握验证委员会的共识结果。同时，也没有任何有效的机制来阻止拥有足够存款账户的用户参与验证委员会。因此，我们还引入了工作量证明机制，该机制要求每时每刻只有计算出相应工作量证明谜题的节点才能参与验证委员会。它不仅保证了我们选择的验证委员会成员依赖于他们拥有的存款数量，而且还防止了权益的积累。它还可以防止具有大量存款的节点控制共识结果。</p>
<p>另一方面，如果我们这里只用工作量证明来做判断，普通用户也没有动力加入验证委员会，正确报告验证结果。即使报告了错误的结果，用户也不会受到任何惩罚，只能被踢出委员会。验证委员会中的每个用户都需要提供押金，作为对报告正确验证结果的诚实用户的奖励，以及对报告错误验证结果的恶意用户的惩罚。恶意用户的押金也作为对正确举报用户的奖励，以激发其诚实行为。</p>
<p>我们假设对于想要加入验证委员会的节点，恶意节点的总算力在任何时候都应该小于总算力的 1&#x2F;4。 否则，就会出现自私挖矿攻击[44]。 假设总共选择了 w个节点 加入验证委员会。 如果我们要求来自多数规则的最终验证结果的计数超过 a，则意味着验证委员会中恶意节点的百分比被强制要求小于 $t &#x3D; (w-a) &#x2F; w$。我们假设 X 是一个随机变量，代表我们在验证委员会中选择拜占庭节点的次数。 这样，恶意节点的最大数量 c 等于 $w\times{t}$ 。 我们可以使用累积二项分布来计算w节点委员会中恶意节点比例小于t时的概率P[45]。 </p>
<p>$$$<br>P[X\leq c]&#x3D;\sum_{k&#x3D;0}^{c}{\binom{w}{k}p^k(1-p)^{w-k}}<br>$$$</p>
<p>表III第一列表示委员会中恶意节点的比例不超过t，第一行代表委员会中的节点数。数据表明，在确定验证委员会的节点数时，恶意节点的比例不超过t的概率。当委员会中的恶意节点数量不超过 t 时，恶意节点提供的错误验证结果的比例不会超过 t，因为正常节点肯定会提供正确的验证结果。这样，一旦合约收集的验证结果超过t的比例，就可以将结果视为最终的正确结果。例如，当我们取 10 个验证委员会成员时，恶意节点的数量不超过总数的 1&#x2F;2 的概率为 0.99。这意味着，如果智能合约得到半数以上的验证委员会成员一致的判断，当恶意节点的比例不超过 1&#x2F;2 时，就可以认为这个结果是正确的。由于正常节点肯定会提供正确的验证结果，因此合约收集到的错误验证结果不会超过委员会中恶意节点数量的比例。从表中也可以看出，验证委员会的成员人数越多，合约在收集到足够多的验证后得到正确判断结果的概率就越大。然而，即使验证委员会的成员数量很少，该方案在我们的假设中仍然是安全的。</p>
<center>表III：拜占庭节点在所有委员会成员中的比例的二项分布（BINOMIAL DISTRIBUTION）</center>

<table>
<thead>
<tr>
<th>t&#x2F;w</th>
<th>10</th>
<th>20</th>
<th>50</th>
<th>100</th>
</tr>
</thead>
<tbody><tr>
<td>0.7</td>
<td>0.9997</td>
<td>1.0000</td>
<td>1.0000</td>
<td>1.0000</td>
</tr>
<tr>
<td>0.6</td>
<td>0.9965</td>
<td>1.0000</td>
<td>1.0000</td>
<td>1.0000</td>
</tr>
<tr>
<td>0.5</td>
<td>0.9957</td>
<td>0.9992</td>
<td>1.0000</td>
<td>1.0000</td>
</tr>
<tr>
<td>0.4</td>
<td>0.9219</td>
<td>0.9784</td>
<td>0.9937</td>
<td>0.9997</td>
</tr>
<tr>
<td>0.3</td>
<td>0.7759</td>
<td>0.8034</td>
<td>0.8369</td>
<td>0.8962</td>
</tr>
</tbody></table>
<h3 id="C-公平性"><a href="#C-公平性" class="headerlink" title="C. 公平性"></a>C. 公平性</h3><p>如第 V-C.1 节和第 V-C.2 节所述，在我们的协议过程中，无论 C1 或 C2 未能在规定时间内提供押金，或付款人的转账超时或失败，合约都将退还C1 或 C2 并终止协议。因此，诚实行为的参与者在这个过程中不会有任何损失。我们不能保证中介被选中后是完全可靠的，但可以保证即使中介出现恶意行为，也不会对跨链交易双方造成任何损失。</p>
<p>一方面，对于中介C1来说，他&#x2F;她唯一能做的恶意行为就是在获得A的转账后，假装转账失败，从而终止合约，获得A的转账。但是在我们的协议中，A 和 C1 之间的转账交易的验证结果是由验证委员会来保证的。一旦C1提供了与A交易的保证金和账户地址，他&#x2F;她的行为就完全受合约控制。如果合约从验证委员会收到转账成功的验证结果，将自动执行后续操作。否则，如果转账结果失败或超出定时器范围，合约将退还两个中介的押金并终止操作。</p>
<p>另一方面，如果C1是诚实的，而C2是恶意的，没有转给B，合约就会把C2的押金转给B。因为我们要求无论是C1还是C2，合约中的实际押金金额不小于 A 和 B 实际转移的金额。因此，在将 C2 的存款转给 B 后，B 也可以使用这笔存款通过我们的方案兑换他&#x2F;她需要的加密货币。在这种情况下，A 已成功将加密货币转移到 C1。因此，为了防止 A 在这个过程中获得额外的加密货币，我们选择将 C1 的存款发送给 C2。这样，A就完成了正常的计划流程，并没有损失任何收益。总的来说，我们的跨币种交易方案已经针对A和C1进行了成功。对于 C2，智能合约中记录了异常交易。但是对于Bit来说，完成从存款到他&#x2F;她需要的其他类型货币的转换是必要的。与正常流程相比，这确实带来了额外的开销。但是可以保证程序正常进行。如果该计划终止，将带来不低于现有计划的成本。由于 A 转给 C1 的加密货币不再退还，我们不能仅通过结束程序来保证安全。一种可能的解决方案是将 C1 的押金退还给 A，但这也会带来不少于我们现有解决方案的额外开销。</p>
<h3 id="D-稳定性"><a href="#D-稳定性" class="headerlink" title="D. 稳定性"></a>D. 稳定性</h3><p>在第 IV-B 节中描述的安全假设下，我们的协议可以很好地抵御区块链网络中的常见攻击。</p>
<p>1）Double-Spend Attack：在我们的方案中，存在付款人委托两个不同的中介同时向不同用户进行相同支付的情况。或者在委托中介过程中，付款人可以在其他场合进行同样的付款。为了防止双花攻击[46]，我们的方案要求验证者遵守加密货币本身的验证方法。例如，如果付款人以比特币支付，则验证者必须在交易后等待 6 个以上的区块才能将其判断发送到合约。我们的方案不会对所涉及的加密货币进行任何更改，以确保加密货币交易的安全性。</p>
<p>2）女巫攻击Sybil Attack：任何用户都可以发送交易请求，即使用户在向合约发送应用程序后没有进行后续转账。在这种情况下，只会损失少量的以太坊交易费用。在此过程中，恶意用户可能会发送大量的小额交易请求，甚至可能会在请求发出后拒绝发起交易。但是，在我们的方案中，允许中介在收到用户的交易请求后进行选择。也就是说，中介可以通过用户的账户地址来确认账户有足够的余额。如果转账金额太小，中介将移除用户请求，从而确保用户不是 Sybil 节点 [47]。</p>
<p>3）DoS 攻击：恶意节点可能会伪造大量账号试图加入验证委员会或冒充中间人，通过 DoS 攻击破坏正常的协议进程。但是，我们的方案不会受到这些恶意行为的影响，因为我们有两个预防措施。首先，验证委员会的每个成员都应该支付一些以太币作为保证金。其次，每个节点都需要提交 PoW 难题的解决方案，才能被认可为验证委员会的成员。因此，恶意节点无法轻易伪造身份加入验证委员会而无需支付任何费用。同样，恶意节点也不能充当中介，因为中介节点需要有加入验证委员会的记录。</p>
<h3 id="E-原子性"><a href="#E-原子性" class="headerlink" title="E. 原子性"></a>E. 原子性</h3><p>交易的原子性要求跨链交易必须要么完全成功要么完全失败。在我们的方案中，不会出现一方付款而另一方没有收到转账的情况。我们的方案通过基于智能合约和超时判断的协议设计来实现这一目标。</p>
<p>在我们的方案中，如果所有参与者都正常遵守协议，交易将被正确执行。如果一些联盟偏离了协议，在正常执行中不会对参与者造成任何损失。并且协议将被终止或违反操作将受到惩罚。如图 3 所示，我们的协议具有三个执行判断。第一个是中介需要在开始时提供足够的押金，并在智能合约上设置哈希时间锁。然后，A 可以转移到 C1。这里我们依靠验证委员会来判断交易结果，并在合约中设置时间锁定，以防止转账超时。如果传输失败，则交易终止。最后，需要中介C2向B转账，验证委员会也验证交易结果并设置哈希时间锁，防止转账超时。如果C2恶意不转账给B，合约会将C2的保证金转账给B，因此B会收到不少于他&#x2F;她到期价值的转账货币。在这种情况下，遵守协议的一方不会遭受损失，恶意方也不会从中获得任何好处。因此，恶意方没有动机偏离我们的协议。</p>
<img src="/post/enabling-x-chain-txs/image-20211014012244488.png" class="" title="image-20211014012244488">

<center>图3：协议状态转移图</center>

<h3 id="F-安全性和活力"><a href="#F-安全性和活力" class="headerlink" title="F. 安全性和活力"></a>F. 安全性和活力</h3><p>安全性：诚实（非拜占庭）节点同意相同的值。</p>
<p><strong>证明</strong>：如果所有诚实节点都同意交易验证的相同结果，则提议的协议提供安全性。<br>为了实现这一点，利用多数规则来确定最终的验证结果。对于要验证的交易 tx，每个验证节点 Pi 将给出以下两个结果之一： <code>Validation(tx, Pi ) = true</code> 或 <code>Validation(tx, Pi) = false</code> 。冲突的验证结果将验证节点分为两组：<code>True(tx) = &#123; Pi, Validation(tx, Pi ) = true&#125;</code> 和 <code>False( tx) = &#123; Pj , Validation(tx, Pj ) = false &#125;</code>。通过使用多数规则，如果|True(tx)|&gt;|False(tx)|，则最终验证结果为真；否则，即如果 |False(tx)|&gt;|True(tx)|，它将为 false 。根据我们的安全假设，委员会中拜占庭节点的数量少于 1&#x2F;4，给出最终验证结果的节点是诚实的，其他的都是拜占庭节点。我们选择通过反证法来证明这个特征。我们要表明，根据多数规则，委员会不可能同时承认真假。对于最终结果为真的认可，必须是委员会中半数以上的节点都认可了“真”。同时，对于最终结果为false的认可，必须是“false”也得到了委员会半数以上节点的认可。然而，这意味着 ||True(tx)| + |False(tx)||大于委员会成员总数，这是不可能的。因此，这就产生了矛盾，因为这两个结果都不能同时被委员会中超过一半的节点认可。换句话说，诚实节点不同意这两种不同的结果，从而证明我们的协议实现了安全性。</p>
<p><strong>活力</strong>：事务最终会中止或提交。</p>
<p>证明：在我们的方案中，我们采用弱同步&#x2F;部分同步的时间假设，这意味着保证消息在一定的时间限制后被传递。我们方案的设计也是基于这个假设。因此，我们的方案将在智能合约中设置一个计时器，以防止恶意节点拒绝提供验证结果。在这种弱&#x2F;部分同步时间假设下，按照执行顺序，合约中有五种请求：R1（C1&amp;C2存款）、R2（付款人转账）、R3（付款人确认）、R4（收款人转账）和R5 （收款人确认）。因此，有六个有效状态：S0（开始）、S1（中介存款）、S2（付款人转移）、S3（付款人确认）、S4（收款人转移）、S5（收款人确认）。在每个状态 Si ，合约等待相应的请求 Ri+1。如果成功，则合约转移到下一个状态 Si+1；否则，如果失败或超时，则合约终止并宣布交易失败。如果合约成功遍历了有效的状态转换序列，即“S0→R1→S1→R2→S2→R3→S3→R4→S4→R5→S5”，则交易成功完成。总之，合约总是在进步，永远不会在任何状态下无限期地阻塞。因此，我们的协议实现了活力。</p>
<h2 id="VII-性能分析"><a href="#VII-性能分析" class="headerlink" title="VII 性能分析"></a>VII 性能分析</h2><p>为了评估我们方案的部署成本，我们在以太坊的官方测试网络 Ropsten [48] 上部署了我们的合约。 Gas 用于衡量智能合约代码中每一步的成本。表 IV 中概述了第 V-B 部分中描述的每个功能的 Gas 和财务成本。我们使用 1 以太币 &#x3D; 130 美元的兑换率和 0.000000003 以太币的gas价格（即 2020 年 4 月的实际成本）估算了以美元（美元）为单位的成本。中间人计算 PoW 难题的代码未包含在合约，因为用户可以在他们的本地机器上执行这部分并将结果发送到合约。</p>
<center>表IV：每个操作所花费Gas值</center>

<table>
<thead>
<tr>
<th>Transaction</th>
<th>Gas</th>
<th>USD</th>
</tr>
</thead>
<tbody><tr>
<td>IC.Deploy</td>
<td>3,690,283</td>
<td>1.43</td>
</tr>
<tr>
<td>IC.Register</td>
<td>181,591</td>
<td>0.07</td>
</tr>
<tr>
<td>IC.Update</td>
<td>80,995</td>
<td>0.03</td>
</tr>
<tr>
<td>CC.Verify_PoW</td>
<td>191,737</td>
<td>0.07</td>
</tr>
<tr>
<td>TC.Prepare</td>
<td>398,525</td>
<td>0.15</td>
</tr>
<tr>
<td>TC.Deposit</td>
<td>36,452</td>
<td>0.01</td>
</tr>
<tr>
<td>TC.Validation</td>
<td>163,780</td>
<td>0.06</td>
</tr>
</tbody></table>
<p>对于需要进行跨币种交易的用户，只需要用户调用<code>TC.Prepare</code>的功能即可。即使是多方情况，每个用户也只需要调用一次该函数，费用为 0.15 美元。对于中级用户，有 <code>IC.Register</code> 和 <code>IC.Update</code>功能提供自己的信息，分别只需 0.07 美元和 0.03 美元。在一笔交易中，为每个中介发行存款的操作平均成本为 0.01 美元。想要加入验证组的中介需要执行 <code>CC.Verify_PoW</code> 的验证操作，费用为 0.07 美元。验证的费用由验证组的每个成员承担。根据我们合约的调用开销，用户可以选择是否在可接受的范围内使用我们的服务</p>
<h3 id="A-时序分析"><a href="#A-时序分析" class="headerlink" title="A. 时序分析"></a>A. 时序分析</h3><p>我们还测量了合约的运行时间。所有测量均在运行 Windows 10、配备 6 核、3.0 GHz Intel Core i5 和 8 GB DDR4 RAM 的台式机上进行。在本节中，我们将展示我们方案的运行时结果，这表明我们的合约可以在可接受的时间开销内实现预期的功能。</p>
<p>我们方案的实现分为两部分：链下部分和链上部分。用户加入验证组执行的 PoW 拼图计算在用户本地机器上进行链下。智能合约只需要通过IC.Verify_PoW函数接收和验证PoW谜题的解法，并根据解题时间调整PoW的难度值。这样，解决PoW问题的时间间隔可以保持在十分钟左右。对于链上部分，我们只考虑方案中智能合约的运行时间。该方案涉及其区块链上其他类型加密货币的确认时间，我们不考虑。</p>
<p>由于gas和区块大小的限制，我们在一轮协议过程中将参与交易的付款人和收款人的数量设置为少于10个。当我们改变参与交易的用户数量时，主要影响合约准备阶段的执行时间。我们记录了通过 TC.Prepare 函数独立调用合约的用户的最大执行时间，结果如图 4 所示。我们可以看到，我们的合约运行时间随着收款人数量的增加而增加。这是因为对于单个付款人，合约需要记录和处理用户的每个收款人的信息。因此，所有收款人的数量越多，发送到合约的信息就越多，从而导致合约的整体运行时间更长。也可以看出，由于每个支付者都是不同的节点，他们的操作是并行的。增加付款人的数量不会显着增加合约运行时间。因此，合约的准备时间仅受每个付款人的交易用户数量影响。在收集到十个用户的请求或超过此等待时间后，合约将进行下一步。</p>
<img src="/post/enabling-x-chain-txs/image-20211014014941680.png" class="" title="image-20211014014941680">

<center>图4：当收款人数量增加时，在准备阶段花费的时间</center>

<p>我们还改变了验证委员会的用户数量和一对用户之间的交易数量，以分析合约在验证过程中的表现。当我们改变验证委员会的参与者数量时，合约通过 <code>TC.Validation</code> 函数执行这一步所需的时间如图 5 所示。第一个验证是针对付款人与中介 C1 之间的交易，而第二个验证用于中介 C2 和收款人之间的交易。我们可以看到，当验证委员会成员数量增加时，验证过程所需的时间也会显着增加。尽管如此，即使验证委员会有 100 名成员，每个验证过程也只需要大约 1 秒钟。与确认比特币等公共区块链加密货币交易所需的时间相比，这个时间可以忽略不计。我们也可以从图 6 中看出，随着付款人和单个收款人之间的交易数量增加，不会增加通过合约进行交易验证的时间成本。这是因为同一对用户之间的所有交易都会通过合约合并为一笔交易，从而不会增加时间成本。</p>
<img src="/post/enabling-x-chain-txs/image-20211014015119229.png" class="" title="image-20211014015119229">

<center>图5：当验证委员会规模增加时，在验证阶段花费的时间</center>

<img src="/post/enabling-x-chain-txs/image-20211014015625525.png" class="" title="image-20211014015625525">

<center>图5：当一对用户之间的交易数量发生变化时，验证阶段花费的时间。</center>

<p>当我们增加参与交易的用户数量时，每个额外用户的每笔额外交易都会增加合约的运行成本。为了实验的方便，我们同时添加了一对payer和payee。图 7 和图 8 分别显示了两个交易所需的验证时间。两个图中的两个彩色列代表两种不同的情况。第一种情况是每个付款人都与一个收款人进行交易，其中交易的数量等于参与者的数量。而第二种情况是每个付款人与每个收款人进行交易，其中交易数量是参与者数量的两倍。但是，在允许误差范围内，我们可以从图中得出结论，两种情况下的时间成本是相同的。这意味着我们方案的验证时间仅受参与交易的用户数量影响，而与每个用户的交易数量无关。这是因为在我们的合约中，每个参与用户所涉及的交易都是合并的，这也是我们的解决方案在大量交易的情况下保持高吞吐量的前提。</p>
<img src="/post/enabling-x-chain-txs/image-20211014015956848.png" class="" title="image-20211014015956848">

<center>图7：第一次加密货币交易的验证过程所花费的时间</center>

<img src="/post/enabling-x-chain-txs/image-20211014020044430.png" class="" title="image-20211014020044430">

<center>图8：第二次加密货币交易的验证过程所花费的时间。</center>

<p>我们还测量了在不同时间调用合约主要功能所需的验证时间。如图 9 所示，虽然测试链上的验证时间只能作为参考，但可以看出合约执行时间与交易确认时间相比可以忽略不计。因此，我们的解决方案所需的机器上的执行时间是可以接受的。在未来的工作中，我们还将把我们的合约部署在以太坊主链上，以便在实际网络下进行测试。</p>
<img src="/post/enabling-x-chain-txs/image-20211014021043744.png" class="" title="image-20211014021043744">

<center>图9：协议主要步骤中交易验证的时间成本（a. 工作证明机制；b. 预备阶段；c. 第一次加密货币交易验证过程；d. 第二次加密货币交易验证过程）</center>

<h2 id="VIII-结论"><a href="#VIII-结论" class="headerlink" title="VIII  结论"></a>VIII  结论</h2><p>在本文中，我们提出了一种基于智能合约的多用户交易的去中心化跨加密货币交换方案。 在我们的方案中，我们使用以太作为连接不同类型加密货币之间的交易的传输方式。 我们还实现了合约并评估了它在本地机器上的执行开销。 结果表明，我们方案的时间成本仅受参与交易的用户总数的影响，而用户交易的数量对我们合约的运行时间没有显着影响。 </p>
<p>未来，我们将从两个方面从实验部分进一步完善我们的方案。<br>首先，我们会争取更多的参与者来完成该计划的实施。 其次，我们将在以太坊主网上部署我们的方案，以测试我们的方案在实际网络中的成本</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>The authors sincerely thank the Editor, Dr. Debdeep Mukhopadhyay, and the anonymous referees<br>for their valuable suggestions that have led to the present improved version of the original manuscript.</p>
<p>[1] S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. 2008.<br>Accessed: Apr. 2021. [Online]. Available: <a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">https://bitcoin.org/bitcoin.pdf</a></p>
<p>[2] C. Lee. (2011). Litecoin. Accessed: Apr. 2021. [Online]. Available:<br><a href="https://litecoin.org/" target="_blank" rel="noopener">https://litecoin.org/</a></p>
<p>[3] G. Wood. (2017). Ethereum: A Secure Decentralised Generalised Trans-<br>action Ledger EIP-150 REVISION (759dccd-2017-08-07), Ethereum<br>Project Yellow Paper. Accessed: Apr. 2021. [Online]. Available:<br><a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="noopener">https://ethereum.github.io/yellowpaper/paper.pdf</a></p>
<p>[4] P2PB2B. Accessed: Apr. 2021. [Online]. Available: <a href="https://p2pb2b.io/" target="_blank" rel="noopener">https://p2pb2b.io</a></p>
<p>[5] MXC. Accessed: Apr. 2021. [Online]. Available: <a href="https://mxc-exchange/" target="_blank" rel="noopener">https://mxc-exchange</a>.<br>zendesk.com&#x2F;hc&#x2F;zh-cn</p>
<p>[6] BKEX. Accessed: Apr. 2021. [Online]. Available: <a href="https://www.bkex.co/" target="_blank" rel="noopener">https://www.bkex.co</a></p>
<p>[7] Bilaxy. Accessed: Apr. 2021. [Online]. Available: <a href="https://bilaxy.com/" target="_blank" rel="noopener">https://bilaxy.com</a></p>
<p>[8] LBank. Accessed: Apr. 2021. [Online]. Available: <a href="https://www.lbank/" target="_blank" rel="noopener">https://www.lbank</a>.<br>info</p>
<p>[9] C. Y. Kim and K. Lee, “Risk management to cryptocurrency<br>exchange and investors guidelines to prevent potential threats,” in<br>Proc. Int. Conf. Platform Technol. Service (PlatCon), Jan. 2018,<br>pp. 1–6.</p>
<p>[10] R. Khalil, A. Gervais, and G. Felley. (2019). TEX-A Securely Scalable<br>Trustless Exchange, Cryptology ePrint Archive. [Online]. Available:<br><a href="https://eprint.iacr.org/2019/265" target="_blank" rel="noopener">https://eprint.iacr.org/2019/265</a></p>
<p>[11] E. Heilman, S. Lipmann, and S. Goldberg, “The Arwen trading proto-<br>cols,” in Proc. Int. Conf. Financial Cryptogr. Data Secur. (FC). Berlin,<br>Germany: Springer, 2020, pp. 156–173.</p>
<p>[12] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making smart<br>contracts smarter,” in Proc. ACM SIGSAC Conf. Comput. Commun.<br>Secur. (CCS), 2016, pp. 254–269.</p>
<p>[13] V. Buterin. (2014). A Next-Generation Smart Contract and Decentralized<br>Application Platform. Accessed: Apr. 2021. [Online]. Available: https:&#x2F;&#x2F;<br>cryptorating.eu&#x2F;whitepapers&#x2F;Ethereum&#x2F;Ethereum_white_paper.pdf</p>
<p>[14] Metronome. Accessed: Apr. 2021. [Online]. Available: <a href="https://www/" target="_blank" rel="noopener">https://www</a>.<br>metronome.io</p>
<p>[15] Y. V. L. Luu. (2018). Kybernetwork: A Trustless Decentralized Exchange<br>and Payment Service. Accessed: Apr. 2021. [Online]. Available:<br><a href="https://whitepaper.io/document/43/kyber-network-whitepaper" target="_blank" rel="noopener">https://whitepaper.io/document/43/kyber-network-whitepaper</a></p>
<p>[16] J. Chow. BTC Relay. Accessed: Apr. 2021. [Online]. Available: https:&#x2F;&#x2F;<br>github.com&#x2F;ethereum&#x2F;btcrelay</p>
<p>[17] F. Vogelsteller and V. Buterin. (2015). EIP 20: ERC-20 Token Stan-<br>dard. Accessed: Apr. 2021. [Online]. Available: <a href="https://eips.ethereum/" target="_blank" rel="noopener">https://eips.ethereum</a>.<br>org&#x2F;EIPS&#x2F;eip-20</p>
<p>[18] W. Warren and A. Bandeali. (2017). 0x: An Open Protocol for Decen-<br>tralized Exchange on the Ethereum Blockchain. Accessed: Apr. 2021.<br>[Online]. Available: <a href="https://github.com/0xProject/whitepaper" target="_blank" rel="noopener">https://github.com/0xProject/whitepaper</a></p>
<p>[19] EtherDelta. Accessed: Apr. 2021. [Online]. Available: <a href="https://etherdelta/" target="_blank" rel="noopener">https://etherdelta</a>.<br>com</p>
<p>[20] IDEX. Accessed: Apr. 2021. [Online]. Available: <a href="https://idex.market/" target="_blank" rel="noopener">https://idex.market</a></p>
<p>[21] (2019). TBTC: A Decentralized Redeemable BTC-Backed ERC-20<br>Token. Accessed: Apr. 2021. [Online]. Available: <a href="https://docs.keep/" target="_blank" rel="noopener">https://docs.keep</a>.<br>network&#x2F;tbtc&#x2F;index.pdf<br>[22] T. Zhang and L. Wang. (2017). Republic Protocol. Accessed: Apr. 2021.<br>[Online]. Available: <a href="https://republicprotocol.github.io/whitepaper/" target="_blank" rel="noopener">https://republicprotocol.github.io/whitepaper/</a><br>republic-whitepaper.pdf</p>
<p>[23] J. Teutsch, M. Straka, and D. Boneh, “Retrofitting a two-way peg<br>between blockchains,” 2019, arXiv:1908.03999. [Online]. Available:<br><a href="http://arxiv.org/abs/1908.03999" target="_blank" rel="noopener">http://arxiv.org/abs/1908.03999</a></p>
<p>[24] J. Kwon and E. Buchman. (2016). Cosmos: A Network of Distrib-<br>uted Ledgers. Accessed: Apr. 2021. [Online]. Available: <a href="https://cosmos/" target="_blank" rel="noopener">https://cosmos</a>.<br>network&#x2F;whitepaper</p>
<p>[25] G. Wood. (2016). Polkadot: Vision for a Heterogeneous Multi-<br>Chain Framework. Accessed: Apr. 2021. [Online]. Available: https:&#x2F;&#x2F;<br>github.com&#x2F;w3f&#x2F;polkadot-white-paper&#x2F;raw&#x2F;master&#x2F;PolkaDotPaper.pdf</p>
<p>[26] J. Kwon. (2014). Tendermint: Consensus Without Mining, Draft<br>V.0.6. Accessed: Apr. 2021. [Online]. Available: <a href="https://tendermint/" target="_blank" rel="noopener">https://tendermint</a>.<br>com&#x2F;docs&#x2F;tendermint.pdf</p>
<p>[27] A. Zamyatin, D. Harz, J. Lind, P. Panayiotou, A. Gervais, and<br>W. Knottenbelt, “XCLAIM: Trustless, interoperable, cryptocurrency-<br>backed assets,” in Proc. IEEE Symp. Secur. Privacy (S&amp;P), May 2019,<br>pp. 193–210.</p>
<p>[28] I. Bentov, Y. Ji, F. Zhang, L. Breidenbach, P. Daian, and A. Juels,<br>“Tesseract: Real-time cryptocurrency exchange using trusted hardware,”<br>in Proc. ACM SIGSAC Conf. Comput. Commun. Secur. (CCS), 2019,<br>pp. 1521–1538.</p>
<p>[29] S. Matetic, M. Ahmed, K. Kostiainen, A. Dhar, D. Sommer, and<br>A. Gervais, “ROTE: Rollback protection for trusted execution,” in Proc.<br>26th USENIX Secur. Symp. (USENIX Security), 2017, pp. 1289–1306.</p>
<p>[30] N. Weichbrodt, A. Kurmus, P. Pietzuch, and R. Kapitza, “AsyncShock:<br>Exploiting synchronisation bugs in intel SGX enclaves,” in Proc. Eur.<br>Symp. Res. Comput. Secur. (ESORICS). Berlin, Germany: Springer,<br>2016, pp. 440–457.</p>
<p>[31] M. Herlihy, “Atomic cross-chain swaps,” in Proc. ACM Symp. Princ.<br>Distrib. Comput. (PODC), 2018, pp. 245–254.</p>
<p>[32] M. Herlihy, B. Liskov, and L. Shrira, “Cross-chain deals and adversarial<br>commerce,” Proc. VLDB Endowment, vol. 13, no. 2, pp. 100–113, 2019.</p>
<p>[33] G. Malavolta, P. Moreno-Sanchez, C. Schneidewind, A. Kate, and<br>M. Maffei, “Anonymous multi-hop locks for blockchain scalability<br>and interoperability,” in Proc. Annu. Netw. Distrib. Syst. Secur. Symp.<br>(NDSS), 2019, pp. 1–15.</p>
<p>[34] E. Tairi, P. Moreno-Sanchez, and M. Maffei (2019). A2L: Anony-<br>mous Atomic Locks for Scalability and Interoperability in Pay-<br>ment Channel Hubs, Cryptology ePrint Archive. [Online]. Available:<br><a href="https://eprint.iacr.org/2019/589.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2019/589.pdf</a></p>
<p>[35] P. Moreno-Sanchez, A. Blue, D. V. Le, S. Noether, B. Goodell, and<br>A. Kate, “DLSAG: Non-interactive refund transactions for interoperable<br>payment channels in Monero,” in Proc. Int. Conf. Financial Cryptogr.<br>Data Secur. (FC), 2019, pp. 325–345.</p>
<p>[36] C. Egger, P. Moreno-Sanchez, and M. Maffei, “Atomic multi-channel<br>updates with constant collateral in Bitcoin-compatible payment-channel<br>networks,” in Proc. ACM SIGSAC Conf. Comput. Commun. Secur.<br>(CCS), 2019, pp. 801–815.</p>
<p>[37] S. King and S. Nadal. (2012). PPCoin: Peer-to-Peer Crypto-<br>Currency With Proof-of-Stake. Accessed: Apr. 2021. [Online]. Available:<br><a href="https://peercoin.net/assets/paper/peercoin-paper.pdf" target="_blank" rel="noopener">https://peercoin.net/assets/paper/peercoin-paper.pdf</a><br>[38] (2018). EOS.IO Technical White Paper V2. Accessed: Apr. 2021.<br>[Online]. Available: <a href="https://github.com/EOSIO/Documentation/blob/" target="_blank" rel="noopener">https://github.com/EOSIO/Documentation/blob/</a><br>master&#x2F;TechnicalWhitePaper.md</p>
<p>[39] Y. Sompolinsky and A. Zohar, “Secure high-rate transaction processing<br>in Bitcoin,” in Proc. Int. Conf. Financial Cryptogr. Data Secur. (FC).<br>Springer, 2015, pp. 507–527.</p>
<p>[40] M. Castro and B. Liskov, “Practical byzantine fault tolerance,” in Proc.<br>3rd Symp. Operating Syst. Design Implement. (OSDI), 1999, vol. 99,<br>no. 1999, pp. 173–186.</p>
<p>[41] M. Castro and B. Liskov, “Practical Byzantine fault tolerance and proac-<br>tive recovery,” ACM Trans. Comput. Syst., vol. 20, no. 4, pp. 398–461,<br>2002.</p>
<p>[42] D. Ongaro and J. K. Ousterhout, “In search of an understandable<br>consensus algorithm,” in Proc. USENIX Annu. Tech. Conf. (ATC), 2014,<br>pp. 305–319.</p>
<p>[43] A. Zamyatin et al. (2019). SoK: Communication Across Distrib-<br>uted Ledgers, IACR Cryptology ePrint Archive. [Online]. Available:<br><a href="https://eprint.iacr.org/2019/1128.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2019/1128.pdf</a></p>
<p>[44] I. Eyal and E. G. Sirer, “Majority is not enough: Bitcoin mining is<br>vulnerable,” in Proc. Int. Conf. Financial Cryptogr. Data Secur. (FC).<br>Berlin, Germany: Springer, 2014, pp. 436–454.</p>
<p>[45] E. K. Kogias, P. Jovanovic, N. Gailly, I. Khoffi, L. Gasser, and B. Ford,<br>“Enhancing Bitcoin security and performance with strong consistency</p>
<p>via collective signing,” in Proc. 25th USENIX Secur. Symp. (USENIX<br>Security), 2016, pp. 279–296.<br>[46] G. O. Karame, E. Androulaki, and S. Capkun, “Double-spending fast<br>payments in Bitcoin,” in Proc. ACM Conf. Comput. Commun. Secur.<br>(CCS), 2012, pp. 906–917.<br>[47] J. R. Douceur, “The Sybil attack,” in Proc. 1st Int. Workshop Peer-to-<br>Peer Syst. (IPTPS). Berlin, Germany: Springer, 2002, pp. 251–260.</p>
<p>[48] The Ethereum Block Explorer: ROPSTEN (Revival) TESTNET.<br>Accessed: Apr. 2021. [Online]. Available: <a href="https://ropsten.etherscan.io/" target="_blank" rel="noopener">https://ropsten.etherscan.io</a></p>
]]></content>
      <tags>
        <tag>cross-chain</tag>
        <tag>exchange</tag>
        <tag>cryptocurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>基于区块链的环境监测系统 Environmental Monitoring System based on Blockchain</title>
    <url>/post/environmental_monitoring_system_based_on_blockchain/</url>
    <content><![CDATA[<p>FIT5125 Ass4 里要求的做成视频表述</p>
<p>原文：</p>
<p>Yan, J., Zhang, F, Ma, F., Xinxin, A., Li, Y., &amp; Huang,Y., (2019). Environmental Monitoring System Based on Blockchain. In Proceedings of the 4th International Conference on Crowd Science and Engineering (ICCSE’19). Association for Computing Machinery,. <a href="https://doi.org/10.1145/3371238.3371245" target="_blank" rel="noopener">https://doi.org/10.1145/3371238.3371245</a></p>
<p>翻译内容非全文。</p>
<p>随着信息技术、生物技术、遥感技术等技术的应用，环境保护领域的研究取得了重大突破。 但是现有的环保体系还存在环境数据的硬件造假和软件造假等问题。<br>本文提出了一种基于区块链的环境监测系统，其中全网环境数据统一，数据处理、共识和发布需要多方认证。 因此，通过采用本文所建议的系统，可以防止环境数据的伪造。<br>此外，提出了三维环境监控架构和智能可信设备，可以保证设备采集的环境数据的完整性和原始性。</p>
<span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>环境监测是环境保护的前提，环境监测是生态文明建设的重要环节。基于环境监测数据，不仅可以客观评价环境质量，还可以反映治理的有效性。此外，环境管理和决策也应以环境监测数据为基础。但是，污染企业数据造假、政府环境监测设备干扰、各部门环境数据不一致等行为屡禁不止。上述情况严重降低了环境监测数据的质量，进而影响环境管理水平。<br>由于环境监测涉及方多，监测设备数量多且分散，测试环境复杂，环境监测数据质量很难提高。因此，有必要采用一个全面，多方向，系统的环境监测系统。<br>本文提出了一种基于区块链的环境监测系统。区块链的特点非常符合提高环境监测数据质量的需求。</p>
<h3 id="此前研究"><a href="#此前研究" class="headerlink" title="此前研究"></a>此前研究</h3><p>随着城市化和能源消耗的快速发展，环境污染日益严重。与此同时，越来越多的机构和个人开始关注环境保护。<br>关于空气污染的研究如下。研究表明，许多疾病与<strong>空气污染</strong>密切相关[1, 2]。 CO 和 SO2 是中国大多数城市的两种重要污染物，但城市之间的差异很大[3]。空气质量及其影响因素具有明显的空间异质性[4]。许多研究都着眼于通过开发许多新的空气污染指数和测试来提高 AQI [5, 6]。对于<strong>水污染</strong>，分析了主要的水污染物及其对人体健康的影响[7]。综述了处理药物残留的电化学方法[8]。<br>在环境监测领域，有<strong>新的设备、试剂[9]和型号的研究</strong>。在遥感方面，高分系列卫星不仅用于检测局部污染，还用于监测水、大气和生态环境[10]。<br>对于环境数据收集，环境监测数据涉及复杂的多维权衡[11]，它需要跨学科和系统的方法、新的数据源和利益相关者的伙伴关系[12]。</p>
<h3 id="传统数据采集方法缺陷"><a href="#传统数据采集方法缺陷" class="headerlink" title="传统数据采集方法缺陷"></a>传统数据采集方法缺陷</h3><p>如<strong>图1</strong>所示，传统的环保数据采集方式为部门采集、第三方采集和部门间数据共享。 部门采集包括车辆排放监测、企业排放监测、其他渠道的数据采集等，采集的数据大部分将采集到监测平台的数据中心。 而传统的监测数据采集方法存在诸多缺陷。</p>
<ul>
<li>数据收集和管理的方式大不相同。</li>
<li>目前，没有标准化的质量保证和质量控制手段。</li>
<li>报告低置信度数据的风险。</li>
</ul>
<p>有两个主要的自动数据收集通道。 一个是属于政府的监测站，另一个是公共和私人组成的传感器网络。</p>
<p>另外，监控数据本身也存在很多问题。 环境数据存在的问题分为三部分，如<strong>图3</strong>所示，即硬件欺诈、软件欺诈和公开透明。 一旦出现问题，从数据的采集、处理、传输、发布，都很难开展环保工作。</p>
<h3 id="假想平台架构"><a href="#假想平台架构" class="headerlink" title="假想平台架构"></a>假想平台架构</h3><p>提出的基于区块链的环保系统如<strong>图4</strong>所示。 在系统中，底部是环境数据采集设备，例如 空气和水品质的传感器。 然后，从数千台设备收集的原始数据直接汇集到大数据平台。 基于大数据平台，将完成三项任务。 <strong>一是要搭建一个区块链平台</strong>，搭建一个网络，搭建一个服务。 其次，原始数据的哈希值、即刻采样的原始数据、统计数据、修正后的<strong>环保数据</strong>应毫无保留地写入区块链。 <strong>三是智能监测分析</strong>，包括环保标准监测、装置参数监测、原始数据采集监测、修正数据监测等。</p>
<p>区块链在防止环境数据造假方面的价值可以列举如下。</p>
<ul>
<li>全网环境数据统一，杜绝数据造假。</li>
<li>直接记录原始数据，这减少了数据流链接并提高了数据的可靠性。</li>
<li>修改设备参数和监控数据需要达成共识，加强监管，增加软件造假难度。</li>
<li>数据处理、共识和发布需要多方认证，记录信息不可修改，权责清晰。 建立责任追溯制度，相关人员对原始监测数据和监测报告的真实性负责。</li>
<li>环境数据记录公开透明，增强了数据的可信度，也便于监督和实施。</li>
<li>为大数据分析提供可靠的数据记录，更好地支持设备运行状态分析，帮助识别恶意数据欺诈。</li>
</ul>
<p>环保传感器与区块链网络的交互机制如<strong>图5</strong>所示。作为一个轻节点，每个传感器应该具备以下四个功能。<br>首先，它可以存储公钥和私钥。<br>其次，应该有区块链客户端SDK。<br>第三，所有收集的原始数据都应签名和加密。<br>第四，每个传感器可以将采集到的原始数据存储一段时间。<br>签名和加密的数据将通过网络从传感器传输到整个节点。<br>然后，在整个节点内，将完成两个主要功能，将传感器数据发送到区块链和同步区块链网络内的所有数据。</p>
<h3 id="分布式与可信数据"><a href="#分布式与可信数据" class="headerlink" title="分布式与可信数据"></a>分布式与可信数据</h3><h4 id="3D-三维-环境监控系统"><a href="#3D-三维-环境监控系统" class="headerlink" title="3D (三维)环境监控系统"></a>3D (三维)环境监控系统</h4><p>三维环境监测系统由四个主要部分组成。<br>最外围是空间卫星，可以实现对大气、水、土壤和生态的动态监测。<br>第二部分是航空气象、污染物和辐射监测。 第三部分是针对人类活动的，包括工业、农业、交通、建筑的监测，可以实现跨行业的数据分析和验证。<br>底部为地面，通过分布在各处的物联网设备监测土壤、水和生态状况。</p>
<h4 id="智能可信设备"><a href="#智能可信设备" class="headerlink" title="智能可信设备"></a>智能可信设备</h4><p>如<strong>图3</strong>所示，监测数据存在问题。区块链虽然在某些情况下可以防止环境数据被篡改，但无法保证原始数据的真实性和有效性。<br>基于以上考虑，提出了一种环保机器人方案，主要由全息数据采集模块、通信模块、执行模块、存储模块、电源模块、智能可信设备组成。</p>
<p>智能环保监控机器人具有感知、视觉、听觉、分析、计算、学习、管理、控制等功能，多台智能环保监控机器人根据其能覆盖的范围部署在特定区域。<br>它们与环保平台互联互通，形成环保监控智慧网络，是环保监控物联网的升级版。</p>
<p>所提出的机器人的具体功能如下。</p>
<ul>
<li>能够以有线或无线方式连接环保平台。</li>
<li>机器人可以通过有线或无线方式相互连接。</li>
<li>机器人可自动采集特定区域的关键环境数据，如大气、水、土壤、噪声等参数。</li>
<li>通过摄像头实时监控特定的环保区域。</li>
<li>基于分析和学习控制联网的智能机械操作。</li>
<li>多台机器人协同分析诊断特定区域的环保状况。</li>
</ul>
<p>智能可信设备的详细功能见<strong>图8</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本文中，我们提出了一种基于区块链的环境监测系统，包括环境数据采集装置、大数据平台、区块链和智能监测。<br>采用区块链可以防止环境数据被篡改，其中全网环境数据统一，数据处理、共识和发布需要多方认证。<br>还提供了传感器与区块链网络之间的交互机制。<br>此外，提出了三维环境监测系统，由四个主要部分组成，保证了采集数据的完整性。<br>而对于智能可信设备，则可以保证数据的来源。</p>
<p>在这篇论文的基础上，还有很多进一步的研究可以做。<br>首先，应提供更多详细信息。 其次，建议的系统需要通过案例研究进行分析和验证。</p>
]]></content>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>使用现有基础架构进行服务器端WiFi室内定位的经验与挑战 Experiences &amp; Challenges with Server-Side WiFi Indoor Localization Using Existing Infrastructure</title>
    <url>/post/fit5046-a2-paper/</url>
    <content><![CDATA[<p>FIT5046 要求做PPT演讲的paper</p>
<p>Authors:</p>
<img src="/post/fit5046-a2-paper/image-20210412225148141.png" class="" title="image-20210412225148141">

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>在大型公共场所中，基于WiFi的室内定位的实际部署很少，而且相差甚远，因为大多数最新解决方案都需要客户端或基础架构方面的更改。因此，即使这些解决方案可以实现较高的定位精度，但由于成本和&#x2F;或客户采用原因，它们并不实用。大多数公共场所都使用商业控制器管理的WLAN解决方案，该解决方案既不允许客户更改，也不允许基础架构更改。实际上，对于这样的场所，我们已经观察到高度异构的设备，客户端应用的采用率非常低。</p>
<p>在本文中，我们介绍了在此类场所部署可扩展位置系统的经验。我们证明服务器端定位并非易事，并且提出了与此方法相关的两个独特挑战，即基数不匹配和高客户端扫描延迟。 “不匹配”挑战导致在离线阶段和在线阶段报告客户端的一组接入点（AP）之间严重不匹配，而“延迟”挑战导致报告任何特定客户端的AP报告数据的数量较少。我们从已经部署了四年以上的WiFi设置中收集了三周的详细地面真相数据（≈200个地标），以提供证据证明这些问题的严重程度并了解这些问题的影响。我们提出启发式方法来减轻它们。我们还总结了实际部署面临的挑战和陷阱，这些挑战和陷阱会影响定位的准确性。</p>
<span id="more"></span>

<h2 id="CCS概念"><a href="#CCS概念" class="headerlink" title="CCS概念"></a>CCS概念</h2><p>网络→网络测量； 基于位置的服务</p>
<p>以人为中心的计算→遍及移动计算的实证研究</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>基于WiFi的室内定位研究已有很长的历史[1-3、6、9、12、13、15、18-20、22、23、27-30、32、33、35， 36，39，42–47，49，50]。但是，尽管取得了一些突破，但在公共场所中几乎没有基于WiFi的室内定位系统的实际部署。造成这种情况的原因有很多，最常见的三个原因是：（a）部署成本高，（b）可以说是缺乏令人信服的业务使用，以及（c）现有解决方案无法无缝工作与所有设备。实际上，当前的解决方案在通用性，准确性和能量之间进行了折衷，例如，将基于惯性的跟踪与WiFi扫描相结合的基于客户端的解决方案可提供更高的准确性，但需要一种移动应用程序，这可能会更快地消耗能量并降低能耗。只有少数访问者可以下载[53]。</p>
<p>在本文中，我们介绍了在亚洲一所小型大学的整个校园中部署和运行基于WiFi的室内定位系统的经验。值得注意的是，大约有10,000名学生和1,500名教职员工密集地占据了环境。该系统已投入生产四年以上。它部署在多个场所，包括两所大学（新加坡管理大学，马萨诸塞大学，阿默斯特大学）和四个不同的公共场所（购物中心，会议中心，机场和圣淘沙度假胜地）[21，40]。这些场所使用定位系统进行各种实时分析，例如组检测，占用检测和队列检测，同时还要注意用户的隐私。</p>
<p>我们的目标是突出挑战并提出易于集成的解决方案，以构建通用的室内定位系统-该系统可以对园区中所有支持WiFi的设备进行定位，而无需进行客户端或基础设施方面的任何修改。这种实际环境的规模和性质带来了一系列独特的挑战–（a）基础架构，即控制器和AP不允许进行任何更改，（b）设备无法以任何方式进行修改，即，不明确&#x2F;隐式参与数据生成，不允许应用程序下载，也不允许芯片组更改，并且（c）仅可用数据是来自AP的RSSI测量，这些数据由控制器使用实时定位服务（RTLS）接口进行集中控制[8] 。值得注意的是，面对这些挑战，我们必须排除更复杂的最新方案，例如细粒度的CSI测量[28]，到达角[9]，时间间隔-Flight [29]，SignalSLAM [37]或Inertial Sensing [14]。</p>
<p>面对挑战，我们采用基于指纹的离线方法来计算每个设备的位置。事实证明，在人群密集的空间中，指纹比基于模型的方法更准确[26]，因此受到广泛青睐。我们的定位软件使用众所周知的“经典”基于指纹的技术来处理RSSI更新[36]。鉴于这种方法的广泛使用，我们的经验和结果适用于大多数定位算法。</p>
<p>我们的主要贡献是详细介绍这种常规方法成功与失败的情况。我们重点介绍了使该方法在当前的大规模WiFi网络中起作用的相关挑战，然后开发适当的解决方案来克服已观察到的挑战。我们在大规模部署中收集了三周的详细地面真相数据（约200个地标），精心构建了一组实验研究，以显示两个独特的挑战-基数不匹配和与服务器端定位方法相关的高客户端扫描延迟。这三周的数据代表了我们四年的数据。</p>
<p>（a）基数不匹配：我们将基数定义为针对位于特定地标的客户端的一组AP报告。我们首先表明，在线阶段的基数通常与离线阶段的基数有很大不同。注意，这种差异存在于报告AP的集合中，而不仅仅是RSSI向量值的不匹配。直观上，这颠覆了基于指纹的系统的前提，即在离线和在线阶段，在任何界标处看到的基数都是相同的。这种现象是由所有商业级WiFi网络（例如，Aruba，Cisco和其他供应商提供的网络）中的集中控制器执行的动态电源和客户端管理所产生的，以实现以下目的：</p>
<p>​    （i）使总体干扰降到最低（将相邻的AP移至备用信道），</p>
<p>​    （ii）提高吞吐量（将客户端移至备用AP），以及</p>
<p>​    （iii）降低能耗（在低负载期间关闭冗余AP）</p>
<p>（b）高客户端扫描延迟：大多数定位系统使用客户端定位技术，在这种情况下，客户端在需要位置修复时会主动扫描网络。但是，在使用服务器端定位时，定位系统无法诱导来自客户端设备的扫描。因此，当客户端扫描作为其正常行为的一部分时，系统只能“看到”客户端。但是，正如我们在第4节中所示，对于较低的RSSI，客户端的扫描频率较低。</p>
<p>这些现象在过去的试点研究中经常使用的小规模部署中不存在，在这些部署中，每个AP都是独立配置的。在大规模部署中，使用带有大量设备的控制器管理的WLAN相当普遍，这些现象在很大程度上不可避免地持续存在。为了举例说明，在我们的部署中，我们注意到2.4 GHz时有57.30％的基数不匹配，而5 GHz时有30.60％的基数不匹配。我们看到客户端扫描间隔的90％为20分钟。在此类环境中使用基于指纹的解决方案进行定位时，这些现象会导致最少或什至更糟的是没有匹配的AP，从而导致客户端位置更新和客户端“跨位置”传送之间的大量延迟。</p>
<p>重要的是要注意，这些算法的时间表不仅是不确定的，而且它们在离线和在线阶段的分发也是不确定的。这归因于以下基本事实：WiFi网络的动态（例如负载和干扰）在大多数情况下是不确定的，并且控制器算法对我们来说是一个黑匣子。此外，2.4和5 GHz信号传播和扫描行为的差异也导致了这些问题。我们相信，我们是第一个提出服务器端定位挑战及其缓解方法的人。我们的建议与设备无关，简单易用，可与任何大规模WiFi部署轻松集成，以高效地定位设备</p>
<h3 id="Key-Contributions"><a href="#Key-Contributions" class="headerlink" title="Key Contributions:"></a>Key Contributions:</h3><ul>
<li><strong>我们确定并描述了与服务器端定位框架相关的两个新颖的基本问题</strong>。特别是，我们为（i）“基数不匹配”和（ii）“高客户端扫描延迟” 问题提供了证据，解释了为什么这些问题在商业WiFi部署中变得越来越重要。我们讨论了在不允许客户端&#x2F;基础架构方面的挑战的情况下解决这些问题的重要性的原因。我们的整个分析都是针对–2.4和5 GHz两个频段。</li>
<li><strong>我们基于三个星期内收集的200个地标的地面真相数据进行了广泛的评估，从而提供了有关这些问题成因的宝贵见解</strong>。面对这些问题，我们提出启发式方法来提高定位的准确性。我们看到从最低的35.40％改善到最高的100％。与SignalSLAM [37]相比，我们在更高的百分位数上显示出改进。这表明我们的经验教训具有改进现有定位算法的潜力。</li>
<li>我们描述了我们在部署，管理和改进基于指纹的WiFi定位系统方面的经验，该系统自2013年以来一直在新加坡管理大学的整个校园中投入运营。我们不仅关注使用RTLS数据馈送的最终“最佳解决方案”，而且还讨论了多年来遇到的挑战和陷阱。</li>
</ul>
<p>论文组织：我们在第2节中讨论相关工作。在第3节中介绍系统体系结构和数据收集的详细信息。在第4节中介绍挑战，证据，并提出解决方案。在第4节中，我们讨论了定位客户的挑战 在实际部署中以及第5节中我们提出的解决方案的局限性。在第6节中总结。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>在本节中，我们将讨论现有解决方案及其在室内定位中的局限性。</p>
<p><strong>指纹与基于模型的解决方案</strong>：最古老的定位技术之一是使用基于指纹的[2、19、27、30、33、36、42、55]或基于模型的[1、10、16， 22]方法，或两者的组合[24]。总体而言，基于指纹的解决方案虽然具有较高的设置和维护成本，但其准确性往往比其他方法高[26]。基于指纹的方法是Radar [36]率先提出的，并激发了许多后续研究。例如，Horus [33]使用一种概率技术来构造统计无线电图，该图可以以厘米级的精度推断出位置。 PinLoc [42]将物理层信息合并到位置指纹中。刘等。 [27]通过采用基于p2p声音测距估计的同伴辅助方法提高了准确性。这方面研究的另一个思路是减少指纹识别工作量，例如，使用众包[2，6，52，55]和下采样[19]。数学信号传播模型方法[1，22]的优点是易于部署（不需要指纹），尽管在环境布局或人群动态变化时其准确性会受到影响[10]。诸如EZ之类的系统通过额外使用GPS来指导模型构建来提高准确性。</p>
<p><strong>基于客户端与基于基础架构的解决方案</strong>：关于基于客户端的室内位置解决方案的历史非常丰富，仅举几例，Sig-nalSLAM [37]，SurroundSense [30]，UnLoc [15]和其他[2、3、6、35、39、44]。它们全部共享一些共性，因为它们从客户端设备提取（各种类型的）传感器信号以进行定位。定位算法通常在设备本身上运行；但是，也可以在服务器上运行该算法，并使用来自多个客户端的信号来实现更好的性能[27]。总体而言，基于客户端的解决方案具有很高的准确性（在某些情况下为厘米分辨率[33，42]）。一种替代方法是直接从WiFi基础架构中获取信号测量结果，类似于我们的解决方案。由于它需要完全访问通常是专有的WLAN控制器的访问权限，因此研究界仅对此方法进行了轻率的探索。我们的主要竞争对手是商业WiFi提供商本身。特别是，思科[7]和阿鲁巴[4]都提供定位服务。这些解决方案将服务器端跟踪与基于模型的方法结合使用（以消除指纹设置开销）。</p>
<p><strong>其他解决方案</strong>：还有其他几种解决方案，它们是基于信号强度的技术的补充。基于时间的解决方案[12、29、32、43、45]使用信号的到达时间来估计客户端与AP之间的距离，而基于角度的解决方案[9、18、20、28， [图46]利用从天线阵列估计的到达角信息来定位移动用户。近来，已经提出了被动位置跟踪的概念[13、23、47、49、50]，其不假定人们携带设备。然而，在大型且拥挤的场所，这种被动跟踪的可行性和准确性仍是一个悬而未决的问题。其他系统，例如基于光的定位[25、34、38]和基于声音的定位[31、41、48、54]。<br>上述解决方案的局限性：这些解决方案可以实现更高的准确性，但是它们至少具有以下限制之一-（a）需要定制的硬件，而这种硬件无法在大规模部署中实现，（b）安装客户端应用程序，使其难以扩展，（c）根植客户端OS-An-droid或iOS，这限制了它们的通用性，（d）精通能量，（e）密集网络中的高错误率，以及（f）专有且昂贵部署（尤其是思科和Aruba等供应商的解决方案）。</p>
<p>总而言之，即使有几种出色的解决方案可用，但它们的可扩展性仍然是一个问题。 因此，我们提倡使用带有指纹的服务器端定位方法。 我们的目标不是比较不同方法的功效，而是使用当今的WiFi标准和硬件（例如，使用5 GHz频段和基于控制器的体系结构）来应对实际且广泛部署的与设备无关的室内定位的挑战。</p>
<h2 id="SYSTEM-ARCHITECTURE-amp-DATA-COLLECTION"><a href="#SYSTEM-ARCHITECTURE-amp-DATA-COLLECTION" class="headerlink" title="SYSTEM ARCHITECTURE &amp; DATA COLLECTION"></a>SYSTEM ARCHITECTURE &amp; DATA COLLECTION</h2><p>在本节中，我们介绍有关系统体系结构和数据集的详细信息。</p>
<h3 id="背景和部署"><a href="#背景和部署" class="headerlink" title="背景和部署"></a>背景和部署</h3><p>这项工作始于2013年，当时我们开始在整个园区内部署基于WiFi的定位解决方案。 从那以后，它经历了许多主要和次要的演变。 但是，在本文中，由于我们可以完全访问该场所，因此我们仅将评估和结果集中在一个场所上-一所大学。</p>
<p>我们的大学校园在不同的建筑物中有七所学校。 五栋建筑物有六层，其余两栋分别有五层和三层，建筑面积约为70，000 m2。 以喷水为特征的地标每三个米在指定的楼层上部署一次，以表示特定位置。 七所学校的38层中共有3203个地标。 WLAN部署包括750多个双频AP，由11个WiFi控制器集中控制，每天约有4000个关联的客户端。</p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>图1表示系统的主要构建块。系统由WLAN控制器配置的AP引导，每5秒向RTLS服务器发送一次RTLS数据提要。大多数商用WLAN基础结构都允许这种配置。配置完成后，AP绕过WLAN控制器，并将RTLS数据提要直接报告给我们的位置服务器。表1列出了每个客户端的RTLS数据供稿中包含的所有字段。报告的RSSI值不是基于每个帧，而是来自多个接收到的帧的汇总值。位置服务器分析这些RTLS数据馈送，以获取不同AP报告的信号强度，以估计客户端的位置。请注意，AP不会报告帧的类型。他们从当前的操作渠道收集信息，并扫描其他渠道以收集数据。供应商具有AP可以测量的微观细节[5]，但是作为最终用户，我们没有比指定的更多的信息访问权限。但是，即使是大规模的信息，也可以从单个角度对整个网络进行查看。</p>
<h3 id="指纹的记录"><a href="#指纹的记录" class="headerlink" title="指纹的记录"></a>指纹的记录</h3><p>我们将指纹定义为<strong>给定客户端的来自AP的RSSI向量</strong>。 我们考虑两种类型的指纹-脱机指纹和在线指纹。 在启动定位过程之前，会收集脱机指纹并将其存储在数据库中，而实时会收集联机指纹。</p>
<p>离线指纹识别在每个楼层为每个地标准备一个二维离线指纹图。 用于指纹识别的客户端设备是与网络关联的双频Android手机，它们会主动扫描AP。 对于每个地标，设备都会收集5分钟的数据。 当客户端扫描附近时，AP会为客户端整理RSSI报告，并将其测量结果作为RTLS数据提要发送到位置服务器。 对于给定的地标Li，离线指纹采用以下形式：</p>
<img src="/post/fit5046-a2-paper/image-20210414081339575.png" class="" title="image-20210414081339575">

<p>我们在2.4和5 GHz频段上都保留指纹。 在上述等式中，频段B取一个正在记录的频段的值。 向量存储在位置服务器上的数据库中。</p>
<p>在线指纹客户的定位是通过在线指纹完成的。 除地标外，联机指纹与公式1中的脱机指纹采用相同的语法，如下所示：</p>
<img src="/post/fit5046-a2-paper/image-20210414081350095.png" class="" title="image-20210414081350095">

<p>现在，我们将该在线指纹与每个地标的离线指纹进行匹配，以计算信号空间中的距离，如[36]中所述。 在信号空间中具有最小距离的地标被报告为客户端的可能位置。</p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>现在，我们介绍数据收集及其处理的详细信息。</p>
<h4 id="收集地面实况"><a href="#收集地面实况" class="headerlink" title="收集地面实况"></a>收集地面实况</h4><p>我们收集在线指纹的地面实况数据。我们希望将数据收集与实际使用场景相关联。因此，我们根据WiFi设备的WiFi关联状态和数据传输选择四种最常见的状态。状态为–（i）断开连接，（ii）关联的WiFi –（ii.a）从未被用户积极使用，（ii.b）间歇性使用，以及（ii.c）积极使用。这些状态隐式调制扫描频率。我们为每个州使用单独的电话；因此，我们使用4部三星Galaxy S7手机记录每个地标的地面真实情况。</p>
<p>状态（a）客户端已断开连接。在这种状态下，WiFi已打开但未与任何AP关联，并且在整个数据收集过程中，屏幕始终保持关闭状态。因此，只有从此客户端生成的流量才扫描流量，而没有数据流量。我们确保此客户端未遵循MAC地址随机化，大多数最新设备在未关联状态下遵循MAC地址随机化[17]。</p>
<p>状态（b）客户端已关联但未激活。在此状态下，WiFi已打开，它已关联，但在整个数据收集过程中，屏幕始终保持关闭状态。</p>
<p>状态（c）客户端已关联并间歇使用。在这种状态下，WiFi处于打开状态，客户端已关联，并且用户间歇性地使用设备。这是移动设备最常见的状态之一，以前的研究[11]指出，只要设备屏幕亮起，就会触发扫描。</p>
<p>状态（d）客户端已关联并正在积极使用。在这种状态下，WiFi处于打开状态，客户端已关联，并且YouTube视频将在整个数据收集过程中播放。此状态会产生大多数数据流量，即非扫描流量。每个客户在移至下一个地标之前在地标上停留约一分钟。我们以秒为单位手动记录了每个界标的开始时间和结束时间。我们对我们大学的3203个地标进行了此练习，收集了86个小时的数据，占54 096个文件的274 GB数据。定位客户端的时间为40秒。处理整个数据集大约需要100天。因此，考虑到整个数据集的大小，我们提出了对200个地标的分析，这些地标占3121个文件和15.3 GB数据。图2显示了其中一所学校的地板图，我们将其数据用于分析。</p>
<p>我们的目的是演示与基于指纹的定位相关的挑战。这些挑战适用于采用基于指纹定位的所有解决方案，而与网络中存在的设备类型无关。 RSSI随设备异质性的变化是众所周知的[51]，这将进一步加剧本文确定的问题。我们只用一台设备收集事实真相，这样我们就可以突出问题，而不会因异构设备而增加任何复杂性。</p>
<h4 id="RTLS数据馈送的预处理"><a href="#RTLS数据馈送的预处理" class="headerlink" title="RTLS数据馈送的预处理"></a>RTLS数据馈送的预处理</h4><p>我们的代码读取每个提要，以提取报告特定客户端的AP的详细信息。 RTLS数据馈送可以获取客户端的过时记录。因此，我们对原始RTLS数据馈送进行过滤，以获取年龄小于或等于15秒的最新值，并且RSSI应当大于或等于-72 dBm。年龄阈值是一种获取最新读数的试探法。 RSSI的阈值基于以下事实决定：当RSSI低于-72 dBm时，客户端会失去关联。</p>
<p>对于我们的分析，我们将MAC层帧分为两类：（a）扫描帧–高功率和低比特率探测请求；（b）非扫描帧–所有其他MAC层帧。离线指纹是从扫描帧中得出的，众所周知，扫描帧可以在以全功率传输时提供准确的距离估计。在离线阶段，客户端配置为连续扫描。但是，在联机阶段，我们无法控制客户端的扫描行为，从而导致扫描帧和非扫描帧混合在一起。因此，在使用指纹进行定位时，可用于匹配的RSSI来自不同类别的帧。 RTLS数据提要不报告帧的类型，也没有MAC层帧到提要的一对一映射。因此，我们设计了一种概率方法来识别这些框架。</p>
<p>我们通过一组受控实验进行设计，在该实验中，我们一次在两种设置之一中配置了客户端（a）仅发送扫描帧，并且（b）仅发送非扫描帧。这两个设置是互斥的。我们使用嗅探器从客户端收集了流量，并收集了相应的RTLS数据供稿。然后，我们比较两个日志（嗅探器和RTLS），以确认帧类型和相应的数据速率。<br>我们的分析表明，当客户端被关联并发送非扫描帧时，与其关联的AP将客户端报告为已关联。 RTLS数据馈送的数据速率在各种802.11д速率之间有所不同，例如1、2、5.5，…，54 Mbps。尽管我们的网络部署是双频的，并且支持包括802.11ac在内的最新802.11标准，但RTLS数据馈送中报告的速率仍然遵循802.11g。我们无法通过控制器的算法来推断报告数据速率中这种不匹配的原因。但是，当客户端发送扫描帧时，所有可以看到该客户端的AP都将客户端报告为未关联，并且根据配置的探测响应速率，报告的数据速率固定为1、6或24 Mbps。</p>
<p>我们使用这些事实来区分非扫描和扫描RTLS数据供稿。我们认为此方法可正确推断扫描帧，因为（a）数据速率固定为1、6或24 Mbps，（b）当关联的客户端进行扫描时，其他AP报告该客户端为未关联的客户端，以及（c）未关联的客户端只能发送扫描帧或关联帧。但是，在以下情况下，我们的方法可能仍会错误地将扫描帧识别为未扫描–（a）当关联的客户端进行扫描并且与其关联的AP进行报告时。该AP报告客户端已关联，其数据速率为1、6或24 Mbps。在这种情况下，这些速率也可能是由于非扫描帧所致。我们将此类供稿标识为非扫描。 （b）当未关联的客户端发送关联或认证帧时。同样在这种情况下，速率与扫描数据速率重叠，并且关联状态报告为未关联。在这里，我们错误地将非扫描帧识别为扫描帧。但是，这些情况很少见。对于其他情况，我们的方法在确定性上是正确的。</p>
<h2 id="发现挑战"><a href="#发现挑战" class="headerlink" title="发现挑战"></a>发现挑战</h2><p>在本节中，我们提供有关问题的证据，即<strong>基数不匹配</strong>和<strong>高客户端扫描延迟</strong>。我们比较了两个频段这些问题的严重性。我们确定了这些问题背后的原因，并衡量了它们对这些问题的影响。</p>
<h3 id="4-1问题的证据"><a href="#4-1问题的证据" class="headerlink" title="4.1问题的证据"></a>4.1问题的证据</h3><p>基数不匹配是由中央控制器执行的动态电源和客户端管理以及客户端电源管理引起的。考虑到这些管理策略的动态性质，不可能估计它们对基数不匹配的影响，从而对定位错误也没有影响。我们采用一种经验方法来观察（a）是否可以找出这些对基数不匹配和定位误差的影响的严重性，以及（b）确定相关因素的可调性。</p>
<p><strong>图3</strong>绘制了2.4 GHz和5 GHz离线阶段和在线阶段之间基数的差异。图3a显示了在我们的离线指纹中观察到的基数。图3b显示了在线阶段观察到的基数。在离线阶段，最大基数为16，而在在线阶段，最大基数仅为6。这显示了基数不匹配的范围。在在线阶段，80％的时间中只有1个AP报告5 GHz的客户端，而40％的时间是2.4 GHz。基数如此大的差异会对任何基于指纹的算法产生不利影响。对于每个频段，我们找出基数不匹配的程度。总体而言，在所有基数上，2.4 GHz的失配率为57.30％，5 GHz的失配率为30.6％。 5 GHz频带受到基数不匹配问题的不利影响更大，因为它的基数较低，从而增加了失配的机会。总体而言，在离线阶段和在线阶段，2.4 GHz的基数总是比5 GHz高。这是因为2.4 GHz的信号比5 GHz的信号传播得更远。但是，这不是唯一的原因。另一个原因是发送的扫描帧数。与数据帧不同，扫描帧是广播的，因此可以被更多数量的AP听到。随着扫描帧数量的增加，更多的AP会听到它们并还原，从而增加了基数。</p>
<p>此外，与数据帧相比，扫描帧的RSSI变化较小。为了验证这一点，我们对固定的客户端执行了受控实验，并使用嗅探器收集了客户端的流量。客户端正在进行数据传输，并且每15秒触发一次定期扫描。从嗅探到的数据包捕获中，我们提取每帧RSSI。针对两种情况重复进行该实验-（a）客户端靠近AP，并且（b）客户端远离AP。在这两种情况下，我们模拟来自AP的低RSSI和高RSSI的客户端行为。</p>
<p><strong>图4</strong>显示了两种情况下的RSSI测量。在第一种情况下，当客户端靠近AP时，扫描帧的RSSI变化最多10 dB，对于非扫描帧，其RSSI变化最多50 dB。类似地，在第二种情况下，当客户端距离AP较远时，扫描帧的RSSI变化最多5 dB，而对于非扫描帧，其RSSI变化最多30 dB。我们的两个实验都验证了来自扫描帧的RSSI的变化远小于非扫描帧的变化。这意味着来自扫描框架的在线RSSI匹配更加紧密，并且可以更可靠地指示客户的位置。我们想研究采用默认配置的客户端在真实网络中的行为。因此，我们不会以任何方式修改客户端驱动程序的默认行为。我们使用三星，Nexus，小米和iPhone的设备重复了该实验。</p>
<p>接下来，我们研究频带对扫描频率的影响。我们收集嗅探器在两个频段上当时正在运行的频道上侦听6小时的WiFi流量。记录了200个WiFi客户端的数据。图5显示了该图。对于2.4 GHz和5 GHz频带，频率都随着RSSI的降低而增加。总体而言，即使我们网络中的大多数客户端（5 x 2 GHz）与5 GHz相关联，该频率在5 GHz时也较低。扫描频率越高，基数不匹配的机会就越小。我们对这两个频段的比较分析显示，由于干扰较低，导致扫描的帧丢失和连接质量较差的情况在5 GHz时要低得多。对我们客户的扫描行为的分析表明–（a）扫描间隔的第90％ile值约为1000秒，这对于基于指纹的解决方案来说是很多，（b）5 GHz是最不受欢迎的频段（c）客户端很少扫描两个频段。因此，我们排除了5 GHz范围缩小导致扫描帧减少的可能性。</p>
<h3 id="问题背后的原因"><a href="#问题背后的原因" class="headerlink" title="问题背后的原因"></a>问题背后的原因</h3><p>接下来，我们研究扫描频率（即每小时扫描次数）和传输距离对心率的综合影响。为此，我们将考虑在<strong>3.4.1节</strong>中讨论的四种状态之一中配置的客户端。请注意，每个状态都隐式控制扫描量。我们不会手动控制扫描行为来模仿现实世界。在没有客户端扫描的情况下，AP仅获得非扫描帧。对于客户的四个状态中的每个状态，我们研究有多少个AP报告该客户，即汽车通行费。通过此分析，我们能够针对2.4 GHz和5 GHz频段比较存在扫描和不存在扫描的基数。我们看到，随着扫描频率的增加，更多的AP响应并且基数增加。由于篇幅所限，我们不会显示客户各个州的结果。<strong>图6</strong>显示了汇总结果。 2.4 GHz的基数始终高于5 GHz。这意味着较高的扫描频率可能会减少基数不匹配，反之亦然。</p>
<p>但是，2.4 GHz的缺点是帧（扫描和非扫描）的RSSI差异较大。这意味着，即使基数不匹配的程度较低，RSSI在2.4 GHz上的差异也更大。为了确认这一点，我们通过一次在一个频带中启用它的关联并完全禁用另一频带来分析固定客户端的RSSI。我们使用在RTLS服务器上记录的RSSI持续1小时。如<strong>图7</strong>所示，即使有更多可用的扫描信息，与5 GHz相比，2.4 GHz更容易出现RSSI波动。出现这种现象的原因是：（a）2.4 GHz的范围几乎是5 GHz范围的两倍，并且（b）较少数量的非重叠信道使其容易受到干扰。因此，来自2.4 GHz的RSSI可以预测远距离和瞬态位置。我们使用其他四个型号的设备在不同的位置验证了这一点。</p>
<p>总而言之，存在很大程度的基数不匹配和高客户端扫描延迟。对于两种类型的帧和两种操作范围，问题的程度有所不同。尽管扫描帧具有更长的传输距离，并且RSSI的变化较小，但客户端并不经常发送它们。支持2.4 GHz的因素是更长的传输距离和更高的扫描频率。但是，RSSI的低变化有利于5 GHz。我们在表2中总结了这些观察结果。</p>
<h3 id="原因对定位错误的影响"><a href="#原因对定位错误的影响" class="headerlink" title="原因对定位错误的影响"></a>原因对定位错误的影响</h3><p>现在，我们评估原因对定位错误的影响。我们使用众所周知的基于指纹的方法在服务器端实现了定位[36]。由于我们使用服务器端处理，因此不需要任何客户端修改。我们的建议不对客户端或控制器的硬件或操作系统进行假设。尽管现有工作中基于指纹的技术的每种改编都可能导致不同的错误，但是我们的练习为我们提供了跨越所有改编的基线。 2.4和5 GHz频段的传输距离，RSSI的变化和扫描频率都不同。我们测量两个频段的定位误差。</p>
<p>我们在在线阶段报告基数每个值的定位错误，以了解该错误如何随基数变化。我们根据（a）不同楼层和（b）同一楼层错误来衡量错误。不同下限错误是估计错误下限的总记录的百分比。这些出现在较高的百分位数处。对于其余记录，“同一楼层”误差是楼层上实际和预测地标之间的距离（以米为单位）。较高百分位数的错误对于安全性应用至关重要，例如，在确定犯罪嫌疑人时进行的地板错误可能会形成或破坏证据。我们希望最小化这两个错误。<br>表3中“基线”下的列显示了结果。错误率高，基数低。我们看到2.4 GHz的误差比5 GHz的误差更大。尽管存在这样的事实，即更多的AP听到客户端的声音，并且扫描帧的传输频率对于2.4 GHz更高。这意味着RSSI的变化（包括由发射功率控制引起的变化）对基数有很大影响，因此对定位误差也有很大的影响。</p>
<h3 id="减少定位错误"><a href="#减少定位错误" class="headerlink" title="减少定位错误"></a>减少定位错误</h3><p>如<strong>表2</strong>所示，原因相互冲突。 2.4 GHz和5 GHz都没有其全部原因。因此，摆脱这两个问题并非易事。为了改进，我们将充分利用在线阶段收到的RSSI的优势。<strong>我们使用启发式方法从在线阶段中选择AP，以减少定位错误</strong>。</p>
<p>我们知道每个AP的位置。我们使用此信息从在线指纹中选择AP。该算法首先选择一个楼层，然后将位于同一楼层的所有AP入围。我们使用入围的AP查找具有脱机指纹的匹配项。为了选择下限，我们探索了三种启发式方法：（a）最大AP数-最高AP向其报告客户端的地板；</p>
<p>（b）具有最大RSSI的AP-从中接收最强RSSI的地板，以及</p>
<p>（c）关联AP-客户端当前与之关联的AP的下限。</p>
<p><strong>表3</strong>显示了针对85％百分数的三种启发式方法的定位误差的变化情况。<strong>对于同一楼层和不同楼层的错误，显然都有改进</strong>。<strong>具有最大数量的AP的楼层检测所带来的改进最少</strong>。实际上，直到基数为4时，它的表现都比基准差。这背后的原因是，距离较长的AP（特别是在2.4 GHz中具有更长的传输距离）会响应，因此定位错误会增加。接下来，是具有最大RSSI的AP和关联AP的楼层检测。具有最大RSSI的AP或关联的AP通常最接近客户端，除非控制器进行负载平衡和发射功率控制时。 5 GHz略有改善。由于<strong>表3</strong>仅显示了第85个百分位数的数据，因此对于2.4 GHz，在<strong>图8</strong>中针对基数&#x3D; 1绘制了误差CDF。我们看到，所有百分位数的误差都减小了。对于其他基数，我们会看到类似的结果，但是由于篇幅所限，我们不将其包括在内。</p>
<p>我们将结果与Signal SLAM [37]进行比较，Signal SLAM [37]部署在购物中心等公共场所，因为我们也进行了类似的部署。我们在其他场所也有类似的观察。我们发现他们使用现有基础架构进行服务器端WiFi室内定位</p>
<p>第90个百分位数约为15米。我们执行类似。实际上，他们的AP可见性算法具有24.3米的90％百分位。我们在5 GHz上的表现要比这更好。考虑到Signal SLAM包含的算法的复杂性和所需的感应量，我们认为即使精度达到几米，我们的方法也会更好。特别是因为它简单且可扩展。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>现在，我们讨论了在实际部署中定位客户端时遇到的实际挑战以及我们解决方案的局限性。</p>
<h3 id="实际部署的挑战"><a href="#实际部署的挑战" class="headerlink" title="实际部署的挑战"></a>实际部署的挑战</h3><p>实际部署面临无数实际挑战，这些挑战阻碍了实证研究的效率和准确性。例如，<strong>可能会有突然的和意外的人群移动，这已知会增加信号变化</strong>。此外<strong>，在需要时，网络管理员可以替换旧的AP或部署新的AP</strong>。这些行政决定不受我们的控制。但是，此类更改严重影响了脱机指纹并更改了地板热图，最终影响了位置准确性。为具有数千个地标的整个校园准备指纹已经很繁琐，这样的发展使迭代过程变得更加繁琐。</p>
<p>除了测量和等待时间不足的问题外，各种<strong>上下文动态机制还使基于指纹的系统变得错误</strong>。主要原因是这种动态变化会<strong>导致RSSI测量中出现明显的波动</strong>，从而影响定位算法的距离计算。这些波动可能会非常频繁地发生，因为有许多不同的因素会影响AP及其客户端之间的RSSI，例如人群阻塞信号路径，用于负载均衡的AP侧功率控制以及节省电池的客户端功率控制。在第4节中，我们将阐明大多数这些因素。但是，我们对未来的工作进行了全面的评估。最后，我们系统中的所有MAC地址都是匿名的。我们不做任何人与人之间的映射来保护用户隐私。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>这项工作的主要局限性在于我们尚未考虑详尽的设备集。考虑到众多设备供应商，实际上不可能考虑使用所有类型的设备进行这种深入分析。不过，我们确实涵盖了最新的设备集，包括iPhone和Android设备。</p>
<p>第二个局限性是，即使我们收集的数据既轻松（学期休，学期很少，学生在校园内），也很繁重（学期学期，大多数学生在校园内）。<strong>我们仅在负荷较轻的数据集的子集上对负荷较轻的数据集进行了测试</strong>。我们尚不了解整个系统在整个负载繁重的日子中的行为。具体而言，涉及客户端数量和业务量的负载预计会增加干扰，从而增加信号变化。但是，这项研究仍是未来工作的一部分。这项工作的第三个局限性是<strong>我们没有考虑使客户端难以处理的MAC地址随机化算法的影响</strong>。尽管有一个活跃的研究领域提出了将随机MAC映射到实际MAC的方法[17]，但是鉴于其复杂性，我们不采用这些方法。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总而言之，我们提出了两个主要问题，需要对它们进行处理才能执行服务器端定位。我们通过跨大学校园部署的生产WLAN的大量数据验证了这些挑战。我们讨论了这些挑战的成因及其对这些挑战的影响。我们提出了启发式方法来应对挑战并减少定位错误。我们的发现适用于所有使用指纹识别技术的服务器端定位算法。大部分工作提供了在现实中以设备不可知方式对客户端进行本地定位的“哪里”和“什么”可能出错的证据。</p>
<p>gigahertz</p>
<p>Hello, This is Qian’ang Mao. Let me show the evaluation for the solution which Randy has just said. </p>
<p>The table shows how the localization errors vary for the three heuristics for 85th percentile values. It is clearly that having an improvement for both Same Floor and Different Floor errors. And Floor detection with Max Number of APs gives the Least improvement. The reason behind this is that the distant APs respond, and thus localization errors increase.</p>
<p>Since the Previous Table only showed data for 85th percentile, this Diagram shows Cumulative Distribution Function values of the error for cardinality&#x3D;1 and 2.4 GHz. From the this, we can see that the Error reduces for all the percentiles. And the researchers inffered that there are Similar results for other cardinalities.</p>
<p>They have also compared their solution whith the signal SLAM by deploying in public as signal SLAM did. They got 90th percentile is about 15 meters which is similar to signalSLAM in theory. But AP visibility of signalSLAM has 90th percentile as 24.3 meters in fact.  in 5 GHz, Solution performs better than Signal SLAM. Researchers believe even with few meters of accuracy the solution is better because its simple and scalable</p>
<p>The last part is the analysis to the work.</p>
<p>increase signal variations </p>
<p>lose compatibility with existing devices</p>
<p>nowdays many operating system support, hard to trace </p>
<p>Limitations on testing</p>
]]></content>
      <tags>
        <tag>Wi-Fi</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5057: Project management</title>
    <url>/post/fit5057-pm-notes/</url>
    <content><![CDATA[<p>可以说是上到现在觉得PPT做的最操蛋的一门课了，花里胡哨的，知识点不清晰，很难让人抓住重点。</p>
<img src="/post/fit5057-pm-notes/image-20210408081128562.png" class="" title="image-20210408081128562">

<p>主要学习内容为<del>图中1234</del>全部</p>
<span id="more"></span>

<h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><p>PM的定义：A temporaryendeavor undertaken to create a unique product, service or result</p>
<p>6个特性Key Characteristics：</p>
<p>PM Lifecycle Vs SDLC Lifecycle</p>
<h2 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h2><p>Enterprise Architecture, Software Development &amp; DevOps Fundamentals</p>
<p>基本上涵盖了整个ASS1</p>
<p>EA Methodology describes the program management activities for creating and maintaining, storing &amp; retrieving and using the EA documents in strategy, business &amp; technology management &amp; project work </p>
<p>EA Frameworks describe the organisation structure of how all the EA documents are to be catalogued and accessed to develop digital capabilities in the organisation from the perspectives of strategic, business &amp; technology requirements</p>
<h3 id="SDLC-Phases"><a href="#SDLC-Phases" class="headerlink" title="SDLC Phases"></a>SDLC Phases</h3><p>Software Development Lifecycle( SLDC)的各个阶段 </p>
<p>User Requirement Analysis -&gt; System Design -&gt; System Coding -&gt; System Testing -&gt; Software Operational Support</p>
<h3 id="Software-Development-Configuration-Strategies"><a href="#Software-Development-Configuration-Strategies" class="headerlink" title="Software Development Configuration Strategies"></a>Software Development Configuration Strategies</h3><p>Waterfall SDLC: Execute the Lifecycle Phases sequentially <strong>ONCE</strong></p>
<img src="/post/fit5057-pm-notes/image-20210408212011519.png" class="" title="image-20210408212011519">

<p>Agile SDLC: Execute the Lifecycle Phases sequentially <strong>more than ONCE</strong></p>
<img src="/post/fit5057-pm-notes/image-20210408212138839.png" class="" title="image-20210408212138839">

<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>Combining SDLC &amp; Ops Management Methodologies as one seamless process from software conceptualisation to operations</p>
<p>“DevOps is the combination of cultural philosophies, practices, and tools that increases an organization’s ability to deliver applications and services at high velocity: evolving and improving products at a faster pace than organizations using traditional software development and infrastructure management processes. This speed enables organizations to better serve their customers and compete more effectively in the market”</p>
<img src="/post/fit5057-pm-notes/image-20210408213249088.png" class="" title="image-20210408213249088">

<p>EA和DevOps关系</p>
<img src="/post/fit5057-pm-notes/image-20210408220150479.png" class="" title="image-20210408220150479">



<h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><p>Software Design, Governance &amp; Project Setup</p>
<h2 id="W4"><a href="#W4" class="headerlink" title="W4"></a>W4</h2><p>Managing People (Workbook2) 项目人员管理</p>
<h3 id="项目利益相关者管理"><a href="#项目利益相关者管理" class="headerlink" title="项目利益相关者管理"></a>项目利益相关者管理</h3><p>项目相关方管理 </p>
<h3 id="项目资源管理"><a href="#项目资源管理" class="headerlink" title="项目资源管理"></a>项目资源管理</h3><h3 id="项目交流管理"><a href="#项目交流管理" class="headerlink" title="项目交流管理"></a>项目交流管理</h3><h2 id="W5-项目范围管理"><a href="#W5-项目范围管理" class="headerlink" title="W5 项目范围管理"></a>W5 项目范围管理</h2><p>Scope Management</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>Scope</strong>: The sum of the products, services, and results to be provided as a project.</p>
<p><strong>Product Scope</strong>: The features and functionalities that characterize a product, service, or result.</p>
<p><strong>Project Scope</strong> (&#x3D;work scope&#x2F;<strong>WBS</strong>): The DevOps work performed to deliver a product, service, or result as specified in the product scope</p>
<p>WBS &#x3D; Work breakdown structure</p>
<h3 id="范围管理过程"><a href="#范围管理过程" class="headerlink" title="范围管理过程"></a>范围管理过程</h3><p>范围准线文档</p>
<p>控制范围延申</p>
<p>范围管理方法</p>
<h2 id="W7"><a href="#W7" class="headerlink" title="W7"></a>W7</h2><p>成本管理</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h3 id="成本管理过程"><a href="#成本管理过程" class="headerlink" title="成本管理过程"></a>成本管理过程</h3><h3 id="成本透明与欺诈"><a href="#成本透明与欺诈" class="headerlink" title="成本透明与欺诈"></a>成本透明与欺诈</h3>]]></content>
      <tags>
        <tag>project management</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5125: IT research methods S1 2021</title>
    <url>/post/fit5125-research-method-notes/</url>
    <content><![CDATA[<p>这门课是本科，研究生和博士生一起上的。任务量巨大。</p>
<span id="more"></span>

<p>W2</p>
<ul>
<li>Physical or psychological harm or abuse 身体或心理上的伤害或虐待</li>
<li>Informed consent 知情同意</li>
<li>Right of withdrawal 退出的权利 ​​</li>
<li>Access to outcomes 对成果知情</li>
<li>Vulnerable participant groups 弱势参与者群体</li>
<li>Deception and coercion 欺骗与强迫</li>
<li>Illegal practices 违法</li>
<li>Invasion of privacy 侵犯隐私</li>
<li>Confidentiality 保密</li>
<li>Human subject data 人体主题数据</li>
</ul>
<p>Deception 欺骗<br>欺骗的类型：<br>•“故意”：告诉参与者不正确的事情<br>•“遗漏”：不告诉参与者或模棱两可<br>一些研究需要欺骗，例如：<br>•防止参与者猜测正在研究的行为<br>•“欺骗”本身就是正在研究的现象<br>•当需要研究员的“同盟”时<br>尽量减少欺骗<br>必须尽早通知参与者有关欺骗的信息<br>汇报时<br>欺骗不得造成困扰（包括汇报后）<br>欺骗的使用受到争议（违反了知情同意）</p>
<p>强制和不当影响 Coercion &amp; undue influence<br>参与研究的压力。<br>显式强制 Explicit coercion：例如<br>•告诉参与者他们将不会获得某些好处<br>•告诉参与者他们必须参加<br>隐式强制 Implicit coercion：例如<br>•参与者推断他们将受到不利待遇<br>不当影响 Undue influence：<br>•参与奖励过多或不适当<br>研究人员必须意识到会对潜在参与者产生不适当的影响：<br>•例如 在他们的学生或同事身上</p>
<hr>
<h2 id="W6-质性研究"><a href="#W6-质性研究" class="headerlink" title="W6 质性研究"></a>W6 质性研究</h2><p>关键学的是主题分析（法），百科上内容挺少。</p>
<p>这里内容来自<a href="https://www.jianshu.com/p/427779f36752%E7%9A%84%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">https://www.jianshu.com/p/427779f36752的记录</a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对这些内容进行归纳整理，从而提炼出一些主题</p>
<h3 id="1-熟悉数据"><a href="#1-熟悉数据" class="headerlink" title="1. 熟悉数据"></a>1. 熟悉数据</h3><p><em>将口头语言转录为文字</em></p>
<h3 id="2-生成初始code"><a href="#2-生成初始code" class="headerlink" title="2. 生成初始code"></a>2. 生成初始code</h3><p>对数据进行初步的编码。</p>
<p>编码在一定程度上取决于主题是更“数据驱动”还是“理论驱动” </p>
<p>在前者中，主题将取决于数据，但在后者中，是在特定问题中处理数据。</p>
<p>在编码过程中需要注意：<br> a）尽可能多地编码潜在主题&#x2F;模式——因为永远不知道后面的内容是否与此相关；<br> b）对代码的摘录中，保留一些上下文相关的数据。<br> c）可以按照适合的多种“主题”来编码单个数据摘录，因此，相关的摘录可能会未被编码，被一次编码或多次编码。</p>
<h3 id="3-寻找主题"><a href="#3-寻找主题" class="headerlink" title="3. 寻找主题"></a>3. 寻找主题</h3><p>对代码进行整理和归纳。即分析编码，并要考虑如何将代码结合形成一个总体主题。</p>
<p>排序不同的代码到潜在的主题，整理所有相关的编码数据中提取出的主题。</p>
<p>有些编码可能会形成主主题，有些则成为子主题，还有一些可能不属于任何地方，可以为此创建一个名为“misc”的主题来存放这类编码。</p>
<p>最后得到候选主题和子主题的集合，以及与它们相关的编码的所有数据摘要。</p>
<h3 id="4-审阅主题"><a href="#4-审阅主题" class="headerlink" title="4. 审阅主题"></a>4. 审阅主题</h3><p>通过详细分析，会发现一些候选主题并不是真正的主题(例如，如果没有足够的数据来支持它们，或者数据太多样化)，而其他的主题可能会相互合并(例如，两个明显独立的主题可能会形成一个主题)。有些主题可能需要被分解成单独的主题。</p>
<h3 id="5-定义与命名主题"><a href="#5-定义与命名主题" class="headerlink" title="5. 定义与命名主题"></a>5. 定义与命名主题</h3><p>通过定义和细化，我们指的是确定每个主题的本质(以及主题的总体)，并确定每个主题捕获的数据的哪个方面。</p>
<p>段结束时，可以清楚地定义什么是你的主题，什么不是。或者，是否能用几句话来描述每个主题的范围和内容</p>
<h3 id="6-撰写报告"><a href="#6-撰写报告" class="headerlink" title="6. 撰写报告"></a>6. 撰写报告</h3><p>主题分析写作的任务，无论是出版或研究任务或论文，是以一种让读者信服你的分析的价值和有效性的方式，讲述数据背后的复杂故事。</p>
<p>重要的是，分析(包括数据摘录)提供了一个简洁、连贯、有逻辑、不重复、有趣的数据在主题内和主题间讲述的故事。你的书面记录必须在数据中提供足够的关于主题的证据，也就是说，足够的数据摘录来证明主题的普遍性。选择特别生动的例子，或能抓住你所展示的要点的精华，作为这个问题的示例。</p>
<p>然而，报告需要做的不仅仅是提供数据。摘要需要嵌入到一个分析性的叙述中，以引人注目地说明你正在讲述的关于你的数据的故事，而你的分析性的叙述需要超越对数据的描述，并对你的研究问题提出一个论点。</p>
<hr>
<p>W7</p>
<p>统计</p>
<p>descriptive statistics</p>
<p>敘述统计（descriptive statistics），是统计学中，来描绘或总结观察量的基本情况的统计总称</p>
<hr>
<p>W8</p>
<img src="/post/fit5125-research-method-notes/image-20210511195219137.png" class="" title="image-20210511195219137">

<p>correlational 与 experimental study的区别</p>
<p>cor就相关性研究（相关性 -1→ 0 → 1）</p>
<p>相关研究是揭示相关关系，实验研究是揭示因果关系</p>
<p>exp：</p>
<p>要证明两个变量之间有因果关系，必须满足以下几个条件：</p>
<p>第一，两个变量均是引发变量。即自变量必须是可以人为操纵变化的（这个变化是指在同一个人身上的变化），因变量的变化必须是自变量的变化所引起的。</p>
<p>第二，两个变量在时间上有前后关系，比如，必须是A先发生，B后发生，才能有因果关系的可能。</p>
<p>第三，两个变量的关系需排除掉第三种可能的解释。</p>
<p>Experimental design is about varying&#x2F;manipulating one or more Independent Variables, to see its effect on one or more Dependent Variables, whilst minimising the effect of Confounding Variables</p>
<p>独立度量设计和重复度量设计有什么区别？</p>
<p>1.独立措施：<br>独立度量设计（也称为组间）是一种实验设计，其中在自变量的<strong>每种条件</strong>下使用<strong>不同的参与者</strong>。这意味着实验的每个条件都包括不同的参与者组。 </p>
<p>这应该通过随机分配来完成，这可以确保每个参与者都有被分配到一个组或另一个组的同等机会。</p>
<p>独立措施涉及使用两组独立的参与者；每个条件一个。例如：</p>
<img src="/post/fit5125-research-method-notes/Ind.jpg" class="" title="独立措施实验设计">

<p>缺点：与重复测量设计相比，需要更多的人（即，更耗时）。<br>优点：由于人们仅参与一种情况，因此避免了订单效应（例如练习或疲劳）。如果一个人遇到多种情况，到第二种情况时他们可能会变得无聊，疲倦和烦躁，或者对实验的要求变得明智！<br>缺点：例如，小组参与者之间的差异可能会影响结果。年龄，性别或社会背景的差异。这些差异称为参与者变量（即，一种无关的变量）。<br>控制：招募参与者后，应将他们随机分配到他们的组中。这应确保各组平均相似（减少参与者变量）。</p>
<p>2.重复措施：<br>重复测量设计是一种实验设计，其中<strong>相同的参与者</strong>参与自变量的<strong>每种条件</strong>。这意味着实验的每个条件都包括同一组参与者。</p>
<p>重复测量设计也称为组内或主题内设计。</p>
<p>优点：由于在每种情况下使用相同的参与者，因此参与者变量（即个体差异）减少了。<br>缺点：可能会有订单效果。顺序效应是指影响参与者行为的条件顺序。第二种情况下的表现可能会更好，因为参与者知道该做什么（即练习效果）。否则在第二种情况下它们的性能可能会变差，因为它们很累（即疲劳效果）。可以使用平衡来控制此限制。<br>优点：参与各种情况所需的人员更少（即节省时间）。<br>控制：为了对抗秩序效应，研究人员平衡了参与者的条件秩序。改变参与者在不同实验条件下的执行顺序。</p>
<p><strong>参数测试</strong> 假设数据中存在基础统计分布。因此，必须满足几个有效性条件，以便参数测试的结果可靠。例如，仅当每个样本服从正态分布并且样本方差是均质的时，两个独立样本的Student t检验才是可靠的。</p>
<p><strong>非参数测试</strong> 不依赖任何分布。因此，即使不满足有效性的参数条件，也可以应用它们。 </p>
<p>非参数测试 比参数测试更 <strong>健壮</strong>。换句话说，它们在更广泛的情况下（较少的有效条件）有效。</p>
<p>使用参数测试而不是非参数等效项的优点在于，前者 将比后者具有更大的统计 <strong>能力</strong>。换句话说，参数测试更有可能导致拒绝H0。在大多数情况下，与参数测试关联的p值将低于与在相同数据上运行的非参数等效项关联的p值。</p>
]]></content>
      <tags>
        <tag>research</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5046: Mobile and distributed computing systems</title>
    <url>/post/fit5046-mobi-notes/</url>
    <content><![CDATA[<p>这门课说的是Mobile，但是实际上在开发时就完全是Android，至少到w5期中都没见iOS的影子。</p>
<p>另外这门也不纯粹是开发（虽然占大头），也有读paper的ass</p>
<span id="more"></span>

<h2 id="W1-理论介绍"><a href="#W1-理论介绍" class="headerlink" title="W1 理论介绍"></a>W1 理论介绍</h2><p>最后考试部分为part2与REST</p>
<p>（不考的part1是课程介绍）</p>
<h3 id="分布式的定义"><a href="#分布式的定义" class="headerlink" title="分布式的定义"></a>分布式的定义</h3><p>一系列自制系统实体组成计算上的范式，实体在地理上分散，之间能够通过网络交流与交换信息以达成特定任务</p>
<p>垂直（V）分布：不同业务逻辑分层到不同机器上</p>
<p>水平（H）分布： 单个层、组件分布到众多机器来扩容（分布式数据库）</p>
<h4 id="新兴概念"><a href="#新兴概念" class="headerlink" title="新兴概念"></a>新兴概念</h4><ul>
<li>节点不固定的移动计算</li>
<li>无处不在的计算，其中节点嵌入我们的环境中</li>
<li>上下文感知计算</li>
<li>IoT（物联网）</li>
<li>云计算</li>
<li>边缘或雾计算</li>
</ul>
<h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><ul>
<li><p><strong>C&#x2F;S</strong></p>
</li>
<li><p><strong>P2P</strong></p>
</li>
</ul>
<h4 id="SOA-Service-Oriented-Architecture"><a href="#SOA-Service-Oriented-Architecture" class="headerlink" title="SOA (Service-Oriented Architecture)"></a>SOA (Service-Oriented Architecture)</h4><p>应用程序功能作为松散耦合的服务提供<br>使用标准接口（Web 服务）来调用、发布和发现服务<br>通过接口进行基于消息的交互<br>重用公共服务、服务组合和互操作性以支持不同平台</p>
<h4 id="Web-Services"><a href="#Web-Services" class="headerlink" title="Web Services"></a>Web Services</h4><p>Web 服务是一段软件&#x2F;代码，旨在支持通过网络 (W3C) 进行可互操作的机器对机器交互<br>Web 服务提供了一个接口，使一组操作可供公众使用<br>它们支持访问业务逻辑、数据和流程或其他服务<br>它们可以被人类、机器或其他 WS 访问<br>使用如此多的支持工具进行开发既简单又便宜<br>SOAP 和 RESTful Web 服务（RESTful Web API）</p>
<h4 id="SOAP-Simple-Object-Access-Protocol"><a href="#SOAP-Simple-Object-Access-Protocol" class="headerlink" title="SOAP (Simple Object Access Protocol)"></a>SOAP (Simple Object Access Protocol)</h4><p>XML, WSDL and UDDI</p>
<p>WSDL 用于定义和描述 SOAP Web 服务</p>
<p>UDDI（通用描述、发现和集成）用于使用目录注册和发现 SOAP Web 服务（就route）</p>
<p>SOAP 涵盖以下主要领域：</p>
<ul>
<li>消息结构：提供一种消息格式，描述消息如何打包到 XML 文档中</li>
<li>处理模型：处理 SOAP 消息的规则和涉及处理 SOAP 消息的实体的简单分类。 消息的哪些部分应该由谁阅读以及如何在内容不被理解的情况下做出反应</li>
<li>可扩展性模型：如何使用特定于应用程序的构造来扩展基本消息构造</li>
<li>协议绑定框架：允许使用不同的协议（HTTP、SMTP、TCP 等）传输 SOAP 消息<ul>
<li>HTTP 的具体绑定</li>
</ul>
</li>
</ul>
<h5 id="SOAP-Message"><a href="#SOAP-Message" class="headerlink" title="SOAP Message"></a>SOAP Message</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--header is optional--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--Fault is optional--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Header: </p>
<ul>
<li>可选的</li>
<li>SOAP Header 元素包含特定于应用程序的信息: 身份验证（PIN，密码）、加密、缓冲&#x2F;缓存等</li>
<li>如果Header 元素存在，它必须是Envelope 元素的第一个子元素。</li>
<li>SOAP Header 中定义的属性（mustUnderstand）定义了接收者应该如何处理 SOAP 消息。如果 mustUnderstand 的值为 1，则中间节点必须对header中间内容进行处理，否则会发生错误</li>
</ul>
<p>Body：</p>
<ul>
<li>m:XXX 命名空间限定 namespace-qualified</li>
</ul>
<h5 id="http-binding"><a href="#http-binding" class="headerlink" title="http binding"></a>http binding</h5><p>Content-Type: application&#x2F;soap+xml;</p>
<h4 id="WSDL-的作用"><a href="#WSDL-的作用" class="headerlink" title="WSDL 的作用"></a>WSDL 的作用</h4><p>由 URI 标识的软件应用程序，其接口和绑定能够被定义、描述和发现为 XML 工件.</p>
<p>即为类A与处理B之间的绑定，让接收到A之后能开始运行B（routeMap）</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>CS</p>
<h4 id="约束：Client-Server："><a href="#约束：Client-Server：" class="headerlink" title="约束：Client-Server："></a>约束：Client-Server：</h4><p>分离关注点</p>
<ul>
<li>将用户界面问题（例如客户端）与数据存储问题（例如服务器）分开</li>
<li>允许组件独立进化</li>
<li>提高用户界面跨多个平台的可移植性</li>
<li>通过简化服务器组件提高可扩展性</li>
</ul>
<h4 id="Stateless"><a href="#Stateless" class="headerlink" title="Stateless"></a>Stateless</h4><p>从客户端到服务器的每个请求都必须包含理解请求所需的所有信息</p>
<p>不能利用服务器上任何存储的上下文</p>
<p>提高可扩展性和可靠性</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>对请求的响应中的数据被隐式或显式标记为可缓存或不可缓存</p>
<p>如果响应是可缓存的，则该响应可以在以后重复用于等效请求</p>
<ul>
<li>提高网络效率和性能</li>
<li>降低可靠性（陈旧数据的可能性）</li>
</ul>
<h4 id="Uniform-Interface"><a href="#Uniform-Interface" class="headerlink" title="Uniform Interface"></a>Uniform Interface</h4><p>所有资源都使用通用接口访问（例如， HTTP GET、POST、PUT、DELETE）</p>
<h4 id="Layered-System"><a href="#Layered-System" class="headerlink" title="Layered System"></a>Layered System</h4><p>允许架构由分层层组成</p>
<ul>
<li>每个组件都不能“看到”超出它们与之交互的直接层</li>
<li>客户端不知道他们调用的服务也可能调用其他服务</li>
<li>这可用于通过启用跨多个网络和处理器的服务负载平衡来提高可扩展性</li>
</ul>
<h4 id="Code-On-Demand"><a href="#Code-On-Demand" class="headerlink" title="[Code-On-Demand]"></a>[Code-On-Demand]</h4><p>“允许通过下载和执行小程序或脚本形式的代码来扩展客户端功能。”</p>
<h2 id="W2-安卓开发基础"><a href="#W2-安卓开发基础" class="headerlink" title="W2 安卓开发基础"></a>W2 安卓开发基础</h2><p>最基础的EventListener和Spinner（相当于下拉选择器）</p>
<p>考点：</p>
<ul>
<li>3种 mobile applications</li>
<li>Views, ViewGroupsand Layouts (what they are and their purpose)</li>
<li>All the <strong>important files</strong> in Android, what they are and their purpose</li>
</ul>
<p>Spinner不考</p>
<h3 id="mobile-app分类"><a href="#mobile-app分类" class="headerlink" title="mobile app分类"></a>mobile app分类</h3><ul>
<li><p>Native App：略</p>
</li>
<li><p>Web Apps：说的不是Cordova这种哦，是纯网页的，没任何线下的，比如bitcointalk网站</p>
</li>
<li><p>Progressive Web App (PWA)：React Native居然算PWA。。。（flutter应该也算了</p>
</li>
</ul>
<h3 id="基础布局-Layout"><a href="#基础布局-Layout" class="headerlink" title="基础布局 Layout"></a>基础布局 Layout</h3><p>模拟考题内容</p>
<p>作为APP组件，定义app界面（how the app will look like）</p>
<h4 id="Layout，View-amp-ViewGroup关系"><a href="#Layout，View-amp-ViewGroup关系" class="headerlink" title="Layout，View &amp; ViewGroup关系"></a>Layout，View &amp; ViewGroup关系</h4><ul>
<li>Layout定义了活动&#x2F;片段中 UI 的结构</li>
<li>Layout的元素由 View 和 ViewGroup 对象的层次结构组成</li>
<li>ViewGroup 就像一个<strong>不可见的容器</strong>，可以包含其他View</li>
<li>ViewGroup 是 <strong>Layout</strong> 和 <strong>View</strong> 容器的 <strong>基类</strong> （ViewGroup是View的子类</li>
<li>View 表示 UI 组件的<strong>基本构建块</strong></li>
<li>基类是类似按钮和文本字段等小部件</li>
</ul>
<h4 id="常见Layout"><a href="#常见Layout" class="headerlink" title="常见Layout"></a>常见Layout</h4><p>ConstraintLayout, RelativeLayout, Linear layouts (Vertical or Horizontal), FrameLayout, GridLayout</p>
<h5 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h5><p>Android Studio 中的默认布局</p>
<p>它支持创建复杂的布局</p>
<p>它只能使用布局编辑器的可视化工具构建（？我明明盲着编辑的</p>
<p>类似于相对布局，它创建了一个平面视图层次结构</p>
<p>它需要添加约束constraints来定义视图的位置</p>
<p>每个View需要至少一个水平和一个垂直约束</p>
<h3 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h3><ul>
<li>manifests<ul>
<li>manifests&#x2F;AndroidManifest.xml</li>
<li>包括有关应用程序的重要信息：应用程序组件的描述，例如Activity和Service；声明所需的权限</li>
</ul>
</li>
<li>GradleScripts： Android build gradle提供了一个自定义构建工具来管理和配置构建apk文件，有助于导入、下载和添加本地和远程依赖项<ul>
<li>build.gradle(Project: APPLICATION_NAME) 作用域为整个项目<ul>
<li>使您能够轻松导入和使用远程存储库</li>
<li>存储库Repositories 是指存储所有库和jar文件的位置&#x2F;目录，Repositories 包括 google() 和 jcenter() maven 存储库</li>
<li>所有 Jetpack 组件都可以通过谷歌 Maven 存储库 google() 获得，您可以添加项目中所有模块使用的仓库 例如<code>maven &#123; url&quot;https://jitpack.io&quot; &#125;</code></li>
</ul>
</li>
<li>build.gradle(Module: app) 作用域为单个Module<ul>
<li>包含有关 compileSDKversion, minSdkVersion, targetSdkVersion、版本代码version code和名称name 等信息</li>
<li>您可以在此处添加和配置应用程序依赖项，但请确保它们的存储库包含在 build.gradle(Project) 中</li>
</ul>
</li>
</ul>
</li>
<li>java<ul>
<li>java&#x2F;PACKAGE_NAME&#x2F;MainActivity.java 定义应用程序的行为方式以及与用户的交互方式</li>
</ul>
</li>
<li>res<ul>
<li>res&#x2F;drawable</li>
<li>res&#x2F;layout&#x2F;activity_main.xml(and any other layout files)</li>
<li>res&#x2F;menu：目录的Layout文件</li>
<li>res&#x2F;values&#x2F;strings.xml<ul>
<li>可以在此文件中包含字符串常量</li>
<li>能够在一个位置管理所有 UI 文本，更容易在应用中查找和更新文本</li>
<li>在Java代码中引用方式：<code>String message = getString(R.string.edit_message);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>在构建和运行应用程序时，在 MainActivity 类中，<code>setContentView()</code> 方法加载并扩充作为参数传递给它的 XML 布局文件并创建视图层次树</p>
<h4 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h4><ol>
<li>onCreate() 初始化活动组件，例如 创建视图或用数据填充列表（这里必须调用 setContentView() 方法</li>
<li>OnStart() Activity变得可见</li>
<li>onResume() 已准备好接受用户输入，在活动堆栈的顶部（即，在前台）</li>
<li>onPause() 失去焦点，将进入停止或恢复状态</li>
<li>onStop() 不再可见</li>
<li>onDestroy() 即将终止</li>
</ol>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>简洁明了</p>
<p>安全的（避免 NullPointerException 问题）</p>
<p>工具友好</p>
<p>可以在JVM上工作，可以与 Java 和 Android 完全互操作</p>
<p>Kotlin 类中的属性被声明为 var或者 val</p>
<p>用于可变属性的变量，例如 var message: String&#x3D;”你好”</p>
<p>valis 用于只读属性，例如 val message: String&#x3D;”你好”</p>
<p>必须初始化属性或必须提供自定义访问器</p>
<p>lateinit 修饰符 可用于声明为非空的属性，以便稍后对其进行初始化 <code>private lateinit var binding: ActivityMainBinding</code></p>
<h4 id="空值安全-Null-Safe"><a href="#空值安全-Null-Safe" class="headerlink" title="空值安全 Null Safe"></a>空值安全 Null Safe</h4><p>Kotlin 的 null 安全旨在消除 Java 的 NullPointerException(NPE)</p>
<p>在 Kotlin 中，常规属性不能为空（非空类型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message: String=&quot;Hello&quot;</span><br><span class="line">message = null // 在编译时产生错误</span><br></pre></td></tr></table></figure>

<p>要允许空值并将属性声明为可空值，请使用“?”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message：String? = &quot;Hello&quot;</span><br><span class="line">message = null // 现在可以了</span><br></pre></td></tr></table></figure>

<p>使用可空引用时：</p>
<ul>
<li>选项 1：检查条件是否为空，例如 <code>if (message != null)</code></li>
<li>选项 2：通过使用此符号 ? 来使用安全调用。例如 <code>println(message?.length)</code></li>
<li>选项 3：使用!!运算符将任何值转换为非空类型并在值为空时抛出异常（行为与 Java 相同）<code>val = b!!.length</code></li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>类的主要构造函数可以是类头类的一部分</p>
<p><code>class Person(varvalue: Double) &#123; /*...*/ &#125;</code></p>
<p>主构造函数不能包含任何代码，因此初始化代码放置在初始化程序块中，例如 <code>init&#123; if(value&lt;1) value=1.0 &#125;</code></p>
<p>默认情况下，Kotlin类是final（不能继承）。<br>要使类可继承，请使用 open 关键字，例如 <code>open class Person</code></p>
<p>使用单个冒号字符 (:) 继承，而不是 Java的extends 关键字</p>
<p>不需要 new 关键字，并且要创建对匿名内部类的引用，它使用“对象”</p>
<p>在 Kotlin 中，所有方法都是函数（fun）</p>
<p>冒号 (:) 在函数中用于返回类型，例如 fundoubleIt(x: Int): Int{ …}</p>
<p>Protected 具有私有的可见性和子类的可见性（类似于 Java 的私有和公共可见性）</p>
<h4 id="Backing-fields-amp-properties"><a href="#Backing-fields-amp-properties" class="headerlink" title="Backing fields &amp; properties"></a>Backing fields &amp; properties</h4><ul>
<li><p>Backing fields 支持字段：在访问器中使用字段标识符</p>
<ul>
<li><p>‘field’ 关键字只能在属性被初始化时使用</p>
</li>
<li><p>&#96;&#96;&#96;kotlin<br>varname:String&#x3D;”default”<br>get() &#x3D; field.capitalize()<br>set(value){<br>if(value.isEmpty()) {<br>    field &#x3D; “blank”<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Backing properties 支持属性：当支持字段不足以满足我们需要做的事情时使用，使用概念上相同但一个具有更广泛可见性的两个属性，另一个是实现细节</span><br><span class="line"></span><br><span class="line">  - binding 属性的作用域仅在 onCreateView 和 onDestroyView 之间</span><br><span class="line"></span><br><span class="line">  - ```kotlin</span><br><span class="line">    private var _binding: ViewFragmentBinding? = null</span><br><span class="line">    private val binding get() = _binding!!</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    _binding = ViewFragmentBinding.inflate(inflater, container, false)</span><br><span class="line">    val view = binding.root</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    override fun onDestroyView() &#123;</span><br><span class="line">    	super.onDestroyView()</span><br><span class="line">    	_binding = null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="W3-多Activity项目开发"><a href="#W3-多Activity项目开发" class="headerlink" title="W3 多Activity项目开发"></a>W3 多Activity项目开发</h2><p>Multiple Activities结构的APP 以及用于在Activities直接传输消息的Intent</p>
<ul>
<li>Views 和 Event Handling（例如按钮onClick）</li>
<li>Views 和 Adapters （ Spinner ）</li>
<li>View binding</li>
<li>Intent和Multi-Activity</li>
<li>Bundle</li>
<li>Parcelable</li>
</ul>
<h3 id="Events-amp-Event-Listeners"><a href="#Events-amp-Event-Listeners" class="headerlink" title="Events &amp; Event Listeners"></a>Events &amp; Event Listeners</h3><h3 id="View-Binding"><a href="#View-Binding" class="headerlink" title="View Binding"></a>View Binding</h3><p>优势：</p>
<ul>
<li>减少样板代码</li>
<li>空值安全 - 视图绑定创建对视图的直接引用，因此它消除了空指针异常的风险</li>
<li>类型安全：每个绑定类中的字段都具有与视图匹配的类型，因此它避免了类转换异常</li>
</ul>
<h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><ul>
<li>启动Activity</li>
<li>启动Service</li>
<li>启动广播Broadcast （让其他App可接受到</li>
<li>Activity之间传递信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>类似于建立一个通道，然后往通道塞东西，在通道另一端主动收取（go chan？</p>
<p>而且还是个双向的，对方也可以取这个来返回消息</p>
<h4 id="Use-Intent-to-Receive-Results"><a href="#Use-Intent-to-Receive-Results" class="headerlink" title="Use Intent to Receive Results"></a>Use Intent to Receive Results</h4><ol>
<li>startActivity() 方法启动另一个活动（单向）</li>
<li>开始另一个Activity并接收结果：</li>
<li>第一个Activity：<ol>
<li>唤起<code>startActivityForResult(Intent intent, int requestCode)</code>， 你提供一个像 1 (requestCode&gt;&#x3D; 0) 这样的值，这样你就可以得到结果.</li>
<li>实现 <code>onActivityResult()</code> 方法接收结果</li>
</ol>
</li>
<li>第二个Activity：<ol>
<li>调用 setResult() 方法设置将返回到第一个活动的结果。<code>void setResult(int resultCode, Intent intent)</code>，result code可以是标准结果RESULT_CANCELED，或者RESULT_OK<br>您不创建新的 Intent，而是使用第一个Activity给的<code>Intent returnIntent= getIntent();</code></li>
<li>将结果发送给调用者后，调用<code>finish()</code> 方法关闭并销毁Activity</li>
</ol>
</li>
</ol>
<h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>有了Intent，要发送一组数据项，您可以使用 Bundle</p>
<p>您将所有数据项添加到一个包对象，然后通过调用 putExtras() 将包添加到 Intent，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bundle bundle=<span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line"></span><br><span class="line">bundle.putString(“name”, “Helen”);</span><br><span class="line">bundle.putString(“surname”, “Jones”);</span><br><span class="line">bundle.putString(“phone”, “<span class="number">9902000</span>”);</span><br><span class="line"></span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>在第二个Activity中从bundle中检索数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bundle bundle=getIntent(). getExtras();</span><br><span class="line">String name=bundle.getString(“name”);</span><br></pre></td></tr></table></figure>

<h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><p>Bundle传的都是KV的，如果要传的是Object就需要实现个Parcelable</p>
<p>与 Java 的序列化相比，Android Parcelable 是一个用于序列化对象并更快地（具有更好的性能）传输对象及其状态和属性的接口</p>
<ol>
<li>添加一个parcelable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bundle.putParcelable(<span class="string">&quot;student1&quot;</span>, student);</span><br><span class="line">intent.putExtras(bundle);</span><br></pre></td></tr></table></figure></li>
<li>在其他Activity检索parcelable<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bundle bundle= getIntent().getExtras();</span><br><span class="line">bundle.getParcelable(“student1&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>但这<strong>只有在学生类是 Parcelable 时才有效</strong></p>
<p>实现Parcelable</p>
<ol>
<li>implements Parcelable</li>
<li>加个<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel parcel, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">  parcel.writeInt(id);</span><br><span class="line">  parcel.writeString(name);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>写个无脑赋值constructor</li>
<li>加个public int describeContents()</li>
<li>加个<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;T&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;T&gt;() &#123;<span class="comment">/**/&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>加getter、setter</li>
<li>&#x3D; &#x3D; 让IDE教自己吧</li>
</ol>
<h2 id="W4-基于Fragment的开发"><a href="#W4-基于Fragment的开发" class="headerlink" title="W4 基于Fragment的开发"></a>W4 基于Fragment的开发</h2><p>Fragments 结构的APP，先学的是用SharedPref来通信（其实就是个本地db</p>
<p>以及用于在Fragments直接传输消息的LiveData</p>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ul>
<li>用于构建应用程序用户界面的一部分</li>
<li>有自己的布局和生命周期</li>
<li>必须托管在Activity中</li>
<li>具有附加到宿主的视图层次结构的视图层次结构</li>
<li>提供可重用性和模块化</li>
<li>使用fragment，更容易动态修改activity的外观</li>
</ul>
<h4 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h4><p>Lifecycle：</p>
<p>onCreate()→onCreateView()→onViewCreated()→onStart()→onResume()</p>
<p>→onPause()→onStop()→onSaveInstanceState()→onDestoryView()→onDestoy()</p>
<p>在fragment类中必须实现onCreateView()方法并调用inflate()方法返回View为fragment绘制UI<br>inflate() 方法从指定的 XML 节点inflate（膨胀）一个新的视图层次结构，将其转换为相应的View和ViewGroup</p>
<p><strong>Callback Methods</strong>:</p>
<ul>
<li>onAttach(): 当附加到其宿主Activity时调用</li>
<li>onDetach(): 当与其宿主Activity分离时调用</li>
</ul>
<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><ul>
<li>能够以key-vaule的形式保存和检索简单的值</li>
<li>SharedPreferences 对象指向包含键值对的 XML 文件，并提供简单的方法来读取和写入它们</li>
<li>如果<strong>不需要存储大量数据</strong>，也<strong>不需要结构</strong>，这是一种合适的存储和访问数据的方式<br>这是一种在Fragment之间传递数据的简单方法</li>
</ul>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><ul>
<li>LiveData 是 Android Jetpack 中的架构组件之一</li>
<li>LiveData是一个可以被观察的数据持有者类（一个抽象类），使用observer（观察者）模式</li>
<li>LiveData 允许observer订阅更新，当 LiveData 对象持有的数据发生变化时，observer会收到通知</li>
<li>当一个类（一个活动或一个片段）想要被通知可观察对象的变化时，它可以实现Observer接口</li>
<li>LiveDatais 具有生命周期感知能力<ul>
<li>LiveData 更新处于活动生命周期状态下的App组件observer</li>
</ul>
</li>
<li>LiveData 的实例通常在 ViewModel 类中创建</li>
<li>LiveData 对象（保存数据）存储在 ViewModel 对象中，并通过 getter 方法访问</li>
<li>LiveData 允许应用程序组件（例如 Activity 或 Fragment）中的观察者观察更新，并获得更改通知</li>
</ul>
<p>MutableLiveData extends LiveData</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><ul>
<li>ViewModel 也是 Jetpack 中的架构组件之一</li>
<li>ViewModel 为片段或活动准备和管理数据</li>
<li>当 Activity 处于其任何生命周期状态，ViewModel 都处于活动状态且正在运行，</li>
<li>ViewModel 保留数据——它不会在配置更改期间被破坏，例如旋转设备破坏并重新创建其所有者（Activity或Fragment）</li>
</ul>
<h2 id="W5-导航栏-Navigation"><a href="#W5-导航栏-Navigation" class="headerlink" title="W5  导航栏 Navigation"></a>W5  导航栏 Navigation</h2><p>导航栏（侧边</p>
<p>大作业这部分要求用侧边的，用底部的不给分</p>
<ul>
<li>Material Design 中的导航</li>
<li>导航抽屉</li>
<li>Jetpack 导航组件<ul>
<li>NavigationUI</li>
<li>NavHost</li>
<li>NavController</li>
<li>Navigation Graph</li>
</ul>
</li>
</ul>
<h3 id="导航的类别"><a href="#导航的类别" class="headerlink" title="导航的类别"></a>导航的类别</h3><ol>
<li>Lateral 横向导航：Navigation Drawer, Bottom Nav Bar, Tabs</li>
<li>Forward 前向导航：Container(Card), Button, Link</li>
<li>Reverse (Upward) 反向导航: 回退按键</li>
</ol>
<h3 id="Drawer"><a href="#Drawer" class="headerlink" title="Drawer"></a>Drawer</h3><p>侧边叫Modal drawer。底部身上来的叫Bottom drawer</p>
<h4 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h4><ul>
<li>可识别<ul>
<li>确保用户可以清楚地识别导航</li>
<li>基于位置和列表样式内容的抽屉</li>
</ul>
</li>
<li>有组织的<ul>
<li>确保按重要性或使用频率对导航抽屉中的菜单选项（目的地）进行排序，并将相关的组合在一起</li>
</ul>
</li>
<li>上下文相关<ul>
<li>导航抽屉可以显示或隐藏以适应不同的应用程序布局</li>
</ul>
</li>
</ul>
<h2 id="W6-基于-Room-的安卓存储"><a href="#W6-基于-Room-的安卓存储" class="headerlink" title="W6 基于 Room 的安卓存储"></a>W6 基于 Room 的安卓存储</h2><p>关系型数据库</p>
<p>Android 单线程模型的两条规则：</p>
<ul>
<li>规则 1：不要阻塞 UI 线程</li>
<li>规则 2：不要从 UI 线程之外（从worker thread）访问 Android UI 工具包</li>
</ul>
<p>解决方案：</p>
<p>runOnUiThread(Runnable)</p>
<p>View.post(Runnable)</p>
<p>View.postDelayed(Runnable, long) &#x2F;&#x2F; long: the delay (in milliseconds)</p>
<h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><h4 id="Immediate"><a href="#Immediate" class="headerlink" title="Immediate:"></a>Immediate:</h4><p>需要用户活跃</p>
<ul>
<li>Java: ExecutorService and a thread pool</li>
<li>Kotlin: Kotlin coroutines</li>
</ul>
<h4 id="Exact"><a href="#Exact" class="headerlink" title="Exact:"></a>Exact:</h4><p>AlarmManager</p>
<h4 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred:"></a>Deferred:</h4><p>WorkManager</p>
<h3 id="Room-Persistence-Library"><a href="#Room-Persistence-Library" class="headerlink" title="Room Persistence Library"></a>Room Persistence Library</h3><ul>
<li>Room Persistence 库是 Android Jetpack 的一部分</li>
<li>Room 在 SQLite 上提供了一个抽象层，可以实现更强大的数据库访问</li>
<li>SQLite 提供了一个关系数据库管理系统，用于永久存储结构化数据</li>
<li>存储在 SQLite 中的数据可以被应用程序中的任何类访问，但不能被应用程序外部访问</li>
<li>直接使用 SQLite API 需要编写复杂的代码，并使用 Helper 和 Cursor 来访问和管理数据</li>
<li>为了减少创建和管理 SQLite 数据库的工作量，引入了 Room</li>
</ul>
<p>Room Persistent Library 包括：</p>
<ul>
<li>数据库Database：包含数据库持有者并有权访问底层持久化的关系数据（SQLite 数据库）</li>
<li>实体Entity：代表数据库中的表</li>
<li>DAO（数据访问对象Data Access Object）类<ul>
<li>包含提供对数据库的抽象访问的查询方法</li>
<li>提供 SQL 查询到插入或删除等方法的映射</li>
</ul>
</li>
</ul>
<h3 id="Entity-Class"><a href="#Entity-Class" class="headerlink" title="Entity Class"></a>Entity Class</h3><ul>
<li>@Entity 将类标记为实体</li>
<li>对于每个实体，在关联数据库中创建一个表</li>
<li>实体类提供了到数据库中 SQLite 表的映射</li>
<li>Room 默认使用数据库表名作为类名</li>
<li>要更改表名，请使用@Entity 注解的tableName 属性</li>
<li>Room 使用字段&#x2F;属性名称作为数据库中的列名称</li>
<li>要更改列名，请在字段中添加@ColumnInfo 注释</li>
<li>每个实体必须有一个主键，注释为 @PrimaryKey</li>
<li>如果您希望 Room 为实体分配自动 ID，请设置 @PrimaryKey 的 autoGenerate 属性</li>
<li>为了使该字段持久化，Room 必须有权访问它，或者将它们设为公开（不需要 getter 和 setter）或私有，但为包括 id 在内的所有字段添加 getter 和 setter</li>
</ul>
<h4 id="在两个实体之间创建一对多关系"><a href="#在两个实体之间创建一对多关系" class="headerlink" title="在两个实体之间创建一对多关系"></a>在两个实体之间创建一对多关系</h4><ul>
<li>子实体（Playlist)）必须包含一个引用主键的变量</li>
<li>父实体（User）的</li>
<li>使用子实体实例列表（Playlists）创建一个新的表示关系的类（UserWithPlayLists）</li>
<li>给子实体（用户）的实例添加**@Relation**注解</li>
<li>设置 parentColumn 为父实体的主键</li>
<li>将 entityColumn 设置为引用父实体 PK 的子实体的列</li>
</ul>
<h3 id="DAO-Data-Access-Object"><a href="#DAO-Data-Access-Object" class="headerlink" title="DAO (Data Access Object)"></a>DAO (Data Access Object)</h3><ul>
<li>DAO 包括提供对数据库的抽象访问的方法</li>
<li>通过使用 DAO 类而不是直接查询来访问数据库，我们可以将数据库的不同组件分开</li>
<li>DAO 方法示例：<ul>
<li>@Insert</li>
<li>@Update</li>
<li>@Delete</li>
<li>@Query</li>
</ul>
</li>
</ul>
<p>Dao下也能用LiveData的返回值来实现observer订阅</p>
<p>如果需要ViewModel则需要继承AndroidViewModel，需要将Application 作为上下文传入来实现全局注册</p>
<h4 id="RoomDatabase"><a href="#RoomDatabase" class="headerlink" title="RoomDatabase"></a>RoomDatabase</h4><p>数据库类满足以下条件：</p>
<p>成为扩展 RoomDatabase 的抽象类</p>
<p><code>public abstract class CustomerDatabase extends RoomDatabase &#123;</code></p>
<p>在@Database 注释中包含数据库的实体列表</p>
<p><code>@Database(entities = &#123;Customer.class&#125;, version = 1, exportSchema =false)</code></p>
<p>包含一个没有参数的抽象方法，返回 DAO</p>
<p><code>public abstract CustomerDAO customerDao();</code></p>
<p>创建基于单例模式的 Database 实例，以防止同时打开多个数据库实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CustomerDatabase INSTANCE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> CustomerDatabase <span class="title function_">getInstance</span><span class="params">(<span class="keyword">final</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">        		CustomerDatabase.class, <span class="string">&quot;CustomerDatabase&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在工作线程&#x2F;后台线程上运行数据库操作，我们使用了一个带有固定线程池的 ExecutorService（允许重用以前创建的线程来执行多个数据请求）</p>
<p><code>public static final ExecutorService databaseWriteExecutor = Executors.newFixedThreadPool(NUMBER_OF_THREADS);</code></p>
<p>如果数据库架构更改，则处理迁移（略</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>Repository 就像是 DAO 和 ViewModel 之间的中间层，提供了一个“干净的 API”</p>
<ul>
<li>它还负责管理查询线程（ExecutorService 和我们在 Database 类中添加的线程池）</li>
<li>Repository 类中的 DAO 实例提供通过它访问数据库的所有读&#x2F;写方法</li>
</ul>
<p>相当于就是中间一层专门用db.databaseWriteExecutor.execute(()-&gt;{dao.insert(customer);});</p>
<h3 id="Kotlin-1"><a href="#Kotlin-1" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Dao，Room这种差不多，但是异步上因为Kotlin有自家Coroutines，因此与Java的操作有大不同</p>
<p>协程是一种并发设计模式，用于在不阻塞主线程的情况下管理长时间运行的作业（用于异步编程）</p>
<ul>
<li>协程使用“暂停”技术，使它们“轻量级”</li>
<li>多个协程可以在一个线程上运行而不阻塞线程</li>
<li>提高资源消耗和并发操作</li>
<li>Suspend：一个正在运行的协程可以被挂起，其相应的计算将被暂停，但它的局部变量将存储在内存中，使线程可以自由执行其他作业</li>
<li>Resume：当计算准备好继续时，它返回到一个线程，并从它挂起的地方继续执行挂起的协程</li>
<li>我们使用 suspend 关键字来强制从协程中调用一个函数（挂起函数）</li>
</ul>
<p>挂起函数只返回一个值，但为了支持 LiveData，我们需要接收多个值（更新），因此我们使用 Kotlin 的 Flow</p>
<ul>
<li>一个 Flow 可以依次产生多个值</li>
<li>在 Room 中，可以使用 Flow 接收来自数据库的实时更新</li>
<li>在 Kotlin 中，我们通过使用 Dao 中的 Flow 来实现 LiveData，使 UI 在底层数据发生变化时自动更新</li>
<li>然后在 ViewModel 类中，我们可以通过调用 asLiveData() 将 Flow 转换为 LiveData</li>
</ul>
<p>要创建协程，我们需要在某些 CoroutineScope 的上下文中使用诸如 launch 或 async 之类的协程构建器</p>
<ul>
<li>launch 创建一个新的协程，它不携带任何结果值</li>
<li>async 是另一个协程构建器，用于创建一个协程，稍后将结果作为延迟值返回</li>
<li>为了得到结果，我们对延迟值使用 .await()</li>
</ul>
<p>协程是在某些 CoroutineScope 的上下文中创建的</p>
<ul>
<li>viewModelScope 是一个预定义的 CoroutineScope，因此我们访问<br>ViewModel 通过其 viewModelScope 属性的 CoroutineScope： ViewModel.viewModelScope</li>
<li>在主activity中，我们可以访问LifecycleOwner.lifecycleScope</li>
</ul>
<p>Kotlin 协程使用调度器来确定哪些线程用于协程执行<br>常见的调度员有以下三种类型：</p>
<ul>
<li>Dispatchers.Default - 该调度器经过优化，可以在主线程之外执行 CPU 密集型工作，例如 对列表进行排序并解析 JSON</li>
<li>Dispatchers.IO – 它用于在主线程之外执行磁盘或网络 I&#x2F;O，例如使用 Room 组件、读取或写入文件以及运行任何网络操作<strong>（安卓里取数据基本用这个）</strong></li>
<li>Dispatchers.Main（和 Dispatchers.Main.immediate）——在与 UI 交互时使用，例如调用挂起函数、处理 Android UI 对象或更新 LiveData 对象</li>
</ul>
<h2 id="W6-RecyclerView"><a href="#W6-RecyclerView" class="headerlink" title="W6 RecyclerView"></a>W6 RecyclerView</h2><p>考前才发现这个没看（全算考试内容的），考试考到了挺简单的</p>
<p>实际考试出题在ViewHolder（就是单个item的layout）上，以及onBindViewHolder()作用（用list内容填充各个layout）。比较简单就不加上去了</p>
<h2 id="W7-UI"><a href="#W7-UI" class="headerlink" title="W7 UI"></a>W7 UI</h2><p>主要还是讲G家的UI规范：MD</p>
<h3 id="设计风格与范式"><a href="#设计风格与范式" class="headerlink" title="设计风格与范式"></a>设计风格与范式</h3><ul>
<li>拟物</li>
<li>Flat平面</li>
<li>Material Design</li>
</ul>
<h3 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h3><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><h5 id="Material（材料）是个隐喻"><a href="#Material（材料）是个隐喻" class="headerlink" title="Material（材料）是个隐喻"></a>Material（材料）是个隐喻</h5><ul>
<li>Material design 试图根据现实世界的物体创造数字世界，捕捉它们的光影</li>
</ul>
<h5 id="粗体、图形、刻意"><a href="#粗体、图形、刻意" class="headerlink" title="粗体、图形、刻意"></a>粗体、图形、刻意</h5><ul>
<li>Material Design 使用排版、空间、比例、颜色和图像来创建层次结构、意义和焦点</li>
<li>用于强调操作并使它们对用户可见</li>
<li>旨在创造一种身临其境的体验</li>
</ul>
<h5 id="运动提供意义"><a href="#运动提供意义" class="headerlink" title="运动提供意义"></a>运动提供意义</h5><ul>
<li>用户执行动作和动作创建动作，通过微妙的反馈和连贯的过渡</li>
<li>动作应该是有意义和适当的</li>
<li>反馈应该清晰可见，但不能太明显和分散注意力</li>
</ul>
<h4 id="环境Environment"><a href="#环境Environment" class="headerlink" title="环境Environment"></a>环境Environment</h4><p>材料设计支持使用光、阴影，和具有 x、y 和 z 3维度的Material对象的 3D 环境</p>
<ul>
<li>每个Sheet都有标准的 1dp 厚度</li>
</ul>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>定义</p>
<ul>
<li>颜色系统用于创建反映您的品牌或风格的颜色主题</li>
<li><strong>主色primary colour</strong>是屏幕上最常用的颜色</li>
<li><strong>主要颜色的浅色或深色变体</strong>可用于创建对比度以区分 UI 元素</li>
<li><strong>副色secondary colour</strong>是可选的，可用于强调 UI 中的选定部分<ul>
<li>常用于浮动动作按钮文本选择、进度条、滑块、开关和链接</li>
</ul>
</li>
<li><strong>对比色Contrast</strong>：基于可访问性标准的原色和副色之间</li>
</ul>
<p>规则</p>
<ul>
<li>分层：使用颜色来显示它们的重要性级别以及它们之间的关系</li>
<li>品牌：使用颜色来强调品牌存在感</li>
<li>状态：使用颜色来显示元素或组件的当前状态，或应用程序、组件或元素的状态变化</li>
<li>含义：使用颜色来传达 UI 元素的含义</li>
</ul>
<h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul>
<li>原则：<ul>
<li>信息性：发送明确的信息</li>
<li>令人愉快的：带来快乐和愉悦</li>
<li>有意：必须有目的和故事</li>
</ul>
</li>
<li>使用适当的分辨率大小</li>
<li>使排版在图像之上清晰易读</li>
<li>使用用户生成的摄影、专业摄影或不同类型的插图</li>
</ul>
<h4 id="图标，字体，菜单"><a href="#图标，字体，菜单" class="headerlink" title="图标，字体，菜单"></a>图标，字体，菜单</h4><p>略</p>
<h4 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h4><p>使用滚动Tabs：</p>
<ul>
<li>当一组选项卡无法显示在屏幕上时</li>
<li>选项的数量约为5到7</li>
<li>当items密切相关或属于一个类别时</li>
<li>某些项目将不可见（被挤出去了），因此用户无法一次看到所有项目</li>
</ul>
<p><strong>滚动标签不用于主要导航</strong></p>
<h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><ul>
<li>创建流畅自然的对话流程</li>
<li>字段的逻辑分组和排序</li>
<li>区分分组项目</li>
<li>有意义且熟悉的字段标签</li>
<li>一致的术语和缩写</li>
<li>如果需要，提供提示和示例</li>
<li>视觉上吸引人的布局（对齐）</li>
<li>可选和必填字段明确标记（*）</li>
<li>如果可能，使用列表来减少错误</li>
<li>最小化输入的数量：<ul>
<li>合并相似的输入字段</li>
<li>消除多余的和不太重要的条目</li>
</ul>
</li>
<li>错误预防和错误消息<ul>
<li>使用有意义且清晰的错误消息</li>
<li>纠错：重新关注包含错误的字段</li>
</ul>
</li>
<li>即时反馈和完成反馈<ul>
<li>为用户提供当前状态和进度的反馈</li>
<li>尽早验证，但不要中断对话流程</li>
<li>适当的内联反馈</li>
</ul>
</li>
</ul>
<p>纵向排列Label和input优于横向</p>
<h3 id="WCAG-2-0-and-Other-W3C-x2F-WAI-Guidelines"><a href="#WCAG-2-0-and-Other-W3C-x2F-WAI-Guidelines" class="headerlink" title="WCAG 2.0 and Other W3C&#x2F;WAI Guidelines"></a>WCAG 2.0 and Other W3C&#x2F;WAI Guidelines</h3><h4 id="原则-1：可感知"><a href="#原则-1：可感知" class="headerlink" title="原则 1：可感知"></a>原则 1：可感知</h4><h5 id="1-1-小屏幕尺寸"><a href="#1-1-小屏幕尺寸" class="headerlink" title="1.1. 小屏幕尺寸"></a>1.1. 小屏幕尺寸</h5><ul>
<li>最小化信息量（例如更少的内容模块或图像）</li>
<li>提供合理的默认尺寸以最小化放大和缩小的需要</li>
<li>将表单字段置于其标签下方</li>
<li>使链接文本的长度适应视口宽度<ul>
<li>视口指的是网页的可见区域，在手机上较小</li>
</ul>
</li>
</ul>
<h5 id="1-2-缩放-x2F-放大"><a href="#1-2-缩放-x2F-放大" class="headerlink" title="1.2 缩放&#x2F;放大"></a>1.2 缩放&#x2F;放大</h5><ul>
<li>允许用户在移动设备上控制内容&#x2F;文本大小的方法<ul>
<li>例如。 在用户手指下使用放大镜视图</li>
<li>文本的大小最多可调整为 200%</li>
</ul>
</li>
</ul>
<h5 id="1-3-对比度"><a href="#1-3-对比度" class="headerlink" title="1.3 对比度"></a>1.3 对比度</h5><ul>
<li>移动设备在不同照明环境中使用<ul>
<li>为小屏幕考虑正确的大&#x2F;小文本对比度</li>
</ul>
</li>
</ul>
<h4 id="原则-2：可操作"><a href="#原则-2：可操作" class="headerlink" title="原则 2：可操作"></a>原则 2：可操作</h4><h5 id="2-1-触摸屏设备的键盘控制"><a href="#2-1-触摸屏设备的键盘控制" class="headerlink" title="2.1 触摸屏设备的键盘控制"></a>2.1 触摸屏设备的键盘控制</h5><p>当前的移动设备显示屏幕键盘以接受文本输入</p>
<ul>
<li>键盘可访问性非常重要，一些移动操作系统包含键盘接口以支持外部键盘或其他替代品</li>
</ul>
<h5 id="2-2-触摸目标尺寸和间距"><a href="#2-2-触摸目标尺寸和间距" class="headerlink" title="2.2 触摸目标尺寸和间距"></a>2.2 触摸目标尺寸和间距</h5><ul>
<li>交互元素必须足够大，彼此之间有足够的距离</li>
<li>为触摸目标使用正确的大小和间距</li>
</ul>
<h5 id="2-3-触摸屏手势"><a href="#2-3-触摸屏手势" class="headerlink" title="2.3 触摸屏手势"></a>2.3 触摸屏手势</h5><p>可以通过触摸屏上的手势操作移动设备</p>
<p>手势包括简单的敲击或使用多个手指的复杂操作</p>
<ul>
<li>手势应该尽可能简单</li>
<li>对于复杂的手势，设计替代方案以支持简单的点击或滑动手势</li>
<li>通过 mouseup或者 touchend event 激活元素</li>
<li>使用 mouseup或者 touchend event 触发操作有助于防止在触摸和鼠标交互过程中出现意外操作</li>
</ul>
<h5 id="2-4-设备操作手势"><a href="#2-4-设备操作手势" class="headerlink" title="2.4 设备操作手势"></a>2.4 设备操作手势</h5><ul>
<li>设备的物理操作，例如摇晃或倾斜</li>
<li>确保提供触摸和键盘可操作的替代控制选项</li>
</ul>
<h5 id="2-5-将按钮放置在易于访问的位置"><a href="#2-5-将按钮放置在易于访问的位置" class="headerlink" title="2.5 将按钮放置在易于访问的位置"></a>2.5 将按钮放置在易于访问的位置</h5><ul>
<li>请将按钮放置在用户可以轻松够到的地方，即使用户不同姿势摆放设备</li>
</ul>
<h4 id="原则-3：可理解"><a href="#原则-3：可理解" class="headerlink" title="原则 3：可理解"></a>原则 3：可理解</h4><h5 id="3-1-更改屏幕方向（纵向-x2F-横向）"><a href="#3-1-更改屏幕方向（纵向-x2F-横向）" class="headerlink" title="3.1 更改屏幕方向（纵向&#x2F;横向）"></a>3.1 更改屏幕方向（纵向&#x2F;横向）</h5><p>支持两种方向模式，不要期望用户旋转（例如当移动设备安装在轮椅的固定臂上时）</p>
<h5 id="3-2-一致的布局"><a href="#3-2-一致的布局" class="headerlink" title="3.2 一致的布局"></a>3.2 一致的布局</h5><p>“跨多个页面重复的组件应该以一致的布局呈现。”</p>
<h5 id="3-3-在页面滚动前定位重要的页面元素"><a href="#3-3-在页面滚动前定位重要的页面元素" class="headerlink" title="3.3 在页面滚动前定位重要的页面元素"></a>3.3 在页面滚动前定位重要的页面元素</h5><p>小屏幕限制了无需滚动即可显示的内容量</p>
<ul>
<li>定位重要的页面信息，使其无需滚动即可看到，以帮助弱视用户和有认知障碍的用户</li>
</ul>
<h5 id="3-4-对执行相同动作的可操作元素进行分组"><a href="#3-4-对执行相同动作的可操作元素进行分组" class="headerlink" title="3.4 对执行相同动作的可操作元素进行分组"></a>3.4 对执行相同动作的可操作元素进行分组</h5><p>“当多个元素执行相同的操作或前往相同的目的地时（例如带有链接文本的链接图标），这些应该包含在同一个可操作的元素中”。</p>
<h5 id="3-5-明确说明要素是可操作的"><a href="#3-5-明确说明要素是可操作的" class="headerlink" title="3.5 明确说明要素是可操作的"></a>3.5 明确说明要素是可操作的</h5><p>使用视觉特征来表示可操作的元素（例如斜角按钮）</p>
<h5 id="3-6-提供自定义触摸屏和设备操作手势的说明"><a href="#3-6-提供自定义触摸屏和设备操作手势的说明" class="headerlink" title="3.6 提供自定义触摸屏和设备操作手势的说明"></a>3.6 提供自定义触摸屏和设备操作手势的说明</h5><p>提供可见且易于访问的说明，例如工具提示和教程</p>
<h4 id="原则-4：Robust"><a href="#原则-4：Robust" class="headerlink" title="原则 4：Robust"></a>原则 4：Robust</h4><h5 id="4-1将虚拟键盘设置为所需的数据输入类型"><a href="#4-1将虚拟键盘设置为所需的数据输入类型" class="headerlink" title="4.1将虚拟键盘设置为所需的数据输入类型"></a>4.1将虚拟键盘设置为所需的数据输入类型</h5><h5 id="4-2-提供简单的数据录入方法"><a href="#4-2-提供简单的数据录入方法" class="headerlink" title="4.2 提供简单的数据录入方法"></a>4.2 提供简单的数据录入方法</h5><ul>
<li>通过提供菜单、单选按钮或自动输入减少文本输入量</li>
</ul>
<h5 id="4-3-支持平台特性"><a href="#4-3-支持平台特性" class="headerlink" title="4.3 支持平台特性"></a>4.3 支持平台特性</h5><p>移动设备提供帮助残障用户的功能，例如缩放、字幕或更大的字体，但这些功能因设备类型和操作系统而异</p>
<h2 id="W7-Retrofit-网络库"><a href="#W7-Retrofit-网络库" class="headerlink" title="W7 Retrofit 网络库"></a>W7 Retrofit 网络库</h2><p>网络请求库 <a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">https://square.github.io/retrofit/</a></p>
<p>权限声明 <code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code>写进AndroidManifest.xml</p>
<h3 id="Model-Classes"><a href="#Model-Classes" class="headerlink" title="Model Classes"></a>Model Classes</h3><p>其实就是Entity</p>
<p>创建Model类以提供到响应正文及其元素的结构的映射，作为 JSON模型</p>
<p>通常，对公共 API 的 http GET 调用会返回非常长且复杂的 JSON 响应。 使用 Retrofit 的 Model 类，您可以仅包含映射所需的 JSON 响应中的字段&#x2F;对象</p>
<p>例如。 <a href="https://developers.google.com/custom-search/v1/reference/rest/v1/Search" target="_blank" rel="noopener">Google 搜索响应 (JSON) </a>包含许多对象，但我们只想访问“items”下的“snippet”，因此我们创建了一个 Retrofit Model 类来仅映射这两个对象并忽略其他对象</p>
<p>Model 类应该匹配 Retrofit Interface 中返回的类型</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>只讲了GET…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@GET(“students/&#123;id&#125;&quot;)</span></span><br><span class="line">        Call&lt;StudentResponse&gt; <span class="title function_">getStudentById</span><span class="params">(<span class="meta">@Path(“id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@GET(&quot;customsearch/v1&quot;)</span></span><br><span class="line">    Call&lt;SearchResponse&gt; <span class="title function_">customSearch</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Query(&quot;key&quot;)</span> String API_KEY,</span></span><br><span class="line"><span class="params">        <span class="meta">@Query(&quot;cx&quot;)</span> String SEARCH_ID_cx,</span></span><br><span class="line"><span class="params">        <span class="meta">@Query(&quot;q&quot;)</span> String keyword)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul>
<li><p>Retrofit 客户端类负责创建 Retrofit 实例</p>
</li>
<li><p>Retrofit 有一个 Retrofit.Builder 可以通过提供以下配置使用配置的值调用 build() 轻松创建 Retrofit 实例：</p>
<ul>
<li>baseUrl() 设置 API 基本 URL</li>
<li>转换器通过调用 addConverterFactory() 并将 GsonConverterFactoryforencoding 传递给 JSON 并从 JSON 解码</li>
</ul>
</li>
<li><p>我们在 Retrofit 实例上调用 create() 方法并传递我们创建的 Retrofit 接口，以便 Retrofit 可以生成接口定义的 API 端点（即 URL）的实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetrofitClient</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Retrofit retrofit;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_URL=<span class="string">&quot;https://www.googleapis.com/&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">RetrofitInterfacegetRetrofitService</span><span class="params">()</span>&#123;</span><br><span class="line">		retrofit=<span class="keyword">new</span> <span class="title class_">Builder</span>()</span><br><span class="line">			.baseUrl(BASE_URL)</span><br><span class="line">			.addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">			.build();</span><br><span class="line">		<span class="keyword">return</span> retrofit.create(RetrofitInterface.class); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Call-back"><a href="#Call-back" class="headerlink" title="Call(back)"></a>Call(back)</h3><h4 id="InterfaceCall-lt-T-gt"><a href="#InterfaceCall-lt-T-gt" class="headerlink" title="InterfaceCall&lt;T&gt;"></a><code>InterfaceCall&lt;T&gt;</code></h4><p>Call 发送请求并返回响应</p>
<p>Call 提供了两种发出 HTTP 请求的方法：</p>
<ol>
<li><code>Response&lt;T&gt; execute()</code> – 用于发送同步请求</li>
<li><code>void enqueue(Callback&lt;T&gt;)</code> – 用于发送异步请求并在收到响应时调用回调方法</li>
</ol>
<h4 id="InterfaceCallback-lt-T-gt"><a href="#InterfaceCallback-lt-T-gt" class="headerlink" title="InterfaceCallback&lt;T&gt;"></a><code>InterfaceCallback&lt;T&gt;</code></h4><p>回调需要实现两个方法：</p>
<ol>
<li><p><code>void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response)</code></p>
<ul>
<li>为收到的 HTTP 响应调用</li>
<li><code>Response.isSuccessful()</code> 可以调用来判断响应是否成功</li>
</ul>
</li>
<li><p><code>void onFailure(Call&lt;T&gt; call, Throwable t)</code></p>
<ul>
<li>发生网络异常或意外异常时调用</li>
</ul>
</li>
</ol>
<h3 id="Kotlin-2"><a href="#Kotlin-2" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>协程写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">RetrofitInterface</span>&#123;</span><br><span class="line">	<span class="meta">@GET(&quot;customsearch/v1&quot;)</span></span><br><span class="line">	suspend fun <span class="title function_">customSearch</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@Query(&quot;key&quot;)</span> API_KEY: String,</span></span><br><span class="line"><span class="params">		<span class="meta">@Query(&quot;cx&quot;)</span> SEARCH_ID_cx: String,</span></span><br><span class="line"><span class="params">		<span class="meta">@Query(&quot;q&quot;)</span> keyword: String</span></span><br><span class="line"><span class="params">	)</span>: Response&lt;SearchResponse&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给fun加了个suspend</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val retrofitInterface: RetrofitInterface= RetrofitClient.getRetrofitService()</span><br><span class="line"></span><br><span class="line">binding.btnSearch.setOnClickListener(object : View.OnClickListener&#123;</span><br><span class="line">	override fun onClick(v: View?) &#123;</span><br><span class="line">		keyword = binding.editText.text.toString()</span><br><span class="line">		CoroutineScope(Dispatchers.IO).launch&#123;</span><br><span class="line">			val response: Response&lt;SearchResponse&gt; = retrofitInterface.customSearch(API_KEY,SEARCH_ID_cx,keyword)</span><br><span class="line">			withContext(Dispatchers.Main)&#123;</span><br><span class="line">				if (response.isSuccessful) &#123;</span><br><span class="line">					val list = response.body()!!.items</span><br><span class="line">					val result: String = list[0].snippet</span><br><span class="line">					binding.tvResult.text= result</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					Log.i(&quot;Error &quot;, &quot;Response failed&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在CoroutineScope作用域里干活</p>
<h2 id="W8-普适计算-Ubiquitous-Computing"><a href="#W8-普适计算-Ubiquitous-Computing" class="headerlink" title="W8 普适计算 Ubiquitous Computing"></a>W8 普适计算 Ubiquitous Computing</h2><p>普适计算，也叫pervasive computing（无孔不入计算），由 Mark Weiser 于 1988 年左右创造的一种计算范式，其中计算机变得如此普遍和“隐形”，以至于我们根本看不到计算机</p>
<ul>
<li>“<strong>隐形</strong>”传感和处理设备<strong>嵌入我们的环境中</strong>，如此自然、如此友好，以至于我们在使用它们时甚至没有注意到</li>
<li>这是关于“<strong>随时随地</strong>”的计算</li>
</ul>
<h3 id="人机交互（HCI"><a href="#人机交互（HCI" class="headerlink" title="人机交互（HCI"></a>人机交互（HCI</h3><ul>
<li>从命令行交互开始，然后转向直接操作</li>
<li>在普适计算中，设备无处不在并嵌入我们的环境中</li>
<li>沉浸式系统</li>
<li>多模式交互</li>
</ul>
<h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><ul>
<li>间接指向设备<ul>
<li>鼠标、轨迹球、操纵杆</li>
</ul>
</li>
<li>直接指向设备<ul>
<li>触摸屏、触控笔</li>
</ul>
</li>
<li>语音&#x2F;语音</li>
<li>动作和手势</li>
<li>生物识别输入数据：<ul>
<li>面部、手指、虹膜或视网膜，或行走方式&#x2F;步态</li>
</ul>
</li>
<li>生理信号（例如心率、血压、脑电图信号）<ul>
<li>基于脑信号的脑机接口（BCI）</li>
</ul>
</li>
</ul>
<h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><ul>
<li>语音&#x2F;语音</li>
<li>小尺寸到壁挂式屏幕</li>
<li>3D打印机</li>
<li>3D可视化</li>
<li>全息图</li>
<li>虚拟现实和增强现实</li>
</ul>
<h3 id="上下文-x2F-情境感知计算-Context-x2F-Situation-Aware-Computing"><a href="#上下文-x2F-情境感知计算-Context-x2F-Situation-Aware-Computing" class="headerlink" title="上下文&#x2F;情境感知计算 Context&#x2F;Situation-Aware Computing"></a>上下文&#x2F;情境感知计算 Context&#x2F;Situation-Aware Computing</h3><p>相关领域</p>
<p>Context： 任何可用于表征实体情况的信息</p>
<h4 id="上下文感知"><a href="#上下文感知" class="headerlink" title="上下文感知"></a>上下文感知</h4><p>“根据其使用位置、附近人和物体的集合以及这些物体随时间的变化进行调整的应用程序”</p>
<p>“应用程序感知和响应有关<strong>环境、位置、时间</strong>或<strong>用户</strong>的上下文信息的能力”</p>
<ul>
<li>上下文感知被认为是无处不在的计算系统的关键组成部分</li>
<li>上下文感知系统了解当前上下文，例如位置和物理环境，并使用此信息相应地调整其行为或操作</li>
<li>它使应用程序能够：<ul>
<li>适应动态变化</li>
<li>个性化</li>
<li>聪明主动</li>
<li>成本效益</li>
<li>聪明伶俐</li>
</ul>
</li>
</ul>
<p>首个上下文感知系统：<strong>Active Badge</strong> system at Cambridge AT&amp;T Lab，使用红外信号检测建筑物内人员的位置</p>
<h4 id="情景：高级上下文"><a href="#情景：高级上下文" class="headerlink" title="情景：高级上下文"></a>情景：高级上下文</h4><ul>
<li>情境指的是高层次的上下文</li>
<li>情境代表感兴趣的现实生活情境</li>
<li>情境提供了对周围环境的更广阔视野<ul>
<li>示例：忙碌、迟到、开会、健康、火灾威胁或开车</li>
</ul>
</li>
<li>通过使用推理&#x2F;推理方法推断情况</li>
<li>从多条上下文的聚合（融合）中推断出情况</li>
</ul>
<p>上下文&#x2F;情境推理方法通过对低级上下文进行推理（建模）来产生高级上下文信息</p>
<h4 id="上下文建模"><a href="#上下文建模" class="headerlink" title="上下文建模"></a>上下文建模</h4><p>能够以标准和一致的方式表示上下文</p>
<p>支持应用程序之间的上下文共享</p>
<p>可以在上下文中进行推理</p>
<h4 id="上下文-x2F-情境推理"><a href="#上下文-x2F-情境推理" class="headerlink" title="上下文&#x2F;情境推理"></a>上下文&#x2F;情境推理</h4><ul>
<li>简单的逻辑法</li>
<li>模糊逻辑法</li>
<li>基于本体的推理</li>
<li>机器学习<ul>
<li>朴素贝叶斯</li>
<li>贝叶斯网络</li>
<li>隐马尔可夫模型</li>
<li>决策树</li>
<li>神经网络</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="移动感知-Mobile-Sensing"><a href="#移动感知-Mobile-Sensing" class="headerlink" title="移动感知 Mobile Sensing"></a>移动感知 Mobile Sensing</h3><p>也是相关领域</p>
<p>移动感知是指从移动设备收集传感数据</p>
<p>移动感知通常涉及在手机后台运行的移动应用程序，从内部或外部传感器收集传感数据并将收集到的数据传输到云端或远程来源</p>
<p>感知和收集的关键上下文信息是位置</p>
<p>隐私是移动感知的主要挑战</p>
<h4 id="移动人群感知-Mobile-CrowdSensing"><a href="#移动人群感知-Mobile-CrowdSensing" class="headerlink" title="移动人群感知 Mobile CrowdSensing"></a>移动人群感知 Mobile CrowdSensing</h4><p>术语“人群感应”是指利用人群的力量，使用移动和可穿戴设备中的可用传感器收集有关某些感兴趣现象的信息</p>
<p>移动人群感知从大量用户远程收集有关环境和物理世界的数据，并将其提供给 MCS 应用程序</p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ol>
<li><p>参与式感知 Participatory sensing： </p>
<ul>
<li>用户直接参与数据收集过程</li>
</ul>
</li>
<li><p>机会式感知 Opportunistic sensing：</p>
<ul>
<li>用户不直接参与数据收集过程（最少参与）</li>
<li>感知任务在后台发生</li>
<li>移动设备决定何时以及如何参与传感任务</li>
</ul>
</li>
</ol>
<p>也有个别的移动传感应用，移动传感只在一部手机上单独进行，不与其他用户合作</p>
<h3 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h3><p>也是相关领域</p>
<p>由麻省理工学院的 Kevin Ashton 创造</p>
<p>开启了普适(计算)的新时代</p>
<p>日常物品网络（智能物品）</p>
<p>移动设备、汽车、智能电器等所有对象都连接到互联网，可以进行通信和交换数据</p>
<h3 id="Cloud-and-edge-computing"><a href="#Cloud-and-edge-computing" class="headerlink" title="Cloud and edge computing"></a>Cloud and edge computing</h3><h4 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h4><p>“云计算是通过互联网通过云服务平台按需交付计算能力、数据库存储、应用程序和其他 IT 资源，并采用即用即付定价。” （AWS）</p>
<p>“云计算，通常简称为“云”，是通过互联网以按使用付费的方式交付按需计算资源——从应用程序到数据中心的一切。”（IBM）</p>
<ul>
<li>由计算机、服务器、数据中心和资源组成的大型网络</li>
<li>基于互联网的计算</li>
<li>分布式计算</li>
<li>节省硬件、软件和维护成本</li>
<li>基础设施、平台、软件、硬件和应用即服务</li>
<li>按需和基于效用的计算（按使用付费）</li>
</ul>
<p>公有云</p>
<ul>
<li>所有硬件、软件或支持基础设施均由第三方服务提供商拥有和管理，并由客户通过 Internet 访问</li>
<li>低成本、免维护和无限资源</li>
</ul>
<p>私有云</p>
<ul>
<li>由类似政府机构的组织在专用网络上运营</li>
<li>资源部署在本地</li>
<li>更高的安全性和更灵活</li>
</ul>
<p>混合云</p>
<ul>
<li>公共和私有云网络的组合</li>
</ul>
<h4 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h4><p>“雾计算是定义边缘计算应该如何工作的标准”（Cisco）</p>
<ul>
<li>随着物联网的不断发展，传感器和智能事物产生了大量数据，但将所有物联网数据传输到云端非常昂贵</li>
<li>边缘计算允许在边缘处理数据，更靠近生成位置，而不是将其发送到云</li>
<li>边缘可以是路由器、汽车、笔记本电脑、服务器或无人机</li>
</ul>
<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ol>
<li><p>解决大数据问题</p>
<ul>
<li><p>仅将大数据摘要发送到云端</p>
</li>
<li><p>通过在本地聚合和处理数据并将数据摘要发送到云来降低网络带宽和数据传输的成本</p>
</li>
<li><p>通过在边缘执行不太复杂的数据分析来缩短响应时间</p>
</li>
</ul>
</li>
<li><p>安全性：敏感数据可以在边缘进行分析，而不是将其发送到云端</p>
</li>
<li><p>互联网不可用情况下仍可用：数据可以在边缘缓存，然后上传到云端</p>
</li>
</ol>
<h2 id="W9-无线传感器-Wireless-Sensors"><a href="#W9-无线传感器-Wireless-Sensors" class="headerlink" title="W9 无线传感器 Wireless Sensors"></a>W9 无线传感器 Wireless Sensors</h2><p>无线传感器是一种感知物理现象（如噪声、运动、光、压力或温度）并将这些物理参数转换为可由设备处理的电子信号的设备</p>
<p>无线传感器然后将感测到的数据<strong>无线传输</strong>到另一个设备</p>
<img src="/post/fit5046-mobi-notes/image-20210604142704800.png" class="" title="image-20210604142704800">

<h3 id="电源Power"><a href="#电源Power" class="headerlink" title="电源Power"></a>电源Power</h3><p>负责提供能量</p>
<ul>
<li>电池供电<ul>
<li>最终需要更换电池但基本上用不完</li>
<li>需要能源管理以减少电池消耗</li>
</ul>
</li>
<li>能量收集<ul>
<li>从环境和其他来源中提取能量<ul>
<li>太阳能</li>
<li>机械能：风力、水流或振动</li>
<li>热能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传感器网络-Wireless-Sensor-Networks-WSNs"><a href="#传感器网络-Wireless-Sensor-Networks-WSNs" class="headerlink" title="传感器网络 Wireless Sensor Networks (WSNs)"></a>传感器网络 Wireless Sensor Networks (WSNs)</h3><p>无线传感器网络由大量传感器节点组成，这些节点密集部署在一个区域内，以实现对物理世界的监控</p>
<p>对许多应用领域都很重要</p>
<h3 id="传感器节点-Sensor-Nodes"><a href="#传感器节点-Sensor-Nodes" class="headerlink" title="传感器节点 Sensor Nodes"></a>传感器节点 Sensor Nodes</h3><p>在 WSN 中，节点感知和观察物理现象</p>
<ul>
<li>节点通过无线链路（无线电）将收集到的信息传送到通常的接收器&#x2F;基站</li>
<li>每个传感器都有能力收集和路由数据</li>
<li>通常传感器管理协议确定哪些节点感知以及哪些节点路由数据以确保能源效率</li>
<li>节点具有最少的 CPU、内存和极低的功耗</li>
</ul>
<h3 id="接收器-Sink"><a href="#接收器-Sink" class="headerlink" title="接收器 Sink"></a>接收器 Sink</h3><p>传感器收集的数据通常转发到接收器</p>
<p>与传感器不同，接收器拥有大量资源（内存、CPU、存储、电源）</p>
<p>一个接收器可以在本地使用数据，执行简单的数据处理，或者它可以作为连接到互联网的网关（遥感）</p>
<p>接收器可以向节点发送查询或命令以收集数据</p>
<h3 id="传感器操作模式-Sensor-Operation-Modes"><a href="#传感器操作模式-Sensor-Operation-Modes" class="headerlink" title="传感器操作模式 Sensor Operation Modes"></a>传感器操作模式 Sensor Operation Modes</h3><p>传感器的处理器、收发器和传感部件可以处于不同的操作模式</p>
<ul>
<li>例如。 主动、睡眠或深度睡眠</li>
<li>通过根据当前情况和上下文控制传感器的占空比参数，可以减少电池消耗</li>
</ul>
<table>
<thead>
<tr>
<th>Sleep States</th>
<th>Sensing</th>
<th>Radio&#x2F;Transceiver</th>
</tr>
</thead>
<tbody><tr>
<td>S0</td>
<td>On</td>
<td>Both transmitter and receiver ON</td>
</tr>
<tr>
<td>S1</td>
<td>On</td>
<td>Receiver On (Transmitter off)</td>
</tr>
<tr>
<td>S2</td>
<td>On</td>
<td>Both Off</td>
</tr>
<tr>
<td>S3</td>
<td>Off</td>
<td>Both Off</td>
</tr>
</tbody></table>
<h3 id="节点拓扑"><a href="#节点拓扑" class="headerlink" title="节点拓扑"></a>节点拓扑</h3><ul>
<li>Point to Point Topology</li>
<li>Star Topology</li>
<li>Mesh Topology</li>
<li>Tree Topology</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="静态接收器和移动接收器网络"><a href="#静态接收器和移动接收器网络" class="headerlink" title="静态接收器和移动接收器网络"></a>静态接收器和移动接收器网络</h4><p><strong>静态接受器网络</strong>：</p>
<p>靠近感应区域的固定位置的水槽</p>
<p>它可能会导致瓶颈情况</p>
<p>靠近sink的节点很快就会消亡</p>
<p><strong>移动接收器网络</strong></p>
<p>在mobile-sink网络中，sink在区域内移动</p>
<p>它可以解决上述问题</p>
<h4 id="确定性或非确定性网络"><a href="#确定性或非确定性网络" class="headerlink" title="确定性或非确定性网络"></a>确定性或非确定性网络</h4><p>在<strong>确定性网络</strong>中，传感器的位置是预先计划好的。反之不然</p>
<h4 id="同构或异构网络"><a href="#同构或异构网络" class="headerlink" title="同构或异构网络"></a>同构或异构网络</h4><p><strong>同构网络</strong>包括具有相同功能（能量、计算和存储）的传感器</p>
<h4 id="单汇或多汇网络"><a href="#单汇或多汇网络" class="headerlink" title="单汇或多汇网络"></a>单汇或多汇网络</h4><p>在网络中有多个接收器的多个接收器中，传感器可以将数据发送到最近的接收器</p>
<p>它会增加复杂性和成本，但会提高性能</p>
<h4 id="单跳或多跳无线传感器网络"><a href="#单跳或多跳无线传感器网络" class="headerlink" title="单跳或多跳无线传感器网络"></a>单跳或多跳无线传感器网络</h4><p>（例题考点，估计考边上的其他几种）</p>
<p><strong>单跳网络</strong></p>
<p>长距离，因此在能源消耗方面更昂贵</p>
<p>适用于短覆盖和节点有限的网络</p>
<p>更易于控制和管理</p>
<p><strong>多跳网络</strong></p>
<p>传感器节点通过一个或多个中间节点将其数据传输到接收器</p>
<p>它涉及短距离传输，因此更节能</p>
<p>管理可能很复杂</p>
<p>适用于更大的网络</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><strong>多跳传感器网络</strong>可以分为两种类型：</p>
<ul>
<li><p>平面传感器网络</p>
</li>
<li><p>基于集群的传感器网络</p>
</li>
</ul>
<h4 id="平面多跳架构"><a href="#平面多跳架构" class="headerlink" title="平面多跳架构"></a>平面多跳架构</h4><p>所有传感器节点具有相同的角色并充当对等体</p>
<p>在这样的网络中，sink 通常向所有节点发送查询，只有数据满足查询的节点才会响应</p>
<p>传感器节点也可以充当路由器，通过多跳路由将数据传输到接收器，使用它们的对等节点来中继数据</p>
<h4 id="基于集群的多跳架构"><a href="#基于集群的多跳架构" class="headerlink" title="基于集群的多跳架构"></a>基于集群的多跳架构</h4><p>传感器节点被分组到集群中</p>
<p>每个簇有一个簇头（CH）</p>
<p>每个集群中的传感器节点向其 CH 发送数据</p>
<p>CH进行简单的处理，将处理后的数据发送给sink</p>
<p>减少通信方面的能源消耗</p>
<p>提高大型网络的可扩展性并平衡流量负载</p>
<h4 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h4><p>“最佳”路线可以是特定于应用程序的</p>
<p>就能源消耗而言，它可以是延长网络寿命的最有效途径</p>
<p>它可以是最短路径和最小跳数</p>
<h5 id="Flooding-and-Gossiping"><a href="#Flooding-and-Gossiping" class="headerlink" title="Flooding and Gossiping"></a>Flooding and Gossiping</h5><p>Flooding是最简单的路由技术</p>
<p>节点将数据广播给它的邻居，然后再将数据转发给邻居，直到它到达接收器</p>
<ul>
<li>Flooding导致内爆和重叠，因为节点可以接收相同数据消息的多个副本</li>
<li>网络内浪费能源和带宽</li>
</ul>
<p>Gossiping：接收节点只向随机选择的邻居广播数据</p>
<ul>
<li>它减少了内爆，但仍有一些节点可能会收到相同的数据副本</li>
</ul>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><ul>
<li><p>基于集群的路由（已经讨论过）</p>
</li>
<li><p>基于属性的路由</p>
</li>
<li><p>基于位置的路由</p>
</li>
<li><p>以数据为中心的路由</p>
</li>
<li><p>定向扩散</p>
</li>
<li><p>基于能量的路由</p>
</li>
<li><p>服务质量 (QoS) 路由</p>
</li>
</ul>
<p>这些路由方法有时会重叠</p>
<h5 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h5><p><strong>基于属性值的路由</strong></p>
<ul>
<li>感知数据包括属性值对</li>
<li>接收器可以发送一个查询来表达它的“兴趣”</li>
<li>匹配“兴趣”的数据将被检索并发送回接收器</li>
</ul>
<p><strong>基于位置的路由</strong></p>
<ul>
<li>位置被视为查询的一个属性</li>
<li>使用位置信息来选择路线</li>
<li>根据节点的位置限制路由</li>
<li>节点可以维护一个路由表来识别下一跳</li>
</ul>
<h5 id="以数据为中心的路由和网络内处理"><a href="#以数据为中心的路由和网络内处理" class="headerlink" title="以数据为中心的路由和网络内处理"></a>以数据为中心的路由和网络内处理</h5><p>以数据为中心的路由：中间节点执行网络内处理</p>
<ul>
<li>网络内处理可能涉及：<ul>
<li>数据聚合或平均</li>
<li>过滤掉冗余&#x2F;重复数据</li>
</ul>
</li>
<li>基于处理比通信更耗能的事实</li>
</ul>
<h5 id="网络内处理好处"><a href="#网络内处理好处" class="headerlink" title="网络内处理好处"></a>网络内处理好处</h5><ul>
<li>可以防止瓶颈问题</li>
<li>解决了内爆问题（和重复）</li>
<li>通过最小化传输的数据量来降低能耗，从而延长网络寿命</li>
</ul>
<h5 id="定向传播：广播兴趣"><a href="#定向传播：广播兴趣" class="headerlink" title="定向传播：广播兴趣"></a>定向传播：广播兴趣</h5><p>它是一个基于属性值的协议</p>
<p>由三个主要步骤组成：</p>
<ul>
<li>兴趣传播</li>
<li>梯度建立</li>
<li>沿加强路径传输数据</li>
</ul>
<p>扩散：接收器将通过网络扩散（广播）它的“兴趣”</p>
<ul>
<li><p>使用属性值对将兴趣转换为查询</p>
</li>
<li><p>一个例子：</p>
<p>利息 &#x3D; 温度 &gt; 40</p>
<p>采样周期 &#x3D; 10s</p>
</li>
</ul>
<h5 id="定向扩散：梯度建立"><a href="#定向扩散：梯度建立" class="headerlink" title="定向扩散：梯度建立"></a>定向扩散：梯度建立</h5><p>任何收到兴趣的节点都会将兴趣进一步传播给邻居</p>
<p>梯度建立：节点向收到兴趣的邻居建立梯度（即回复链接）</p>
<p>源节点是与兴趣匹配的节点</p>
<p>传感器检测到的数据示例</p>
<ul>
<li>事件 &#x3D; 温度 41</li>
<li>位置 &#x3D; 矩形 &#x3D; [-100, 100, 200, 400]</li>
</ul>
<h5 id="定向扩散：强化"><a href="#定向扩散：强化" class="headerlink" title="定向扩散：强化"></a>定向扩散：强化</h5><p>从源到接收器可能有几条路径</p>
<p>传感器网络加强了一个梯度路径</p>
<p>例如。 加强路径可以基于最短路径</p>
<h5 id="能源集约型路由"><a href="#能源集约型路由" class="headerlink" title="能源集约型路由"></a>能源集约型路由</h5><p>基于能量的路由方案侧重于确定最有效的路径</p>
<p>可以考虑节点的能源等级</p>
<p>目的是延长网络生命周期</p>
<h5 id="多路径路由和能源效率"><a href="#多路径路由和能源效率" class="headerlink" title="多路径路由和能源效率"></a>多路径路由和能源效率</h5><p>将查询从 Sink 路由到 T</p>
<img src="/post/fit5046-mobi-notes/image-20210604235524113.png" class="" title="image-20210604235524113">

<ul>
<li><p>PA 是可用功率</p>
</li>
<li><p>α是通过相关路由传输数据包所需的能量</p>
</li>
</ul>
<img src="/post/fit5046-mobi-notes/image-20210604235529057.png" class="" title="image-20210604235529057">

<p>最低能量路线：Route 1 （α最小）</p>
<p>最小跳数路由：Route 3</p>
<h5 id="服务质量-QoS-路由"><a href="#服务质量-QoS-路由" class="headerlink" title="服务质量 (QoS) 路由"></a>服务质量 (QoS) 路由</h5><p>在 WSN 中，应用程序可能有不同的要求</p>
<p>除了讨论的路由选项之外，QoS routing 还可以关注其他标准</p>
<p>QoS routing旨在平衡数据质量和能耗以实现路由优化</p>
<p>网络质量可以包括 QoS metrics，例如：</p>
<ul>
<li>能源（节能路由），</li>
<li>成功交付率（丢包）</li>
<li>延迟</li>
<li>网络带宽</li>
</ul>
<h3 id="遥感-通信"><a href="#遥感-通信" class="headerlink" title="遥感-通信"></a>遥感-通信</h3><p>传感器节点和接收器之间通信的无线技术：</p>
<ul>
<li>ZigBee (IEEE 802.15.4)</li>
<li>蓝牙 (IEEE 802.15.1)</li>
<li>WiFi(IEEE 802.11x)</li>
</ul>
<p>接收器和远程计算机之间通信的其他通信选项：</p>
<ul>
<li>4G 和 5G 等蜂窝网络</li>
<li>卫星通讯</li>
<li>无线网络 WiMAX</li>
</ul>
<h2 id="W10-位置感知计算-Location-Aware-Computing"><a href="#W10-位置感知计算-Location-Aware-Computing" class="headerlink" title="W10 位置感知计算 Location Aware Computing"></a>W10 位置感知计算 Location Aware Computing</h2><p>全考</p>
<ul>
<li>Location-aware Computing</li>
<li>GPS</li>
<li>室内定位系统 Indoor Positioning Systems (IPS)</li>
<li>Applications</li>
</ul>
<p>定义</p>
<ul>
<li>室内外定位系统用于确定物体或人的精确物理位置</li>
<li>位置感知应用程序从定位系统获取位置信息</li>
<li>位置感知应用程序用于许多领域：<ul>
<li>运输、军事、营销和广告、快递服务、旅游、跟踪和监控应用</li>
</ul>
</li>
</ul>
<p>纬度和经度可以表示为：</p>
<ul>
<li><p>十进制度</p>
<ul>
<li><p>一度等于大约 70 英里</p>
</li>
<li><p>例如。 莫纳什考菲尔德校区：</p>
<p>-37.876823, 145.045837</p>
<p>37.876823°S, 145.045837°E</p>
</li>
</ul>
</li>
<li><p>度、分和秒 (DMS)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Latitude</td>
<td>-37.876823</td>
</tr>
<tr>
<td>Longitude</td>
<td>145.045837</td>
</tr>
<tr>
<td>DMS Lat</td>
<td>37°52’ 36.5628’’ S</td>
</tr>
<tr>
<td>DMS Lon</td>
<td>145°2’ 45.0132’’ E</td>
</tr>
</tbody></table>
<p><strong>三边测量和三角测量</strong></p>
<ul>
<li>Lateration 边（三边测量 Trilateration）：通过测量物体与多个参考位置的距离来计算物体的位置</li>
<li>Angulation 角度（三角测量 Triangulation):）：使用距离和角度（三角形的几何特性）来确定对象的位置</li>
</ul>
<p>（就是画圆和画线求交点，如果有误差那就是交区</p>
<h3 id="GPS架构"><a href="#GPS架构" class="headerlink" title="GPS架构"></a>GPS架构</h3><ul>
<li>GPS卫星</li>
<li>GPS接收器</li>
<li>地面站：跟踪和监控 GPS 卫星及其传输、执行分析以及更新时钟和卫星轨道</li>
</ul>
<p>第一颗可操作的 GPS 卫星于 1978 年发射</p>
<p>GPS卫星（Navstar）由美国政府维护</p>
<p>GNSS - 全球导航卫星系统</p>
<p>其他卫星导航系统，如俄罗斯的 GLONASS、欧洲的伽利略和中国的北斗</p>
<h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p>定位在 MEO（中地球轨道）中的 GPS 卫星</p>
<p>每颗卫星每天绕地球运行两次</p>
<p>卫星排列成 6 个等距环绕地球的轨道平面</p>
<p>最初的 24 槽排列确保几乎从任何角度都能看到至少四颗卫星</p>
<p>目前共有31颗可运行的GPS卫星（2021年1月9日）</p>
<h4 id="GPS的三边测量"><a href="#GPS的三边测量" class="headerlink" title="GPS的三边测量"></a>GPS的三边测量</h4><p>和两个卫星的距离已知，可以画出俩球，俩球交面和地球切出一条线就是可能的位置，这时候再得到个第三个卫星距离（第三个球），该球和线的位置就是实际位置</p>
<p>为了确定位置，GPS 接收器需要知道：</p>
<ul>
<li>四颗或更多卫星的轨道信息和位置</li>
<li>来自需要时钟同步的卫星发射器的无线电信号的<strong>到达时间</strong>：将使用此信息来计算您与每颗卫星之间的<strong>距离</strong></li>
</ul>
<h4 id="计算卫星距离"><a href="#计算卫星距离" class="headerlink" title="计算卫星距离"></a>计算卫星距离</h4><ul>
<li>速度：无线电波以光速传播（真空中每秒约 299,792 公里）</li>
<li>时间：GPS卫星广播信号的传输时间及其当时的位置</li>
<li>卫星使用原子钟</li>
</ul>
<p>距离：接收器可以通过以下方式计算信号传播的距离：</p>
<p>$ 距离&#x3D; （接收器接收信号的时间-卫星发射信号的时间）\times 光速$</p>
<p>为了确定物体的位置，GPS 接收器需要：</p>
<ol>
<li>定位四颗或更多卫星</li>
<li>通过测量卫星和接收器之间信号的传输时间并乘以光速来计算到每个卫星的距离</li>
<li>使用此信息执行三边测量以确定位置</li>
<li>还要考虑并解决接收器的时钟偏差（时间同步）</li>
</ol>
<h3 id="室内定位系统-Indoor-Positioning-Systems-IPS"><a href="#室内定位系统-Indoor-Positioning-Systems-IPS" class="headerlink" title="室内定位系统 Indoor Positioning Systems (IPS)"></a>室内定位系统 Indoor Positioning Systems (IPS)</h3><ul>
<li>虽然 GPS 和户外导航对于许多应用至关重要，但室内定位系统 (IPS) 也可以提供许多用途和好处</li>
<li>此类应用的示例：<ul>
<li>紧急服务（例如在建筑物内定位消防员）</li>
<li>基于位置的广告，例如 在购物中心或机场</li>
<li>寻找博物馆的兴趣点</li>
<li>事件或库存管理</li>
<li>医院室内导航</li>
<li>手推车跟踪</li>
</ul>
</li>
</ul>
<p>使用无线通信技术的IPS：</p>
<ul>
<li>无线上网</li>
<li>蓝牙</li>
<li>红外线 (IR)</li>
<li>射频识别 (RFID)</li>
<li>超声波脉冲</li>
<li>蜂窝网络</li>
<li>LiFi</li>
</ul>
<p>IPS 可以使用从以下位置收集的其他数据：</p>
<ul>
<li>罗盘</li>
<li>陀螺仪（测量方向）</li>
<li>加速度计</li>
<li>里程表</li>
<li>气压计（测量大气压力）</li>
</ul>
<h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>RSS（接收信号强度）是对接收到的无线信号强度的测量</p>
<p>RSS 和 TOA（到达时间）广泛用于室内定位，例如 WiFi 三边测量和 WiFi 指纹识别</p>
<p>WiFi 三边测量使用 WiFi 信号强度 (RSS) 信息、WiFi 接入点 (AP) 的位置和 MAC 地址来计算移动设备与 AP 的距离，然后执行三边测量来计算设备的室内位置</p>
<h3 id="位置指纹识别-Location-Fingerprinting"><a href="#位置指纹识别-Location-Fingerprinting" class="headerlink" title="位置指纹识别 Location Fingerprinting"></a>位置指纹识别 Location Fingerprinting</h3><p>指纹识别使用RSS，由在线和离线阶段组成</p>
<ul>
<li>离线阶段：在该区域选择一组参考点，并在每个点测量来自 AP 的 RSS 并存储在数据库中以表示该区域的无线电地图</li>
<li>在线阶段：测量移动站的 RSS 并与数据库中的测量值进行比较，以找到最相似的指纹以估计设备的位置</li>
</ul>
<p>例: Microsoft RADAR</p>
<h3 id="用于室内定位的-LiFi"><a href="#用于室内定位的-LiFi" class="headerlink" title="用于室内定位的 LiFi"></a>用于室内定位的 LiFi</h3><p>Li-Fi 是一种可见光通信 (VLC) 技术，使用 LED 以光的形式传输高速数据。 使用可见光的光通信的 IEEE 802.15.7 标准，可以比 WiFi 更快更便宜</p>
<p>数据通过 LiFi 发送，通过调制 LED 发出的光（速度太快以至于人类无法注意到）</p>
<ul>
<li><p>LED 部署在预定的固定位置</p>
</li>
<li><p>传输的数据包括：i) 确定发射器坐标的发送方 ID 和 ii) 确定距离的时间戳</p>
</li>
<li><p>发送方和接收方的时钟必须同步</p>
</li>
<li><p>使用三边测量或三角测量计算位置</p>
</li>
</ul>
<h3 id="主动蝙蝠系统"><a href="#主动蝙蝠系统" class="headerlink" title="主动蝙蝠系统"></a>主动蝙蝠系统</h3><p>主动蝙蝠向天花板上的接收器发送超声波脉冲</p>
<p>距离是根据飞行时间（ToF）确定的</p>
<p>信号发射与反射后返回发送端的时间差</p>
<p>然后根据三边测量原理，通过计算主动蝙蝠到 3 个或更多接收器的距离来确定位置</p>
<h3 id="板球系统，MIT"><a href="#板球系统，MIT" class="headerlink" title="板球系统，MIT"></a>板球系统，MIT</h3><p>安装在天花板上的信标发射超声波脉冲和射频信号</p>
<p>移动设备上的听众接收射频信号，然后接收超声波脉冲</p>
<p>听者估计对应信标的距离，然后进行三边测量</p>
<h3 id="位置感知钟"><a href="#位置感知钟" class="headerlink" title="位置感知钟"></a>位置感知钟</h3><p>论文：行踪钟 Whereabouts Clock（Brown，2007）</p>
<ul>
<li>钟面显示家庭成员的当前位置</li>
<li>它使用手机上可用的手机 ID 来提供位置数据</li>
</ul>
<h3 id="地理围栏"><a href="#地理围栏" class="headerlink" title="地理围栏"></a>地理围栏</h3><p>将有关用户当前位置的信息与用户与感兴趣位置的接近程度相结合</p>
<p>地理围栏 &#x3D; 位置（纬度和经度）+ 接近度（半径）</p>
<p>地理围栏可以使用您移动设备的定位服务来获取您进入或退出时（或您在地理围栏区域内停留的时间）的信息</p>
<p>它可以向用户的移动设备发送广告，例如 特别优惠信息、提醒、优惠券或其他信息</p>
<h2 id="W12-移动传输技术-Mobile-Communication-Technologies"><a href="#W12-移动传输技术-Mobile-Communication-Technologies" class="headerlink" title="W12 移动传输技术 Mobile Communication Technologies"></a>W12 移动传输技术 Mobile Communication Technologies</h2><p>全考</p>
<ul>
<li>无线电radio基础</li>
<li>IEEE 802.11 标准和 WiFi</li>
<li>无线个域网 Wireless Personal Area Networks (WPAN) (IEEE 802.15)<ul>
<li>蓝牙 (IEEE 802.15.1)</li>
<li>ZigBee (IEEE 802.15.4)</li>
</ul>
</li>
<li>射频识别 RFID</li>
<li>WiMAX (IEEE 802.16)</li>
<li>蜂窝网络 Cellular Networks</li>
</ul>
<h3 id="无线电radio基础"><a href="#无线电radio基础" class="headerlink" title="无线电radio基础"></a>无线电radio基础</h3><ul>
<li>无线电波radio wave使无线通信和网络成为可能</li>
<li>无需电缆，信号通过空气传输</li>
<li>无线电波是一种电磁辐射</li>
<li>电磁辐射具有三个重要特性：<ul>
<li>频率：每秒周期数(Hz)</li>
<li>波长：峰间距离</li>
<li>能量：在光子中发现的能量</li>
</ul>
</li>
</ul>
<p>工业、科学和医疗 (ISM) 包括国际保留的无线电频段，无需许可即可使用</p>
<p>FCC（联邦通信委员会）在 5 GHz 范围内引入了新频段（UNII-1、UNII-2、UNII-3</p>
<p>【UNII &#x3D;（未经许可的国家信息基础设施）</p>
<h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3><p>IEEE 802.11 是一组用于定义和实现无线局域网 (WLAN) 通信的标准</p>
<h4 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h4><ol>
<li>基础设施网络：无线客户端通过无线接入点 (AP) 相互通信</li>
<li>Ad Hoc Network：临时建立的去中心化点对点网络。例如。 在自然灾害等紧急情况下或在员工之间的会议室中</li>
</ol>
<p>Wi-Fi Direct：让 Wi-Fi 设备在没有互联网连接的情况下以简单方便的方式相互连接</p>
<h4 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h4><ul>
<li>基站 Station (STA)：无线&#x2F;移动客户端，例如笔记本电脑或智能手机</li>
<li>接入点 Access Point (AP)：使 STA 与骨干网之间的通信成为可能</li>
<li>基本服务集 Basic Service Set（BSS）：是由支持多个STA的单个无线AP组成的无线网络<ul>
<li>客户端站之间不直接通信</li>
</ul>
</li>
<li>分布式系统 Distribution System（DS）：连接两个或多个 AP 并扩展 BSS。</li>
<li>扩展服务集 Extended Service Set (ESS)：由多个互连的基本服务集 (BSS) 组成，连接到同一有线网络骨干网</li>
<li>独立基本服务集 Independent basic service set（IBSS）：ad hoc模式下的STA形成IBSS，无法接入无线AP<br><a href="https://technet.microsoft.com/pt-pt/library/cc757419(v=ws.10).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/pt-pt/library/cc757419(v=ws.10).aspx</a></li>
</ul>
<h4 id="无线分配系统-Wireless-Distribution-System-WDS"><a href="#无线分配系统-Wireless-Distribution-System-WDS" class="headerlink" title="无线分配系统 Wireless Distribution System (WDS)"></a>无线分配系统 Wireless Distribution System (WDS)</h4><p>WDS 是指两个或多个相互连接的无线 AP</p>
<ul>
<li>无线桥接 Wireless Bridging，其中无线 AP 相互通信，并作为路由器与其他移动客户端通信</li>
<li>无线中继 Wireless Repeating，其中无线 AP 仅相互通信（作为中继器），扩展现有 AP 的无线覆盖范围</li>
</ul>
<img src="/post/fit5046-mobi-notes/image-20210605164634294.png" class="" title="image-20210605164634294">

<img src="/post/fit5046-mobi-notes/image-20210605164642991.png" class="" title="image-20210605164642991">

<h4 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h4><p>Wi-Fi 是 WiFiAlliance 的商标<br>“……基于电气和电子工程师协会 (IEEE) 802.11 标准的无线局域网 (WLAN) 产品”（Wi-Fi 联盟）</p>
<p>WiFiAlliance 是一个贸易协会，致力于推广和认证符合特定互操作性标准的产品</p>
<ul>
<li>802.11a：由于在高频 5GHz 频段上运行，数据速率更高，但墙壁和其他物理障碍物对信号的吸收更多</li>
<li>802.11b：在 2.4 GHz 频段运行以解决衰减问题</li>
<li>802.11g：在 2.4 GHz 频段运行，但数据速率更高</li>
<li>802.11n (WiFi4)：在 2.4GHz 和 5GHz 频段上运行，数据速率更高</li>
<li>802.11ac (WiFi5)：在 5GHz 频段上运行，数据速率更高</li>
<li>802.11ad (WiGig)：在 60GHz 频段上运行，速度非常快，距离短</li>
<li>802.11ah：工作在900MHz频段，支持物联网</li>
<li>802.11ax (WiFi6)：在 2.4GHz 或 5GHz 以及 6 GHz 频段上运行</li>
</ul>
<img src="/post/fit5046-mobi-notes/image-20210605165212828.png" class="" title="image-20210605165212828">

<h3 id="无线个域网-Wireless-Personal-Area-Networks-WPAN-IEEE-802-15"><a href="#无线个域网-Wireless-Personal-Area-Networks-WPAN-IEEE-802-15" class="headerlink" title="无线个域网 Wireless Personal Area Networks (WPAN) (IEEE 802.15)"></a>无线个域网 Wireless Personal Area Networks (WPAN) (IEEE 802.15)</h3><h4 id="IEEE-802-15"><a href="#IEEE-802-15" class="headerlink" title="IEEE 802.15"></a>IEEE 802.15</h4><p>由 IEEE 802.15 Task Group 管理的无线个人区域网络 (WPAN) 的一系列通信规范</p>
<ul>
<li>任务组 1：IEEE 802.15.1（蓝牙）</li>
<li>任务组 2：IEEE 802.15.2-2003: 提供互操作性并解决 WPAN 和 WLAN 共存的问题</li>
<li>任务组 3：IEEE 802.15.3（高速 WPAN）: 支持实时视频和音乐，更好的电源管理</li>
<li>任务组 4：IEEE 802.15.4（低速率 WPAN）：<ul>
<li>非常低带宽、低能耗的家庭通信（例如遥控器、警报）、WSN</li>
<li>ZigBee 的基础</li>
</ul>
</li>
<li>任务组 5：IEEE 802.15.5（网状网络）</li>
<li>任务组 6：IEEE 802.15.6：人体内外的短距离、低功耗和高度可靠的无线通信<ul>
<li>支持无线体域网 (BAN) 中的通信</li>
</ul>
</li>
<li>任务组 7：IEEE 802.15.7 使用可见光的光通信标准: <ul>
<li>Li-Fi 是一种可见光通信 (VLC) 技术，使用 LED 以光的形式传输高速数据</li>
</ul>
</li>
</ul>
<h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>一种短距离无线通信技术和标准，2002 年标准化为 IEEE 802.15**.1**</p>
<p>短程、低功耗、高效</p>
<p>在 <strong>2.4 GHz ISM 频段 (2402-2480 MHz)</strong> 上运行</p>
<p>最初旨在成为 RS-232 的无线替代品</p>
<p>广泛的应用</p>
<h4 id="ZigBee"><a href="#ZigBee" class="headerlink" title="ZigBee"></a>ZigBee</h4><p>基于 IEEE 802.15**.4** 的低速率 WPAN（无线个人区域网络）标准</p>
<p>在 <strong>868 MHz 和 915 (900-928) MHz 频段</strong>上运行</p>
<p>ZigBee 的好处：</p>
<ul>
<li><p>易于设置和维护（网格、自组织）</p>
</li>
<li><p>可靠性（自我恢复）</p>
</li>
<li><p>能够扩展到数千个设备（节点）</p>
</li>
<li><p>电池寿命长</p>
</li>
<li><p>低成本</p>
</li>
</ul>
<h4 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h4><p>RFID（射频识别）是一种电子标签&#x2F;识别技术，便于自动识别</p>
<p>它的工作原理是在阅读器和标签之间交换电磁信号</p>
<p>[125 KHz, 5.8 GHz]</p>
<p>RFID 系统也可能不受 125 KHz 和 5.8 GHz 的限制。 系统<br>也正在为这个范围之外的频率开发</p>
<p>应答器&#x2F;标签的类型</p>
<ul>
<li>被动：无内部电源</li>
<li>半被动：他们有自己的电源（一个小电池），只为微芯片供电</li>
<li>主动：它们有发射器和内部电源（板载电池）来为微芯片供电并将信号传输到阅读器</li>
</ul>
<p>基本形式的 RFID 系统包含以下内容:</p>
<p>Reader: 阅读器发送用于为标签供电&#x2F;唤醒的微弱信号（一种能量形式）。 然后标签将其微芯片上的信息传输回阅读器。</p>
<p>Tag&#x2F;transponder: 带有硅芯片的设备，盘绕天线（Coiled Antenna）</p>
<ul>
<li><p>近距离访问控制（卡和钥匙扣）</p>
</li>
<li><p>护照</p>
</li>
<li><p>收费</p>
</li>
<li><p>运输和物流</p>
</li>
<li><p>医院和医疗保健</p>
</li>
<li><p>牲畜和野生动物追踪</p>
</li>
<li><p>零售</p>
</li>
<li><p>供应链</p>
</li>
<li><p>资产追踪</p>
</li>
<li><p>库存系统</p>
</li>
</ul>
<p>（本科时候图书馆里的书籍管理、借阅</p>
<h3 id="IEEE-802-16-and-WiMAX"><a href="#IEEE-802-16-and-WiMAX" class="headerlink" title="IEEE 802.16 and WiMAX"></a>IEEE 802.16 and WiMAX</h3><p>IEEE 802.16 是用于大型城市无线网络的无线 MAN（城域网）标准系列</p>
<p>WiMAX（微波接入全球互操作性）是 IEEE 802.16 标准的商业名称</p>
<p>WiMAX 在不同国家的不同频段上运行； 通常在2.3 GHz、2.5 GHz、3.5 GHz、5.8 GHz频段</p>
<p>IEEE 802.16 标准最初针对固定无线宽带接入技术（Fixed WiMAX）</p>
<p>后来在移动 WiMAX 中考虑了移动性支持，这是一种广域无线网络技术</p>
<p>移动 WiMAX，一种用于 4G 的竞争技术</p>
<h4 id="Fixed-WiMAX-架构"><a href="#Fixed-WiMAX-架构" class="headerlink" title="Fixed WiMAX 架构"></a>Fixed WiMAX 架构</h4><p>WiMAX 基站 (BS)：连接到公共网络</p>
<p>用户站（SS）：通常为建筑物提供服务</p>
<p>覆盖“最后一公里”区域：为普通有线技术无法覆盖的区域提供高速互联网接入</p>
<h3 id="Cellular-Networks"><a href="#Cellular-Networks" class="headerlink" title="Cellular Networks"></a>Cellular Networks</h3><p>蜂窝网络，贝尔实验室（1957 -1960）</p>
<p>在蜂窝网络中，地理覆盖区域通常被划分为小区，用六边形表示</p>
<p>多个用户如何可以同时共享同一个链接而不受干扰？</p>
<ul>
<li>频分多址 Frequency-Division Multiple Access (FDMA)</li>
<li>时分多址 Time-Division Multiple Access (TDMA)</li>
<li>码分多址 Code Division Multiple Access (CDMA)</li>
<li>直接序列扩频 Direct-sequence spread spectrum (DSSS)</li>
<li>跳频扩频 Frequency-hopping spread spectrum (FHSS)</li>
<li>正交频分复用 Orthogonal Frequency Division Multiplexing (OFDM)</li>
</ul>
<h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><p>Question 1. Which of the following statements is NOT true about a multi-hop sensor network?</p>
<p>A. It makes it easy to control and manage the network.</p>
<p>B. It involves transmission over short distances.</p>
<p>C. It involves one or more intermediate nodes along the path that receive and forward packets.</p>
<p>D. It can quickly drain the battery of the nodes close to the sink.</p>
<p>答案A，错选BD。</p>
<p>A是单跳的</p>
<p>多跳网络描述：</p>
<ul>
<li><p>传感器节点通过一个或多个中间节点将其数据传输到接收器（C对）</p>
</li>
<li><p>它涉及短距离传输，因此更节能（B对）</p>
</li>
<li><p>管理可能很复杂（和A相反）</p>
</li>
<li><p>适用于更大的网络</p>
</li>
</ul>
<p>D需要理解。</p>
<img src="/post/fit5046-mobi-notes/image-20210605215713114.png" class="" title="image-20210605215713114">

<p>如图，多跳下，不管怎么跳肯定要跳到最上面的三个上面。</p>
<img src="/post/fit5046-mobi-notes/image-20210605215749334.png" class="" title="image-20210605215749334">

<p>单跳就不用。</p>
<p>所以多跳时候上面三个更closer的就更费电</p>
<p>Question 2. Which of the following statements is NOT true about a ViewGroup?</p>
<p>A. A ViewGroup is a special view that can contain other views.</p>
<p>B. A ViewGroup is the base class for widgets, which are used to create interactive UI components.</p>
<p>C. A ViewGroup is the base class for layouts and views containers.</p>
<p>D. The ViewGroup is a subclass of View.</p>
<p>答案B，错选CD。</p>
<p>W2内容</p>
<p>ViewGroup是结构上的底层概念，本质上是没有UI的一个概念体。具体形状由View负责。因此B里面作为UI组件的基类是明显不对的，C说法正确。D搜出来的确对的，ViewGroup extends View</p>
<p>ViewGroup 是 View 类的特殊子类，用作多个 View 的容器。 有几个有用的小部件可以扩展 ViewGroup 类。 大多数实际上是另一个称为Layout（的 ViewGroup） 的子类。</p>
<p>Question 4. Which of the following Kotlin code examples is CORRECT?</p>
<p>A. var num:Int</p>
<p>B. var Int:num &#x3D; 1</p>
<p>C. var num:Int &#x3D; null</p>
<p>D. var num &#x3D; 1</p>
<p>答案D，错选AD。</p>
<p>因为在playground测试了A是可以的（只要后面有用值初始化</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i: <span class="built_in">Int</span></span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>精C玩家震怒。这里就只能当是错的吧</del></p>
<p>错误原因见[空值](#空值安全 Null Safe)和前面那个lateinit。因为没?也没lateinit声明所以A就不正确</p>
<p>考试又考了一遍，正确答案就在空值部分例子里</p>
]]></content>
      <tags>
        <tag>android</tag>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5136: Software engineering</title>
    <url>/post/fit5136-se-notes/</url>
    <content><![CDATA[<p>FIT5136个人感觉应该是S1这学期里理论知识上收获最大的一门课（实践最多的是FIT5046安卓开发）</p>
<span id="more"></span>

<h2 id="W1-Introduction"><a href="#W1-Introduction" class="headerlink" title="W1: Introduction"></a>W1: Introduction</h2><p>SE: 一门工程学科，涉及从最初的概念到操作和维护的软件生产的所有方面。</p>
<p>CS vs SE：计算机科学侧重于理论和基础； 软件工程关注开发和交付有用的软件的实用性</p>
<p>重要性：</p>
<p>• 本身就是一门学科<br>• 越来越多的系统由软件控制，因此正确设计软件并不是一个坏主意<br>• 所有发达国家的经济都依赖于软件<br>• 软件成本通常在计算机系统成本中占主导地位<br>• 延迟和失败的项目需要更多的成本、时间和资源<br>• 需要能够经济快速地生产可靠且值得信赖的 (!) 系统<br>• 从长远来看，为软件系统使用软件工程技术和方法比仅仅为编程项目编写程序更便宜<br>• 尽管它很重要，但仍然没有一个明确的定义！</p>
<p>好软件的属性：</p>
<ul>
<li><strong>可维护性</strong>：软件应该以这样的方式编写，以便它可以发展以满足客户不断变化的需求。</li>
<li><strong>可靠性和安全性</strong>：不应在系统故障时造成物理或经济损失。 恶意用户不应能够访问或损坏系统。</li>
<li><strong>效率</strong>：不应浪费系统资源，例如内存和处理器周期——响应能力、处理时间、内存利用率等。</li>
<li><strong>可接受性</strong>：必须能够被其设计的用户类型所接受。 必须易于理解、可用并与他们使用的其他系统兼容。</li>
</ul>
<p>囊括：</p>
<ul>
<li>人：Team， Client， Users</li>
<li>围绕软件生命周期的过程：Agile， Waterfall</li>
<li>技术：例如platforms，object-oriented design&#x2F;models，languages，methods (testing)，tools (IDE)</li>
</ul>
<p>Software Engineering Body of Knowledge (SWEBOK6)</p>
<p>软件工程师需要了解以下大部分（如果不是全部）：<br>• 软件要求<br>• 软件设计和构建<br>• 软件质量和测试<br>• 软件维护<br>• 软件配置管理<br>• 软件工程管理<br>• 软件工程模型和方法<br>• 软件工程专业实践<br>• 软件工程经济学<br>• 计算、数学和工程方面的基础知识</p>
<p>经济角度：</p>
<ul>
<li>软件成本通常高于硬件成本</li>
<li>软件的维护成本高于开发成本<ul>
<li>对于长寿命系统，维护成本可能是开发成本的几倍。</li>
</ul>
</li>
<li>软件工程关注具有成本效益的软件开发</li>
</ul>
<p>软件过程：</p>
<p>• 开发软件系统所需的一组结构化活动<br>• 将任务分解为更小的步骤<br>• 许多不同类型的软件过程，但所有过程都涉及以下活动：</p>
<ol>
<li>需求和分析（规范）——定义系统应该做什么</li>
<li>设计和实现——定义系统应该如何做，组织制度和执行制度</li>
<li>系统验证和确认——检查它是否符合客户的要求</li>
<li>革新（维护）——改变系统以响应不断变化的需求</li>
</ol>
<p>付出和成本</p>
<ul>
<li>糟糕的软件只能运行一次<ul>
<li>不能重复使用、回收或进化。</li>
<li>对团队和公司不利</li>
</ul>
</li>
<li>好的软件会进化，成为更大系统的一部分，更容易集成到另一个系统<ul>
<li>可维持 10、20 年以上！</li>
<li>可以轻松应对需求的变化</li>
<li>可以轻松完成技术（例如数据库）的更改</li>
</ul>
</li>
<li>大部分成本用于在软件投入使用后对其进行更改（扩展和增强）。</li>
<li>在生命周期的早期修复故障更容易、更便宜</li>
<li>软件的维护成本高于开发成本，尤其是对于寿命较长的系统。</li>
</ul>
<p>过程模型</p>
<ul>
<li><strong>计划驱动</strong>的流程<ul>
<li><strong>Waterfall 瀑布生命周期模型</strong> <img src="/post/fit5136-se-notes/image-20210312074837106.png" class="" title="image-20210312074837106"></li>
<li>Rapid prototype 快速原型生命周期模型</li>
</ul>
</li>
<li>增量开发 </li>
<li><strong>敏捷方法论</strong> -&gt;有staff支持，有iteration</li>
<li>统一流程模型 <strong>The unified process model</strong> </li>
<li>同步和稳定模型</li>
<li>螺旋 Spiral  生命周期模型</li>
<li>开源软件开发</li>
</ul>
<h3 id="Code-and-fix"><a href="#Code-and-fix" class="headerlink" title="Code-and-fix"></a>Code-and-fix</h3><p>（也就是solo）的弊端</p>
<p>• 生命周期后期的变更成本要高得多<br>• 无需求、分析、设计阶段——在实施或维护期间捕获所有错误<br>• 没有规范或设计文件，维护极其困难，更容易出现回归故障<br>• 仅适用于有限的情况</p>
<h3 id="Waterfall"><a href="#Waterfall" class="headerlink" title="Waterfall"></a>Waterfall</h3><img src="/post/fit5136-se-notes/image-20210620225755060.png" class="" title="image-20210620225755060">

<p>• 在计划驱动的流程中，所有活动都已计划好，并根据该计划衡量进度。<br>• 瀑布生命周期模型需要有具体的计划来完成项目。 当需求被很好地理解时，可以保证在设计过程中更改是有限的。<br>• 流程没有对错之分，然而，瀑布模型为变化或频繁的客户交互留下了有限的空间。<br>• 对于在多个地点开发系统的大型系统工程项目，瀑布模型的计划驱动性质有助于协调工作。<br>• 移动目标问题使得使用瀑布模型难以保持正轨<br>• 在进入下一阶段之前必须完成一个阶段<br>•（Schach 第 52 页）“一般来说，规范文档很长、很详细，而且坦率地说读起来很无聊”</p>
<p>（就是照本宣科）</p>
<p>不能适应由于公司变更、扩张，客户更改，Feature creep（就不断要求feature）导致的moving-target问题</p>
<p>对软件所做的任何更改都可能导致回归故障（软件明显不相关部分的故障）</p>
<img src="/post/fit5136-se-notes/image-20210620230134919.png" class="" title="image-20210620230134919">

<p>加个带反馈的。</p>
<p>但是仍然不能解决问题</p>
<p>• 在每个阶段结束时，将生成技术文档——例如 UML 图<br>• 这些客户难以理解<br>• 在每个阶段，它没有显示成品将如何工作以及它的外观……<br>• 结果，当客户看到最终产品时……</p>
<h3 id="Rapid-prototype-快速原型生命周期模型"><a href="#Rapid-prototype-快速原型生命周期模型" class="headerlink" title="Rapid prototype 快速原型生命周期模型"></a>Rapid prototype 快速原型生命周期模型</h3><p>原型是系统的初始版本，用于演示概念和尝试设计选项。可用于</p>
<ul>
<li>需求工程（W2</li>
<li>开发 UI 设计的设计流程（W7</li>
<li>在测试中运行黑盒测试（W11</li>
</ul>
<p>快速原型制作 &#x3D; 在功能上等同于产品子集的工作模型</p>
<p>它是面向客户的，客户可以在继续之前就原型提供反馈</p>
<img src="/post/fit5136-se-notes/image-20210620230707043.png" class="" title="image-20210620230707043">

<p>moving-target问题解法：</p>
<ul>
<li>“没有已知的解决方案”<ul>
<li>但是，为更改制作文档将有助于团队和向客户收费</li>
</ul>
</li>
<li>变化是不可避免的<ul>
<li>成长中的公司总是会改变</li>
<li>即便呼吁变革的个人有足够的影响力，依然无能为力</li>
</ul>
</li>
</ul>
<h3 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h3><p>大纲描述：概述系统要求</p>
<p>所有活动都相互<strong>交错</strong>，而不是分开，跨活动快速反馈。</p>
<ul>
<li>需求和分析（规范）</li>
<li>设计和实施（开发）</li>
<li>验证（测试）</li>
</ul>
<p>初始版本：开发初始实施</p>
<p>中间版本：从客户和用户那里获得反馈并通过版本改进软件直到系统开发</p>
<p>每个“增量”包括客户端请求的一些功能。</p>
<p>好处</p>
<ul>
<li>降低适应变化的成本</li>
<li>更容易获得客户对已完成开发工作的反馈</li>
<li>可以更快速地向客户交付和部署有用的软件</li>
</ul>
<p>问题</p>
<ul>
<li>进程不可见。 管理人员需要定期交付成果来衡量进度。 如果系统开发得很快，那么生成反映系统每个版本的文档并不划算。</li>
<li>随着新增量的增加，系统结构趋于退化。 除非将时间和金钱花在重构以改进软件上，否则定期更改往往会破坏其结构，合并进一步的软件更改变得越来越困难且成本高昂。</li>
</ul>
<h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><ul>
<li>基于<strong>增量开发</strong>，敏捷于 1990 年代后期出现，以减少工作软件系统的<strong>交付时间</strong></li>
<li>适用于客户不确定系统规格的情况</li>
<li>快速开发和交付至关重要。 软件必须快速发展以反映不断变化的业务需求。</li>
<li>渐进式发展：<br>o 程序规范、设计和实现是交错的<br>o 客户和用户参与版本规范和评估的一系列版本或增量</li>
<li>广泛的工具支持：例如 自动化测试工具，Trello</li>
<li>最少的文档——专注于工作代码</li>
</ul>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><h5 id="Kanban"><a href="#Kanban" class="headerlink" title="Kanban"></a>Kanban</h5><ul>
<li>看板就是关于<strong>可视化</strong>您的工作、限制正在进行的工作和最大限度地提高效率。</li>
<li>看板团队专注于减少项目从开始到结束所花费的时间。</li>
</ul>
<h5 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h5><ul>
<li>Scrum 是帮助团队合作开发、交付和维持复杂产品的框架</li>
<li>一切都分为<strong>时间</strong>框架</li>
</ul>
<h3 id="统一流程模型"><a href="#统一流程模型" class="headerlink" title="统一流程模型"></a>统一流程模型</h3><p>The Unified Process 重点</p>
<img src="/post/fit5136-se-notes/image-20210620231849874.png" class="" title="image-20210620231849874">

<ul>
<li>一个迭代的、增量的、面向对象的流程模型</li>
<li>对于 FIT5136，我们专注于<strong>统一流程</strong>：（好家伙我到期末一直都以为是用的agile<ul>
<li>学习敏捷概念（右倾</li>
<li>制作一些用于学期内评估的文件（左倾</li>
</ul>
</li>
</ul>
<h3 id="开源软件开发"><a href="#开源软件开发" class="headerlink" title="开源软件开发"></a>开源软件开发</h3><p>略：No standard lifecycle model</p>
<h2 id="W2-需求工程"><a href="#W2-需求工程" class="headerlink" title="W2 需求工程"></a>W2 需求工程</h2><p>基于 IEEE 软件工程术语表</p>
<ol>
<li>用户解决问题或实现目标所需的条件或能力。</li>
<li>系统或系统组件为满足合同、标准、规范或其他正式强制文件而必须满足或拥有的条件或能力。</li>
<li>(1) 或 (2) 中的条件或能力的书面表示。</li>
</ol>
<ul>
<li>定义、记录和维护需求的过程</li>
<li>软件工程过程的一部分</li>
<li>建立客户从系统中要求的服务及其运行和开发的约束的过程。</li>
<li>系统需求是对需求工程过程中产生的系统服务和约束的描述。</li>
<li>客户提供的系统需求通常是非正式的和简短的，因此找到系统详细需求的过程就是需求工程</li>
</ul>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><h4 id="需求的类型"><a href="#需求的类型" class="headerlink" title="需求的类型"></a>需求的类型</h4><ul>
<li>业务：业务需要系统做什么</li>
<li>用户：用户（或客户）要求系统做什么。 用户可以是利益相关者。</li>
<li><strong>Functional 功能性</strong>：系统在功能上应该做什么</li>
<li><strong>Non-functional 非功能性</strong>：系统需要提供的服务质量</li>
<li>约束：系统应该禁止用户做的事情</li>
<li>实现：系统的平台等要求</li>
</ul>
<p>• <strong>完整</strong>需求：  它们应包括实现功能所需的所有设施的描述。<br>• 持续需求：描述中不应有冲突或矛盾。</p>
<p>在实践中，由于系统和环境的复杂性，不可能产生<strong>完整</strong>且<strong>一致</strong>的需求文档。</p>
<h4 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h4><ul>
<li><p><strong>需求</strong>不得含糊不清、不完整和不一致</p>
</li>
<li><p>当<strong>功能性需求</strong>没有被准确表述时就会出现问题。</p>
</li>
<li><p>开发人员和用户可能以不同的方式解释不明确的需求。</p>
<p>例如：考虑“用户应该能够搜索所有郊区的房产。”</p>
<ul>
<li>一种解释：在所有郊区搜索特定的房产。</li>
<li>另一种解释：搜索特定郊区的房产。 用户选择郊区然后搜索。</li>
</ul>
</li>
</ul>
<h4 id="Functional-requirements"><a href="#Functional-requirements" class="headerlink" title="Functional requirements"></a>Functional requirements</h4><p>描述<strong>功能</strong>或<strong>系统服务</strong></p>
<p>描述<strong>系统</strong>应如何对特定输入做出反应以及<strong>系统</strong>在特定情况下应如何运行</p>
<p>表示为<strong>输入</strong>和<strong>输出</strong></p>
<p>例子：</p>
<ul>
<li>用户应能够搜索所有郊区的房产。</li>
<li>每月月底，系统应生成已售或出租的物业清单</li>
<li>每个房地产经纪人都应由他或她的 8 位员工编号唯一标识。</li>
</ul>
<h4 id="Non-functional-requirements"><a href="#Non-functional-requirements" class="headerlink" title="Non-functional requirements"></a>Non-functional requirements</h4><p>• 可用于判断系统运行情况的<strong>特定标准</strong>，而不是特定行为<br>• 系统提供的<strong>服务</strong>或<strong>功能的细节</strong>。 <strong>使系统质量更好的要求</strong>。<br>• 例如，允许的客户数量、密码要求、响应时间、存储要求、I&#x2F;O 设备能力等。</p>
<p>重要性：</p>
<ul>
<li>通常适用于整个系统而不是单个特征或功能。</li>
<li>非功能性需求可能比功能性需求更重要。</li>
<li>如果不满足，则系统可能无法使用。</li>
</ul>
<p>例如</p>
<p>• 物业管理系统应在正常工作时间（周一至周五，08：30-17：30）提供给所有物业代理。<br>• 任何一天内正常工作时间内的停机时间不得超过五秒。<br>• 客户必须使用他们的驾驶执照进行身份验证。<br>• 收到检验请求后，系统必须在 10 秒内回复电子邮件进行确认。<br>• 流程要求，例如 强制要求特定的 IDE、编程语言或开发方法。<br>• 在某些情况下，如果客户不确定，他们希望您推荐</p>
<p>实现</p>
<p>• 非功能性需求通常影响系统的整体架构而不是单个组件。<br>• 例如，为确保满足性能要求，“设计”系统以尽量减少组件之间的通信。<br>• 单个非功能性需求，例如安全性需求，可能会生成多个相关的功能性需求，这些需求定义了所需的系统服务</p>
<h3 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h3><ul>
<li>用于 RE 的过程因应用领域、涉及的人员和制定需求的组织而异。但是，所有流程都有许多通用活动<ul>
<li>需求启发；</li>
<li>需求分析;</li>
<li>需求验证；</li>
<li>需求管理。</li>
</ul>
</li>
</ul>
<p>在实践中，RE 是一种<strong>迭代</strong>活动，其中这些过程是<strong>交错</strong>的。</p>
<h4 id="elicitation-and-analysis-需求启发和分析"><a href="#elicitation-and-analysis-需求启发和分析" class="headerlink" title="elicitation and analysis 需求启发和分析"></a>elicitation and analysis 需求启发和分析</h4><img src="/post/fit5136-se-notes/image-20210621001052151.png" class="" title="image-20210621001052151">

<p>• 发现客户的要求：• 需求获取（或需求收集）• 方法包括访谈和调查<br>• 完善和扩展初始要求：• 需求分析<br>• 让技术人员与客户&#x2F;客户一起工作，以了解有关应用领域、系统应提供的服务以及系统的操作限制的更多信息。<br>• 可能涉及利益相关者——最终用户、经理、参与维护的工程师、领域专家、工会等。</p>
<h4 id="确定需求（需求验证）"><a href="#确定需求（需求验证）" class="headerlink" title="确定需求（需求验证）"></a>确定需求（需求验证）</h4><p>• 很难将软件产品及其功能可视化：从客户角度，可视化问题要更加严重<br>• 需要从客户那里获取适当信息的技巧<br>• 客户是此信息的唯一来源</p>
<p>解决方案：<br>• 从客户端获取初始信息<br>• 将此初始信息用作软件工程过程的输入<br>• 按照步骤确定客户的真实需求</p>
<h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><p>一、了解应用领域（或简称领域）<br>• 目标产品运行的特定环境<br>二、构建商业模式<br>• 为客户的业务流程建模<br>三、用商业模式来确定客户的需求</p>
<p>重复上述步骤</p>
<h5 id="域"><a href="#域" class="headerlink" title="域"></a>域</h5><p>开发团队的每个成员都必须完全熟悉应用程序领域<br>• 正确的术语terminology至关重要</p>
<p>构建词汇表glossary<br>• 领域中使用的技术词及含义的列表</p>
<h5 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h5><p>业务模型是对组织业务流程的描述</p>
<h3 id="需求收集技术Requirements-gathering-techniques"><a href="#需求收集技术Requirements-gathering-techniques" class="headerlink" title="需求收集技术Requirements gathering techniques"></a>需求收集技术Requirements gathering techniques</h3><p>• 采访<br>• 问卷<br>• 现有文件和系统<br>• 研讨会<br>• 领域专家<br>• 直接观察<br>• “驾驭卡车”——了解业务<br>• 原型制作</p>
<p>具体介绍略</p>
<h3 id="需求规范"><a href="#需求规范" class="headerlink" title="需求规范"></a>需求规范</h3><p>在需求文档中写下用户和系统需求的过程。<br>• 没有技术背景的最终用户和客户必须能够理解用户要求。<br>• 系统要求是更详细的要求，可能包括更多的技术信息。<br>• 要求可能是系统开发合同的一部分<br>• 因此，尽可能完整是很重要的。</p>
<h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>用例（用户案例）对软件产品本身与该软件产品的用户（即Actor）之间的交互进行建模</p>
<ul>
<li>使您对需求的理解正式化的工具。</li>
<li>捕获一些用户可见的功能或行为。</li>
<li>Actor和用例之间的关系</li>
</ul>
<p>用例图不是：</p>
<ul>
<li>流程图！</li>
<li>用例的描述。</li>
<li>定义用例的一系列步骤</li>
</ul>
<p>用例图应该很简单！<br>迭代和递增，直到你做对了！</p>
<p>Note：<br>请遵循这些幻灯片中描述的用例图 UML 语法。 参考书 Satzinger et al。 使用不同的语法。</p>
<p>定义<img src="/post/fit5136-se-notes/image-20210621173206972.png" class="" title="image-20210621173206972"></p>
<ul>
<li>Actor是软件产品之外的世界的成员</li>
<li>通常很容易识别Actor<ul>
<li>Actor通常是软件产品的用户</li>
<li>大多数软件都有不止一种类型的Actor</li>
</ul>
</li>
<li>一般来说，参与者在软件产品方面发挥作用。 一个Actor：<ul>
<li>作为发起人：通常是发起用例的参与者；放置在用例图的<strong>左侧</strong></li>
<li>作为参与者：通常是参与用例的参与者；放置在用例图的<strong>右侧</strong>；一个Actor可以参与多个用例</li>
<li>作为在用例中扮演关键角色的人</li>
<li>作为扮演多个角色的人。 例如。 工作人员可以是讲师和助教</li>
</ul>
</li>
</ul>
<p>Actor不必是人</p>
<ul>
<li>注意：这个系统永远不能是一个Actor。 其他系统可以。<br>示例：电子商务信息系统必须与信用卡公司信息系统交互</li>
<li>从电子商务信息系统的角度来看，信用卡公司信息系统是一个Actor</li>
<li>信用卡公司是电子商务系统用例图中的参与者。</li>
<li>从信用卡公司信息系统的角度来看，电子商务信息系统是一个Actor</li>
<li>电子商务系统是信用卡系统用例图中的参与者。</li>
</ul>
<p>Overlapping Actor（Actor泛化）</p>
<p>或者：<br>• 如果两个参与者以相同的方式与同一组用例进行通信，我们可以将其表示为对另一个（可能是抽象的）参与者的泛化。<br>• 泛化（继承&#x2F;类型）</p>
<img src="/post/fit5136-se-notes/image-20210621192500797.png" class="" title="image-20210621192500797">

<p>包含和扩展</p>
<p>包含：<br>• &lt;&lt;Include&gt;&gt;<br>• 包含是用例的强制性部分。<br>• 包含用例永远不会单独存在。 它始终包括包含的用例</p>
<img src="/post/fit5136-se-notes/image-20210621193132111.png" class="" title="image-20210621193132111">

<p>扩展：<br>• &lt;&lt;Extend&gt;&gt; 用于将可选行为与强制性行为分开<br>行为。<br>• 扩展用例可能是独立的，但在某些条件下，它可能会被另一个用例扩展。    </p>
<img src="/post/fit5136-se-notes/image-20210621193622094.png" class="" title="image-20210621193622094">

<p>good solution</p>
<img src="/post/fit5136-se-notes/image-20210623104202889.png" class="" title="image-20210623104202889">

<h3 id="User-stories-用户故事"><a href="#User-stories-用户故事" class="headerlink" title="User stories 用户故事"></a>User stories 用户故事</h3><p>• 当团队使用<strong>敏捷</strong>方法开发系统时编写用户故事。<br>• 用户故事应该非常简短，并从客户的角度编写——它们通常需要放在索引卡上。<br>• 由于它们是根据需要来表述的，因此通常很容易为它们编写测试。<br>• 这些用户故事应以客户的语言编写，并使用适合其业务的术语。<br>• 客户了解用户故事很重要，因为敏捷方法通常涉及客户反复选择接下来要实施的用户故事。<br>• 对于每个用户故事，需要包括对实现所需功能或用户故事大小或与难度或优先级相关的故事点所需的时间的估计。</p>
<p>例如：</p>
<ul>
<li>作为调查参与者，我希望获得进度指示，以便我知道我还有多少要完成</li>
<li>作为一个 wiki 用户，想上传一个文件到 wiki 以便我可以与我的同事共享</li>
<li>作为客户，我希望系统不会损坏数据库。</li>
</ul>
<p>使用 INVEST 助记符是制作优秀用户故事的便捷指南：</p>
<ul>
<li>Independent 独立：用户故事应该是独立的。</li>
<li>Negotiable 可协商：用户故事应该能够轻松修改或替换，例如使用满足相同结果的不同用户故事。</li>
<li>Valuable 有价值：用户故事必须对最终用户有益。</li>
<li>Estimable 可估算的：用户故事应该对应于可以估算实施工作量的功能。</li>
<li>Small 小：用户故事必须足够小，以便独立考虑和安排。</li>
<li>Testable 可测试：用户故事必须提供足够的信息来验证它已被令人满意地实施。 某些任务或要求可能与以用户为中心的功能无关。 您可以根据用户来描述这些内容，将它们写为开发人员故事，或者只是在内部跟踪它们。</li>
</ul>
<p>你需要利益来评估</p>
<ul>
<li>Negotiable 可协商：在 不知道结果（收益）的情况下难以协商</li>
<li>Valuable  有价值：如果不知道用户故事给用户带来什么好处，就无法知道用户故事的价值</li>
<li>Testable 可测试：有时可以通过解释进行测试，但我们不想将其留给假设</li>
</ul>
<h3 id="Acceptance-criteria-验收标准"><a href="#Acceptance-criteria-验收标准" class="headerlink" title="Acceptance criteria 验收标准"></a>Acceptance criteria 验收标准</h3><p><strong>验收标准</strong>定义了<strong>用户故事的边界</strong>，用于确认软件何时按预期工作，即故事何时完成。简单来说，就是测试用户故事是否按预期实施的标准。</p>
<ul>
<li>对于智能家居应用程序，其中一个用户故事可能是：“作为房主，我希望能够调暗或调亮单个灯泡，这样我就可以创造出理想的照明。”， 此用户故事的验收标准可能是：</li>
<li>用户将选择一个地球仪，然后看到这个视图；</li>
<li>此视图应使用滑块控件，以便用户拥有可用的全部亮度级别；</li>
<li>打开此视图时，初始滑块位置应反映所选地球的当前亮度；</li>
<li>光球响应用户更改的时间不应超过 1 秒。</li>
</ul>
<h2 id="W3-分析与OOP理论"><a href="#W3-分析与OOP理论" class="headerlink" title="W3 分析与OOP理论"></a>W3 分析与OOP理论</h2><h3 id="系统建模"><a href="#系统建模" class="headerlink" title="系统建模"></a>系统建模</h3><p>开发一个系统的抽象模型，每个模型代表该系统的不同视图或视角。<br>• 使用图形符号表示系统，例如统一建模语言 (UML)。<br>• 使用系统建模<br>• 在需求工程期间了解系统的功能并与客户沟通。<br>• 在设计期间向实施系统的工程师描述系统<br>• 用例图是系统建模的一个例子。</p>
<h4 id="perspective-and-viewpoints-系统视角和观点……"><a href="#perspective-and-viewpoints-系统视角和观点……" class="headerlink" title="perspective and viewpoints 系统视角和观点……"></a>perspective and viewpoints 系统视角和观点……</h4><p>• 外部视角——对系统的上下文或环境进行建模。<br>• 交互视角——对系统与其环境之间或系统组件之间的交互进行建模。<br>• 结构视角——对系统的组织或系统处理的数据结构进行建模。<br>• 行为视角——对系统的动态行为及其对事件的响应方式进行建模。</p>
<h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p>UML 是一种标准语言，用于指定、可视化、构建和记录软件系统的人工制品，以及用于业务建模和其他非软件系统。</p>
<p>分类：</p>
<ul>
<li>结构图，根据构成系统的组件及其关系显示系统的组织。<ul>
<li>静态图，显示系统设计的结构，或</li>
<li>动态图，显示系统执行时的组织结构。</li>
</ul>
</li>
<li>行为图，显示系统中对象的动态行为。例如，不同组件如何相互通信以执行任务。</li>
</ul>
<p>类别</p>
<ol>
<li>用例图，显示系统与其环境之间的交互，以及提供更多交互细节的用例场景。</li>
<li>类图，显示系统中的对象类以及这些类之间的关联。</li>
<li>交互图，显示参与者与系统之间以及系统组件之间的交互。<br>• 序列图<br>• 通讯图<br>• 以前称为协作图。</li>
<li>状态图，显示系统如何对内部和外部事件做出反应。</li>
<li>活动图，显示流程或数据处理中涉及的活动。 （本课程未涵盖）</li>
</ol>
<p>作为促进关于现有或提议系统的讨论的一种方式<br>• 不完整和不正确的模型都可以，因为它们的作用是支持讨论。</p>
<p>记录现有系统<br>• 模型应该是系统的准确表示，但不必是完整的。</p>
<p>作为可用于生成系统实现的详细系统描述<br>• 模型必须正确且完整。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>目的：</p>
<ol>
<li>对需求有<strong>更深入的了解</strong></li>
<li><strong>系统建模</strong></li>
<li>以可维护的<strong>设计</strong>和<strong>实现</strong>的方式<strong>描述</strong>它们</li>
</ol>
<p><strong>增量和迭代</strong>地执行以下三个步骤</p>
<ol>
<li>功能建模：所有用例的当前场景（一个场景是一个用例的实例）</li>
<li>类建模：确定<strong>实体类</strong>及其属性；实体类之间的<strong>相互关系和相互作用</strong>；以<strong>类图</strong>的形式呈现这些信息</li>
<li>动态建模：确定由或对每个<strong>实体类</strong>执行的<strong>操作</strong>；以<strong>状态图</strong>的形式呈现此信息</li>
</ol>
<p>• 面向对象分析 (OOA) 是面向对象范式的半形式分析技术。<br>• 它是用例驱动的<br>• 在分析期间，类被提取</p>
<h3 id="第一步：功能建模-用例场景"><a href="#第一步：功能建模-用例场景" class="headerlink" title="第一步：功能建模 - 用例场景"></a>第一步：功能建模 - 用例场景</h3><p>所有用例的呈现场景</p>
<ul>
<li>场景 &#x3D; 用例的描述</li>
<li>场景可以是“ 正常”和“例外”</li>
</ul>
<p><strong>正常情况</strong>：用户和系统之间的一组交互，对应于我们理解系统应该如何用于实现目标的方式。</p>
<p><strong>异常场景</strong>：描述如何处理不希望发生的事件的场景，即干扰目标进展的事件。或者作为干扰正常场景的异常条件的结果的场景。</p>
<h4 id="用例场景模板"><a href="#用例场景模板" class="headerlink" title="用例场景模板"></a>用例场景模板</h4><p>Use Case Name 用例名称：简短的描述性动词短语；<br>Scenario： 捕捉用例本质（功能）的句子；<br>Trigger 触发器：实际触发用例的参与者；<br>Brief description 简要描述：描述用例目标的段落；<br>Actors 参与者： 用例中涉及的参与者（发起者和参与者参与者）；<br>Related use cases 相关用例：该用例是否与其他用例有任何关系 - 包含&#x2F;排除&#x2F;泛化？<br>Preconditions 先决条件：在用例可以执行之前必须为真的事情——它们是对系统状态的约束；<br>Postconditions 后置条件： 在用例结束时必须为真的事情；<br>Flow of events 事件流：用例中的步骤（如果一切顺利——没有错误、中断）；<br>Exception conditions 异常条件： 主要流程的替代列表（捕获错误，中断主要流程）。</p>
<img src="/post/fit5136-se-notes/use_case_scenario.png" class="" title="use_case_scenario">

<h4 id="软件需求规范"><a href="#软件需求规范" class="headerlink" title="软件需求规范"></a>软件需求规范</h4><p>不在考试范围</p>
<p>• 软件需求规范(SRS) 是对要开发的软件系统及其功能和非功能需求的详细描述。<br>• SRS 是根据客户与您之间的协议制定的。<br>• 它可能包括用户将如何与软件系统交互的用例。<br>• 软件需求规范文档与项目开发所需的所有必要需求一致。<br>• 要开发软件系统，我们应该对软件系统有清晰的认识。<br>• 为实现这一目标，我们需要与客户持续沟通以收集所有需求。</p>
<p>• 一个好的 SRS 定义了软件系统如何与所有内部模块、硬件、与其他程序的通信以及人类用户与广泛的现实生活场景交互。<br>• 使用 QA 主管的软件需求规范 (SRS) 文档，管理人员创建测试计划。<br>• 测试人员必须清楚本文档中指定的每个细节，以避免测试用例及其预期结果中的错误，这一点非常重要。<br>• 强烈建议在开始编写测试用例和制定任何测试计划之前查看或测试 SRS 文档。 让我们看看如何测试 SRS 以及测试时要记住的重点。</p>
<ol>
<li>应检查SRS的正确性</li>
<li>应避免歧义</li>
<li>要求要完整</li>
<li>一致的要求</li>
<li>预期结果的验证</li>
<li>测试环境</li>
<li>安全和性能标准</li>
<li>应避免假设</li>
</ol>
<h3 id="第二步：使用类图进行类建模"><a href="#第二步：使用类图进行类建模" class="headerlink" title="第二步：使用类图进行类建模"></a>第二步：使用类图进行类建模</h3><p>• 类图用于开发面向对象的系统模型以显示系统中的类以及这些类之间的关联。<br>• 对象类可以被认为是一种系统对象的一般定义。<br>• 当您在软件工程过程的早期阶段开发模型时，对象代表现实世界中的某些事物，例如患者、处方、食谱、医生、讲师、学生等。</p>
<p>UML类图内必要元素</p>
<ul>
<li>类</li>
<li>属性</li>
<li>操作</li>
<li>关系</li>
<li>联系<ul>
<li>归化</li>
<li>组合&#x2F;聚合</li>
<li>依赖</li>
</ul>
</li>
<li>约束规则和注意事项</li>
</ul>
<h4 id="OOP面向对象的概念修订"><a href="#OOP面向对象的概念修订" class="headerlink" title="OOP面向对象的概念修订"></a>OOP面向对象的概念修订</h4><p>对象通常来自以下来源之一（最初由 Shlaer 和 Mellor 提供，后来由 Booch 转述，并在此处进一步改编）<br>• 有形的或“现实世界的东西”：书、记事本、小册子；<br>• 角色：图书馆成员、学生、教育主任；<br>• 事件：到达、离开、请求；<br>• 互动 ： 会议、交集。</p>
<p>• 它们类似于现实生活中的“对象”<br>• 描述对象的数据（成为它的属性&#x2F;特性）<br>• 可以由&#x2F;在对象上执行的操作&#x2F;方法。</p>
<p>一个类描述了一组对象<br>• 相似的属性（属性），<br>• 常见行为（操作），<br>• 与其他对象的共同关系，<br>• 和普通含义（“语义”）。</p>
<p>一个类有<br>• 数据属性&#x2F;属性：与其实例相关的信息<br>• 操作&#x2F;方法：对象支持的功能<br>• 类是对个人共同点的描述。<br>• 对象是具有不同价值观的个人。</p>
<p>UML作图略</p>
<p>• 一个类用 UML 符号表示为一个带有三个隔间的盒子<br>• 类属性：是我们想要捕获的关于类的信息！<br>• 例如，在现实世界中，当我们谈论一个人时，我们通常谈论<br>• 他们的姓名、地址、生日……<br>• 请注意，根据不同的域，我们可能需要捕获不同的属性！</p>
<p>描述类<br>• 绘制类时，不必在每个图中都显示属性和操作</p>
<p>问题域中的类<br>• 需要先确定类别！<br>他们之间的关系<br>• “Collaborates with”（association关联）<br>• “is-a”（inheritance or generalisation 继承或泛化）<br>• “has-a”（aggregation or composition 聚合或组合）</p>
<p>（后面的内容）</p>
<h4 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h4><p>继承略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Polymorphism-多态"><a href="#Polymorphism-多态" class="headerlink" title="Polymorphism 多态"></a>Polymorphism 多态</h5><p>源自希腊语 Poly &#x3D;&gt; many 和 morph &#x3D;&gt; form, shape。 所以多态意味着以许多不同的形式出现<br>• 多态性是对象具有多种形式的能力。<br>• 当使用父类引用来引用子类对象时，OOP 中多态性的最常见用途发生。</p>
<p>• 多态性使您能够“在一般情况下编程”而不是“在特定情况下编程”。<br>• 多态性使您能够编写直接或间接处理共享相同超类的对象的程序<br>• 实现可扩展性 Extensibility<br>• 只要新类是程序一般处理的继承层次结构的一部分，就可以在对程序的一般部分稍加修改或不修改的情况下添加新类。</p>
<p>• 依靠每个对象知道如何“做正确的事”（即，做适合该类型对象的事情）以响应相同的方法调用是多态的关键概念。 发送到各种对象的相同消息（在这种情况下，声音）具有多种形式的结果——因此术语多态性。<br>• 在运行时自动选择合适的方法称为动态绑定。</p>
<p>• 回忆：对象使用方法相互通信。<br>例如。 另一个对象可以执行以下代码与 <code>aCircle</code> 通信<br>使用 <code>calcArea()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span> <span class="variable">aCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line">area = aCircle.calcArea();</span><br></pre></td></tr></table></figure>

<p>• 可以通过调用相同的方法将相同的消息（您需要计算面积）发送到不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aSquare.calcArea();</span><br><span class="line">aRectangle.calcArea();</span><br><span class="line">aCircle.calcArea();</span><br></pre></td></tr></table></figure>
<p>• 每个对象以不同的方式“响应”同一消息。<br>• 这称为多态性。</p>
<h6 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h6><p>• 当我们想到一个类时，我们假设程序将创建该类型的对象。 有时声明类（称为抽象类）很有用，您从未打算为其创建对象。<br>• 抽象超类过于笼统，无法创建真正的对象——它们只指定子类之间的共同点<br>• 抽象类的主要目的是提供一个合适的超类，其他类可以从该超类继承并因此共享共同的设计。<br>• 一个抽象类通常包含一个或多个抽象方法，如果它们是具体的，子类必须覆盖这些方法。<br>• 抽象类不完整<br>• 抽象方法不提供实现。</p>
<p>• Java 中的抽象方法没有方法的body，并在声明后以分号终止。<br>• 具有至少一种抽象方法的类必须声明为抽象的。<br>• 来自超类的抽象方法必须在子类中实现，否则Java 将给出错误消息。<br>• Shape 抽象类中的两个方法都必须在 Circle 和 Rectangle 子类中具有主体（或声明为抽象）。</p>
<h2 id="W4-团队合作，统一流程，更多关于敏捷、VCS"><a href="#W4-团队合作，统一流程，更多关于敏捷、VCS" class="headerlink" title="W4 团队合作，统一流程，更多关于敏捷、VCS"></a>W4 团队合作，统一流程，更多关于敏捷、VCS</h2><h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>• 它包含在澳大利亚工程师第一阶段的能力中<br>• 团队合作是澳大利亚工作文化的重要组成部分。<br>• 大多数软件产品对于单个程序员来说太大了（在可用时间内）<br>• 如果软件组件由不同的人编写，则该软件可以满足更多人群的需求<br>• 不仅在 IT，还有 Coles、Kmart 等商店<br>• 你们争论但也互相学习<br>• 您将学习如何管理您的工作和您的团队<br>• 您将学习如何处理复杂的情况<br>• 您将学习如何与来自不同文化和经历的人一起工作</p>
<p>类型：</p>
<ol>
<li>民主党队</li>
<li>首席编程团队</li>
<li>现代编程团队</li>
<li>同步和稳定团队</li>
<li><strong>极限编程团队</strong></li>
<li><strong>Scrum 团队</strong></li>
<li><strong>开源编程团队</strong></li>
</ol>
<h4 id="极限编程团队"><a href="#极限编程团队" class="headerlink" title="极限编程团队"></a>极限编程团队</h4><p>敏捷软件开发技术</p>
<ul>
<li>所有代码由共享一台计算机的两个程序员编写，“结对编程”<ul>
<li>驱动者：编写代码</li>
<li>导航者：检查或查看代码</li>
</ul>
</li>
<li>测试用例由团队中的一名成员起草，但测试由另一名成员完成。</li>
<li>如果一名程序员离开，知识不会全部丢失</li>
<li>没有经验的程序员可以学习（向有经验的程序员学习）</li>
</ul>
<h4 id="Scrum-团队"><a href="#Scrum-团队" class="headerlink" title="Scrum 团队"></a>Scrum 团队</h4><p>•（可以说）民主模式的变体。<br>• 7 +&#x2F;- 2 人 团队</p>
<p>角色</p>
<ul>
<li><p>“Scrum Master”：确保团队遵循Scrum 规则；保护团队免受外部障碍的影响</p>
</li>
<li><p>“Product Owner 产品拥有者”， 一个人，客户&#x2F;顾客代表。负责将要开发的内容和顺序。</p>
</li>
<li><p>“开发团队”：负责确定如何交付产品所有者所要求的产品。</p>
</li>
</ul>
<p>• 敏捷方法——固定长度的“迭代”<br>• 民主地同意在迭代中完成多少工作<br>• 团队成员在迭代（Sprint）内注册任务<br>• 问责机制的数量<br>• 客户&#x2F;客户在每个 Sprint 结束时都能看到进展！<br>• 每个人都看到其他人在做什么<br>• 燃尽图跟踪 Sprint 中的进度<br>• 它显示了在 Sprint 中还有多少任务需要完成。</p>
<img src="/post/fit5136-se-notes/image-20210622000449925.png" class="" title="image-20210622000449925">

<p>• 许多团队声称使用 Scrum<br>• 根据我们的经验，大多数团队需要任命领导者，因为他们需要指导<br>• Scrum 旨在自组织，不依赖于领导者<br>• 可能与经验丰富、积极主动的全职开发人员合作良好<br>• 全栈开发人员喜欢它<br>• 如果一家 IT 公司想要改变他们的团队模式，他们将与敏捷大师一起举办研讨会</p>
<p>敏捷过程中的团队合作</p>
<p>• <strong>接受整个团队的责任</strong>：团队应该对产品的各个方面负责<br>• <strong>依赖专家，但要谨慎</strong>：使用彼此的才能、技能和品质，但要谨慎<br>• <strong>每件事都做一点点</strong>：这就是学习的方式。 实习就是这样设计的。<br>• <strong>促进团队学习</strong>：不要自满。 总是有改进的机会<br>• <strong>通过承诺鼓励合作</strong>：重振精神并专注于共同的目标<br>• <strong>现在齐心协力</strong>：建立正确的团队合作意识，但它具有挑战性</p>
<p>成功的变革并不完全是……<br>• 自上而下：组织跟随领导者 (CEO) 实现愿景 没有人能够制定正确的愿景，将其传达给大量人员，消除所有关键障碍，产生 短期获胜，领导和管理数十个变革项目，并在组织文化的深处扎根新方法。 (1996, 51-52)<br>• 自下而上：一个团队或一些个人决定需要改变，并着手实现它。<br>• 您可能会看到“稍后请求原谅”的态度，违反规则并尽可能长时间地躲避雷达<br>• 大多数成功的变革，尤其是对像 Scrum 这样的敏捷框架的变革，都必须包含两者的要素。<br>• 你想做一场运动，就需要得到高层的支持，否则坚持不了太久。</p>
<p>最终状态不可预测<br>• Scrum 转换中的结束状态是不正确的，在需要持续改进的过程中不可能有结束状态。<br>• 您能做的最好的事情就是找出我们现在所处的位置与改进的中间状态之间的差距。<br>• 但我们仍然需要找到关闭它们的方法。<br>• 很难（有时甚至不可能）预测人们将如何应对较小的变化以变得敏捷。<br>• 所以你摇晃着等待回应。<br>• 这些戳戳和刺激不是随机的，而是根据经验、智慧和直觉精心阐述的，以推动成功过渡到 Scrum</p>
<p>Scrum 无处不在<br>• 孤立的变化更容易引入组织。 例如：改变一个特定的例程<br>• 现在，考虑一个过渡到 Scrum 的开发人员<br>• 必须一次处理一个功能的较小部分，以便在每个时间盒冲刺结束时完成某项工作。<br>• 她可能必须编写自动化测试来处理每一段新代码。<br>• 可能不得不交替进行称为 TDD 的短时间测试和编码<br>• 配对编程，无需耳机<br>• 这些是根本性的变化，您正在改变开发人员工作日的一切。</p>
<p>阻力会更大，因为影响更大！ 无孔不入！</p>
<p>Scrum 完全不同<br>• 许多变化与他们过去的大部分训练背道而驰。<br>• 例如：<br>• 传统上，程序员已经接受过在开始任何编码之前深入分析问题并设计完美解决方案的培训。<br>• Scrum 说，在开始编码之前并不总是需要经过充分考虑的设计。<br>• 传统上，测试人员了解到他们的工作是测试是否符合规范。<br>• Scrum 说，测试人员了解到测试也与用户需求的一致性有关。</p>
<p>最佳实践是危险的<br>• 有人找出了做某事的正确或最佳方式，我们将其作为“最佳实践”与大家分享<br>• 然而，在过渡到 Scrum 时，收集最佳实践可能很危险。<br>• 最佳实践诱使我们放松并停止对 Scrum 至关重要的持续改进的努力。<br>• 虽然，您应该与您的团队分享好主意，但让我们抵制将它们编入一组最佳实践的冲动。<br>• 让我们不要规定您何时运行每日 Scrum。 这是不必要的微观管理。</p>
<p>这是值得的。 为什么？…<br>• 更高的生产力<br>• 更低的花费<br>• 提高员工敬业度和工作满意度 (!)<br>• 更快的上市时间<br>• 更高质量<br>• 提高利益相关者的满意度<br>• 我们一直在做的事情不再奏效</p>
<h4 id="开源团队"><a href="#开源团队" class="headerlink" title="开源团队"></a>开源团队</h4><p>无偿、异步沟通、没有团队会议、没有经理、没有规范、没有设计、几乎没有文档</p>
<p>开源项目之所以成功，是因为</p>
<ul>
<li>完成“有价值”任务的纯粹享受——志愿者想要学习新技能以获得晋升或更好的工作机会</li>
<li>目标产品的性质：你希望任何人和每个人都参与进来</li>
<li>煽动者的个性</li>
<li>核心组成员的才能</li>
</ul>
<h3 id="团队问题"><a href="#团队问题" class="headerlink" title="团队问题"></a>团队问题</h3><ul>
<li><p>会议是一种开销<br>• 会议不应超过 45 分钟<br>• 如果是，则您正在进行不相关的讨论和无效的会议</p>
</li>
<li><p>团队成员不理解 彼此；彼此的情况；彼此的符号、模型等：<br>• 有同理心<br>• 尝试相互了解<br>• 力所能及的地方提供帮助</p>
</li>
<li><p>任务分配：分工的优势 - 交流</p>
</li>
</ul>
<ol>
<li>更短的“上市时间”</li>
<li>质量提升（其他人可以检查）</li>
<li>更有效（通过使用专家）</li>
</ol>
<ul>
<li>缺乏生产力： 了解可以并行执行的操作以及必须执行的操作<br>依次<br>• 优先级！</li>
</ul>
<h3 id="The-Unified-Process-统一流程"><a href="#The-Unified-Process-统一流程" class="headerlink" title="The Unified Process 统一流程"></a>The Unified Process 统一流程</h3><p>统一过程不是构建软件产品的一系列步骤<br>• 不存在这种单一的“一刀切”方法<br>• 有多种不同类型的软件</p>
<p>统一流程是一种适应性强的方法论<br>• 必须针对要开发的特定软件产品和开发团队进行修改</p>
<h4 id="面向对象范式中的迭代和增量"><a href="#面向对象范式中的迭代和增量" class="headerlink" title="面向对象范式中的迭代和增量"></a>面向对象范式中的迭代和增量</h4><p>在实践中<br>• 一个工件是一块一块地构造的（增量）<br>和<br>• 每个增量都经过多个版本（迭代）</p>
<img src="/post/fit5136-se-notes/image-20210622002135841.png" class="" title="image-20210622002135841">



<p>项目分解为一系列瀑布式迷你流程<br>每个小项目都扩展了<br>• 需求工件<br>• 分析工件<br>• 设计工件<br>• 实施工件<br>• 测试工件<br>最后一组神器就是完整的产品</p>
<p>好处<br>• 检查正确性的多种机会<br>• 可以相对较早地确定架构的稳健性<br>• 尽早降低风险<br>• 始终拥有软件的工作版本<br>看起来乱七八糟，其实管理方面也没那么差……<br>• 因为它是一套瀑布式迷你项目</p>
<h4 id="OOP"><a href="#OOP" class="headerlink" title="+OOP"></a>+OOP</h4><p>统一过程是一种建模技术<br>• 模型是一组 UML 图，代表我们要开发的软件产品的各个方面<br>UML代表统一建模语言<br>• UML 是我们用来表示（建模）目标软件产品的工具</p>
<p>面向对象范式本质上是迭代和增量的<br>• 在 UML 图令人满意之前，除了重复迭代和递增之外别无选择</p>
<h3 id="工作流（垂直）"><a href="#工作流（垂直）" class="headerlink" title="工作流（垂直）"></a>工作流（垂直）</h3><p>（这个图是考点……）</p>
<img src="/post/fit5136-se-notes/image-20210622161130304.png" class="" title="image-20210622161130304">

<p>（在考试里，这四个Phase加起来叫一个Event，另外Event之间需要解释</p>
<h4 id="需求工作流"><a href="#需求工作流" class="headerlink" title="需求工作流"></a>需求工作流</h4><p>需求工作流的目标：确定客户的需求，回顾（了解应用领域，建立商业模式：使用 UML 来描述客户的业务流程，如果在任何时候客户认为成本不合理，开发将立即终止）</p>
<p>确定客户的限制至关重要<br>• 截止日期：如今，软件产品通常是关键任务<br>• 并行运行<br>• 便携性<br>• 可靠性<br>• 快速响应时间<br>• 成本 - <strong>客户很少会告诉开发商有多少钱可用</strong>：改为使用投标程序</p>
<h5 id="分析工作流"><a href="#分析工作流" class="headerlink" title="分析工作流"></a>分析工作流</h5><p>目标：<strong>分析和细化需求</strong></p>
<p>为什么不在需求工作流程中执行此操作？</p>
<ul>
<li>客户必须完全理解需求工件</li>
<li>因此，需求工作流的工件必须以自然（人类）语言表达：<strong>所有自然语言都是不精确的</strong></li>
</ul>
<p>来自制造信息系统的示例：“从数据库中读取零件记录和工厂记录。 如果它包含字母 A 后跟字母 Q，则计算将该零件运输到该工厂的成本”，它指的是什么？零件记录？工厂记录？还是数据库？</p>
<p>需要两个独立的工作流程</p>
<ul>
<li>需求工件必须用客户的语言表达</li>
<li>分析工件必须精确，并且对于设计者来说足够完整</li>
</ul>
<h5 id="Software-Project-Management-Plan-软件项目管理计划"><a href="#Software-Project-Management-Plan-软件项目管理计划" class="headerlink" title="Software Project Management Plan 软件项目管理计划"></a>Software Project Management Plan 软件项目管理计划</h5><p>一旦客户签署了规范（可能以 SRS 形式的合同），详细的规划和估算就开始了<br>我们制定软件项目管理计划（SPMP），包括<br>• 成本估计<br>• 持续时间估计<br>• 可交付成果<br>• 里程碑<br>• 预算<br>这是 SPMP 最早的可能时间</p>
<h5 id="设计工作流"><a href="#设计工作流" class="headerlink" title="设计工作流"></a>设计工作流</h5><p>• 设计工作流程的目的是改进分析工作流程，直到材料成为可由程序员实施的形式：许多非功能性需求此时需要最终确定，包括编程语言的选择、重用问题、可移植性问题<br>• 在分析工作流程中提取类并在设计工作流程中设计类<br>• 保留设计决策：当达到死胡同时，防止维护团队重新发明轮子<br>• 我们不是在谈论原型（或任何类似的东西）。 这是关于软件架构的。</p>
<h5 id="实现工作流"><a href="#实现工作流" class="headerlink" title="实现工作流"></a>实现工作流</h5><p>实施工作流的目标是以选定的实施语言实施目标软件产品</p>
<ul>
<li>大型软件产品被划分为子系统</li>
<li>子系统由组件或代码工件组成</li>
</ul>
<h5 id="可追溯性"><a href="#可追溯性" class="headerlink" title="可追溯性"></a>可追溯性</h5><p>所有工件都需要被检查，因此需要可追溯性：</p>
<ul>
<li>分析工件中的每个项目都必须可追溯到需求工件中的一个项目。</li>
<li>设计和实现工件也是如此</li>
</ul>
<p>应通过审查来检查分析工件</p>
<ul>
<li>必须对 SPMP 进行类似检查，特别注意成本和持续时间估算</li>
<li>设计（用户界面和架构）审查必不可少：因为客户代表通常不在场</li>
</ul>
<h5 id="测试工作流"><a href="#测试工作流" class="headerlink" title="测试工作流"></a>测试工作流</h5><p>• 单元测试：每个组件在实施后立即进行测试<br>• 集成测试：在每次迭代结束时，组合并测试完成的组件<br>• 产品测试：当产品看起来是完整的时，它会作为一个整体进行测试<br>• 验收测试：一旦完成的产品安装在客户的计算机上，客户就会对其进行测试</p>
<h3 id="阶段（水平）"><a href="#阶段（水平）" class="headerlink" title="阶段（水平）"></a>阶段（水平）</h3><h4 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h4><p>初始阶段的目的是确定所提议的软件产品是否是<br>经济上可行</p>
<ol>
<li>了解领域，构建业务模式</li>
<li>划定拟议项目的范围，关注商业模式的子集<br>被提议的软件产品所涵盖</li>
<li>开始制作最初的商业案例</li>
</ol>
<p>1.获得商业案例的初始版本是inception阶段的总体目标</p>
<ol>
<li>此初始版本包含</li>
<li>软件产品范围的描述</li>
<li>财务细节</li>
<li>休息取决于软件的使用地点（内部或销售）</li>
</ol>
<h4 id="细化阶段"><a href="#细化阶段" class="headerlink" title="细化阶段"></a>细化阶段</h4><p>细化阶段的目标是细化初始需求<br>• 优化架构<br>• 监控风险并优化其优先级<br>• 完善业务案例<br>• 制定项目管理计划<br>细化阶段的任务对应于：<br>• 完成需求工作流程<br>• 执行几乎整个分析工作流程<br>• 开始架构设计</p>
<h4 id="施工阶段"><a href="#施工阶段" class="headerlink" title="施工阶段"></a>施工阶段</h4><p>建设阶段的目标是产生第一个操作质量<br>软件产品的版本<br>• 这有时称为测试版<br>这一阶段的重点是<br>• 执行<br>• 测试<br>• 模块的单元测试<br>• 子系统的集成测试<br>• 整个系统的产品测试</p>
<h4 id="过渡阶段"><a href="#过渡阶段" class="headerlink" title="过渡阶段"></a>过渡阶段</h4><p>过渡阶段的目的是确保确实满足客户的要求<br>• 软件产品中的故障得到纠正<br>• 已完成所有手册<br>• 尝试发现任何以前未识别的风险<br>此阶段由安装测试版的站点的反馈驱动</p>
<h3 id="1-维-与-2-维生命周期模型"><a href="#1-维-与-2-维生命周期模型" class="headerlink" title="1 维 与 2 维生命周期模型"></a>1 维 与 2 维生命周期模型</h3><img src="/post/fit5136-se-notes/image-20210622003949552.png" class="" title="image-20210622003949552">

<p>a. waterfall; b. agile</p>
<p>为什么是二维模型？<br>• 在理想情况下，每个工作流都将在下一个工作流开始之前完成<br>• 实际上，开发任务太大了<br>• 开发任务必须分为增量（阶段）<br>• 在每个增量内，执行迭代直到任务完成<br>• 处理好不可避免的变化<br>• 移动目标问题<br>• 不可避免的错误<br>• 将一个大问题视为一组较小的、很大程度上独立的子问题<br>• 它提供了一个增量和迭代的框架</p>
<p>过渡到敏捷很难！<br>• 成功的变革并不完全是自上而下或自下而上<br>• 最终状态是不可预测的<br>• Scrum 无处不在<br>• Scrum 截然不同<br>• 变化比以往任何时候都来得更快<br>• 最佳做法很危险</p>
<h4 id="使用-Scrum-框架实现敏捷"><a href="#使用-Scrum-框架实现敏捷" class="headerlink" title="使用 Scrum 框架实现敏捷"></a>使用 Scrum 框架实现敏捷</h4><p>• Scrum 是帮助团队合作开发、交付和维持复杂产品的框架<br>• Sprint 计划是 Scrum 中的一个事件，它定义了在即将到来的 Sprint 中可以交付的内容以及如何实现这些工作<br>• Sprint 是一个短的、有时间限制的时期，Scrum 团队在此期间完成一定数量的工作。 冲刺通常在两周左右。<br>• 每日 Scrum 或站会是与 Scrum 团队的其他成员在同一时间和地点举行的简短会议，以相互更新 sprint 的进度<br>• 在 sprint 结束时，团队聚在一起进行 sprint 审查，非正式会议以查看演示并查看已完成的内容<br>• 在 sprint 回顾中，团队聚在一起讨论和记录哪些行得通，哪些行不通。 回顾可以是关于冲刺、人员、项目、关系和工具</p>
<h4 id="使用看板框架实现敏捷"><a href="#使用看板框架实现敏捷" class="headerlink" title="使用看板框架实现敏捷"></a>使用看板框架实现敏捷</h4><p>• 看板就是关于可视化您的工作、限制正在进行的工作和最大限度地提高效率。<br>• 看板团队专注于减少项目从开始到结束所花费的时间。<br>• 看板正在为您的团队在项目上的工作方式制作自定义列。<br>• 主要列范围从积压、优先排序、要做、做、审查中、完成和部署。 团队可以添加或删除这些列是必需的。<br>• 在每一列中，制作卡片（或票）。 每张卡片都是分配给团队成员的任务。<br>• 取决于团队使用的软件，可以使用附加功能，例如添加清单、截止日期、标记团队成员等</p>
<p>好处<br>• 更短的周期时间可以更快地交付功能<br>• 对变化的反应能力<br>• 当优先级变化非常频繁时，看板是理想的选择<br>• 平衡需求与吞吐量可确保大多数以客户为中心的功能始终有效<br>• 只需较少的组织&#x2F;房间设置更改即可开始<br>• 减少浪费并移除不会为团队&#x2F;部门&#x2F;组织增加价值的活动<br>• 快速反馈循环增加了更有动力、更有能力和更高绩效的团队成员的机会</p>
<p>如何使用看板框架？看板方法假设三件事：<br>• 您了解当前的流程，因为它们实际上已在实践中，并尊重当前的角色、职责和职位。<br>• 您同意通过渐进式变革追求持续改进。<br>• 您鼓励各个层面的领导行为——从个人贡献者到高级管理人员。</p>
<p>• 看板正在为您的团队在项目上的工作方式制作自定义列<br>• 主要列范围从积压、优先排序、要做、做、审查中、完成和部署。 团队可以根据需要添加或删除这些列。<br>• 在每一列中，制作卡片（或票）。 每张卡片都是分配给团队成员的任务。<br>• 取决于团队使用的软件，可以使用附加功能，例如添加清单、截止日期、标记团队成员等</p>
<h3 id="敏捷过程"><a href="#敏捷过程" class="headerlink" title="敏捷过程"></a>敏捷过程</h3><p>Backlog 积压<br>• 用户故事的待办事项列表可能会变得非常复杂，因此对它们进行进一步分类可能会有所帮助。 将用户故事分解为单独的开发任务也很有帮助。<br>• 这就是backlog 的用途——允许对用户故事和相关的开发人员任务进行优先级排序，并将任务分配给各个开发人员。<br>• 有关积压工作的更多信息，请参阅 Atlassian 的积压工作指南。<br>• 积压可以在白板上进行跟踪，但更常见的是保存在电子表格或在线系统中。</p>
<p>燃尽图<br>• 一个示例燃尽图，显示了一段时间内的剩余任务。<br>• 在敏捷开发方法中，进度通常用燃尽图来跟踪。<br>• 这些图表定期（通常每天）显示待办事项中的剩余故事，以及<br>指示预计完成时间范围的“估计”趋势线。<br>• 图表的梯度表示团队朝着目标前进的速度<br>项目完成情况以及大致剩余的工作量。<br>• 这些信息让软件工程师知道他们是否需要，比如说，减少<br>如果没有足够的时间来完成此功能或与客户重新协商规格<br>项目的一部分。</p>
<img src="/post/fit5136-se-notes/image-20210622004514973.png" class="" title="image-20210622004514973">



<h4 id="Version-Control-Systems-版本管理系统"><a href="#Version-Control-Systems-版本管理系统" class="headerlink" title="Version Control Systems 版本管理系统"></a>Version Control Systems 版本管理系统</h4><p>略，不要太熟练:laughing:</p>
<h2 id="W5-分析（续）"><a href="#W5-分析（续）" class="headerlink" title="W5 分析（续）"></a>W5 分析（续）</h2><p>问题域中的类： 需要先确定类别！</p>
<p>类之间的关系</p>
<ul>
<li>“collaborates with”（关联）</li>
<li>“is-a”（继承或泛化）</li>
<li>“has-a”（聚合&#x2F;组合）</li>
</ul>
<p>请记住，这是迭代过程，所以不会一次性完成所有这些！</p>
<h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p>类图还有用吗？</p>
<ul>
<li>新程序员倾向于学习新的语言和技术，但不会首先专注于学习创建合适的软件架构</li>
<li>缺乏合适的软件架构会导致高耦合和低内聚，导致代码不可扩展和不可重用<br>– 即他们的代码在实施期间或实施后无法适应更改&#x2F;新功能<br>– 所以他们所做的就是为了它而“摇摆不定”，这导致了糟糕的软件架构</li>
<li>你不需要有一个完整的类图。</li>
<li>从你能做的开始，随着你的进展不断增加和迭代。<br>– 对于敏捷，您可以选择在编写实际代码的同时执行此操作。</li>
</ul>
<h4 id="Associations-关联"><a href="#Associations-关联" class="headerlink" title="Associations 关联"></a>Associations 关联</h4><ul>
<li>关联表示类之间的关系。</li>
<li>它们被表示为连接两个相关类的线，最简单的就是它们。</li>
<li>如果关联具有导向性（即一端有箭头），则表明一个类知道另一个类，反之则不然。</li>
<li>如果可以帮助您了解关系的性质，您可以给关系一个名称&#x2F;标签。<br>– “has”这个名字对理解几乎没有什么帮助（不鼓励使用）</li>
</ul>
<img src="/post/fit5136-se-notes/image-20210622005501542.png" class="" title="image-20210622005501542">

<p>（箭头表示学生知道怎么找到老师</p>
<p>有时，关联很复杂——需要一个类（有时称为关联类）来表示它……</p>
<img src="/post/fit5136-se-notes/image-20210622005809093.png" class="" title="image-20210622005809093">

<p>关联的每一端都可以显示其多重性: 这表示关联中涉及每个类的对象数量。（一对一，一对多，多对一，多对多</p>
<p>我们从左到右读取多重性</p>
<p>注意：其他多重性也是可能的，例如 2, 10 等</p>
<h3 id="归化关系"><a href="#归化关系" class="headerlink" title="归化关系"></a>归化关系</h3><p>很多不同的术语：继承，”is a”，泛化&#x2F;专化，超类&#x2F;子类。</p>
<p>• 泛化是我们用来管理复杂性的日常技术。<br>• 我们不是学习我们所经历的每个实体的详细特征，而是将这些实体置于更一般的类（动物、汽车、房屋等）中并学习这些类的特征。<br>• 这使我们能够推断这些类的不同成员具有一些共同特征，例如 松鼠和老鼠是啮齿动物。</p>
<p>• 在建模系统中，检查系统中的类以查看是否有泛化的余地通常很有用。<br>• 在面向对象的语言（如 Java）中，泛化是使用语言内置的类继承机制实现的。<br>• 概括地说，与较高级别的类相关联的属性和操作也与较低级别的类相关联。<br>• 低级类是子类从其超类继承属性和操作。 这些较低级别的类然后添加更具体的属性和操作。</p>
<img src="/post/fit5136-se-notes/image-20210622010247509.png" class="" title="image-20210622010247509">

<p>子类继承其超类的属性和操作。<br>– 每个讲师和每个导师都有从 User 类继承的名称、ID 和密码。<br>– 讲师和导师可以标记作业，因为用户可以。<br>子类提供额外的操作和属性。<br>– 例如。 讲师可以创建作业。<br>子类可以覆盖其超类的操作。<br>– 我们稍后会展示这一点。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>聚合（或共享聚合）——一种特殊形式的关联，“has-a”关系</p>
<ul>
<li>聚合模型展示了作为集合的类是如何由其他类组成的。</li>
<li>聚合是存在于组与其成员之间的一种关联。</li>
<li>共享聚合的三个最重要的特性是：<br>– 聚合对象可能在没有其组成对象的情况下存在（尽管不一定处于有用状态），<br>– 在任何时候，每个对象都可能是多个集合的组成部分（例如，一个人可能属于多个俱乐部），并且<br>– 组成对象通常属于同一类（但同样，情况并非总是如此）。</li>
</ul>
<img src="/post/fit5136-se-notes/image-20210622010532394.png" class="" title="image-20210622010532394">

<h4 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h4><p>复合聚合是存在于整体与其部分之间的聚合。</p>
<p>复合聚合相对于共享聚合的三个最重要的特征是：<br>– <strong>没有组件的复合对象不存在</strong>，<br>– 在任何时候，每个<strong>组件</strong>都<strong>可能只是一个组合的一部分</strong>，并且<br>– 组件对象很可能是混合类型（尽管情况并非总是如此。）</p>
<img src="/post/fit5136-se-notes/image-20210622010710153.png" class="" title="image-20210622010710153">

<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="识别类和对象"><a href="#识别类和对象" class="headerlink" title="识别类和对象"></a>识别类和对象</h5><p>目标：创建抽象字典（名词提取）。<br>方式：</p>
<ul>
<li>研究用例场景</li>
<li>其他要求文档。</li>
</ul>
<p>步骤：</p>
<ol>
<li>从寻找<strong>有形事物</strong>开始。</li>
<li>弄清楚问题边界（问题域）<strong>内、外</strong>的内容</li>
<li>有些东西可能是类</li>
<li>有些可能是简单的<strong>属性</strong>。</li>
</ol>
<h5 id="识别抽象（类和对象）的角色和职责"><a href="#识别抽象（类和对象）的角色和职责" class="headerlink" title="识别抽象（类和对象）的角色和职责"></a>识别抽象（类和对象）的角色和职责</h5><p>抽象名词（属性）</p>
<p>• “职责”~&#x3D; 属性+方法（在详细的类图中）。<br>将这些记录在：<br>• UML 类图<br>• CRC 卡。<br>• 文本。</p>
<h5 id="模式清除"><a href="#模式清除" class="headerlink" title="模式清除"></a>模式清除</h5><p>寻找类之间职责的共性。<br>看看这些是否可以使用继承来简化： 是否存在“is-a”关系？<br>继承示例：<br>– 属性类型：屋，公寓<br>– 类别类型：出租，出售</p>
<h3 id="三种类型的类"><a href="#三种类型的类" class="headerlink" title="三种类型的类"></a>三种类型的类</h3><ul>
<li>实体类（为初始类图提取）</li>
<li>边界类（稍后在设计中决定）</li>
<li>控制类（稍后在设计中决定）</li>
</ul>
<img src="/post/fit5136-se-notes/image-20210622011659902.png" class="" title="image-20210622011659902">

<img src="/post/fit5136-se-notes/image-20210622012028916.png" class="" title="image-20210622012028916">



<h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>模型“长期”信息</p>
<p>通常是“被动的”</p>
<p>但它们可能仍然包含复杂的算法。示例：财产、代理、公司</p>
<h4 id="边界类"><a href="#边界类" class="headerlink" title="边界类"></a>边界类</h4><p>存在于系统“自动化边界”上的类<br>• 模拟产品和环境（Actor）之间的交互<br>• 与输入或输出相关</p>
<h4 id="控制类"><a href="#控制类" class="headerlink" title="控制类"></a>控制类</h4><p>调解边界和实体类之间的交互。<br>• 为复杂的计算和算法建模<br>• 有时与用例相关——但并非总是如此。<br>• 对于简单程序，可能是包含 main() 方法的类</p>
<h3 id="类的交互"><a href="#类的交互" class="headerlink" title="类的交互"></a>类的交互</h3><img src="/post/fit5136-se-notes/image-20210622012055988.png" class="" title="image-20210622012055988">

<ol>
<li>Actor 只能与边界对象对话。</li>
<li>边界对象只能与控制器和演员对话。</li>
<li>实体对象可以与控制器以及其他实体对象对话。</li>
<li>控制器可以与边界对象和实体对象对话，也可以与其他控制器对话，但不能与角色对话</li>
</ol>
<h3 id="Interaction-Diagrams-交互图"><a href="#Interaction-Diagrams-交互图" class="headerlink" title="Interaction Diagrams 交互图"></a>Interaction Diagrams 交互图</h3><p>使用交互图描述用例的特定场景的实现（准确地模拟了用例场景）（必须包括边界类对象和控制类对象）</p>
<h4 id="UML-Sequence-Diagram-序列图"><a href="#UML-Sequence-Diagram-序列图" class="headerlink" title="UML Sequence Diagram 序列图"></a>UML Sequence Diagram 序列图</h4><p>• 对系统内的<strong>逻辑流</strong>进行建模<br>• 描述一组对象如何以及以何种顺序协同工作<br>• 显示对象之间的交互。<br>• 规划并了解现有或未来场景的详细功能。<br>• 对用例的详细信息建模——用例场景。</p>
<img src="/post/fit5136-se-notes/image-20210622235848762.png" class="" title="image-20210622235848762">

<p>画出</p>
<img src="/post/fit5136-se-notes/image-20210622012608569.png" class="" title="image-20210622012608569">

<p>步骤：</p>
<p>如何细化场景并用它来展示<br>对象之间的交互？</p>
<ol>
<li>使用类图中的信息</li>
<li>然后，添加boundary边界和control控制类（意思就是这俩其实不在类图里……）</li>
<li>如果需要，您可以添加更多箭头来显示内部工作<br>系统</li>
<li>添加尽可能多的信息</li>
</ol>
<h4 id="UML-state-charts-状态表"><a href="#UML-state-charts-状态表" class="headerlink" title="UML state charts 状态表"></a>UML state charts 状态表</h4><p>考点：动态建模，使用特定场景的状态图对对象的行为进行建模。</p>
<img src="/post/fit5136-se-notes/image-20210622012553688.png" class="" title="image-20210622012553688">

<p>TODO</p>
<h2 id="W6-设计：从模块到对象"><a href="#W6-设计：从模块到对象" class="headerlink" title="W6 设计：从模块到对象"></a>W6 设计：从模块到对象</h2><h3 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h3><p>考点</p>
<p><strong>词法上连续</strong>的程序语句序列，以<strong>边界元素</strong>为界，带有<strong>聚合标识符</strong>（例如Java一个类）</p>
<p>好的模块化设计是：<br>模块<strong>内</strong>的最大关系<br>+<br>模块<strong>之间</strong>的最小关系</p>
<h4 id="模块的操作"><a href="#模块的操作" class="headerlink" title="模块的操作"></a>模块的操作</h4><p>– 它做什么，它的行为<br>– 例如 “计算其参数的平方根”</p>
<h4 id="模块的逻辑"><a href="#模块的逻辑" class="headerlink" title="模块的逻辑"></a>模块的逻辑</h4><p>– 它如何执行其操作<br>– 例如 牛顿计算平方根的方法</p>
<h4 id="模块的上下文："><a href="#模块的上下文：" class="headerlink" title="模块的上下文："></a>模块的上下文：</h4><p>– 具体用途<br>– 例如 计算双精度整数的平方根</p>
<h4 id="分配给模块的名称，即其操作"><a href="#分配给模块的名称，即其操作" class="headerlink" title="分配给模块的名称，即其操作"></a>分配给模块的名称，即其操作</h4><p>–（不是它的逻辑或上下文）<br>– 例如 computeSquareRoot、compute_square_root</p>
<h3 id="模块内聚-Cohesion"><a href="#模块内聚-Cohesion" class="headerlink" title="模块内聚 Cohesion"></a>模块内聚 Cohesion</h3><p>– 模块<strong>内</strong>的交互程度<br>– 模块<strong>内</strong>的元素属于一起的程度。</p>
<p>七个类别&#x2F;级别的凝聚力（非线性尺度）：</p>
<img src="/post/fit5136-se-notes/image-20210622013437939.png" class="" title="image-20210622013437939">

<p>模块的高内聚性是首选，因为它与软件的几个理想特性相关，包括健壮性、可靠性、可重用性和可理解性。</p>
<h4 id="Coincidental-Cohesion-碰巧内聚"><a href="#Coincidental-Cohesion-碰巧内聚" class="headerlink" title="Coincidental Cohesion 碰巧内聚"></a>Coincidental Cohesion 碰巧内聚</h4><p>模块执行多个完全不相关的操作（彼此松散相关）<br>例如：包含以下操作的模块：<br><code>printTheNextLine</code>, <code>reverseStringOfCharactersComprisingSecondArgument</code><br><code>add7ToFifthParameter</code>, <code>convertFourthParameterToFloatingPoint</code><br>来自这样的规则：“每个模块将由 35 到 50 个语句组成”</p>
<h4 id="Logical-Cohesion-逻辑内聚"><a href="#Logical-Cohesion-逻辑内聚" class="headerlink" title="Logical Cohesion 逻辑内聚"></a>Logical Cohesion 逻辑内聚</h4><p>模块执行一系列相关操作，其中一个由调用模块选择。<br>§ 执行逻辑相关的任务。例子：<br>– printReport() 函数&#x2F;方法打印各种销售报告。<br>§ 本地销售报告<br>§ 区域销售报告<br>§ 全国销售报告<br>§ 一份国际销售报告。<br>– 如果用户只需要区域报告怎么办？<br>– 如果您想生成每周报告怎么办？</p>
<p>出现什么问题？</p>
<ol>
<li>降低<strong>可读性</strong></li>
<li>多个操作的代码可能会<strong>交织</strong>在一起：“打印区域销售报告”和“打印全国销售报告”可能会交织在一起。</li>
<li><strong>维护</strong>问题，难以重复使用</li>
</ol>
<p>可以通过为每个报告制定程序来消除逻辑耦合的需要<br>可以引入继承来提高内聚度。</p>
<h4 id="时间（经典）内聚"><a href="#时间（经典）内聚" class="headerlink" title="时间（经典）内聚"></a>时间（经典）内聚</h4><p>一个模块执行多个功能，而这些功能之间的关联在于它们必须在特定时间的同一时间跨度内发生。例子：</p>
<p>一个程序（模块）执行以下步骤<br>§ 关掉电视<br>§ 关灯<br>§ 刷牙<br>§ 睡觉</p>
<p>例子：<br>– 执行以下操作的“初始化”程序：</p>
<ol>
<li>打开所有文件。</li>
<li>初始化数组和所有变量。</li>
<li>设置所有常量</li>
<li>设置所有标志</li>
<li>读取第一笔交易</li>
</ol>
<p>– 捕获异常后调用过程</p>
<ol>
<li>关闭所有打开的文件</li>
<li>创建错误日志</li>
<li>通知用户</li>
</ol>
<p>时间内聚很容易被发现，因为代码被放在一个过程中并被执行，因为在程序中的某个时间这样做很方便。</p>
<h4 id="Procedural-过程内聚"><a href="#Procedural-过程内聚" class="headerlink" title="Procedural 过程内聚"></a>Procedural 过程内聚</h4><p>§ 模块执行一系列操作，这些仅与受软件影响的一般过程有关<br>§ 两个模块示例：<br>– <code>readPartNumberAndUpdateRepairRecordOnMasterFile</code><br>– 在绘图仪上绘制图形 R2 并打印报告 XYZ。<br>§ R2 上的信息和报告 XYZ 不相关。<br>§ 至少两个操作在过程上是相互关联的。<br>§ 与 Temporal Cohesion 非常相似，但这不仅在特定时间执行。<br>§ 为什么这么糟糕？<br>– 动作仍然弱连接，<br>– 所以模块不可重用</p>
<p>需要将它们分成数个过程，例如上面第一个模块：<br>– <code>readPartNumber()</code><br>– <code>UpdateRepairRecordonMasterFile()</code></p>
<h4 id="Communication-通信内聚"><a href="#Communication-通信内聚" class="headerlink" title="Communication 通信内聚"></a>Communication 通信内聚</h4><p>§ 如果一个模块支持的所有活动都使用相同的输入或输出数据，或者访问和修改数据结构的相同部分，则该模块表现出通信内聚。<br>§ 例子：<br>一个模块包含以下活动：<br>– 查找书名<br>– 查找书的价格<br>– 查找图书出版商<br>– 查找书籍作者<br>§ 为什么不制作一个包含所有必需值的 Book 对象？</p>
<p>§ 更好 - 操作更紧密地联系在一起<br>§ 为什么还是不行？<br>§ 可重用性仍然存在问题</p>
<h4 id="Functional-功能内聚"><a href="#Functional-功能内聚" class="headerlink" title="Functional 功能内聚"></a>Functional 功能内聚</h4><p>一个模块只执行一个动作<br>§ 例子：<br>– getTemperatureOfFurnace<br>– computeOrbitalOfElectron<br>– writeToDatabase<br>– calculateSalesCommission<br>– sortArray<br>– findLargestValue</p>
<p>为什么这么好？<br>§ 更可重用<br>§ 纠正性维护更容易: 更少的回归错误<br>§ 更容易扩展产品</p>
<h4 id="信息内聚"><a href="#信息内聚" class="headerlink" title="信息内聚"></a>信息内聚</h4><p>模块执行多个动作，每个动作都有自己的入口点，每个动作都有独立的代码，都在相同的数据结构上执行。</p>
<p>例子<br>– <code>void addEmployee(int status, empRec rec);</code><br>– <code>void updateEmployee(int status, empRec rec);</code><br>– <code>void deleteEmployee(int status, empRec rec);</code></p>
<p>模块执行所有主文件访问操作。 它读取、添加、更新和删除主文件记录。 这些函数中的每一个都有自己的入口点。</p>
<p>示例：控件类</p>
<p>好处<br>§ 信息内聚使开发人员能够“打包”与给定数据结构相关的所有功能。<br>§ 如果通过应用程序为所有与数据结构相关的功能提供单一位置，这可以降低维护成本。<br>缺点<br>§ 如果其他应用程序不需要所有功能，则可能会增加应用程序的内存需求，从而限制其他应用程序的效用</p>
<h3 id="模块耦合"><a href="#模块耦合" class="headerlink" title="模块耦合"></a>模块耦合</h3><p>– 模块<strong>之间</strong>的交互程度<br>– 软件模块<strong>之间</strong>的相互依赖<br>– 衡量两个例程或模块的紧密程度</p>
<p>如果对一个模块的更改不会对另一个模块产生太大影响，则这两个模块是松散耦合的。</p>
<p>如果两个模块完全不相关，则它们是解耦的。</p>
<img src="/post/fit5136-se-notes/image-20210622015305163.png" class="" title="image-20210622015305163">


<p>低耦合是结构良好的计算机系统的标志。 当与高内聚性相结合时，支持高可读性和可维护性的一般目标。</p>
<h4 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h4><p>一个模块直接引用另一个模块的内容<br>一个模块修改或依赖另一个模块的内部工作<br>§ 示例 1：模块 p 修改模块 q 的语句<br>§ 示例 2：模块 p 指的是模块 q 的局部数据，表示 q 内的一些数值位移（变化）。<br>§ 示例 3：模块 p 分支到模块 q 的本地标签<br>§ 示例 4：公共与私有属性。</p>
<p>为什么这么糟糕？<br>§ 几乎对模块 q 的任何更改，甚至用新编译器重新编译 q，都需要对模块 p 进行更改<br>§ 违反信息隐藏<br>§ 数据封装</p>
<h4 id="公共耦合"><a href="#公共耦合" class="headerlink" title="公共耦合"></a>公共耦合</h4><p>§ 公共耦合，当两个或多个函数共享全局数据时发生。<br>– 对它们的任何更改都会产生连锁反应。<br>§ 示例 1：模块 cca 和 ccb 可以访问和更改 globalVariable 的值<br>§ 示例 2：模块 cca 和 ccb 都可以访问同一个数据库，并且可以读写相同的记录</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (globalVar == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xyz.arg &gt; <span class="number">25</span>)</span><br><span class="line">        xyz.method3();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        xyz.method4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块可能有副作用</p>
<p>影响可读性：是什么导致这个循环终止？</p>
<p>§ 在一个模块中对全局变量的声明进行更改需要在其他模块中进行相应的更改<br>§ 公共耦合模块难以重用<br>§ 一个模块暴露于比必要更多的数据。 这可能导致网络犯罪</p>
<h4 id="控制耦合"><a href="#控制耦合" class="headerlink" title="控制耦合"></a>控制耦合</h4><p>一个模块将控制元素传递给另一个<br>当一个模块通过传递控制信息来控制另一个模块的流量时发生控制耦合<br>§ 示例1：一个操作码被传递给一个具有逻辑内聚性的模块<br>§ 示例 2：作为参数传递的控制开关</p>
<p>p调用q</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Module p &#123; // has two methods</span><br><span class="line">	print(int i)&#123;</span><br><span class="line">		………</span><br><span class="line">		printReport(i); // control switch i passed as an argument</span><br><span class="line">		…………</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	doSomething(int k) &#123;………&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这么差？<br>模块不是独立的<br>– 模块q（被调用模块）必须知道模块p的内部结构和逻辑<br>– 这会影响可重用性</p>
<h4 id="标记耦合"><a href="#标记耦合" class="headerlink" title="标记耦合"></a>标记耦合</h4><p>§ 一些语言只允许简单的变量作为参数</p>
<p>– partNumber<br>– satelliteAltitude<br>– degreeOfMultiprogramming</p>
<p>§ 很多语言也支持数据结构的传递</p>
<p>– partRecord<br>– satelliteCoordinates<br>– segmentTable</p>
<p>如果<strong>数据结构</strong>作为参数传递，则两个模块是标记耦合的，但被调用的模块对数据结构的部分而非全部独立组件进行操作</p>
<p>为什么这么糟糕？<br>§ 例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calculateLibraryFine(StudentRecord student)</span><br></pre></td></tr></table></figure>

<p>§ 不清晰，不阅读整个模块，记录的哪些字段被访问或更改<br>§ 难以理解<br>§ 不太可能重复使用<br>§ 传递了不必要的数据<br>§ 注意：如果数据结构的所有组件都被访问和&#x2F;或更改，则将数据结构作为参数传递是可以的</p>
<h4 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h4><p>§ 当方法通过参数定期共享数据时，会发生数据耦合。<br>§ 数据耦合优于戳耦合，因为模块准确地获取它需要的东西，而无需知道特定数据结构的结构。<br>§ 例子：</p>
<p>– displayTimeOfArrival(flightNumber);<br>– computeProduct(firstNumber,secondNumber);<br>– getJobWithHighestPriority(jobQueue);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> speed, order;</span><br><span class="line">	loop:</span><br><span class="line">	get(order);</span><br><span class="line">	<span class="keyword">switch</span>( order )&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: calculate_airspeed(speed);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: display_airspeed(speed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这么好？<br>§ 不存在内容、通用、控制、标记耦合的困难<br>§ 维护更简单<br>§ 减少回归故障。</p>
<h3 id="内聚-耦合"><a href="#内聚-耦合" class="headerlink" title="内聚+耦合"></a>内聚+耦合</h3><p>§ 模块的高内聚性是首选，因为它与软件的几个理想特性相关，包括健壮性、可靠性、可重用性和可理解性。<br>§ 低耦合是结构良好的计算机系统的标志。 当与高内聚性相结合时，支持高可读性和可维护性的一般目标。</p>
<p><strong>因此，高内聚和低耦合是好的设计的关键。</strong></p>
<h3 id="UML的导向性"><a href="#UML的导向性" class="headerlink" title="UML的导向性"></a>UML的导向性</h3><p>• 也称为“导航可见性”、“导航”或“可见性”或“知道”。<br>• 即，要将消息从一个对象发送到另一个对象，它必须是可见的。<br>• 例子：</p>
<img src="/post/fit5136-se-notes/image-20210622075518208.png" class="" title="image-20210622075518208">

<p>• 学生可以“看到”单位，因为它是学生类中的一个属性。<br>• 用箭头表示：单向可见性（单向）。</p>
<p>• 双向导向增加了复杂性<br>– 每当发生更改时都需要维护关联的两端</p>
<p>• 学生了解单位，单位了解学生。<br>• 当一种方式就足够时尽量避免。</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">READ height of rectangle</span><br><span class="line">READ width of rectangle</span><br><span class="line">COMPUTE area as height times width</span><br><span class="line"></span><br><span class="line">// Input: READ, OBTAIN, GET</span><br><span class="line">// Output: PRINT, DISPLAY, SHOW</span><br><span class="line">// Compute: COMPUTE, CALCULATE, DETERMINE</span><br><span class="line">// Initialize: SET, INIT</span><br><span class="line">// Add one: INCREMENT, BUMP</span><br><span class="line"></span><br><span class="line">IF (HoursWorked &gt; NormalMax)</span><br><span class="line">  Display overtime message</span><br><span class="line">ELSE</span><br><span class="line">  Display regular time message</span><br><span class="line">END IF</span><br><span class="line">// Can also have ELSE IF</span><br><span class="line"></span><br><span class="line">WHILE Population &lt; Limit</span><br><span class="line">  Compute Population as Population + Births – Deaths</span><br><span class="line">ENDWHILE</span><br><span class="line"></span><br><span class="line">WHILE employee.type NOT EQUAL manager AND personCount &lt; numEmployees</span><br><span class="line">  INCREMENT personCount</span><br><span class="line">  CALL employeeList.getPerson with personCount RETURNING employee</span><br><span class="line">ENDWHILE</span><br><span class="line"></span><br><span class="line">CASE grade OF</span><br><span class="line">  A : points = 4</span><br><span class="line">  B : points = 3</span><br><span class="line">  C : points = 2</span><br><span class="line">  D : points = 1</span><br><span class="line">  F : points = 0</span><br><span class="line">ENDCASE</span><br><span class="line"></span><br><span class="line">REPEAT</span><br><span class="line">  Display A</span><br><span class="line">UNTIL A &gt; B</span><br><span class="line"></span><br><span class="line">// FOR each month of the year (good)</span><br><span class="line">// FOR month = 1 to 12 (ok)</span><br><span class="line">// FOR each employee in the list (good)</span><br><span class="line">FOR empno = 1 to listsize</span><br><span class="line">  Display empno</span><br><span class="line">ENDFOR</span><br><span class="line"></span><br><span class="line">CALL Swap with CurrentItem and TargetItem</span><br><span class="line"></span><br><span class="line">CALL SquareRoot with orbitHeight RETURNING nominalOrbit</span><br></pre></td></tr></table></figure>

<h2 id="W7-软件设计"><a href="#W7-软件设计" class="headerlink" title="W7 软件设计"></a>W7 软件设计</h2><p>就是纵向第三步Design workflow</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>TODO：跳过了前面的铺垫</p>
<p>• 模式是一种表示、共享和重用知识的手段。<br>• 架构模式是对良好设计实践的程式化描述，已经在不同环境中进行了尝试和测试。<br>• 模式应包括有关何时有用以及何时无用的信息。<br>• 可以使用表格和图形描述来表示模式。</p>
<h4 id="MVC-pattern"><a href="#MVC-pattern" class="headerlink" title="MVC pattern"></a>MVC pattern</h4><table>
<thead>
<tr>
<th>名称</th>
<th>MVC (Model-View-Controller)</th>
</tr>
</thead>
<tbody><tr>
<td>介绍</td>
<td>将展示和交互与系统数据分开。 该系统由三个相互交互的逻辑组件构成。 模型组件管理系统数据和对该数据的相关操作。 View 组件定义和管理数据如何呈现给用户。 控制器组件管理用户交互（例如，按键、鼠标点击等）并将这些交互传递给视图和模型。</td>
</tr>
<tr>
<td>适用于</td>
<td>当有多种方式查看和交互数据时使用。 当未来对数据交互和呈现的要求未知时也使用。</td>
</tr>
<tr>
<td>优势</td>
<td>允许数据独立于其表示而改变，反之亦然。 支持以不同方式呈现相同数据，并在所有这些方式中以一种表示方式进行更改。</td>
</tr>
<tr>
<td>劣势</td>
<td>当数据模型和交互很简单时，可能会涉及额外的代码和代码复杂性。</td>
</tr>
</tbody></table>
<ul>
<li><p>Model模型管理应用程序域的行为和数据<br>– 响应有关其状态信息的请求（通常来自视图）<br>– 响应改变状态的指令（通常来自控制器）</p>
</li>
<li><p>View视图管理信息的显示</p>
</li>
<li><p>Controller 控制器解释用户输入<br>– 通常是鼠标和键盘，<br>– 通知模型和&#x2F;或视图进行适当的更改。</p>
</li>
</ul>
<p>• 视图和控制器都<strong>依赖于模型</strong>，但模型<strong>不依赖</strong>于它们<br>– 模型可以独立于视图和控制器进行构建和测试<br>• 在独立（桌面）应用程序中，视图和控制器之间的分离并不总是很清楚。<br>– 但总是有益的<br>• 在基于 Web 的应用程序中，它们被清楚地区分：<br>– 视图是在浏览器上实现的<br>– 控制器在服务器端实现：处理 HTTP 请求的组件</p>
<h4 id="Layered-architecture-pattern-分层架构"><a href="#Layered-architecture-pattern-分层架构" class="headerlink" title="Layered architecture pattern 分层架构"></a>Layered architecture pattern 分层架构</h4><p>• 用于模拟子系统的接口。<br>• 将系统组织成一组层（或抽象机器），每个层提供一组服务。<br>• 然而，通常人为地以这种方式构建系统。</p>
<img src="/post/fit5136-se-notes/image-20210622082040975.png" class="" title="image-20210622082040975">

<table>
<thead>
<tr>
<th>名称</th>
<th>分层架构</th>
</tr>
</thead>
<tbody><tr>
<td>介绍</td>
<td>将系统组织成具有与每一层相关联的相关功能的层。 一个层向它上面的层提供服务，因此最低层代表可能在整个系统中使用的核心服务。</td>
</tr>
<tr>
<td>适用于</td>
<td>在现有系统上建造新设施时使用； 当开发分布在多个团队中，每个团队负责一层功能时； 当需要多级安全时。</td>
</tr>
<tr>
<td>优势</td>
<td>只要保持界面，就允许替换整个层。 可以在每一层提供冗余设施（例如，身份验证）以增加系统的可靠性。</td>
</tr>
<tr>
<td>劣势</td>
<td>在实践中，在层之间提供清晰的分离通常很困难，并且高层可能不得不直接与较低层交互，而不是直接通过它下面的层。 由于在每一层处理服务请求时对服务请求进行多级解释，因此性能可能是一个问题。</td>
</tr>
</tbody></table>
<h4 id="Repository-architecture-存储库架构"><a href="#Repository-architecture-存储库架构" class="headerlink" title="Repository architecture 存储库架构"></a>Repository architecture 存储库架构</h4><p>子系统必须交换数据。 这可以通过两种方式完成：<br>– 共享数据保存在中央数据库或存储库中，所有子系统都可以访问；<br>– 每个子系统维护自己的数据库并将数据明确地传递给其他子系统。</p>
<img src="/post/fit5136-se-notes/image-20210622210717116.png" class="" title="image-20210622210717116">

<h4 id="C-x2F-S-architecture-客户端-服务器架构"><a href="#C-x2F-S-architecture-客户端-服务器架构" class="headerlink" title="C&#x2F;S architecture 客户端-服务器架构"></a>C&#x2F;S architecture 客户端-服务器架构</h4><p>• 分布式系统模型，显示数据和处理如何分布在一系列组件中。<br>• 一组提供特定服务（例如打印、数据管理等）的独立服务器。<br>• 一组调用这些服务的客户端。<br>• 允许客户端访问服务器的网络。</p>
<img src="/post/fit5136-se-notes/image-20210622213225241.png" class="" title="image-20210622213225241">

<table>
<thead>
<tr>
<th>名称</th>
<th>Client-server</th>
</tr>
</thead>
<tbody><tr>
<td>介绍</td>
<td>在客户端-服务器架构中，系统的功能被组织成服务，每个服务从一个单独的服务器提供。 客户端是这些服务的用户，并访问服务器以使用它们。</td>
</tr>
<tr>
<td>适用于</td>
<td>当必须从<strong>一系列位置</strong>访问共享数据库中的数据时使用。 因为服务器可以复制，所以也可以在系统负载可变时使用。</td>
</tr>
<tr>
<td>优势</td>
<td>此模型的主要优点是服务器可以分布在网络中。 通用功能（例如打印服务）可以对所有客户端可用，不需要由所有服务实现。</td>
</tr>
<tr>
<td>劣势</td>
<td>每个服务都是单点故障，因此容易受到拒绝服务攻击或服务器故障的影响。 性能可能无法预测，因为它取决于网络和系统。 如果服务器由不同的组织拥有，则可能是管理问题。</td>
</tr>
</tbody></table>
<h3 id="OO设计"><a href="#OO设计" class="headerlink" title="OO设计"></a>OO设计</h3><p>略</p>
<ul>
<li>为您的软件确定设计模式</li>
<li>详细类图，将初始类图推进到：<ul>
<li>添加方法，添加属性</li>
<li>确定属性格式</li>
<li>分配每个方法（返回类型、参数等）</li>
<li>为关联分配可导航性</li>
</ul>
</li>
<li>架构设计（例如 .MVC）和设计决策</li>
<li>设计原则：信息隐藏、责任驱动设计、可扩展性决定类图的方法。</li>
<li>所有软件工程师都能理解的伪代码</li>
</ul>
<h2 id="W8-道德规范-amp-知识产权（IP）"><a href="#W8-道德规范-amp-知识产权（IP）" class="headerlink" title="W8 道德规范 &amp; 知识产权（IP）"></a>W8 道德规范 &amp; 知识产权（IP）</h2><p>软件工程道德规范（考点，略，加油查表）。</p>
<ul>
<li>使用代码评估场景中的行为</li>
<li>建议可能的解决方案或行动。</li>
</ul>
<p>知识产权是思想的表达，而不是思想本身。</p>
<ul>
<li>软件著作权</li>
<li>软件专利</li>
<li>开源软件（Copyleft）</li>
</ul>
<h2 id="W9-实现上的问题"><a href="#W9-实现上的问题" class="headerlink" title="W9 实现上的问题"></a>W9 实现上的问题</h2><p>太coding了基本上不会考</p>
<p>这里相当于implement workflow + construction phase，也就是任务最重的地方</p>
<ul>
<li>重用 Reuse</li>
<li>配置管理</li>
<li>Host target development 主机目标开发</li>
<li>编程问题：<ul>
<li>编程语言的选择</li>
<li>良好的编程习惯</li>
<li>编码标准</li>
<li>集成（持续？）</li>
</ul>
</li>
</ul>
<h2 id="W10-质量和测试"><a href="#W10-质量和测试" class="headerlink" title="W10 质量和测试"></a>W10 质量和测试</h2><ul>
<li>质量保证QA（Quality Assurance）</li>
<li>质量保证技术<ul>
<li>人工审核（演练Walkthroughs和检查Inspections，Non-execution-based）</li>
<li>证明（正式方式，Non-execution-based）</li>
<li>软件测试（Execution-based）</li>
</ul>
</li>
</ul>
<h2 id="W11-软件测试"><a href="#W11-软件测试" class="headerlink" title="W11 软件测试"></a>W11 软件测试</h2><p>必考</p>
<img src="/post/fit5136-se-notes/image-20210622163528781.png" class="" title="image-20210622163528781">

<ul>
<li>Positive正面测试确定您的应用程序按预期工作。 如果在正面测试期间遇到错误，则测试失败。</li>
<li>Negative负面测试可确保您的应用程序可以优雅地处理无效输入或意外的用户行为。<ul>
<li>例如，如果用户尝试在数字字段中键入字母，则在这种情况下的正确行为是显示“不正确，请输入数字”消息。</li>
<li>负面测试的目的是检测此类情况并防止应用程序崩溃。 负面测试可帮助您提高应用程序的质量并找到其弱点。</li>
</ul>
</li>
</ul>
<h4 id="等效性测试"><a href="#等效性测试" class="headerlink" title="等效性测试"></a>等效性测试</h4><p>也称为分区测试，您可以在其中识别具有共同特征并应以相同方式处理的输入组。<br>应该从这些组中的每一个中选择测试。</p>
<ul>
<li>输入数据和输出结果通常属于不同的类，其中一个类的所有成员都是相关的（有效和无效）</li>
<li>这些类中的每一个都是一个等效分区或域，其中程序对每个类成员都以等效的方式运行。</li>
<li>应从每个分区中选择测试用例。</li>
</ul>
<p>假设 DBMS 规定产品必须处理 1 到 16,383 (2 14 1) 之间的任意数量的记录。<br>在伪代码中，它可能是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (</span><br><span class="line">noOfRecords is between 1 and 16,383)</span><br><span class="line">// DBMS must do this…</span><br></pre></td></tr></table></figure>

<p>Range (1..16,383) 构成一个等价类<br>等价类的任何一个成员与等价类的任何其他成员一样是一个很好的测试用例</p>
<p>Range (1..16,383) 定义了三个不同的等价类：</p>
<p>等价类 1：少于 1 条记录</p>
<p>等价类 2：1 到 16,383 条记录</p>
<p>等价类 3：超过 16,383 条记录</p>
<h4 id="边值分析"><a href="#边值分析" class="headerlink" title="边值分析"></a>边值分析</h4><p>在等价类边界的一侧或仅在其一侧选择测试用例 (1 … 16383)<br>结合边界值和等价类测试的测试用例总数：</p>
<ul>
<li>测试用例 1：0 条记录 等价类 1 的成员且与边界值相邻</li>
<li>测试用例 2：1 条记录边界值</li>
<li>测试用例 3：2 条记录邻近边界值</li>
<li>测试用例 4：723 条记录 等价类 2 的成员</li>
<li>测试用例 5：16,382 条记录与边界值相邻</li>
<li>测试用例 6：16,383 条记录 边界值</li>
<li>测试用例 7：16,384 条记录 等价类 3 的成员且与边界值相邻</li>
</ul>
<p>这大大增加了检测到故障的概率</p>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>Test to specifications：忽略代码，使用规范选择测试用例</p>
<p>假设sepc包括 20 个因素，每个因素有 4 个值： 4^20 个测试用例</p>
<p>对规范的详尽测试和对代码的详尽测试都不可行</p>
<p>测试艺术：</p>
<ul>
<li><p>选择一个小的、可管理的测试用例集</p>
</li>
<li><p>最大限度地提高检测到故障的机会，同时</p>
</li>
<li><p>最大限度地减少浪费测试用例的机会</p>
</li>
<li><p>每个测试用例都必须检测到以前未检测到的故障</p>
</li>
</ul>
<p>这样同一故障不会被多个测试用例检测到。 （不会浪费！）</p>
<p>我们需要能够突出尽可能多的错误的方法</p>
<img src="/post/fit5136-se-notes/image-20210622202634687.png" class="" title="image-20210622202634687">

<h4 id="Functional-Testing-功能性测试"><a href="#Functional-Testing-功能性测试" class="headerlink" title="Functional Testing 功能性测试"></a>Functional Testing 功能性测试</h4><p>经典软件黑盒测试的另一种形式</p>
<p>将测试数据基于代码工件的功能，每一项功能或功能都被识别<br>测试数据旨在分别测试每个（较低级别的）功能</p>
<p>然后，测试由这些低级函数组成的高级函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;higher level functionality&gt;::=</span><br><span class="line">  if &lt;conditional expression&gt;</span><br><span class="line">    &lt;lower level functionality 1&gt;;</span><br><span class="line">  else</span><br><span class="line">    &lt;lower level functionality 2&gt;</span><br></pre></td></tr></table></figure>



<h3 id="玻璃盒测试"><a href="#玻璃盒测试" class="headerlink" title="玻璃盒测试"></a>玻璃盒测试</h3><p>Test to code：使用<strong>代码</strong>选择测试用例（不可靠，比如÷0</p>
<p>通过工件的每条路径必须至少执行一次</p>
<p>这也称为Structural结构测试（白盒）</p>
<p>代码流图有助于手动找到正确的覆盖范围</p>
<p>问题：</p>
<ul>
<li>Statement 声明的覆盖</li>
<li>Branch 分支的覆盖</li>
<li>路径的覆盖</li>
<li>所有定义都使用路径的覆盖</li>
</ul>
<h4 id="Statement-coverage"><a href="#Statement-coverage" class="headerlink" title="Statement coverage"></a>Statement coverage</h4><p>运行一组测试用例，其中每个语句至少执行一次</p>
<p>需要跟踪的 CASE 工具</p>
<p>弱点：分支声明</p>
<p>两个语句都可以执行而不会出现错误：&amp;&amp; and ||</p>
<h4 id="Branch-coverage"><a href="#Branch-coverage" class="headerlink" title="Branch coverage"></a>Branch coverage</h4><p>运行一组测试用例，其中每个分支至少执行一次（以及所有语句）</p>
<p>这解决了上一张幻灯片上的问题</p>
<p>同样，需要一个 CASE 工具</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void try(int x, int y) &#123;</span><br><span class="line">  if (x == 0) y++;</span><br><span class="line">  if (y == 0) x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单个测试用例 try(0, 1) 足以满足语句覆盖率，但不足以满足分支覆盖率。</p>
<p>为了实现分支覆盖，测试用例：<br>try(0, 1) 对<strong>两个</strong> if 都为 true<br>try(1, 2) 对<strong>两个</strong> if 都为 false</p>
<h4 id="Path-Coverage"><a href="#Path-Coverage" class="headerlink" title="Path Coverage"></a>Path Coverage</h4><p>运行一组测试用例，其中每条路径都执行一次（以及所有语句）</p>
<p>问题：</p>
<p>路径的数量可能非常大，例如。 for 循环</p>
<p>我们想要一个比所有路径都更弱的条件，但这会显示出比分支覆盖更多的错误</p>
<h4 id="All-Definition-Use-Path-Coverage-所有定义使用路径覆盖"><a href="#All-Definition-Use-Path-Coverage-所有定义使用路径覆盖" class="headerlink" title="All-Definition-Use-Path Coverage 所有定义使用路径覆盖"></a>All-Definition-Use-Path Coverage 所有定义使用路径覆盖</h4><p>每次出现的变量，zz，都被标记为</p>
<ul>
<li><p>变量的定义：<code>zz = 1</code> 或 <code>read(zz)</code></p>
</li>
<li><p>或变量的使用：<code>y = zz + 3</code> 或 <code>if (zz &lt; 9) errorB()</code></p>
</li>
</ul>
<p>确定从变量定义到使用该定义的所有路径（可以通过自动工具完成）</p>
<p>为每个这样的路径设置一个测试用例</p>
<h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul>
<li>在实施工作流程中进行测试</li>
<li>测试用例选择<ul>
<li>黑盒单元测试（功能性）：忽略代码，使用规范选择测试用例</li>
<li>Glass-box玻璃盒单元测试（语句、分支、路径）：忽略规范，使用代码选择测试用例</li>
</ul>
</li>
<li>等价类划分和边值分析（可以是黑盒或玻璃盒）</li>
<li>集成测试（由程序员）</li>
<li>交付前的最终测试：<ul>
<li>产品测试（QA 团队、程序员）</li>
<li>验收测试（客户、QA 团队、程序员）</li>
</ul>
</li>
</ul>
<h2 id="W12-交付后维护"><a href="#W12-交付后维护" class="headerlink" title="W12 交付后维护"></a>W12 交付后维护</h2><p>不在考试内容里</p>
<h2 id="Mock-Exam"><a href="#Mock-Exam" class="headerlink" title="Mock Exam"></a>Mock Exam</h2><p>一般来说考试结构和模拟考差不多（老天保佑），所以这里讲下模拟考里知识点分布</p>
<p>每个part的背景内容不一样，但是实际考试说明了会是一样的（so focus on <strong>traceability</strong>）</p>
<p>考试明说了不会让写代码，顶多伪代码，5个问题（小问题不好说啊，很可能总共10个小问题）</p>
<h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><p>只有一题，偏向理论，20‘。</p>
<p>让你结合案例，分析[the Unified Process](#The Unified Process 统一流程)，W4内容</p>
<p>这里估计会跑偏，就可能是别的definition</p>
<h3 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h3><p>分为三题</p>
<h4 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h4><p>画UML use case diagram 10’</p>
<p>简单，不过要注意是<a href="#%E7%94%A8%E4%BE%8B%E5%9B%BE"><strong>use case</strong> diagram 用例图</a></p>
<p>就几个人（Actor），一个系统框，框里一堆椭圆形操作，人和操作连一连。</p>
<h4 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h4><p>补全[use case scenario](#第一步：功能建模 - 用例场景)的 Exception conditions（including reasonable actions to be taken， 即要写系统怎么handle）9‘</p>
<p>比较简单</p>
<h4 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h4><p>第三个是31’的超级大题</p>
<p>画 <strong>initial</strong> UML <strong>class</strong> diagram</p>
<p>要求：</p>
<p>包括<strong>类</strong>的适当<strong>属性</strong><br>使用泛化、关联和聚合来描述类之间的关系<br>正确指示关系的多样性（基数）。<br><strong>不包括职责或操作</strong>。 此时没有所有信息来执行此操作。</p>
<p>pdf里还有个（1）小题，让找出名词（也就是找class第一步）。</p>
<p>要注意的是问题边界外（即，不在UML里的）的名词也需要写进去</p>
<img src="/post/fit5136-se-notes/image-20210623000050998.png" class="" title="image-20210623000050998">

<h3 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h3><p>[UML **sequence** diagram](#UML Sequence Diagram 序列图)</p>
<img src="/post/fit5136-se-notes/image-20210622235717947.png" class="" title="image-20210622235717947">



<h3 id="Part-4"><a href="#Part-4" class="headerlink" title="Part 4"></a>Part 4</h3><p>[UML **state chart** diagram](#UML state charts 状态表)</p>
<img src="/post/fit5136-se-notes/image-20210622235402270.png" class="" title="image-20210622235402270">

<p>和lecture里的相比多了个框和标题，别的就：</p>
<p>起始点-&gt;各个state-&gt;state之间过程、操作-&gt;终止点</p>
<h3 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h3><p>道德准测，15’</p>
<p>基本上老老实实做ASS的肯定都是熟练工了</p>
<ol>
<li>找到可能存在的问题</li>
<li>评价行为（即，最后需要写should do）</li>
</ol>
<p>都要有code support哦，因为是开卷所以应该是好查的。</p>
<h3 id="Part-6"><a href="#Part-6" class="headerlink" title="Part 6"></a>Part 6</h3><p>画the Unified Process的<a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%EF%BC%88%E5%9E%82%E7%9B%B4%EF%BC%89">工作流</a>，15‘</p>
<p>表现出（粗略）在该项目期间给予<strong>不同工作流</strong>的<strong>相对工作量</strong>。 在 x（时间）轴上大致表示“事件 1”、“事件 2”和“事件 3”发生的时间。</p>
<h3 id="Part-7"><a href="#Part-7" class="headerlink" title="[Part 7]"></a>[Part 7]</h3><p>括号的内容只在PDF（可能只是线下考试）里看见，网上考试没有，疑似被删 （or被精简，毕竟伪代码真的长）</p>
<p>根据分析<a href="#%E4%BC%AA%E4%BB%A3%E7%A0%81">伪代码</a>来写出 <a href="#%E7%8E%BB%E7%92%83%E7%9B%92%E6%B5%8B%E8%AF%95">glass box unit testing</a></p>
<table>
<thead>
<tr>
<th>Test No &amp; Brief Desc</th>
<th>var a</th>
<th>var b</th>
<th>var c</th>
<th>Expected output&#x2F;behaviour</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>和Ass的差不太多，考的明显比Lecture里讲的简单。</p>
<p>和黑盒关注IO参数不一样，玻璃盒就需要关注内部var（需要instr, car.speed, car.status这种原型数据）和if&#x2F;case导致结果的不同</p>
<p>个人感觉考试还是黑盒，明显黑盒更有考点</p>
<img src="/post/fit5136-se-notes/image-20210623000819346.png" class="" title="image-20210623000819346">

<ul>
<li>Reason: Pos&#x2F;Neg? + Desc</li>
<li>vars …</li>
<li>Expected Result</li>
<li>Actual （考试估计不要求，or给定）</li>
<li>Fail&#x2F;Pass+comment（就在失败里写写原因</li>
</ul>
<h3 id="Part-8"><a href="#Part-8" class="headerlink" title="[Part 8]"></a>[Part 8]</h3><p>[Functional requirements](#Functional requirements) 和 [Non-Functional Requirement](#Non-functional requirements)</p>
<p>就帮着修改requirements来达到”精确，明确，完整和一致“</p>
<p>先鉴定是(Non-)Functional，然后再重写。（明显不难</p>
<h2 id="实际考试"><a href="#实际考试" class="headerlink" title="实际考试"></a>实际考试</h2><p>差不多</p>
<p>出乎意料测试没怎么考</p>
<p>反倒是use case让写了全部（手断）</p>
<p>initial UML反而简单。state chart 较难（需要配合guard）</p>
<p>第一题的Unified Process画图也比想想的要难，需要对几个workflow都有点理解，每个event的发生点及影响也要熟练。（感觉自己应该是做错了，四个phase都没画齐全）</p>
]]></content>
      <tags>
        <tag>software management</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5137: Advanced database technology</title>
    <url>/post/fit5137-adv-db-notes/</url>
    <content><![CDATA[<p>所谓的“高级数据库技术”居然是NoSQL……</p>
<span id="more"></span>

<h2 id="W1-Intro"><a href="#W1-Intro" class="headerlink" title="W1 Intro"></a>W1 Intro</h2><p>关系型数据库<br>Structured Query Language (SQL)<br>ACID (Atomicity, Consistency, Isolation, Durability) 原子性，一致性，隔离性，持久性</p>
<p>非关系型数据库（&#x3D;NoSQL）<br>BASE (Basically Available, Soft state, Eventual consistency)  基本可用性，软状态，最终一致性</p>
<p>Big Data特征（3V）</p>
<ul>
<li>Volume （数据）量 -&gt; Scaling up&#x2F;out-&gt;up&#x3D;升配; out&#x3D;加机</li>
<li>Velocity （数据输入的）速 -&gt; stream &#x2F; feedback-loop</li>
<li>Variety 多样化 -&gt; Structured&#x2F;Unstructured&#x2F;Semi-structured</li>
</ul>
<p>因此使用传统关系型数据库难以处理BigData</p>
<p>NoSQL的属性</p>
<ul>
<li>schema-free 不受结构限制</li>
<li>Support distributed database architectures 支持分布式数据库架构</li>
<li>high scalability, high availability, and fault tolerance 高拓展，高可用，错误容忍</li>
</ul>
<p>NoSQL的分类</p>
<ul>
<li>Key-value databases</li>
<li>Document-oriented databases</li>
<li>Column-oriented databases</li>
<li>Graph databases</li>
</ul>
<p>这个unit里不讲kv（讲kv估计要么讲太简单要么讲太难</p>
<p>后面三类的介绍略，在对应week会讲到</p>
<p>NoSQL</p>
<table>
<thead>
<tr>
<th>Adv</th>
<th>Disadv</th>
</tr>
</thead>
<tbody><tr>
<td>高拓展，可用，错误容忍</td>
<td>需要复杂的编程</td>
</tr>
<tr>
<td>使用低成本商品硬件</td>
<td>无关系——只有应用代码</td>
</tr>
<tr>
<td>支持BigData</td>
<td>没有事务完整性支持</td>
</tr>
<tr>
<td>k-v模型提高了存储效率</td>
<td>只提供了最终一致</td>
</tr>
</tbody></table>
<p>Relational Model</p>
<table>
<thead>
<tr>
<th>Adv</th>
<th>Disadv</th>
</tr>
</thead>
<tbody><tr>
<td>使用独立表使得结构独立。表结构变化不影响数据访问或应用程序</td>
<td>RMDBS需要大量硬件和系统软件开销</td>
</tr>
<tr>
<td>表视图提高了概念的简单些，促进数据库设计实现管理与使用</td>
<td>概念上的简单些为相对未受训练的人提供了良好的系统工具，但是如果不加以检查可能会产生与文件系统中数据发生异常</td>
</tr>
<tr>
<td>基于SQL的Ad-hoc查询能力</td>
<td>个人和部门开发各自的应用，产生信息孤岛（islands of info）问题</td>
</tr>
<tr>
<td>强大的RMDBS将最终用户和物理层面细节隔离开，提高实践和管理的简单性</td>
<td></td>
</tr>
</tbody></table>
<h2 id="W2-Intro-to-MongoDB"><a href="#W2-Intro-to-MongoDB" class="headerlink" title="W2: Intro to MongoDB"></a>W2: Intro to MongoDB</h2><p>Document-oriented databases, 本质上是K-V数据库的子类</p>
<p>面向文档的数据库是无模式scheme-free的。</p>
<ul>
<li>存储的数据没有预定义的结构</li>
<li>每个文档都可以有自己的结构</li>
</ul>
<p>文档：MongoDB 中数据的基本单位。<br>➢ 类似于关系数据库中的一行（但更具表现力）。<br>➢ 文档采用 BSON 结构——类似于 JSON（由字段和值对组成的数据结构）</p>
<p>集合：一组 MongoDB 文档。<br>➢ 类似于关系数据库中的表。<br>➢ 通常，集合中的所有文档都有相似或相关的目的。</p>
<p>数据库：集合的物理容器。</p>
<h3 id="易于使用"><a href="#易于使用" class="headerlink" title="易于使用"></a>易于使用</h3><p>用更灵活的模型文档替换了关系数据库中行的概念。</p>
<ul>
<li>复杂的层级关系可以用单个记录表示。</li>
<li>没有预定义的模式：文档的key和value不是固定的类型或大小</li>
</ul>
<p>MongoDB结合了横向扩展(scale out)的能力和各种功能，如二级索引、范围查询、排序、聚合和地理空间索引。</p>
<h3 id="易于拓展"><a href="#易于拓展" class="headerlink" title="易于拓展"></a>易于拓展</h3><p>▪ MongoDB 旨在横向扩展。<br>▪ 面向文档的数据模型可以更轻松地跨多个服务器拆分数据。<br>▪ MongoDB 自动负责平衡集群中的数据和负载，自动重新分发文档并将用户请求路由到正确的机器。<br>➢ 允许开发人员专注于对应用程序进行编程，而不是对其进行扩展。 </p>
<h3 id="众多特性"><a href="#众多特性" class="headerlink" title="众多特性"></a>众多特性</h3><p>MongoDB 旨在成为通用数据库。</p>
<p>主要特点：</p>
<ul>
<li>创建、读取、更新、删除 (CRUD) 操作</li>
<li>索引index：MongoDB 支持通用二级索引，允许多种快速查询，并提供唯一、复合、地理空间和全文索引功能。</li>
<li>聚合aggregation：MongoDB 支持“聚合管道”，允许从简单的片段构建复杂的聚合并允许数据库对其进行优化</li>
<li>特殊集合类型：MongoDB 支持应在特定时间到期的数据的生存时间集合，例如会话。 它还支持固定大小的集合，这对于保存最近的数据（例如日志）很有用。</li>
<li>文件存储：MongoDB 支持易于使用的协议来存储大文件和文件元数据。</li>
</ul>
<p>与关系数据库不同，MongoDB 不支持join和复杂的多行事务，因为在分布式系统中很难有效地提供这两种功能。</p>
<h3 id="不牺牲速度"><a href="#不牺牲速度" class="headerlink" title="不牺牲速度"></a>不牺牲速度</h3><p>MongoDB 的几乎每个方面都旨在保持高性能。</p>
<ul>
<li>MongoDB 为文档添加动态填充并预分配数据文件以换取额外的空间使用以获得一致的性能。</li>
<li>它使用尽可能多的 RAM 作为其缓存，并尝试自动选择正确的索引进行查询。</li>
</ul>
<h2 id="W3-Mongo-Shell"><a href="#W3-Mongo-Shell" class="headerlink" title="W3: Mongo Shell"></a>W3: Mongo Shell</h2><p>一些MongoDB的CRUD操作。GUI上操作是在MongoDB Compass下，在w2最后讲了。w3主要是在shell里自己coding。</p>
<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p>Create（<code>createCollection</code>， <code>insert[One/Many](&lt;Array of Objects&gt;)</code>，）</p>
<p>Update(<code>update[One/Many](&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;</code>) )</p>
<p>Delete(<code>.drop()</code>, <code>.dropDatabase()</code>,<code>delete[One/Many]</code>)在GUI下很简单，这里省略。</p>
<p>主要需要关注R(ead)里即Query的编写：<br><code>find[One/Many](&lt;query&gt;, &lt;fields&gt;)</code></p>
<p>Projection: find的第二个字段表示输出（Project）的内容</p>
<p>Limit &amp; Skip: Skip（跳过数个record）优先于Limit</p>
<p>Sort: 1 ascending , -1 descending</p>
<p>update也可以用replaceOne()，参数相同</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MongoDB 必须进行<strong>集合扫描</strong>（<strong>COLLSCAN</strong>）（扫描集合中的<strong>每个</strong>文档）以检索与用户查询语句匹配的文档。</p>
<p>通过索引（<strong>IXSCAN</strong>），可以加速查询处理。索引支持高效的数据检索，因为 MongoDB 可以使用索引来限制它必须检查的文档数量。</p>
<p><code>db.&lt;collection name&gt;.createIndex( &#123; KEY1:1, KEY2:1 &#125; )</code></p>
<p>注意：要升序索引，请使用 1。要降序索引，请使用 -1。</p>
<h2 id="W4-MongoDB-Aggregation"><a href="#W4-MongoDB-Aggregation" class="headerlink" title="W4: MongoDB Aggregation"></a>W4: MongoDB Aggregation</h2><p>略难的部分，有点绕口</p>
<p>Aggregation聚合操作处理数据记录并返回计算结果。<br>聚合操作将来自多个文档的值组合在一起，并且可以对分组的数据进行各种操作，返回一个<br>单一结果。<br>MongoDB 提供三种聚合方式：</p>
<ul>
<li>Aggregation pipeline</li>
<li>Map-reduce 功能</li>
<li>单一目的Aggregation方法</li>
</ul>
<h3 id="Aggregation管道"><a href="#Aggregation管道" class="headerlink" title="Aggregation管道"></a>Aggregation管道</h3><p>MongoDB 的聚合框架以数据处理管道的概念为模型。文档进入多阶段管道，将文档转换为聚合结果。</p>
<p>特性：<br>➢ 每一阶段接收前一阶段的输出。<br>➢ 应该在一个数组中，因为要遵循某些步骤。</p>
<p>$match：等于find</p>
<p>$group，精髓在于_id的选择</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.persons.aggregate(<span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> $match<span class="punctuation">:</span> <span class="punctuation">&#123;</span>gender<span class="punctuation">:</span> <span class="string">&quot;female&quot;</span><span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> </span><br><span class="line">        $group<span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 表示总人数</span></span><br><span class="line">            _id<span class="punctuation">:</span> <span class="punctuation">&#123;</span> state<span class="punctuation">:</span> <span class="string">&quot;$location.state&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">//匹配了上面所有</span></span><br><span class="line">            totalPersons<span class="punctuation">:</span> <span class="comment">// 新字段名字 </span></span><br><span class="line">                <span class="punctuation">&#123;</span> $sum<span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span> <span class="comment">// group需要配合$sum, $avg, $max, $min, $first, $last之类的操作分组</span></span><br><span class="line">        <span class="punctuation">&#125;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span>).pretty()</span><br></pre></td></tr></table></figure>

<p>$sort</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> $sort<span class="punctuation">:</span> <span class="punctuation">&#123;</span> totalPersons<span class="punctuation">:</span> <span class="number">-1</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>$project</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$project: &#123;</span><br><span class="line">    _id: 0, </span><br><span class="line">    name: 1, </span><br><span class="line">    email: 1, </span><br><span class="line">    birthdate: &#123; $convert: &#123; input: &#x27;$dob.date&#x27;, to: &#x27;date&#x27; &#125; &#125;, </span><br><span class="line">    age: &quot;$dob.age&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>$lookup(匹配文档之间关系)生成嵌入文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    $lookup<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        from<span class="punctuation">:</span> &lt;collection to join&gt;<span class="punctuation">,</span></span><br><span class="line">        localField<span class="punctuation">:</span> &lt;field from the input documents&gt;<span class="punctuation">,</span></span><br><span class="line">        foreignField<span class="punctuation">:</span> &lt;field from the documents of the <span class="string">&quot;from&quot;</span> collection&gt;<span class="punctuation">,</span></span><br><span class="line">        as<span class="punctuation">:</span> &lt;output array field&gt;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如，我们现有文档含有_id这个字段，从address这个collection（含有patron_id）之中找到和_id相同（匹配）的patron_id，然后作为一个列表放在当前文档的addresses里</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.patron.aggregate(<span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        $lookup<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            from<span class="punctuation">:</span> <span class="string">&quot;address&quot;</span><span class="punctuation">,</span></span><br><span class="line">            localField<span class="punctuation">:</span> <span class="string">&quot;_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            foreignField<span class="punctuation">:</span> <span class="string">&quot;patron_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            as<span class="punctuation">:</span> <span class="string">&quot;addresses&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3><p>检索每个含k的文档作为一个map，然后每个执行reduce</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.mapReduce(</span><br><span class="line">                         &lt;map&gt;, // function() &#123; emit(this.cust_id, this.amount) &#125;</span><br><span class="line">                         &lt;reduce&gt;, // function(k, v) &#123; return Array.sum(v) &#125; </span><br><span class="line">                         &#123;</span><br><span class="line">                           out: &lt;collection&gt;,</span><br><span class="line">                           query: &lt;document&gt;,</span><br><span class="line">                           sort: &lt;document&gt;,</span><br><span class="line">                           limit: &lt;number&gt;,</span><br><span class="line">                           finalize: &lt;function&gt;,</span><br><span class="line">                           scope: &lt;document&gt;,</span><br><span class="line">                           jsMode: &lt;boolean&gt;,</span><br><span class="line">                           verbose: &lt;boolean&gt;,</span><br><span class="line">                           bypassDocumentValidation: &lt;boolean&gt;</span><br><span class="line">                         &#125;</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure>

<p>测验常客 $unwind</p>
<h3 id="单一目的Aggregation方法"><a href="#单一目的Aggregation方法" class="headerlink" title="单一目的Aggregation方法"></a>单一目的Aggregation方法</h3><p>.estimatedDocumentCount( )<br>.count( )<br>.distinct( )</p>
<h2 id="W5-Introduction-to-Column-Oriented-Database"><a href="#W5-Introduction-to-Column-Oriented-Database" class="headerlink" title="W5 Introduction to Column-Oriented Database"></a>W5 Introduction to Column-Oriented Database</h2><p>▪ 源自 Google 的 BigTable 产品、HBase 和 Cassandra。<br>▪ 也称为列族数据库。<br>▪ 以键值对的形式组织数据，键映射到值组件中的一组列。<br>➢ Column：类似于关系数据库中一个数据单元格的键值对<br>➢ Key：列名<br>➢ Value：列中存储的数据<br>▪ 一组逻辑相关的列称为超级列。 所有超级列组合在一起以创建列族。 列族在概念上类似于关系模型中的表。<br>▪ 列族中的每个行键可以有不同的列。</p>
<p>▪ 面向列的 DBMS 是一种 DBMS，它将数据表存储为数据列的部分，而不是大多数 DBMS 实现中的数据行。<br>▪ 具有许多空值的列（称为稀疏sparse 数据）可以更有效地处理，而不会浪费空单元格的存储容量。</p>
<p>▪ 关系数据库既可以面向行，也可以面向列。<br>▪ 基于行的系统旨在高效地返回整行的数据，这与用户希望检索有关特定对象或实体的信息的常见用例相匹配。<br>▪ 大多数数据库系统通过数据库索引来加速搜索操作。</p>
<p>▪ 在面向列的数据库中，一列的所有值都放在磁盘上</p>
<p>Column-Oriented Databases</p>
<table>
<thead>
<tr>
<th>Adv</th>
<th>Disadv</th>
</tr>
</thead>
<tbody><tr>
<td>加快查询处理和聚合操作。</td>
<td>检索与单个实体有关的所有属性变得效率低下</td>
</tr>
<tr>
<td>高效的存储空间消耗（非常适合处理稀疏数据）。</td>
<td>Join操作将大大减慢（必须扫描每一列才能找到属于某个外部记录标识符的值）。</td>
</tr>
</tbody></table>
<p>以下是 Google BigTable 的核心功能：<br>➢ 开发者可以动态控制列。<br>➢ 数据值由行标识符、列名和时间戳索引。<br>➢ 数据建模者和开发者可以控制数据的位置。<br>➢ 一行的读写是原子的。<br>➢ 行按排序顺序维护。</p>
<p>▪ 行由多个列族组成。 每个系列由一组相关的列组成。<br>▪ 数据值由行、列名和时间戳记索引</p>
<p>▪ 数据值按行标识符、列名和时间戳编制索引。<br>➢ 行标识符类似于关系数据库中的主键。<br>▪ 一个列值可以存在多个版本。 查询列值时默认返回最新版本。</p>
<p>Apache Cassandra Features</p>
<ul>
<li>Distributed</li>
<li>Decentralized</li>
<li>Elastically scalable</li>
<li>Highly available &amp; Fault-tolerant</li>
</ul>
<p>Monolithic Architecture-&gt; single point of failure</p>
<p>The Master-slave model (only master server performs writes)-&gt; a failure of the write master</p>
<p>sharding to scale writes -&gt; Requires manual shuffling of data &amp; Failure points of the master nodes</p>
<p>处理领导者的死亡<br>▪ 提高主从系统可用性的解决方案。<br>▪ 采用主故障转移协议。<br>▪ 协议因实现而异。<br>▪ 原则是当前一个master失败时指定一个新的master</p>
<p>领导选举的不良特征<br>▪ 应用程序必须了解数据库拓扑。<br>▪ 必须仔细规划数据分区。<br>▪ 写入难以扩展。<br>▪ 故障转移通常会显着增加系统的复杂性，对于多站点数据库尤其如此。<br>▪ 增加容量需要重新整理数据，这可能会导致停机。</p>
<p>Cassandra 是一个可弹性伸缩的数据库<br>▪ 可扩展性——可以在性能几乎没有下降的情况下继续处理更多的请求。<br>➢ 纵向扩展：增加更多的硬件容量和内存。<br>➢ 水平扩展：添加更多的机器，上面有全部或部分数据，这样没有一台机器必须承担服务请求的全部负担。<br>▪ 弹性可扩展性 – 指横向可扩展性的一个特殊属性，这意味着您的集群可以无缝扩展和缩减</p>
<p>Cassandra 的点对点方法<br>▪ Cassandra 集群中的所有节点都可以接受读取和写入，无论写入或请求的数据属于集群中的哪个位置。<br>▪ 节点间通信通过gossip 协议进行，该协议允许所有节点快速接收更新，而无需主协调器</p>
<p>P2P方法有几个优点：</p>
<ol>
<li>简单。</li>
<li>没有节点可以是单点故障。</li>
<li>扩展和缩减相当简单：在集群中添加或删除服务器。<br>➢ 点对点网络中的服务器相互通信，最终为新节点分配一组数据进行管理。<br>➢ 当一个节点被移除时，托管来自被移除节点的数据副本的服务器响应读写请求。</li>
</ol>
<p>▪ 由于P2P网络没有单一的主协调服务器，集群中的服务器负责管理主服务器将处理的许多操作，包括以下内容：<br>➢ 共享集群中服务器状态信息<br>➢ 确保节点拥有最新版本的数据<br>➢ 确保在应该接收写入的服务器不可用时存储写入数据<br>▪ Cassandra 拥有实现所有这些功能的协议。</p>
<p>节点间通信（Gossip）<br>▪ Gossip协议：<br>o 是对等通信协议。<br>o 定期交换关于它们自己和集群中其他节点的状态信息。<br>o 在计时器上每秒运行一次，并最多与其他三个节点交换状态消息。<br>o 用作分布式数据库中的自动复制机制<br>o 较旧的信息被特定节点的最新状态覆盖</p>
<p>▪ 每次将服务器添加到集群中时，以完整的服务器到服务器通信协议发送的消息数量增长得更快。</p>
<p>Gossiper 如何运作<br>▪ 每秒一次，Gossiper 将在集群中随机选择一个节点并与其初始化gossip 会话。<br>o 每轮gossip 需要三个消息。<br>▪ gossip 发起者向其选择的朋友发送 GossipDigestSynMessage。<br>▪ 当朋友收到这个消息时，它返回一个 GossipDigestAckMessage。<br>▪ 当发起者收到好友的 ack 消息时，它会向好友发送 GossipDigestAck2Message 以完成一轮gossip 。</p>
<p>Cassandra ——Read<br>▪ Cassandra 集群中的任何节点都可以处理客户端请求。<br>▪ 所有节点都有关于集群状态的信息，并且可以充当客户端的代理，将请求转发到集群中的适当节点。</p>
<p>Cassandra ——Write<br>▪ 如果一个节点不可用，则其他节点可以代表它接收写入请求，并在可用时将它们转发到预期节点。</p>
<p>什么时候使用面向列的数据库？<br>▪ 列族数据库是需要高水平写入性能、大量服务器或多数据中心可用性的大规模数据库部署的合适选择。<br>➢ Cassandra 支持多数据中心部署，包括多数据中心复制。<br>▪ 写密集型操作，例如社交网络应用程序中的操作，是使用列族数据库的良好候选者。<br>➢ Cassandra 的点对点架构支持暗示切换，这意味着只要至少有一个节点在运行且可达，数据库将始终能够接受写操作。<br>▪ 列族数据库也适用于需要大量服务器来满足预期工作负载的情况。</p>
<h2 id="W6-Apache-Cassandra-Architecture-amp-CQL"><a href="#W6-Apache-Cassandra-Architecture-amp-CQL" class="headerlink" title="W6 Apache Cassandra Architecture &amp; CQL"></a>W6 Apache Cassandra Architecture &amp; CQL</h2><h3 id="Cassandra-架构的特点"><a href="#Cassandra-架构的特点" class="headerlink" title="Cassandra 架构的特点"></a>Cassandra 架构的特点</h3><p>▪ Cassandra 没有主节点或从节点。<br>▪ 它具有环型&#x2F;点对点架构。<br>▪ 数据自动分布在所有节点上。<br>▪ 跨节点复制数据以实现冗余。<br>▪ 数据保存在内存中并缓慢写入磁盘。<br>▪ 键的哈希值用于在集群中的节点之间分配数据。<br>▪ Cassandra 架构支持多个数据中心。<br>▪ 数据可以跨数据中心复制。</p>
<h3 id="环和令牌"><a href="#环和令牌" class="headerlink" title="环和令牌"></a>环和令牌</h3><p>▪ Cassandra 将集群管理的数据表示为环。<br>▪ 环中的每个节点都由一个令牌描述。<br>▪ 令牌是用于标识每个分区的 64 位 ID。<br>▪ 令牌范围从 -263 到 263-1。<br>▪ 通过使用散列函数计算分区键的令牌，将数据分配给节点。</p>
<h3 id="Cassandra-架构的影响"><a href="#Cassandra-架构的影响" class="headerlink" title="Cassandra 架构的影响"></a>Cassandra 架构的影响</h3><p>▪ Cassandra 架构支持将数据透明地分发到节点。<br>➢ 这意味着您可以根据数据确定您的数据在集群中的位置。</p>
<p>▪ 任何节点都可以接受任何请求，因为没有主节点或从节点。<br>➢ 如果一个节点有数据，它会返回数据。<br>➢ 否则，它将请求发送到有数据的节点</p>
<p>▪ 您可以指定数据的副本数以达到所需的冗余级别。<br>➢ 例如，如果数据非常关键，您可能希望指定复制因子为 4 或 5。<br>➢ 如果数据不重要，您可以只指定一两个。</p>
<p>▪ 它还提供可调整的一致性——一致性级别可以指定为与性能的权衡。<br>➢ 事务总是写入磁盘上的提交日志，以便它们是持久的。</p>
<h3 id="关键结构"><a href="#关键结构" class="headerlink" title="关键结构"></a>关键结构</h3><p>▪ 节点：您存储数据的地方。<br>▪ 数据中心：相关节点的集合。<br>▪ 集群：包含一个或多个数据中心。<br>▪ 提交日志：所有数据首先写入提交日志以保证持久性。<br>▪ Mem-table：内存常驻数据结构。<br>▪ SSTable：排序字符串表（SSTable）是一个不可变的数据文件，Cassandra 定期向其中写入内存表。<br>▪ 布隆过滤器：测试元素是否为集合成员的算法。</p>
<h3 id="Cassandra-写入过程"><a href="#Cassandra-写入过程" class="headerlink" title="Cassandra 写入过程"></a>Cassandra 写入过程</h3><ol>
<li>数据写入磁盘上的提交日志。</li>
<li>根据哈希值将数据发送到负责节点。</li>
<li>节点将数据写入名为 mem-table 的内存表。</li>
<li>从mem-table，数据写入内存中的SSTable。<br>➢ SSTable 代表 Sorted String 表。 这具有对表的所有更新的合并数据。</li>
<li>从SSTable，数据更新到实际表。</li>
<li>如果责任节点宕机，数据将写入另一个标识为tempnode的节点。 tempnode 将暂时保存数据，直到负责的节点活跃起来。</li>
</ol>
<p>▪ 将数据写入磁盘上的提交日志以保持持久性。<br>▪ 它也被写入内存中的内存表。<br>▪ Mem-table 数据写入 SSTable，用于更新实际表。</p>
<h3 id="Cassandra-架构"><a href="#Cassandra-架构" class="headerlink" title="Cassandra 架构"></a>Cassandra 架构</h3><p>▪ 数据中心和机架<br>➢ 机架是一组相互靠近的逻辑节点，<br>也许在单个设备机架中的物理机器上<br>➢ 数据中心是一组逻辑机架，可能位于同一<br>建立并通过可靠网络连接</p>
<h3 id="Cassandra-读取过程"><a href="#Cassandra-读取过程" class="headerlink" title="Cassandra 读取过程"></a>Cassandra 读取过程</h3><p>▪ Cassandra 读取过程确保快速读取。<br>▪ 如果节点关闭，则从数据的副本中读取数据。 副本的优先级是根据距离分配的。<br>▪ Cassandra 读取过程的特点是：<br>➢ 同一节点上的数据优先，被认为是本地数据。<br>➢ 同一机架上的数据具有第二优先权，被视为机架本地数据。<br>➢ 同一数据中心上的数据具有第三优先权，被视为数据中心本地。<br>➢ 不同数据中心的数据优先级最低</p>
<h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>▪ Cassandra 通过按以下方式对数据进行水平分区来执行数据的透明分发：<br>➢ 根据数据的主键计算哈希值。<br>➢ 键的哈希值映射到集群中的一个节点<br>➢ 数据的第一个副本存储在该节点上。<br>➢ 分布是透明的，因为您可以计算哈希值并确定特定行的存储位置</p>
<h3 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h3><p>▪ 分区器决定数据如何在集群中的节点之间分布。<br>▪ 分区键用于数据分区。 每行都有一个分区键，用于标识分区。<br>▪ Cassandra 中提供了三种类型的分区器：<br>➢ Murmur3Partitioner – Cassandra 中的默认分区器。<br>➢ RandomPartitioner – 与 Murmur3Partitioner 类似，不同之处在于它使用 MD5（消息摘要版本 5）哈希函数来计算哈希值。<br>➢ ByteOrderedPartitioner – 使用分区键值对行进行排序。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>▪ 复制是指为每一行维护的副本数。<br>▪ 复制为容错提供数据冗余。<br>▪ N 的复制因子意味着系统中维护了 N 个数据副本。<br>▪ Cassandra 允许基于节点、机架和数据中心的复制。<br>▪ 跨数据中心的复制即使在数据中心停机时也能保证数据可用性。</p>
<h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>▪ 复制策略决定了如何维护一个数据行的多个副本。<br>▪ 复制是在keyspace 级别指定的，<strong>不同的keyspace 可以有不同的策略</strong>。<br>▪ Cassandra 以对用户透明的方式跨节点复制数据。<br>▪ 复制因子是集群中将接收相同数据副本的节点数。<br>▪ Cassandra 提供两种常见的复制策略：<br>➢ SimpleStrategy：将副本放置在环周围的连续节点上。<br>➢ NetworkTopologyStrategy：为每个数据中心指定不同的复制因子，将副本分配到不同的机架rack以最大化可用性。</p>
<h3 id="告密者snitches"><a href="#告密者snitches" class="headerlink" title="告密者snitches"></a>告密者snitches</h3><p>▪ snitches确定哪些数据中心和机架节点属于。<br>▪ 任务是确定集群中每个节点的相对主机接近度。<br>▪ snitches会找出节点相对于其他节点的位置。<br>▪ 两种最流行的snitches：<br>➢ Simple Snitch - Simple Snitch 用于没有机架的单个数据中心。<br>➢ 属性文件 Snitch - 属性文件 Snitch 用于具有多个机架的多个数据中心。<br>▪ Cassandra 中的复制基于snitches。</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>▪ 节点故障的影响：<br>➢ 其他节点检测节点故障。<br>➢ 该节点上的数据请求被路由到拥有该数据副本的其他节点。<br>➢ 写入由临时节点处理，直到节点重新启动。<br>➢ 任何丢失的 memtable 或 sstable 数据都从 commitlog 中恢复。<br>➢ 可以使用 nodetool 实用程序永久删除节点。</p>
<h4 id="▪-磁盘故障的影响："><a href="#▪-磁盘故障的影响：" class="headerlink" title="▪ 磁盘故障的影响："></a>▪ 磁盘故障的影响：</h4><p>➢ 磁盘上的数据无法访问。<br>➢ 无法从节点读取数据。<br>➢ 此问题将被视为该部分数据的节点故障。<br>➢ Memtable 和 sstable 不受影响，因为它们是内存表。<br>➢ Commitlog 有副本，它们将用于恢复。</p>
<h4 id="▪-机架rack故障的影响："><a href="#▪-机架rack故障的影响：" class="headerlink" title="▪ 机架rack故障的影响："></a>▪ 机架rack故障的影响：</h4><p>➢ 机架上的所有节点都无法访问。<br>➢ 无法从机架节点读取数据。<br>➢ 读取将路由到数据的其他副本。<br>➢ 这将被视为机架中的每个节点都发生了故障。</p>
<h4 id="▪-数据中心故障的影响："><a href="#▪-数据中心故障的影响：" class="headerlink" title="▪ 数据中心故障的影响："></a>▪ 数据中心故障的影响：</h4><p>➢ 数据中心内的所有数据都将无法访问。<br>➢ 所有读取都必须路由到其他数据中心。<br>➢ 将使用其他数据中心的副本副本。<br>➢ 虽然系统将运行，但客户可能会注意到由于网络延迟而变慢。 这是因为多个数据中心通常位于不同的物理位置并通过广域网连接</p>
<h3 id="一致性级别"><a href="#一致性级别" class="headerlink" title="一致性级别"></a>一致性级别</h3><p>▪ Cassandra 提供可调的一致性级别。<br>▪ 可以为每个读取或写入查询指定一致性级别。<br>➢ 对于读查询，一致性级别指定了有多少副本节点必须响应读请求。<br>➢ 对于写操作，一致性级别指定了必须响应多少副本节点才能上报写操作。<br>➢ R + W &gt; N &#x3D; 强一致性<br>➢ R：读副本数 W：写副本数 N：复制因子</p>
<h2 id="W7-Designing-Column-Oriented-Databases-列数据库设计"><a href="#W7-Designing-Column-Oriented-Databases-列数据库设计" class="headerlink" title="W7 Designing Column-Oriented Databases 列数据库设计"></a>W7 Designing Column-Oriented Databases 列数据库设计</h2><h3 id="Primary-amp-Compound-Keys-主键与复合键"><a href="#Primary-amp-Compound-Keys-主键与复合键" class="headerlink" title="Primary &amp; Compound Keys 主键与复合键"></a>Primary &amp; Compound Keys 主键与复合键</h3><p>Cassandra 中的主键可以是复合键，复合键是指由多列组成的键。<br>当指定复合键时，第一个键被考虑用于数据分区，称为分区键。<br>每个分区中的数据按剩余的键进行聚类和排序。</p>
<h3 id="Guidelines-for-Designing-Tables-表设计"><a href="#Guidelines-for-Designing-Tables-表设计" class="headerlink" title="Guidelines for Designing Tables 表设计"></a>Guidelines for Designing Tables 表设计</h3><p>面向列的数据库的实现方式与关系数据库不同。<br>▪ 重要的是要了解：<br>➢ 列族数据库被实现为稀疏的多维映射。<br>➢ 行之间的列可以不同。<br>➢ 可以动态添加列。<br>➢ 不使用连接； 数据被非规范化。<br>列数据库的这些特性将影响数据库设计指南</p>
<p>在面向列的数据库中设计表时的几个准则：<br>➢ 非规范化而不是连接。<br>➢ 利用无值的列。<br>➢ 使用列名和列值来存储数据。<br>➢ 使用单行对实体进行建模。<br>➢ 避免行键热点。<br>➢ 保留适当数量的列值版本。<br>➢ 避免列值中的复杂数据结构。<br>▪ 应该注意的是，其中一些建议（例如 使用适当数量的列值版本）并不适用于所有列族数据库系统。</p>
<p>Denormalize Instead of Join<br>面向列的数据库通常需要比关系数据库更少的表。<br>➢ 它对数据进行非规范化以避免需要连接。</p>
<p>Make Use of Valueless Columns<br>该表没有像“ProductPurchased1”这样名称为“PR _ B1839”的列，而是简单地将产品 ID 存储为列名</p>
<p>Use Both Column Names and Column Values to Store Data<br>▪ 列名和列值都可以存储数据。<br>▪ 使用无值列的一种变体使用列值进行非规范化。<br>▪ 非规范化数据的缺点：在客户表中保留产品名称的副本会增加使用的存储量。<br>▪ 非规范化数据的好处：客户和他们购买的产品的报告是通过只引用一张表而不是两张表来生成的。<br>▪ 实际上，我们是在牺牲对额外存储的需求来提高读取性能。</p>
<p>Model an Entity with a Single Row<br>▪ 单个实体，例如特定客户或特定产品，应将其所有属性放在一行中。<br>➢ 这可能导致某些行存储的列值多于其他行的情况，但这在列族数据库中并不少见。<br>▪ ColumnFamily数据库不提供与关系数据库相同级别的事务控制。 通常，写入一行是原子的。 如果您更新表中的多个列，它们将全部更新，或者它们都不更新。</p>
<p>Avoid Hotspotting in Row Keys<br>分布式系统使您能够利用大量服务器来解决问题。 在一台或几台机器上指挥过多的工作而其他机器未得到充分利用是低效的。</p>
<p>Keep an Appropriate Number of Column Value Versions<br>▪ HBase 使您能够存储列值的多个版本。<br>▪ 列值带有时间戳，因此您可以确定最新和最早的值。<br>▪ 与其他形式的版本控制一样，如果您<br>需要回滚您对列值所做的更改。<br>▪ 这不适用于 Apache Cassandra</p>
<p>Avoid Complex Data Structures in Column Values<br>例如，关于客户的 JSON 文档可能包含一个存储地址信息的嵌入文档，如下所示：<br>▪ 这种类型的数据结构可能存储在一个列值中，但不推荐使用，除非有特殊原因需要维护这种结构。<br>▪ 为每个属性使用单独的列可以更轻松地将数据库功能应用于属性。 例如，为街道、城市、州和邮政编码创建单独的列意味着您可以对这些值创建二级索引。<br>▪ 此外，将属性分成单独的列允许您在需要时使用不同的列族。 使用二级索引的能力和根据列的使用方式分隔列的选项都可以提高数据库性能。</p>
<p>Using Secondary Indexes Managed by the Column Family Database System<br>使用 ColumnFamily 数据库系统管理的二级索引<br>如果您需要列值的二级索引并且列族数据库系统提供了自动管理的二级索引，那么您应该使用它们。<br>▪ 使用自动管理的二级索引的主要优点是与替代方法相比，它们需要更少的代码来维护。<br>▪ 有时您不应该使用自动管理的索引。 在以下情况下<strong>避免</strong>或至少仔细测试索引的使用：<br>➢ 列中有少量不同的值。<br>➢ 一列有很多唯一unique值。<br>➢ 列值稀疏</p>
<p>▪ 有很少不同值的列不是二级索引的良好候选。<br>▪ 当列中不同值的数量（称为列的基数）很小时，索引不会对性能有太大帮助——它甚至可能会受到伤害。<br>▪ 具有太多不同值的行也不适合用作索引。<br>▪ 自动管理的索引在这里可能没有多大帮助，因为索引必须维护如此多的数据，搜索索引和检索数据可能比扫描表以获取特定值花费更多的时间<br>▪ 在许多行不使用列的情况下，二级索引可能无济于事。<br>▪ 不应为稀疏填充的列编制索引</p>
<p>何时使用表创建和管理二级索引<br>▪ 帮助生成列出购买特定产品的所有客户的报告。<br>▪ 他们还想要一份关于特定产品以及哪些客户购买了这些产品的报告</p>
<h3 id="Guidelines-for-Indexing-索引设计"><a href="#Guidelines-for-Indexing-索引设计" class="headerlink" title="Guidelines for Indexing 索引设计"></a>Guidelines for Indexing 索引设计</h3><h3 id="Cassandra-Data-Model-数据模型"><a href="#Cassandra-Data-Model-数据模型" class="headerlink" title="Cassandra Data Model 数据模型"></a>Cassandra Data Model 数据模型</h3><p>Rules</p>
<p>▪ 最大化写入次数<br>➢ Cassandra 针对高写入性能进行了优化。<br>➢ 最大化写入对于读取性能和数据可用性很有用。<br>▪ 最大化数据复制<br>➢ 数据非规范化和数据重复是 Cassandra 的事实。<br>➢ 磁盘空间通常是最便宜的资源（与 CPU、内存、磁盘 IOP 或网络相比），Cassandra 是围绕这一事实构建的。 为了获得最高效的读取，您经常需要复制数据。<br>➢ 数据复制提供即时数据可用性和无单点故障。</p>
<p>Goals</p>
<p>▪ 在集群周围均匀分布数据<br>➢ 您希望集群中的每个节点具有大致相同的数据量。<br>➢ 行基于分区键的散列分布在集群中，分区键是 PRIMARY KEY 的第一个元素。 因此，均匀分布数据的关键是：选择一个好的主键。<br>▪ 最小化查询数据时读取的分区数<br>➢ 分区是共享相同分区键的行组。 当您发出读取查询时，您希望从尽可能少的分区读取行。<br>➢ 需要选择均衡数量的分区。</p>
<h2 id="W8-Non-Relational-Database-Transactions"><a href="#W8-Non-Relational-Database-Transactions" class="headerlink" title="W8 Non-Relational Database Transactions"></a>W8 Non-Relational Database Transactions</h2><p>BASE</p>
<ol>
<li>Data Management in Big Data</li>
<li>ACID vs BASE</li>
<li>CAP Theorem</li>
</ol>
<p>▪ 数据库旨在做两件事：存储数据和检索数据。<br>▪ 为了实现这些目标，数据库管理系统必须做三件事：<br>➢ 持久存储数据<br>➢ 保持数据一致性<br>➢ 确保数据可用性</p>
<h3 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h3><p>▪ 数据必须持久存储；即必须以数据库服务器关闭时数据不丢失的方式进行存储。<br>▪ 如果数据只存储在内存（即 RAM）中，那么当内存断电时，数据就会丢失。<br>▪ 只有存储在磁盘、闪存、磁带或其他长期存储设备上的数据才被视为永久存储<br>▪ 数据必须可用于检索。<br>▪ 您可以通过多种不同的方式检索永久存储的数据。<br>➢ 存储在闪存设备上的数据直接从其存储位置读取。<br>➢ 磁盘和磁带驱动器的可移动部件放置到位，使设备的读头位于要读取的数据块上。<br>▪ 可以将数据库设计为简单地从数据文件的开头开始，并在执行读取操作时搜索您需要的记录。<br>➢ 这会导致极其漫长的响应时间和宝贵的计算资源的浪费。<br>➢ 无需扫描全表查找数据，您可以使用数据库索引快速找到特定数据块的位置。</p>
<h3 id="数据一致"><a href="#数据一致" class="headerlink" title="数据一致"></a>数据一致</h3><p>▪ 确保将正确数据写入持久存储设备非常重要。<br>➢ 如果写或读操作不能准确记录或检索数据，数据库将没有多大用处。<br>➢ 除非出现硬件故障，否则这很少成为问题。<br>▪ 当两个或更多人使用数据库并希望同时使用相同的数据时，会出现一个更常见的读写问题。<br>▪ 数据库返回的结果表明客户已支付其帐户的应付余额，而不将该付款也包括在可用资金记录中，这将是不一致的。<br>▪ 关系数据库系统旨在支持此类必须被视为单个操作或事务的多步骤过程。</p>
<h3 id="数据可用"><a href="#数据可用" class="headerlink" title="数据可用"></a>数据可用</h3><p>▪ 数据应在需要时可用。<br>➢ 这很难保证。<br>o硬件可能会出现故障。<br>o数据库服务器上的操作系统可能需要打补丁。<br>o您可能需要安装新版本的数据库管理系统。<br>o在单个服务器上运行的数据库可能由于多种原因不可用。<br>▪ 避免数据库服务器不可用问题的一种方法是拥有两台数据库服务器：一个用于更新数据和响应查询，而另一个用作备份，以防第一台服务器出现故障。<br>▪ 用于更新和响应查询的服务器称为主服务器，另一个是备份服务器。<br>▪ 备份服务器从主服务器上的数据库副本开始。<br>▪ 使用数据库时，对主数据库的任何更改也会反映在备份数据库中。<br>▪ 回想一下，数据库事务是由多个步骤组成的操作，必须完成所有步骤才能完成事务。<br>▪ 如果多个步骤中的任何一个失败，则整个交易失败。<br>▪ 更新两个数据库使每次更新成为一个多步骤过程。<br>➢ 当公司使用单台服务器时，更新仓库中特定产品的数量只需一步</p>
<p>▪ 更新两个数据库的过程与其他多步事务类似：两个数据库都必须成功，操作才能成功。<br>▪ 主数据库和备份数据库必须一致。<br>▪ 两阶段提交：<br>➢ 在操作的第一阶段，数据库将数据写入或提交到主服务器的磁盘。<br>➢ 在操作的第二阶段，数据库将数据写入备份服务器的磁盘。</p>
<h2 id="W9-Introduction-to-Graph-Databases"><a href="#W9-Introduction-to-Graph-Databases" class="headerlink" title="W9 Introduction to Graph Databases"></a>W9 Introduction to Graph Databases</h2><p>▪ 图数据库基于称为图论的数学分支。<br>▪ 该数学领域的技术可用于分析实体之间的联系和联系。</p>
<h3 id="什么是图？"><a href="#什么是图？" class="headerlink" title="什么是图？"></a>什么是图？</h3><p>▪ 图是由两部分组成的数学对象：顶点和边。<br>➢ 顶点有时被称为节点。<br>▪ 每个顶点&#x2F;节点代表一个实体（人、地点、事物、类别或其他数据）。<br>▪ 每条边代表两个顶点&#x2F;节点之间的关系（代表两个节点如何关联）。</p>
<h3 id="顶点Vertex"><a href="#顶点Vertex" class="headerlink" title="顶点Vertex"></a>顶点Vertex</h3><p>▪ 一个顶点代表一个用唯一标识符标记的实体。<br>➢ 类似于列族数据库中的行键或关系数据库中的主键。<br>▪ 一个顶点实际上可以代表任何与另一个实体有关系的实体，例如：<br>➢ 社交网络中的人<br>➢ 高速公路连接的城市<br>➢ 与体内其他蛋白质相互作用的蛋白质<br>➢ 公司分销网络中的仓库<br>➢ 集群中的计算服务器<br>▪ 顶点用于表示对象。<br>▪ 顶点可以有属性。<br>o 例如，社交网络中的一个顶点代表一个人； 它具有姓名、地址和出生日期等属性。<br>o 高速公路系统图使用顶点来表示城市。 城市有人口、经度和纬度以及名称，并且位于地理区域内。</p>
<h3 id="边Edge"><a href="#边Edge" class="headerlink" title="边Edge"></a>边Edge</h3><p>▪ 边，也称为链接link或弧arc，定义顶点或连接顶点的对象之间的关系。<br>o 例如，在一个家谱数据库中，顶点可以代表人，而边代表他们之间的关系，例如“女儿”和“父亲”。<br>o 在高速公路数据库的情况下，城市用顶点表示，而边表示连接城市的高速公路。<br>▪ 边代表顶点之间的关系。<br>▪ 与顶点非常相似，边也有属性。<br>o 例如，在高速公路数据库中，所有边都将具有属性，例如距离、限速和车道数。<br>o 在家族树示例中，边可能具有诸如指示两个人是否因婚姻、收养或生物学相关的属性。<br>▪ 一个常用的属性称为边的权重。<br>▪ 权重代表关系的某些价值。<br>o 例如，在高速公路的情况下，权重可能是城市之间的距离。<br>o 在社交网络中，权重可以表明两个人在彼此的墙上发帖或评论彼此的帖子的频率。<br>▪ 一般而言，权重可以表示成本、距离或由顶点表示的对象之间关系的其他度量。</p>
<p>▪ 边有两种类型：有向和无向。<br>▪ 有向边有一个方向。 这用于指示应如何解释由边建模的关系。<br>▪ 然而，方向并不总是需要的。 例如，假设交通双向流动，高速公路图可能是无向的。</p>
<p>图形数据库比关系数据库管理系统 (RDBMS) 更易于理解。</p>
<h3 id="Neo4j-Highlights"><a href="#Neo4j-Highlights" class="headerlink" title="Neo4j Highlights:"></a>Neo4j Highlights:</h3><ul>
<li>A native graph database</li>
<li>Whiteboard friendly.</li>
<li>Supports rapid development.</li>
<li>Designed for business-critical and high-performance operations.</li>
</ul>
<p>图形数据库将数据存储在图形中，图形是最通用的数据结构，能够以高度可访问的方式优雅地表示任何类型的数据。Neo4j 图基于属性图模型。</p>
<h2 id="W10-amp-W11-Graph-Databases"><a href="#W10-amp-W11-Graph-Databases" class="headerlink" title="W10 &amp; W11 Graph Databases"></a>W10 &amp; W11 Graph Databases</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>▪ 通过图的路径是一组顶点以及这些顶点之间的边。<br>▪ 图中的顶点都彼此不同。<br>▪ 如果边是有向的，则路径为有向路径。 如果图是无向图，则其中的路径是无向路径。<br>▪ 示例：从 B 到 D 到 H 到 I 的顶点和边是从顶点 B 到顶点 I 的路径。<br>▪ 路径很重要，因为它们捕获有关图中顶点如何相关的信息。<br>▪ 例如：<br>o 在家庭图中，一个人是其他人的祖先，仅当存在从该人到其祖先的有向路径时。<br>o 就家谱而言，从一个人到一个祖先只有一条路径。<br>o 在高速公路图的情况下，城市之间可能有多条路径。<br>▪ 使用图形时遇到的一个常见问题是找到两个顶点之间的权重最小的路径。<br>➢ 权重可以表示使用边的成本、遍历边所需的时间或您试图最小化的其他一些度量。</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>▪ 环是将顶点与其自身相连的边。<br>▪ 例如，在生物学中，蛋白质可以与其他蛋白质相互作用。 一些蛋白质与相同类型的其他蛋白质分子相互作用。 可以使用循环来表示这一点。<br>▪ 但是，与方向一样，在某些图中允许循环可能没有意义。 例如，循环在家庭树图中没有多大意义； 人们不能成为自己的父母或孩子。</p>
<p>图数据库非常适用于容易用实体和实体之间的关系描述的问题域。<br>▪ 实体几乎可以是任何东西，从蛋白质到行星。<br>▪ 图数据库应用程序经常包括涉及以下内容的查询和分析：<br>o 识别两个实体之间的关系。<br>o 从节点识别边的共同属性。<br>o 从节点计算边的聚合属性。<br>o 计算节点属性的聚合值。</p>
<h3 id="图的操作"><a href="#图的操作" class="headerlink" title="图的操作"></a>图的操作</h3><p>▪ 对数据库执行的常见操作包括插入、读取、更新和删除数据。 图数据库也执行这些操作。<br>▪ 图数据库也非常适合一组额外的操作。 具体来说，操作可用于跟踪路径或检测顶点之间关系中的重复模式。<br>图形独有的三个重要操作：<br>▪ 图的联合<br>▪ 图的交集<br>▪ 图遍历</p>
<p><strong>图的并集</strong>（Union）是图中顶点和边的组合集合。</p>
<p><strong>图的交集</strong>（intersection ）是两个图共有的顶点和边的集合。</p>
<p>图遍历<br>▪ 图遍历是以特定方式访问图中所有顶点的过程。 这样做的目的通常是设置或读取图形中的某些属性值。<br>图遍历是访问图中所有节点的过程</p>
<h3 id="图和节点的属性"><a href="#图和节点的属性" class="headerlink" title="图和节点的属性"></a>图和节点的属性</h3><p>▪ 图形和节点的几个属性在比较和分析图形时很有用。<br>▪ 这些包括：</p>
<h4 id="o-同构Isomorphisms："><a href="#o-同构Isomorphisms：" class="headerlink" title="o 同构Isomorphisms："></a>o 同构Isomorphisms：</h4><p>▪ 如果第一个图中的每个顶点在另一个图中都有一个对应的顶点，则两个图被认为是同构的。<br>▪ 此外，对于第一个图中一对顶点之间的每条边，在另一个图中对应的顶点之间都有一条相应的边。<br>▪ 如果您试图检测一组图中的模式，则图同构很重要。<br>➢ 示例：社交网络图、流行病学</p>
<h4 id="o-顺序和大小Order-and-Size"><a href="#o-顺序和大小Order-and-Size" class="headerlink" title="o 顺序和大小Order and Size"></a>o 顺序和大小Order and Size</h4><p>▪ 顺序和大小是图形大小的度量。<br>➢ 图的阶数是顶点数，图的大小是图中边数。<br>▪ 图形的顺序和大小很重要，因为它们会影响执行操作所需的时间和空间。<br>➢ 很明显，在小图上执行并集或交集比在大图上执行相同操作花费的时间更少。<br>➢ 也很容易假设遍历小图比遍历大图花费的时间更少。</p>
<h4 id="o-等级Degress"><a href="#o-等级Degress" class="headerlink" title="o 等级Degress"></a>o 等级Degress</h4><p>▪ 度数是链接到顶点的边数，是衡量图中任何给定顶点重要性的一种方法。<br>▪ 度数高的顶点比度数低的顶点与其他顶点的连接更直接。<br>▪ 在解决通过网络传播信息或财产的问题时，学位很重要。</p>
<h4 id="o-距离Closeness"><a href="#o-距离Closeness" class="headerlink" title="o 距离Closeness"></a>o 距离Closeness</h4><p>▪ Closeness 是一个顶点的属性，表示该顶点与图中所有其他顶点的距离。<br>▪ 如果您想了解信息在社交网络中的传播、社区中的传染病或分发网络中的材料移动，紧密度是一个重要的衡量标准。<br>▪ 接近度值高的顶点可以比接近度值小的顶点更快地到达网络中的其他顶点。</p>
<h4 id="o-介数Betweenness"><a href="#o-介数Betweenness" class="headerlink" title="o 介数Betweenness"></a>o 介数Betweenness</h4><p>▪ 介数衡量给定顶点的瓶颈程度。<br>▪ 想象一座河上的城市，有许多道路，但只有一座桥<br>▪ 介数有助于识别网络中潜在的脆弱部分</p>
<h3 id="图形建模"><a href="#图形建模" class="headerlink" title="图形建模"></a>图形建模</h3><p>▪ 图形可用于对许多不同领域中的结构和流程进行建模。<br>➢ 有时，图形表示实体之间的关系，例如人或城市。<br>➢ 在其他情况下，图形表示材料或物体通过系统的流动，例如流经市政供水系统的水或高速公路上的卡车。<br>▪ 图表类型：<br>➢ 无向图和有向图<br>➢ 流网络<br>➢ 二部图<br>➢ 多重图<br>➢ 加权图</p>
<p>▪ 无向图是边没有方向的图。<br>➢ 这种类型的图用于对方向没有意义的关系或流进行建模。 例如，您可以使用无向边对家庭关系中的夫妻进行建模。<br>▪ 有向图是具有有向边的图。<br>➢ 您可以对具有有向边的父子关系建模。</p>
<p>无向图和有向图<br>▪ 在某些情况下，图中的某些边是有向的，而有些则不是。<br>➢ 例如，如果您对企业中的员工进行建模，则某些边可能表示员工和经理之间的“报告对象”关系。 这将使用有向边。<br>➢ 另一方面，同行之间的“合作”关系将是没有方向的。 它也可以建模为两个有向边。</p>
<p>流网络<br>▪ 流网络是一个有向图，其中每条边都有一个容量，每个顶点都有一组输入和输出边。<br>▪ 入边容量总和不能大于出边容量总和。<br>▪ 此规则的两个例外是源顶点和汇顶点。 源没有输入但有输出，而汇有输入但没有输出。</p>
<p>▪ 流网络也称为运输网络。<br>▪ 图数据库可用于模拟流动网络，如道路系统或交通网络。<br>▪ 它们还可用于模拟连续流动的过程，例如吸收雨水（源头）并使其流入河流（汇）的雨水渠网络。</p>
<p>二分图<br>▪ 二部图（bigraph）是具有两组不同顶点的图，其中一组中的每个顶点仅连接到另一组中的顶点。<br>▪ 在对不同类型对象之间的关系建模时，二部图很有用。<br>▪ 例如，一组顶点可能代表企业，另一组顶点可能代表人。 如果此人为该企业工作，则该人与该企业之间就会出现边缘。<br>▪ 其他示例包括教师和学生、成员和团体以及火车车厢和火车。</p>
<p>多重图<br>▪ 多重图是顶点之间具有多条边的图。</p>
<p>加权图<br>▪ 加权图是每条边都分配有编号的图。 该数字可以反映成本、容量或其他一些边缘度量。<br>▪ 这通常用于优化问题，例如寻找顶点之间的最短路径。<br>➢ 找到最短路径的一种方法称为 Dijkstra 算法，由 Edsger Dijkstra 创建。<br>➢ Dijkstra 算法用于寻找网络中的最短路径。 这是在 Internet 上路由数据包或为送货卡车寻找最有效路线的理想选择</p>
<h3 id="解决最短路径问题的最常用算法"><a href="#解决最短路径问题的最常用算法" class="headerlink" title="解决最短路径问题的最常用算法"></a>解决最短路径问题的最常用算法</h3><p>▪ Dijkstra 算法<br>▪ 增量网络扩展 (INE)<br>▪ 增量欧几里得限制 (IER)<br>▪ 范围网络扩展 (RNE)<br>▪ 范围欧几里得限制 (RER)<br>图搜索算法有两种基本类型：<br>▪ 深度优先，以及<br>▪ 广度优先。</p>
<p>▪ 深度优先算法从一个起始节点到某个结束节点，然后从同一起始节点沿着不同的路径重复搜索，直到查询得到回答。<br>▪ 通常，在尝试发现离散信息时，深度优先是一个不错的选择。 它们也是一般图遍历的好策略。<br>▪ 深度优先的最经典或基本级别是无信息搜索，其中算法搜索路径直到到达图的末尾，然后回溯到起始节点并尝试不同的路径。</p>
<p>▪ 与深度优先相反，处理语义丰富的图数据库允许进行广度优先算法，如果发现没有兼容的传出关系的节点，则提前终止搜索。<br>▪ 因此，广度优先算法的执行时间也较短。<br>▪ 广度优先算法通过一次探索一个图来进行搜索。<br>▪ 它们从离起始节点深一层的节点开始，然后是深度为 2 的节点，然后是深度为 3 的节点，依此类推，直到遍历了整个图</p>
<h2 id="W12-Selecting-a-Database"><a href="#W12-Selecting-a-Database" class="headerlink" title="W12 Selecting a Database"></a>W12 Selecting a Database</h2><h3 id="选择-NoSQL-数据库"><a href="#选择-NoSQL-数据库" class="headerlink" title="选择 NoSQL 数据库"></a>选择 NoSQL 数据库</h3><table>
<thead>
<tr>
<th>Relational Database</th>
<th>NoSQL Database</th>
</tr>
</thead>
<tbody><tr>
<td>在关系数据库设计中，实体的结构和关系驱动设计。</td>
<td>在 NoSQL 数据库设计中，性能比保留关系模型更重要。</td>
</tr>
<tr>
<td>关系模型的出现是出于务实的原因，即数据异常和难以将现有数据库重用于新应用程序</td>
<td>NoSQL 数据库的出现是出于务实的原因，特别是无法扩展以满足对大量读写操作不断增长的需求。<br/>以提高读写性能作为交换，您可能会失去关系数据库的其他功能，例如即时一致性和 ACID 事务。</td>
</tr>
</tbody></table>
<p>查询推动了数据模型的设计。<br>➢ 因为查询描述了数据的使用方式。<br>➢ 查询也是了解各种 NoSQL 数据库如何满足您需求的良好起点。<br>▪ 您还需要了解其他因素，例如<br>o读写量<br>o对副本中不一致数据的容忍度<br>o实体之间关系的性质以及它如何影响查询模式<br>o可用性和灾难恢复要求<br>o数据模型的灵活性需求<br>o延迟要求</p>
<h3 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h3><p>▪ 文档数据库的设计具有灵活性。<br>▪ 如果应用程序需要能够存储各种属性以及大量数据，那么文档数据库是一个不错的选择。<br>➢ 例如，为了在关系数据库中表示产品，建模者可以使用一个表用于公共属性，并为每个产品子类型使用附加表来存储仅在产品子类型中使用的属性。<br>➢ 文档数据库可以轻松应对这种情况</p>
<p>▪ 文档数据库提供嵌入式文档，这对于反规范化很有用。<br>▪ 不是将数据存储在不同的表中，而是将经常一起查询的数据一起存储在同一个文档中。<br>▪ 文档数据库改进了带有索引的键值数据库的查询能力以及基于文档属性过滤文档的能力。<br>▪ 文档数据库可能是最受欢迎的 NoSQL 数据库，因为它们具有灵活性、性能和易用性。</p>
<p>▪ 这些数据库非常适合许多用例，包括：<br>o对具有大量读取和写入的网站的后端支持<br>o管理具有可变属性的数据类型，例如产品<br>o跟踪元数据的可变类型<br>o使用 JSON 数据结构的应用程序<br>o通过在结构中嵌入结构而受益于非规范化的应用程序</p>
<h3 id="列族数据库"><a href="#列族数据库" class="headerlink" title="列族数据库"></a>列族数据库</h3><p>列族数据库专为海量数据、读写性能和高可用性而设计。<br>➢ Google 推出了 BigTable 来满足其服务的需求。<br>➢ Facebook 开发了 Cassandra 来支持其收件箱搜索服务。<br>▪ 这些数据库管理系统在多台服务器的集群上运行。<br>▪ 如果您的数据小到可以在单个服务器上运行，那么列族数据库可能超出您的需要——考虑使用文档或键值数据库</p>
<p>▪ 列族数据库非常适合用于：<br>o需要能够始终写入数据库的应用程序<br>o地理上分布在多个数据中心的应用程序<br>o可以容忍副本中一些短期不一致的应用程序<br>o具有动态字段的应用程序<br>o具有真正大量数据（例如数百 TB）潜力的应用程序</p>
<p>▪ 多个领域可以使用这种大数据处理能力，例如：<br>o使用网络流量和日志数据模式进行安全分析<br>oBig Science，例如使用遗传和蛋白质组学数据的生物信息学<br>o使用交易数据进行股市分析<br>oWeb 规模的应用程序，例如搜索<br>o社交网络服务</p>
<h3 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h3><p>▪ 适合表示为连接实体网络的问题域非常适合图数据库。<br>▪ 评估图形数据库有用性的一种方法是确定实体实例是否与其他实体实例有关系。<br>▪ 现在考虑图数据库讨论中提到的例子，例如连接城市的高速公路、蛋白质与其他蛋白质的相互作用以及员工与其他员工一起工作。 在所有这些情况下，两个实体实例之间都存在某种类型的连接、链接或直接关系。</p>
<p>▪ 电子商务应用程序中的两个订单可能彼此没有联系。<br>▪ 它们可能由同一位客户订购，但这是一个共享属性，而不是连接。</p>
<p>▪ 与前一种情况类似，一个游戏玩家的配置和游戏状态与其他游戏玩家的配置几乎没有关系。<br>▪ 像这样的实体很容易用键值、文档或关系数据库建模。</p>
<p>▪ 连接城市的高速公路、蛋白质与其他蛋白质的相互作用以及员工与其他员工一起工作。<br>▪ 在所有这些情况下，两个实体实例之间都存在某种类型的连接、链接或直接关系。</p>
<p>▪ 一些非常适合图数据库的问题域示例包括：<br>o网络和 IT 基础设施管理<br>o身份和访问管理<br>o业务流程管理<br>o推荐产品和服务<br>o社交网络<br>▪ 从这些例子中，很明显，当需要对实体之间的显式关系建模并快速遍历实体之间的路径时，图数据库是一个很好的数据库选择。</p>
<h3 id="NoSQL-vs-关系数据库"><a href="#NoSQL-vs-关系数据库" class="headerlink" title="NoSQL vs 关系数据库"></a>NoSQL vs 关系数据库</h3><p>▪ NoSQL 和关系数据库是互补的。<br>▪ 关系数据库提供了许多保护数据完整性和降低数据异常风险的功能。<br>➢ 关系数据库会产生提供这些功能的操作开销。<br>▪ 在某些用例中，性能比确保即时一致性或支持 ACID 事务更重要。 在这些情况下，NoSQL 数据库可能是更好的解决方案。<br>▪ 选择数据库是为工作选择正确工具的过程。 您的工作组合越多样化，您的工具包就越多样化。</p>
<p>关系数据库将继续支持事务处理系统和商业智能应用程序。<br>➢ 数十年来在事务处理系统和数据仓库方面的工作已经产生了继续满足企业、政府和其他组织需求的最佳实践和设计原则。<br>➢ 同时，这些组织正在适应最初制定关系模型时不存在的技术。<br>➢ 面向客户的 Web 应用程序、移动服务和大数据分析可能适用于关系数据库，但在某些情况下则不然。<br>▪ 当前的技术格局需要多种数据库技术。</p>
<p>正如没有最好的编程语言，也没有最好的数据库管理系统。<br>▪ 存在比其他问题更适合某些问题的数据库系统，开发人员和设计人员的工作是为手头的需求找到最佳数据库。</p>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>▪ 应用程序开发人员可以选择他们使用的编程语言、他们工作的开发环境以及他们部署的 Web 框架。 在数据库管理系统方面，他们也有选择。<br>➢ 开发不同类型的数据库管理系统都是为了解决其他类型数据库无法解决的现实问题。<br>▪ 开发人员和设计人员的工作之一是为他们的应用程序选择合适的数据库系统。<br>▪ 您可以通过了解您的问题域和您的用户要求来做到这一点。 通常你会有选择。<br>▪ 数据库的选择应由您的需求驱动</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>选择题10marks</p>
<p>NoSQL基础及Doc-O DB问答题10marks</p>
<p>mongodb案例10marks</p>
<p>Col-O DB问答题10marks</p>
<p>Cassandra案例10marks</p>
<p>Neo4j案例10marks（Mock里没看到query要求</p>
<p>考试要求一张纸，估计要画图（可能是画Neo4J设计）</p>
<p>Mock问答：</p>
<p>定义（建议去db的wiki网站找）&amp;类比<br>优势<br>用例</p>
<p>Mock最后有ref提供三类db的参考（想必实际考试来不及看</p>
]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading paper in FIT5152: 知识评估和进展分析与设计的统一框架 A Unified Framework for Knowledge Assessment and Progression Analysis and Design</title>
    <url>/post/fit5152-a1-paper/</url>
    <content><![CDATA[<p>作者 Shuhan Wang, Fang He &amp; Erik Andersen</p>
<p>论文翻译，侵删</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>设计引人入胜的学习内容固然重要，但也很困难，并且通常涉及许多手动规范。 我们提出了一个统一的框架，该框架利用<strong>自动问题分解和部分排序图的构建</strong>来简化多个工作流：知识评估以及进行性分析和设计。 我们通过在线日语评估工具对847名参与者进行了研究，结果表明我们的框架可以有效地衡量学生的能力并预测学生在特定问题上的表现。 我们还提供了对课程分析的结果，结果表明两种不同教科书的进度令人惊讶地相似，并且我们的框架可以导致发现专家进行设计的一般原理。 最后，我们演示了自动进度生成以及所需的排序和步调，允许进行进度定制以及将从一个课程中提取的参数映射到另一个课程</p>
<span id="more"></span>

<p>ACM Classification Keywords</p>
<p>H.5.0 Information Interfaces and Presentation: General</p>
<p>Author Keywords</p>
<p>education; automatic problem decomposition; knowledgeassessment; progression analysis and design</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>教育中的一个关键挑战是保持学生的参与度，而首要考虑的是向特定学生展示最佳知识的顺序。 排序是一个挑战：首先应该引入哪些知识？ 另一个速度是：进步会变得越来越困难。尽管有教育和心理学等方面的指导原则[15，55，59]可以帮助设计进步，但缺乏务实和自动的方法来弥合教育理论与实践之间的差距， 尤其是整个课程的规模。 设计和优化进度的困难也限制了课程适应每个学生需求的能力</p>
<p>在HCI中，此问题与教育软件[7、14]，视频游戏[11、22、33、37、45]和软件可学习性[25、31]的设计有关。目前，我们主要是手工设计进度，这很昂贵，并且限制了我们寻找最佳进度的实验能力。最近，在自动进度设计中已有一些工作[6，11]。尽管这项工作能够自动组织内容，但仅解决了程序性主题和视频游戏级设计。我们仍然缺乏一个通用的框架来表征能够处理一些非过程性主题（如语言学习）的教育进程。此外，我们<strong>需要一种形式上的方法来使用相同的框架来评估学生的知识</strong>，以便<strong>我们可以针对该学生量身定制学习进度和进度</strong>。理想情况下，我们将能够在不费吹灰之力的情况下针对广泛的教育领域建立适应性的进步。</p>
<p>在本文中，我们提出了一个框架，<strong>该框架允许针对非过程性任务进行自动问题分解和部分排序图构造。该框架促进了多个工作流程</strong>。它建立在项目反应理论[53]，知识空间理论[28]和知识追踪[14]的基础之上，以创建学生知识和问题难度的多维度量，从而可以快速评估和预测绩效。它还定义了起搏和其他进度参数的参数空间，并提供了一种方法来表征和比较进度以及设计符合所需参数的新进度。</p>
<p>我们对框架进行了多次评估。首先，我们提出了对自动问题分解和偏序图构建的理论贡献，以帮助外语学习语法，这是一个重要的非程序性主题。然后，我们讨论了一个有847名参与者的用户对日语评估工具的评估，这表明我们的自动评估算法可以根据项目响应理论准确地进行能力评估和绩效预测。我们还提供了自动分析语言学习进度的结果，显示出两本用于学习日语的教科书令人惊讶地具有相似的节奏和其他进阶特征，并且两种在线语言学习工具具有非常不同的进阶设计策略。最后，我们证明了我们的框架可以自动生成具有所需特征的进度，例如学习进度以及学习和复习的比例。这使得从进度分析中获得的见解可以直接应用于进度设计和个人进度剪裁</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="智能辅导系统"><a href="#智能辅导系统" class="headerlink" title="智能辅导系统"></a>智能辅导系统</h3><p>有成功的适应性学习系统，例如认知母语导师[7]。其中一些工作专门针对语言学习[63，65]。认知导师通过跟踪认知模型中个体生产规则的表现来利用知识边缘跟踪[14]来跟踪知识的获取并提供量身定制的指导[14，39]。该模型已通过多种方式扩展，包括估算学生了解技能的初始概率[49]，评估帮助功能对获得概率的影响[10]以及与项目难度模型集成[ 50]。另一种方法是逻辑回归，这对于涉及多种技能的任务特别有效[64]。但是，这些方法通常不考虑起搏。取而代之的是，他们一直给问题赋予特定的生产规则，直到“隐马尔可夫模型”获得了95％的置信度，即学生已经学会了该规则，然后继续研究下一个概念。此外，认知导师很难构建。据估计，设计一个小时的内容需要多达200-300个小时的专家设计工作[3]，尽管更新的设计技术已将其减少到50-100个小时[4]。我们的工作旨在开发自动分析和优化教育进度的途径。</p>
<h3 id="教育与心理学"><a href="#教育与心理学" class="headerlink" title="教育与心理学"></a>教育与心理学</h3><p>许多理论都支持适度的难度对于交往很重要[1，8，16，20，34，47]。当国际象棋选手的排名略高于他们时[1]，最不愉快的情况。对非竞技游戏的进展分析也支持中等难度的使用[44]。 Csikszentmihalyi的流量理论规定，当挑战既不太高又不太低时，人们最会参与其中[16]。 Vygotsky的近端发展区[59]规定，学习者可以在一定指导下获得一系列概念，而教育内容应继续以此为目标。Reigeluth和Stein的阐述理论[55]认为，简单概念的首先应教授一项任务，然后逐步讲解原始任务，然后逐步进行更复杂的任务。 Li等。通过使用机器学习代理检查问题排序来研究问题排序，发现交错的问题排序比阻塞的排序导致更快的学习[43]。当前，我们缺乏实用的，自动的方法来定量描述这些原理并将其应用于实际的进步，而我们的工作旨在做到这一点。</p>
<h3 id="语言教育"><a href="#语言教育" class="headerlink" title="语言教育"></a>语言教育</h3><p>Krashen [42]提出要以可预测的顺序（自然顺序假设）学习概念，并且当学习者接触的语言超出了他或她所能理解的范围（输入假设）时，就会发生语言习得。 语言学习文献中有广泛的证据表明，学习者在使用语法语素[30]，动词否定[13、62]，问题[52]，所有格确定语[61、66]，相对 条款[29、38]和时间参考[48]。 我们的工作旨在创建一个平台，以评估这些理论并确定它们是否能够激发扎根的学习进展，从而促进学习和参与度的提高</p>
<h3 id="基于跟踪的部分排序"><a href="#基于跟踪的部分排序" class="headerlink" title="基于跟踪的部分排序"></a>基于跟踪的部分排序</h3><p>Andersen提出了一种通过对要学习的过程进行静态分析来自动探索任务进度空间的技术[6]。该技术通过分析在该任务上运行过程所获得的执行跟踪来表征任务。通过将每个任务描述为基本操作的序列，可以指定排序问题难度的部分排序。实验证明，这种部分排序可以与用户在教育代数游戏中对困难的感知相匹配[6]。基于轨迹的框架已应用于数学[6]，视频游戏级设计[11]和教学泰语[5]。这项工作还使用了测试输入生成工具，例如Pex [58]和FShell [36]，它们系统地创建具有高代码覆盖率的测试用例套件，以对所有可能的跟踪（在一定范围内）产生问题。但是，此框架不能应用于非过程性主题。例如，尚不清楚如何分析人类如何理解自然语言的执行轨迹。我们在此工作的基础上提出了问题分解和组织的通用框架，该框架可以应用于非过程教育领域，例如语言学习。在此框架内，我们可以衡量学生的能力并预测学生在新问题上的表现</p>
<h3 id="知识评估：IRT和KST"><a href="#知识评估：IRT和KST" class="headerlink" title="知识评估：IRT和KST"></a>知识评估：IRT和KST</h3><p>响应理论（IRT）为知识评估提供了一个框架[26，27，54]。 IRT认为，对某个项目做出正确反应的概率是项目参数和个人能力的函数[32]。勋爵等。提出了3PL模型[46]，该模型考虑了三个项目参数：项目难度，项目歧视和猜测概率。 Rasch [53]提出了一个更简单的模型，该模型规定正确答案的可能性仅由学生的能力和项目难度之间的差异来确定。然而，IRT模型的一个共同缺点是，它们使用一维数值分数来衡量学生的能力和项目难度[28]，这并不反映出学生可能会根据自己掌握的知识而发现各种困难的子集。衡量学生能力和捕获此类差异的问题难度之间差异的方法。我们使用从在线知识评估平台收集的用户数据验证此模型。</p>
<p>知识空间理论（KST）是用于研究知识的层次结构和强大的知识评估工具的公认观点[23，24]。有几种基于KST的辅导系统，例如Alexs [28]，RATH [35]和一种用于学习有机化学的辅导系统[57]。根据KST，学生的知识表示为知识状态，即学生可以解决的一系列问题。问题被组织成一个知识结构，其中包含所有可能的知识状态以及这些状态之间的联系[2，40，41]。研究人员提出了构建知识结构的方法，例如查询专家[41]和贝叶斯推理[21]。由于表示知识状态的复杂性，Falmagne等人。引入了“边缘”的概念来表征学生的知识，可以通过基于“熵”的方法来计算[28]。我们在此工作的基础上提出了一种自动框架，该框架可以将问题分解成其先决条件的基本技能，并为一系列问题建立层次结构。然后，我们的框架可以通过测量学生在该结构中的能力与问题之间的关系，来预测学生在新问题上的表现。</p>
<h2 id="非过程技能的部分排序"><a href="#非过程技能的部分排序" class="headerlink" title="非过程技能的部分排序"></a>非过程技能的部分排序</h2><p>为了选择适合每个学生的难易程度的练习问题，我们需要一个层次结构来编码问题之间的难度关系。 一种简单的方法是请专家指定这些关系。 但是，随着问题集的规模越来越大，这变得异常困难。 理想情况下，我们将具有自动组织问题的方法。</p>
<p>在先前的工作中[6，12]，研究人员为过程任务建立了部分排序图。 这项工作使用过程执行跟踪来组织内容，并对这些跟踪进行部分排序以创建分层的内容结构。 例如，一个人可以识别出解决整数加法问题所需的至少四个基本技能：不带进位的一位数字加法（A），不带进位的一位数字加法（B），写进位（C） ，然后放下最后一个进位（D）。 例如，问题可以分解为以下基本技能</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>2+3</th>
<th>15+18</th>
<th>93+15</th>
<th>298+865</th>
</tr>
</thead>
<tbody><tr>
<td>追溯</td>
<td>A</td>
<td>ACB</td>
<td>AACD</td>
<td>ACBCBD</td>
</tr>
</tbody></table>
<p>但是，在某些领域（例如语言学习）中，目标对象的知识无法轻松地建模为单个过程。要在此类领域引入层次化的知识结构，我们需要对过程领域进行泛化。为此，我们的框架利用了组合性这一概念，即可以将问题分解为较小的概念单元。在一些半程序领域，例如数学和语言学习中，对此进行了充分的研究[6，60]。</p>
<p>例如，日语句子可以分解为语法模板，专家语言教师和语言学家认为语法单元是最重要的语法知识，并让学生实际学习语言课程。这些模板已被证明对语言学习者的文本难度评估很有帮助[60]。我们发现，语法理解日语句子的特定任务可以分解为（多个）语法模板集。例如，这是三个日语句子及其语法模板</p>
<img src="/post/fit5152-a1-paper/image-20210112002236844.png" class="" title="image-20210112002236844">

<p>我们可以看到S1只有一个语法模板：（–の）。对于日语学习者来说，S2比S1更难，因为它不仅具有（–の）而且还有另一个模板（–は）。 S3重复相同的模板（–の）两次，因此也比S1难。 这些关系无法通过[6]中的部分排序来捕获，因为尚不清楚如何程序化人类如何理解这些句子的过程。 但是，通过考虑概念的多集而不是执行跟踪，我们可以按如下方式容纳它们：</p>
<p>**定义1a. ** 一个问题可以分解为问题所需的一系列概念（基本技能）。 由于问题可能会要求学生重复一次或多次重复某些技能，因此我们使用一组表示为p(s)的基本技能来表征问题的难度</p>
<p><strong>定义1b</strong>。我们说，如果且仅当p（s1）⊒ p（s2）时，问题s1至少与s2一样困难，表示为s1≥s2。 这意味着，如果学生能够解决s1，那么他&#x2F;她也必须能够解决s2 [6]</p>
<p>这里⊒表示多集之间的超集关系。 如果是p（s1）⊒（s2），那么对于问题2次所需的任何概念c，也至少也需要1次。例如，AABC⊒ABC为true，而AABCC⊒ABBC为true，因为ABBC有两个“ B”，而AABCC只有一个</p>
<p><strong>定义1c</strong>。严格偏序1&gt; s2定义为s1≥s2^s2≱s1，这意味着s1（严格来说）比s2难。</p>
<p><strong>定义1d</strong>。如果说且仅当s1&gt; s2并且没有其他问题3使得s1&gt; s3&gt; s2，我们说问题1比s2更难</p>
<p>使用定义1d，我们为一系列问题构建了层次结构，如下所示：</p>
<p><strong>定义2</strong>.我们将一组问题S &#x3D; {s1，s2，···}（我们称为普遍问题集）组织为偏序图G &#x3D; 〈S，E〉，其中</p>
<img src="/post/fit5152-a1-paper/image-20210112005148577.png" class="" title="image-20210112005148577">

<p>即，当且仅当sj比si直接困难时，才在部分排序图中存在从问题si到sj的（定向）边。 图1显示了部分排序图的示例。</p>
<img src="/post/fit5152-a1-paper/image-20210112005317740.png" class="" title="image-20210112005317740">

<p>图一（部分排序图中的学生知识边界。 大写字母表示概念，带有字符串的节点表示问题。 学生可以解决绿色问题，而不能解决红色问题。 从每个问题到知识边界的距离以d表示。 空问题s0是一个焦虑问题，被添加来帮助我们计算距离）</p>
<p><strong>定义3</strong>.我们用知识边界K衡量学生的能力，知识边界K是学生可以解决的最困难的问题。 形式上，如果这是学生可以解决的问题集，则</p>
<img src="/post/fit5152-a1-paper/image-20210112172807977.png" class="" title="image-20210112172807977">

<p>以图1中的偏序图为例。 假设一个学生可以解决问题A，AB，B，AABC和BCC（图中的绿色节点），而不能解决ABCB，D或ABCBD（图中的红色节点）。 然后，知识边界仅包含两个问题：AABC和BCC，因为没有其他“绿色”问题比AABC或BCC难。 知识边界不包括A，AB或B，因为存在一个“绿色”问题AABC，比所有问题都难</p>
<h2 id="计算知识边界"><a href="#计算知识边界" class="headerlink" title="计算知识边界"></a>计算知识边界</h2><p>We present a graph coloring algorithm of calculating a stu-dent’s knowledge boundary in the partial ordering graph. Thisalgorithm is based on two properties of the partial ordering: ifa student can solve problems, he must be able to solve anyproblems′that is at most as hard as s(s≥s′); if a studentcannot solve problems, he must not be able to solve any prob-lems′that is at least as hard as s(s′≥s).  For example, if astudent can solve problem AB, he&#x2F;she can also solve problemsA and B; if a student cannot solve problem ABCB, then he&#x2F;she cannot solve problem ABCBD either.</p>
<p>我们提出了一种图形着色算法，用于计算部分排序图中学生的知识边界。 该算法基于偏序的两个属性：如果一个学生能够解决问题，那么他必须能够解决至多像s(s≥s’)一样困难的任何问题。 如果学生不能解决问题，则他必须不能解决至少与 s(s’≥s) 一样困难的任何问题。 例如，如果学生可以解决问题AB，那么他&#x2F;她也可以解决问题A和B； 如果学生不能解决问题ABCB，那么他&#x2F;她也不能解决问题ABCBD。</p>
<p>At the start of the algorithm, all the problems (nodes) in thepartial ordering graph are uncolored. The algorithm asks thestudent whether he&#x2F;she can solve some problem s*.  If thestudent can solve s*, all the nodes that are at most as hard as s*(including s* itself) will be colored ‘solvable’; if the studentcannot solve s*, all the nodes that are at least as hard as s* (including s* it self) will be colored ‘unsolvable’.  Figure 2 shows how this coloring process works.</p>
<p>在算法开始时，部分排序图中的所有问题（节点）都是未着色的。 该算法询问学生是否可以解决某些问题s*。 如果学生能够求解s*，则所有与s*一样难的节点（包括s*本身）将被着色为“可求解”； 如果学生不能求解s*，则所有至少s*同等困难的节点（包括s*自身）将被着色为“无法解决”。 图2显示了此着色过程的工作方式。</p>
<p>The algorithm repeatedly selects an uncolored problem s* from the partial ordering graph, asks the student to solve it, and then updates the coloring of the graph based on the response. Thisis a greedy algorithm designed to minimize the number ofproblems that must be given to the student.  Formally, if $n^+_s$ denotes the number of the uncolored problems that are at mostas hard as $s$, and $n^-_s$denotes the number of the uncolored problems that are at least as hard as s, then we can maximize thenumber of problems that can be colored based on the student’s response by greedily selecting a problem s* as follows:</p>
<p>该算法从偏序图中反复选择一个无色问题s*，要求学生解决它，然后根据响应更新该图的颜色。 这是一种贪心算法，旨在最大程度地减少必须给学生的问题。 形式上，如果$n^+_s$ 表示最多没有硬色问题的无色问题的数量，而 $n^-_s$表示至少至少像s一样硬的无色问题的数量，那么我们可以使可以 通过贪婪地选择问题s*，根据学生的回答进行着色：</p>
<img src="/post/fit5152-a1-paper/image-20210112191104189.png" class="" title="image-20210112191104189">

<h2 id="预测特定问题的表现"><a href="#预测特定问题的表现" class="headerlink" title="预测特定问题的表现"></a>预测特定问题的表现</h2><h3 id="到知识边界的距离-Distance-to-Knowledge-Boundary"><a href="#到知识边界的距离-Distance-to-Knowledge-Boundary" class="headerlink" title="到知识边界的距离 Distance to Knowledge Boundary"></a>到知识边界的距离 Distance to Knowledge Boundary</h3><p>In order to recommend problems at appropriate difficulty levels to the students, we need to predict students’ performanceon problems. Existing IRT studies have proposed several popular models stipulating how student performance is related tostudent ability [46, 53].  However, they measure a student’sability and the difficulty of a problem using unidimensionalnumeric scores, which is incomprehensive [28].</p>
<p>为了向学生推荐适当难度的问题，我们需要预测学生在问题上的表现。 现有的IRT研究提出了几种流行的模型，这些模型规定了学生的表现与学生能力之间的关系[46，53]。 但是，他们使用一维数字分数来衡量学生的能力和问题的难度，这是不全面的[28]。</p>
<p>Ideally, prediction of a student’s performance would utilizemultidimensional metrics to measure the distance between aproblem and what a student already knows. The key technicalchallenge in the design of multidimensional metrics is thatit is impossible to measure this distance without taking intoaccount the hierarchical structure of the problem space. In ourframework, we can measure this as the distance from the prob-lem to the knowledge boundary in the partial ordering graph.We use signed numbers to distinguish which ‘side’ of theknowledge boundary a problem is on: problems ‘inside’ theboundary (which the student can solve) have positive distanceswhile problems ‘outside’ the boundary (which the student can-not solve) have negative distances.  Using this distance, wecan leverage IRT models to predict a student’s performanceon new problems.</p>
<p>理想情况下，对学生成绩的预测将利用多维指标来衡量问题和学生已经知道的知识之间的距离。 多维度量设计中的关键技术挑战是，如果不考虑问题空间的层次结构，就无法测量该距离。 在我们的框架中，我们可以用偏序图中图中从问题到知识边界的距离来衡量这个问题。 学生可以解决）的距离为正，而“超出”边界的问题（学生无法解决的）的距离为负。 利用此距离，我们可以利用IRT模型来预测学生在新问题上的表现。</p>
<p>Here, we give the definition of this distance together with theexamples in Figure 1. Assume we have the universal problem set S, and a student can solve a subset of problems T.  For example, in Figure 1,S&#x3D;{A, AB, B, AABC, BCC, ABCB, D,ABCBD},T&#x3D;{A, AB, B, AABC, BCC}, and the knowledge boundary K&#x3D;{AABC, BCC}. We calculate the distance fromany problems∈Sto the knowledge boundaryK, indicated as d(s, K), following the steps below:</p>
<p>在这里，我们给出该距离的定义以及图1中的示例。假设我们有通用问题集S，并且学生可以解决问题T的子集。例如，在图1中，S &#x3D; {A，AB， B，AABC，BCC，ABCB，D，ABCBD}，T ＝ {A，AB，B，AABC，BCC}，知识边界K ＝ {AABC，BCC}。 我们按照以下步骤计算从任何问题∈S到知识边界K的距离，表示为d(s, K)：</p>
<p><em>Step 1: Calculate distances for problems on the boundary</em></p>
<p><em>步骤1：计算边界上问题的距离对于任何问题，</em></p>
<p>For any problemssuch thats∈K,d(s,K) &#x3D;0.</p>
<p>对于任何问题s使得s∈K，d(s, K)&#x3D; 0</p>
<p>For example, the distance of problems AABC and BCC is 0</p>
<p>例如，问题AABC和BCC的距离为0例如，问题AABC和BCC的距离为0</p>
<p><em>Step 2: Calculate distances for problems inside the boundary</em></p>
<p><em>步骤2：计算边界内问题的距离</em></p>
<p>For any problem s such that s∈T−K, based on the definition of K, there must be one or more s′∈K such that s′≥s (otherwise, s should be contained in K) , and</p>
<p>对于基于s的定义s∈T-K的任何问题s，必须存在一个或多个s′∈K使得s′≥s（否则s应该包含在K中），并且</p>
<img src="/post/fit5152-a1-paper/image-20210112211143812.png" class="" title="image-20210112211143812">

<p>where d is(s,s′) indicates the length of the shortest directed path from s to s′ in the partial ordering graph.  If there is no directed path from s to s′,  dis(s,s′) &#x3D;∞.  Note that if  s′≥s  ,then there must exist at least one directed path from s′ to s.</p>
<p>其中d is（s，s’）表示部分排序图中从s到s’的最短定向路径的长度。 如果没有从s到s’的定向路径，则dis（s，s’）&#x3D;∞。 请注意，如果s’≥s，则必须存在至少一条从s’到s的定向路径。</p>
<p>For example, the distance of problem AB is 1, since prob-lem AABC, which is on the knowlegde boundary, is directlyharder than AB. Similar for problem B (BCC is direclty harderthan B). The distance of problem A is 2, since the shortest di-rected path from A to any problem on the knowledge boundary(which is A→AB→AABC) has length 2</p>
<p>例如，问题AB的距离为1，因为在知识已知边界上的问题AABC比AB直接困难。 与问题B相似（密件抄送比B硬）。 问题A的距离为2，因为从A到知识边界上任何问题的最短定向路径（A→AB→AABC）的长度为2</p>
<p><em>Step 3:Calculate distances for problems outside the boundary</em></p>
<p><em>步骤3：计算边界外问题的距离</em></p>
<p>In a hierarchical knowledge structure, it follows intuitively thatproblems that are further away from the boundary will be moredifficult to the student. Therefore, for any problemssuch thats∈S−T, we define the distanced(s,K)to be shortest directedpath from any problem inTtos. Note that this distance alsohas a teaching interpretation: if easier problems should alwaysbe taught before harder problems [55], then this distance alsomeasures the number of problems that need to be taught beforeteachings.</p>
<p>在分层的知识结构中，直观地认为，远离边界的问题对学生而言将更加困难。 因此，对于诸如s∈ST的任何问题，我们将距离（s，K）定义为距Ttos中任何问题最短的有向路径。 注意，这个距离也有一个教学上的解释：如果总是在较困难的问题之前总是先教更容易的问题[55]，那么这个距离也可以衡量在教学之前需要教的问题数量。</p>
<p>ince there are some basic problems that have no problemseasier than them, and thus have no incoming edges in the par-tial ordering graph, there is not always a path from a probleminTtos.  For instance, there is no directed path from anyproblem inTto problemDin Figure 1.  To resolve this, weadd anull problems0, the pseudo problem with no prerequisiteconcepts, toT. For any problems∈S−T, if there is no otherproblems′such thatsis directly harder thans′(namely,shas no incoming edges), we add an edge(s0,s)to the partialordering graph</p>
<p>由于存在一些基本问题，没有比这些问题更容易解决的问题，因此在空间排序图中没有传入的边，因此从问题中获取问题的路径并不总是那么容易。 例如，图1中没有从任何问题到问题D的直接路径。要解决此问题，我们将无问题先决条件的伪问题anull问题0添加到T。 对于任何问题∈ST，如果没有其他问题’使假设比’s’直接困难（即没有进入的边），我们将偏边（s0，s）添加到偏序图</p>
<p>Now there is at least one directed path from the null problem s0 or some problem in T to s. We can define the distance as:</p>
<p>现在，从空问题s0或T tos中的某个问题开始，至少有一条有向路径。 我们可以将距离定义为：</p>
<img src="/post/fit5152-a1-paper/image-20210112234958809.png" class="" title="image-20210112234958809">

<p>Note that d(s,K) is negative if and only if s is outside the knowledge boundary.For example, the distance of problem ABCB is -1, since itis directly harder than the “green” problem AB. Problem D has no incoming edges in the partial ordering graph, hence weadd an edge from the null problem s0 to D, and the distanceof problem D is -1 since the path s0→D has length 1. Lastly,the distance of problem ABCBD is -2.  Actually, there aretwo shortest paths with length 2: AB→ABCB→ABCBD ands0→D→ABCBD.</p>
<p>请注意，当且仅当s在知识边界之外时，d(s, K)才为负。例如，问题ABCB的距离为-1，因为它比“绿色”问题AB直接困难。 问题D在偏序图中没有输入边，因此我们将零问题s0到D加上一条边，并且由于路径s0→D的长度为1，因此问题D的距离为-1。最后，问题ABCBD的距离为 -2。 实际上，有两条最短的路径，其长度为2：AB→ABCB→ABCBD和s0→D→ABCBD。</p>
<p>The  metric  of  distance  is  dependent  on  the  density  of  thepartial-ordering graph. This is inevitable since the measure-ment is based on the hierarchical structure of the problemspace. We believe that for most well-defined problem spaces,it is a reasonable assumption that the partial ordering graph will be sufficiently dense.  We will demonstrate this metricworks well for a well-built Japanese language learning corpusin the next section</p>
<p>距离的度量取决于偏序图的密度。 这是不可避免的，因为测量是基于问题空间的层次结构。 我们认为，对于大多数定义明确的问题空间，可以合理地假设偏序图将足够密集。 我们将在下一部分中很好地演示此度量标准，以构建完善的日语学习语料库。</p>
<p>In the later part of this paper, we will use d to denote d(s,K) for convenience</p>
<p>在本文的后半部分，为方便起见，我们将使用d来表示d(s, K)。</p>
<h3 id="Adapted-Rasch-model-改编的Rasch模型"><a href="#Adapted-Rasch-model-改编的Rasch模型" class="headerlink" title="Adapted Rasch model 改编的Rasch模型"></a>Adapted Rasch model 改编的Rasch模型</h3><p>In this section, we describe how we can adapt existing uni-dimensional IRT models to build a multidimensional metricthat leverages the partial ordering graph and the distance d calculated in the previous section in order to predict studentperformance.  One of the most famous models of IRT, the Rasch model [53], stipulates that a student’s performancePis a function of the difference between the student’s ability θ and the problem’s difficulty b</p>
<p>在本节中，我们描述如何适应现有的一维IRT模型以建立多维度量标准，该度量标准利用上一节中计算的偏序图和距离d来预测学生的表现。 Rasch模型[53]是IRT最著名的模型之一，它规定学生的表现是学生的能力θ与问题难度b之差的函数。</p>
<img src="/post/fit5152-a1-paper/image-20210113085907577.png" class="" title="image-20210113085907577">

<p>xxx</p>
<p>In  the  next  section,  we  will  demonstrate  that  this  adaptedmodel nicely fits the data collected from our knowledge as-sessment platform</p>
<p>在下一节中，我们将证明该适应模型非常适合从我们的知识评估平台收集的数据</p>
<h2 id="知识评估的评价-EVALUATION-OF-KNOWLEDGE-ASSESSMENT"><a href="#知识评估的评价-EVALUATION-OF-KNOWLEDGE-ASSESSMENT" class="headerlink" title="知识评估的评价 EVALUATION OF KNOWLEDGE ASSESSMENT"></a>知识评估的评价 EVALUATION OF KNOWLEDGE ASSESSMENT</h2><p>In this section, we will the evaluate our calculation of the knowledge boundary and the distance represented in the previous section by applying it to a Japanese language learning domain.</p>
<p>在本节中，我们将评估我们的知识边界与上一节中表示的距离的计算并把它应用到一个日语学习领域。</p>
<h3 id="语言评估平台-J100-A-Language-Assessment-Platform"><a href="#语言评估平台-J100-A-Language-Assessment-Platform" class="headerlink" title="语言评估平台 J100: A Language Assessment Platform"></a>语言评估平台 J100: A Language Assessment Platform</h3><p>xxx</p>
<h3 id="Reddit部署-Reddit-Deployment"><a href="#Reddit部署-Reddit-Deployment" class="headerlink" title="Reddit部署 Reddit Deployment"></a>Reddit部署 Reddit Deployment</h3><p>xxx</p>
<h3 id="验证知识边界和距离度量-Validating-the-Knowledge-Boundary-and-Distance-Metric"><a href="#验证知识边界和距离度量-Validating-the-Knowledge-Boundary-and-Distance-Metric" class="headerlink" title="验证知识边界和距离度量 Validating the Knowledge Boundary and Distance Metric"></a>验证知识边界和距离度量 Validating the Knowledge Boundary and Distance Metric</h3><p>In order to validate our calculation of the knowledge boundaryand the distance metric, we will demonstrate that the user datacollected from J100 nicely fits the adapted Rasch Model. Wecalculate a user’s knowledge boundaryKbased on his&#x2F;her responses to the problems in the assessment stage, and foreach problemsresponded in the evaluation stage, we measurethe distance from the problems to the knowledge boundary K.The user responses in the evaluation stage can be regarded as users’ self-estimation of their performance, and we score thefive possible responses uniformly from 1 to 0</p>
<p>为了验证我们对知识边界和距离度量的计算，我们将证明从J100收集的用户数据非常适合改编的Rasch模型。 我们根据用户在评估阶段对问题的回答来计算用户的知识边界K，并针对评估阶段所回答的每个问题，测量从问题到知识边界K的距离。评估阶段中的用户响应可视为用户 对他们的表现的自我评估，我们从1到0对5个可能的回答进行了统一评分</p>
<h2 id="过程分析-PROGRESSION-ANALYSIS"><a href="#过程分析-PROGRESSION-ANALYSIS" class="headerlink" title="过程分析 PROGRESSION ANALYSIS"></a>过程分析 PROGRESSION ANALYSIS</h2><p>良好的进步会增强学生对课程的参与度[43,56]，我们的工作旨在发现良好的进步的一般特征。 在本节中，我们将利用我们的框架来分析教育进度，并介绍良好进度的两个重要特征：组成Composition和步调Pace。 我们研究了现有课程，并证明了专家设计的课程中一些惊人的相似之处</p>
<h3 id="组成：学习与复习的平衡-Composition-The-Balance-of-Learning-and-Review"><a href="#组成：学习与复习的平衡-Composition-The-Balance-of-Learning-and-Review" class="headerlink" title="组成：学习与复习的平衡 Composition: The Balance of Learning and Review"></a>组成：学习与复习的平衡 Composition: The Balance of Learning and Review</h3><p>在设计教育进度时，一个关键的考虑因素是应该花多少时间来增强以前引入的知识，而不是引入新知识。 另一个需要考虑的问题是，通过以新的方式将概念组合在一起，进度是否应该越来越复杂。 理想情况下，我们将能够定义可以简洁地捕获这些重要方面的进度参数空间</p>
<p>xxx</p>
<p>我们可以认为强化是对已学知识的回顾，引入是纯学习，重组是两者的混合。 这三种类型的比例揭示了设计师在教育进步中平衡学习和复习的策略，我们将其称为进步组成</p>
<h3 id="步调：知识的增长率-Pace-The-Growth-Rate-of-Knowledge"><a href="#步调：知识的增长率-Pace-The-Growth-Rate-of-Knowledge" class="headerlink" title="步调：知识的增长率 Pace: The Growth Rate of Knowledge"></a>步调：知识的增长率 Pace: The Growth Rate of Knowledge</h3><p>我们想知道进度中课程（章节，单元等）的难度是否以一致的速度增长，从而使学生可以顺利学习。 我们不是通过数字来衡量每节课的难度，而是计算知识的大小，即每节课之前引入的问题总数。 这可以用通用问题集5S中的问题数量来衡量，该数量被学生的知识边界归类为强化。在掌握了从一开始到当前课程的所有知识之后。 因此，知识大小| K |就是此类问题的数量</p>
<h2 id="进度分析的评估"><a href="#进度分析的评估" class="headerlink" title="进度分析的评估"></a>进度分析的评估</h2><h3 id="教材研究"><a href="#教材研究" class="headerlink" title="教材研究"></a>教材研究</h3><h3 id="在线语言学习工具研究"><a href="#在线语言学习工具研究" class="headerlink" title="在线语言学习工具研究"></a>在线语言学习工具研究</h3><h2 id="自动渐进合成"><a href="#自动渐进合成" class="headerlink" title="自动渐进合成"></a>自动渐进合成</h2><p>We have discussed two features of an educational progression:composition and pace.  In this section, we will demonstratethat educational progressions can be automatically synthesizedaccording to specific composition and pace parameters. To bemore precise, a progression can be characterized as three nu-meric parameters: overall pace (pace), proportion of reinforce-ment (ri), and proportion of introduction (in). The proportionof recombination (rc) is redundant since ri+rc+in&#x3D;1.</p>
<p>我们讨论了教育进步的两个特征：组成和步调。 在本节中，我们将<strong>证明可以根据特定的构成和速度参数自动合成教育进度</strong>。 更准确地说，可以将进度表示为三个数字参数：总体步速（步幅），增强比例（ri）和引入比例（输入）。 重组比例（rc）是多余的，因为ri + rc + in &#x3D; 1</p>
<p>We use a greedy algorithm to synthesize progressions.  Thealgorithm starts with an empty progression, repeatedly selectsthe next problem that minimizes the following error function and appends it to the progression:</p>
<p>我们使用贪婪算法来合成进度。 算法以空的级数开始，重复选择下一个使后继误差函数最小化的问题，并将其附加到级数上</p>
<img src="/post/fit5152-a1-paper/image-20210112094950772.png" class="" title="image-20210112094950772">

<p>其中pace, ri, in 都是实际的渐进特性，而pace*, ri*, in*是所需的渐进参数。请注意，可能存在多个具有最小误差的问题。 在这种情况下，我们的算法会从中随机选择一个作为下一个问题</p>
<p><strong>这种贪婪算法并不总是生成具有准确所需参数的级数</strong>。 但是，它运行得非常快。对于一个包含25个问题的通用问题集，它可以在一秒钟内合成100多个进程（每个进程有10个问题），因此，我们可以多次运行此贪婪算法以合成具有所需特征的进程</p>
<p>表2列出了合成过程的四个例子。 我们从Genki进程中提取了以下参数：pace&#x3D; 0.465，ri &#x3D; 0.582，in &#x3D; 0.214。 然后，我们使用这些参数（大约）来合成“ Genki Simulation”进度。 我们还生成了另外三个带有量身定制的参数的进度，这些进度偏向于加强，重组和引入。 这些结果表明，<strong>我们不仅可以利用专家级进度设计的原理并使用对大多数学生都有利的参数来综合进度，而且还可以为具有特定偏好的学生量身定制进度</strong></p>
<img src="/post/fit5152-a1-paper/image-20210112095315867.png" class="" title="image-20210112095315867">

<h2 id="结论与未来工作"><a href="#结论与未来工作" class="headerlink" title="结论与未来工作"></a>结论与未来工作</h2><p>可学习性对于HCI的许多方面都很重要：用户界面，学习工具，视频游戏和软件可用性。 在本文中，我们定义了一个框架，<strong>该框架利用自动问题分解和部分排序图构造来促进与教育相关的多个工作流程：评估学生的知识，确定和描述课程的学习策略以及设计新的学习进度</strong>。 我们以多种方式评估了该框架：通过在线部署日语评估工具，自动从现有课程中提取起搏参数，以及将问题组合成符合所需起搏特征的新项目</p>
<p>我们希望将我们的框架用于几个教育领域，尤其是计算机辅助语言教育。 例如，我们计划利用我们的框架向第二语言学习者推荐适当的阅读材料，并改善用于语言学习的教育游戏[17，18]。 将来，我们不仅将框架应用于语法知识，还将应用于语言学习的其他方面，例如词汇和语义</p>
<p>我们希望这些想法将有助于实现一门进行性分析的科学，在该科学中，可以从涉及多个主题的进展中提取出测序和起搏参数，以识别最佳原则。 此外，我们希望扩展此框架，以便它可以自动构建能够快速进行初始评估和进度调整的自适应学习系统</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>UI</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5152: UI Design</title>
    <url>/post/fit5152-ui-design-notes/</url>
    <content><![CDATA[<p>首先在各种公开消息来源上都说这个是刷分水课来着。再加上本身自己在设计上想要有点提高（怎么说也算当过艺术生的），又经常有需要设计的场景（项目别太多）。现在也是前端更火热，所以掌握这个是很有价值的。</p>
<hr>
<p>总算总结完了，感觉这门课可以改名叫UI Guidelines了……太tm多了这内容</p>
<span id="more"></span>

<h2 id="S1-Introduction-to-HCI-and-User-Interface-Design"><a href="#S1-Introduction-to-HCI-and-User-Interface-Design" class="headerlink" title="S1 Introduction to HCI and User Interface Design"></a>S1 Introduction to HCI and User Interface Design</h2><p>成吨的理论知识……后面几个S分别扩展</p>
<p>HCI，即人机交互，包含了为达成某目标的一系列行为</p>
<p>系统开发生命周期</p>
<img src="/post/fit5152-ui-design-notes/image-20210220115032057.png" class="" title="image-20210220115032057">

<p>交互式系统设计</p>
<img src="/post/fit5152-ui-design-notes/image-20210220115139022.png" class="" title="image-20210220115139022">

<p>HCI主要的三个方面</p>
<ul>
<li>我们如何设计？（谁是用户？哪些任务？）Design</li>
<li>我们如何构造？Prototyping</li>
<li>我们如何评估？Evaluation</li>
</ul>
<h3 id="Design："><a href="#Design：" class="headerlink" title="Design："></a>Design：</h3><p>获取数据及定义需求-&gt; 用户分析，任务分析，环境&#x2F;域分析，数据收集方式：采访，问卷，目标组或观察</p>
<p>Conceptual Design：</p>
<p>描述系统该做什么以及长啥样</p>
<p>Physical Design：</p>
<p>考虑系统实际细节</p>
<h3 id="Prototyping"><a href="#Prototyping" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>Assignment3的内容</p>
<p>Low-fidelity (paper) prototyping</p>
<p>High-fidelity (digital) prototyping</p>
<p>Native prototyping</p>
<h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>Expert reviews专家审阅： Heuristics evaluation 启发式评估, Cognitive walkthrough 认知走查</p>
<p>Usability testing</p>
<p>Field studies</p>
<p>Observation</p>
<h3 id="Usability"><a href="#Usability" class="headerlink" title="Usability"></a>Usability</h3><p>is a quality attribute of the UI</p>
<p><strong>effectiveness</strong>, <strong>efficiency</strong>, and <strong>satisfaction</strong> in a specified context of use</p>
<h3 id="Importance-of-UI-Design"><a href="#Importance-of-UI-Design" class="headerlink" title="Importance of UI Design"></a>Importance of UI Design</h3><p>lead to user satisfaction, business success, and cost savings…</p>
<h3 id="User-Centered-Design"><a href="#User-Centered-Design" class="headerlink" title="User-Centered Design"></a>User-Centered Design</h3><p>puts human needs, capabilities, and behavior first</p>
<p>match the needs and capabilities of the people</p>
<p>based on the needs and interests of the user</p>
<p>Users’ tasks and goals are the driving force</p>
<h3 id="Why-to-involve-users"><a href="#Why-to-involve-users" class="headerlink" title="Why to involve users"></a>Why to involve users</h3><ul>
<li>Users bring important knowledge of work tasks</li>
<li>Designers can gain a better understanding of users’ needs and goals</li>
<li>Greater acceptance of the system often results</li>
<li>Fewer problems during development</li>
<li>Lower maintenance costs over time</li>
<li>Products that are easier to learn</li>
<li>Reduction in errors</li>
<li>Users develop a feeling of ownership through contributing to the development</li>
</ul>
<h3 id="Human-Centered-Design"><a href="#Human-Centered-Design" class="headerlink" title="Human-Centered Design"></a>Human-Centered Design</h3><p>Human-centred design puts more emphasis on all stakeholders, and not just ‘users’</p>
<h3 id="Principles-of-Human-Centered-Design"><a href="#Principles-of-Human-Centered-Design" class="headerlink" title="Principles of Human-Centered Design"></a>Principles of Human-Centered Design</h3><p>The ISO standard describes 6 key principles.<br>These principles apply to user-centred design as well.<br>• The design is based upon an explicit understanding of users, tasks and environments<br>• Users are involved throughout entire development<br>• The design driven and refined by user-centered evaluation<br>• The process is iterative<br>• The design addresses the whole user experience<br>• The design team includes multidisciplinary skills and perspectives</p>
<h2 id="S2-Everyday-Design"><a href="#S2-Everyday-Design" class="headerlink" title="S2 Everyday Design"></a>S2 Everyday Design</h2><p>实际上的标题是Design Theories, Models and Principles</p>
<p>Discoverability</p>
<p>Visibility</p>
<p>Visibility is not just about what you can see</p>
<p>Principles of Discoverability</p>
<ul>
<li>Affordances: 就像椅子、button一样一看就知道咋用</li>
<li>Signifiers: 当affordance不能被察觉的时候拿来提示的（比如门上push, pull的贴纸</li>
<li>Feedback: 反馈（比如震动</li>
<li>Constraints: 约束，约束用户行为别乱搞乱用</li>
<li>Mappings: 两类物品之间的映射关系（如音量+-，还有插头插座</li>
</ul>
<h3 id="Conceptual-model-of-the-system"><a href="#Conceptual-model-of-the-system" class="headerlink" title="Conceptual model of the system"></a>Conceptual model of the system</h3><p>系统的理论模型</p>
<p>It provides understanding about the meaning of the controls and settings and what all that means</p>
<h4 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h4><p>尝试解释产品如何工作</p>
<p>在用户脑子里的叫mental models，通常根据experience, training or interaction with the product来形成</p>
<h4 id="Designers"><a href="#Designers" class="headerlink" title="Designers"></a>Designers</h4><p>可能和用户的（mental models）不同</p>
<p>和用户的交流局限于系统印象</p>
<ol>
<li>the <strong>physical structure</strong> of the product, and the discoverability through using affordances, signifiers, constraints and mappings</li>
<li>technical <strong>manuals</strong> and <strong>documentations</strong></li>
</ol>
<h3 id="Knowledge-in-the-head"><a href="#Knowledge-in-the-head" class="headerlink" title="Knowledge in the head"></a>Knowledge in the head</h3><p>the knowledge in the human <strong>memory</strong> system</p>
<p><strong>requires learning</strong></p>
<p>也可以把knowledge of the world然后转进head</p>
<h3 id="Knowledge-in-the-World"><a href="#Knowledge-in-the-World" class="headerlink" title="Knowledge in the World"></a>Knowledge in the World</h3><p>external knowledge</p>
<p>客观存在的知识</p>
<p>Much of the knowledge need to perform tasks can come from the information in the world (using affordances, signifiers, feedback and mappings) </p>
<p>比如键盘布局！</p>
<h3 id="Cognitive-Process"><a href="#Cognitive-Process" class="headerlink" title="Cognitive Process"></a>Cognitive Process</h3><p>认知过程</p>
<p>include:</p>
<ul>
<li><p>attention (the first step) can be visual or auditory, 就听or看见</p>
</li>
<li><p>perception and recognition, 洞察与辨别</p>
</li>
<li><p>memory, 记下来</p>
</li>
<li><p>Learning (and then reading, speaking and listening) 学习</p>
</li>
<li><p>reasoning and problem solving (reflective cognition) 推理与解决问题（反射式认知）</p>
</li>
</ul>
<p>交互时涉及大量认知过程</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>the ability to store and remember information</p>
<h4 id="Sensory-memory"><a href="#Sensory-memory" class="headerlink" title="Sensory memory"></a>Sensory memory</h4><p>感官记忆，很短，且如果无意识就很快忘</p>
<h4 id="Short-term-or-working-memory-STM"><a href="#Short-term-or-working-memory-STM" class="headerlink" title="Short-term (or working) memory (STM)"></a>Short-term (or working) memory (STM)</h4><p>少量信息。短时间</p>
<p>接触新界面时候，会学习到新元素的使用，会存储这部分内容</p>
<p>好设计应当减少其发生（E.g. using ‘recognition rather than recall’）</p>
<h4 id="Long-term-memory-LTM"><a href="#Long-term-memory-LTM" class="headerlink" title="Long-term memory (LTM)"></a>Long-term memory (LTM)</h4><p>retain the information for hours, months or years </p>
<p>无限容量</p>
<p>过去经历和知识的存储位置</p>
<p>形成了产品的mental model</p>
<h3 id="Cognitive-Load"><a href="#Cognitive-Load" class="headerlink" title="Cognitive Load"></a>Cognitive Load</h3><p>认知负载。处理某任务所花费的气力</p>
<p>减少memory load就能减少cognitive load。这对好的界面设计非常关键</p>
<h3 id="External-Cognition"><a href="#External-Cognition" class="headerlink" title="External Cognition"></a>External Cognition</h3><p>external representations and aids</p>
<p>应该最小化用户需要记忆的内容</p>
<p>通过外部认知能过减小load</p>
<p>– Externalising 外部化<br>• Transforming knowledge into external representations, e.g. using a calendar or diary (birthdays, appointments)<br>– Computational offloading 计算方面减负<br>• e.g. a calculator<br>– Annotating and cognitive tracing 注记或者认知追踪<br>• such as Word Track Changes</p>
<h2 id="S3-Requirement-Gathering-Task-Analysis"><a href="#S3-Requirement-Gathering-Task-Analysis" class="headerlink" title="S3 Requirement Gathering, Task Analysis"></a>S3 Requirement Gathering, Task Analysis</h2><h3 id="Data-gathering"><a href="#Data-gathering" class="headerlink" title="Data gathering"></a>Data gathering</h3><p>首先需要收集 user, tasks, the context of use, the environment&#x2F;domain and if any constraints</p>
<h4 id="techniques"><a href="#techniques" class="headerlink" title="techniques"></a>techniques</h4><ul>
<li>Studying existing documentation</li>
<li>Researching similar systems&#x2F;products</li>
</ul>
<p>就多看书or多抄</p>
<p>或者S1里Design里那些</p>
<h4 id="KYC（Know-your-user）"><a href="#KYC（Know-your-user）" class="headerlink" title="KYC（Know your user）"></a>KYC（Know your user）</h4><p>一些重要指标</p>
<p>▪    Demographics: age, gender, occupation<br>▪    Needs, capabilities and limitations<br>▪    Digital literacy<br>▪    Cultural background<br>▪    Social status</p>
<h4 id="Design-Personas"><a href="#Design-Personas" class="headerlink" title="Design Personas"></a>Design Personas</h4><p>Personas大致就是代表性用户画像的意思</p>
<p>Design personas:  Focus more on user goals, needs, motivations, and user behaviour</p>
<p>Each persona usually have <strong>2-4</strong> goals<br>Goals are different from tasks, which are performed to achieve goals</p>
<p>Scenario: 场景， 就脑补（narrative叙述）一个persona通过交互实现goal的情形</p>
<h3 id="Task-Analysis"><a href="#Task-Analysis" class="headerlink" title="Task Analysis"></a>Task Analysis</h3><p>Hierarchical Task Analysis (HTA)，就Assignment里画过的那东西。就尽可能分割任务然后用图表述。</p>
<p>S4 Navigation, Menus</p>
<h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p>finding information by navigating through the interface</p>
<p>主要是解决<del>fps游戏</del>三大问</p>
<p>– Where am I? 我是谁<br>– What’s here? 这是哪<br>– Where can I go from here? 我该去哪</p>
<p>It requires understanding user needs and behaviour, identifying tasks, and effective content organisation</p>
<h4 id="Structural-Navigation"><a href="#Structural-Navigation" class="headerlink" title="Structural Navigation"></a>Structural Navigation</h4><p>根据页面层级</p>
<ul>
<li><p>顶级页面的主导航</p>
</li>
<li><p>次级页面里的二级导航</p>
</li>
</ul>
<img src="/post/fit5152-ui-design-notes/image-20210221101807538.png" class="" title="image-20210221101807538">

<h4 id="Associative-Navigation"><a href="#Associative-Navigation" class="headerlink" title="Associative Navigation"></a>Associative Navigation</h4><p>Associative navigation connects pages with similar topics and content or with the same level of importance without considering their location in the hierarchy</p>
<p>辅助性导航就属于是常驻的，不管页面层级</p>
<ul>
<li>Footer navigation</li>
<li>quick links </li>
<li>Contextual navigation</li>
</ul>
<p>Contextual Navigation：</p>
<p>发生在内容上的导航</p>
<ul>
<li>Embedded navigation (e.g. Links within the text)</li>
<li>Related links<ul>
<li>Usually provided at the end or to the side of page</li>
</ul>
</li>
<li>Adaptive navigation<ul>
<li>E.g. the links change based on what the site visitors do&#x2F;select</li>
</ul>
</li>
</ul>
<h3 id="Utility-navigation"><a href="#Utility-navigation" class="headerlink" title="Utility navigation"></a>Utility navigation</h3><p>工具导航（不被包括进页面层级</p>
<p>–    Navigation between pages and features that helps with using the interface</p>
<p>比如搜索栏</p>
<h3 id="Visual-Flow"><a href="#Visual-Flow" class="headerlink" title="Visual Flow"></a>Visual Flow</h3><p>扫描顺序为Z形，阅读顺序为F形</p>
<p>▪    Consider the logical flow of the users’ tasks.<br>▪    Create a logical path.<br>▪    Minimise eye movement.<br>▪    Use alignment and size uniformity for screen elements</p>
<p>。。。</p>
<h2 id="S5-Form-Design"><a href="#S5-Form-Design" class="headerlink" title="S5 Form Design"></a>S5 Form Design</h2><h3 id="Issues-with-Forms"><a href="#Issues-with-Forms" class="headerlink" title="Issues with Forms"></a>Issues with Forms</h3><p>可能存在问题：</p>
<p>▪    Too <strong>long</strong><br>▪    <strong>Unclear</strong> purpose, asking for information that <strong>irrelevant</strong> to the user’s goals<br>▪    Poor information about the requirement of a given field，<strong>内容提示不足</strong><br>▪    Asking for the same (or similar) information more than once，<strong>重复</strong><br>▪    When there is an error, it does not clearly indicate where it happened or how it can be corrected，<strong>错误提示不足</strong><br>▪    Not clarifying the right <strong>data format</strong><br>▪    Not providing the necessary <strong>space</strong>，<strong>太窄</strong><br>▪    Taking user control away，<strong>不自由</strong></p>
<h3 id="Data-Quality-Problem"><a href="#Data-Quality-Problem" class="headerlink" title="Data Quality Problem"></a>Data Quality Problem</h3><p>就提交上来的数据存在的问题</p>
<p>▪    Data entered in the forms are often <strong>incomplete</strong> or have <strong>poor quality</strong><br>▪    Well designed forms can improve data quality<br>▪    目标：ensure correct data entry with minimal user effort</p>
<p>用户填表顺序</p>
<ol>
<li>Understanding the question</li>
<li>Finding an answer</li>
<li>Judging an answer</li>
<li>Entering the answer on the form</li>
</ol>
<h3 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h3><p>!important 这东西重要</p>
<ul>
<li>Meaningful, familiar and standard field labels</li>
<li>Consistent terminology and abbreviations</li>
<li>Optional and required fields clearly marked</li>
<li>Comprehensible instructions</li>
<li>Use visible space and boundaries for data entry fields</li>
<li>Differentiate grouped items</li>
<li>Visually appealing layout (alignment)</li>
<li>Use lists if possible to minimise errors</li>
<li>Immediate feedback</li>
<li>Completion feedback</li>
</ul>
<h2 id="S6-Evaluation"><a href="#S6-Evaluation" class="headerlink" title="S6 Evaluation"></a>S6 Evaluation</h2><p>Evaluation and Usability Testing</p>
<h3 id="Evaluation-Aims"><a href="#Evaluation-Aims" class="headerlink" title="Evaluation Aims"></a>Evaluation Aims</h3><p>评估目标</p>
<ul>
<li>Are the options and controls visible to the user?</li>
<li>Does the user know how to interact with the UI elements?</li>
<li>Is the navigation and workflow appropriate?</li>
<li>Does the product do what the user expected it to do?</li>
<li>Is the functionality correct from the user’s perspective?</li>
<li>What are the good and poor features?</li>
</ul>
<p>作用</p>
<ul>
<li>Extensive testing is a key to successful design.</li>
<li>To understand how real users use the product and if it meets their needs.</li>
<li>To identify the issues and addressing them.</li>
<li>To reduce user errors.</li>
<li>To improve user experience and increase user satisfaction.</li>
<li>To ensure the product meets the standards and guidelines.</li>
<li>To compare with similar products.</li>
<li>It is cheaper to fix a problem earlier in development than later.</li>
</ul>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Experts:</p>
<ul>
<li>Cognitive walkthrough</li>
<li>Heuristic evaluation</li>
</ul>
<p>User:</p>
<ul>
<li>Usability Testing</li>
<li>Field studies</li>
<li>Thinking aloud</li>
</ul>
<h3 id="Expert-reviews"><a href="#Expert-reviews" class="headerlink" title="Expert reviews"></a>Expert reviews</h3><p>专家审阅</p>
<p>identify usability problems and provide recommendations</p>
<p>早期或晚期</p>
<p>存在问题：</p>
<ul>
<li>Even knowledgeable experts might not know how real users, particularly first-time users, will interact with the product</li>
<li>experts may not have an adequate understanding of the task domain or user communities.”</li>
</ul>
<h3 id="Cognitive-Walkthrough"><a href="#Cognitive-Walkthrough" class="headerlink" title="Cognitive Walkthrough"></a>Cognitive Walkthrough</h3><p>认知走查</p>
<p>用于设计早期</p>
<h3 id="Heuristic-Evaluation"><a href="#Heuristic-Evaluation" class="headerlink" title="Heuristic Evaluation"></a>Heuristic Evaluation</h3><p>启发式评估,，就assignment内容</p>
<p><strong>–    Nielsen’s 10 heuristics</strong><br><strong>–    Shneiderman’s Eight Golden Rules</strong></p>
<h3 id="Nielsen’s-10-heuristics"><a href="#Nielsen’s-10-heuristics" class="headerlink" title="Nielsen’s 10 heuristics"></a>Nielsen’s 10 heuristics</h3><ol>
<li>Visibility of system status</li>
<li>Match between system and the real world</li>
<li>User control and freedom</li>
<li>Consistency and standards</li>
<li>Error prevention</li>
<li>Recognition rather than recall (menu: to underline text, you look at the menu and recognise the option)</li>
<li>Flexibility and efficiency of use</li>
<li>Aesthetic and minimalist design</li>
<li>Help users recognize, diagnose, and recover from errors</li>
<li>Help and documentation</li>
</ol>
<h3 id="Shneiderman’s-Eight-Golden-Rules"><a href="#Shneiderman’s-Eight-Golden-Rules" class="headerlink" title="Shneiderman’s Eight Golden Rules"></a>Shneiderman’s Eight Golden Rules</h3><ol>
<li>Strive for consistency (&#x3D;N#4)</li>
<li>Cater to universal usability (&#x3D;N#4)</li>
<li>Offer informative feedback (&#x3D;N#9,)</li>
<li>Design dialogs to yield closure</li>
<li>Prevent errors</li>
<li>Permit easy reversal of actions (undo)</li>
<li>Support internal ‘locus of control’</li>
<li>Reduce short term memory</li>
</ol>
<h2 id="S7-Prototyping"><a href="#S7-Prototyping" class="headerlink" title="S7 Prototyping"></a>S7 Prototyping</h2><p>成功UI的四支柱Four pillars：</p>
<img src="/post/fit5152-ui-design-notes/image-20210222203134223.png" class="" title="image-20210222203134223">

<ol>
<li>User interface requirements<br>§    Right and complete requirements are key</li>
<li>Guidelines documents and processes<br>§    Design principles that must be adopted within the design</li>
<li>User-Interface software tools and prototyping<br>§    To give users a clearer idea of design and its implications</li>
<li>Expert reviews and usability testing<br>§    To evaluate the design</li>
</ol>
<h3 id="Prototyping-1"><a href="#Prototyping-1" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>重要性</p>
<p>–    test their ideas,<br>–    test possible alternatives,<br>–    clarify requirements,<br>–    validate requirements,<br>–    solicit feedback<br>–    identify problems<br>–    and improve the final product</p>
<p>类别</p>
<p>Level of fidelity:</p>
<p>§    Low-fidelity prototypes<br>§    High-fidelity prototypes</p>
<p>Type of medium used:</p>
<p>§    Sketching and paper prototypes<br>§    Digital prototypes<br>§    Native prototypes</p>
<p>Level of interactivity:</p>
<p>§    Static prototypes<br>§    Interactive prototypes</p>
<p>Level of detail:</p>
<p>§    Horizontal prototypes<br>§    Vertical prototypes</p>
<h4 id="low-fidelity"><a href="#low-fidelity" class="headerlink" title="low fidelity"></a>low fidelity</h4><p>adv</p>
<p>•    Simple, cheap and quick to create.<br>•    Truly hands-on because the designers have to manually manipulate the content.<br>•    The process of cutting, pasting, sorting, labelling forces designers to become familiar with the content elements.<br>•    It can be constructed quickly and efficiently and taken anywhere.<br>•    Even in a rough form, it gives the users a good idea of content organisation and navigation.<br>•    Easy to refine in the final product.<br>•    Prototypes appear to enhance teambuilding skills.</p>
<p>•    With low-fidelity prototypes, users and designers are often more willing to suggest changes.<br>•    Users are more comfortable working with paper and criticising it rather than the real system.<br>•    Users recognise it as a ‘prototype’ so feel more free to make recommendations.<br>•    It allows for more iterations.<br>•    It allows to test with more users and identify more problems.</p>
<h4 id="High-Fidelity"><a href="#High-Fidelity" class="headerlink" title="High-Fidelity"></a>High-Fidelity</h4><p>adv</p>
<p>•    Interactive<br>•    Enables testing navigation, graphical elements and colours, legibility, image quality, alignment and spacing.<br>•    Looks and works more like the real product, resulting in more useful feedback.<br>•    Designers can show and test real flow and interactions.<br>•    At this stage certain limitations become apparent that were not identified earlier in the design.</p>
<p>disadv</p>
<p>•    It is not as cheap as low-fidelity prototypes.<br>•    It is not as fast as low-fidelity prototypes.<br>•    It cannot be taken anywhere easily like low-fidelity prototypes.<br>•    It cannot be refined as easy as low-fidelity prototypes.</p>
<h2 id="S8-UI-Design-and-Usability-Graphics-and-Visual-Design"><a href="#S8-UI-Design-and-Usability-Graphics-and-Visual-Design" class="headerlink" title="S8 UI Design and Usability - Graphics and Visual Design"></a>S8 UI Design and Usability - Graphics and Visual Design</h2><h3 id="Visual-Design"><a href="#Visual-Design" class="headerlink" title="Visual Design"></a>Visual Design</h3><p>视觉设计</p>
<p>▪    Line<br>▪    Shape<br>▪    Size and volume<br>▪    Position<br>▪    Negative&#x2F;white space<br>▪    Colour<br>▪    Basic visual elements are used to create text, images, icons, textures, and animation</p>
<p>【感觉就像SVG</p>
<h4 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h4><p>Guidelines</p>
<p>•    Select colors carefully<br>•    Minimize number of colors<br>•    Reduce eye strain instead of increasing it<br>•    Follow conventions: e.g. link colors<br>•    Be aware of accessibility rules<br>–    Be aware of color blindness<br>–    Provide sufficient contrast between foreground and background<br>–    Don’t use color alone to convey information</p>
<h4 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h4><p>Guidelines</p>
<p>•    Use more legible fonts<br>•    Use fewer typefaces (generally 1-2, or 3 max)<br>•    Italics, underline and bold can be used to emphasise points but should be used sparingly<br>–    Underlines can be mistaken by hyperlinks<br>•    Minimise using different sizes (1-3 max)<br>•    Support redundancy<br>•    There should be sufficient spacing between text lines to make it easy to read, and to increase reading speed<br>•    The size of the font should be large enough<br>•    The text alignment is also important and better to use left or justified alignment because the centre or right alignments make the text hard to read</p>
<h2 id="S9-UI-Design-and-Usability-Interaction-Styles"><a href="#S9-UI-Design-and-Usability-Interaction-Styles" class="headerlink" title="S9 UI Design and Usability - Interaction Styles"></a>S9 UI Design and Usability - Interaction Styles</h2><p>交互风格</p>
<h3 id="Command-Line-Interfaces"><a href="#Command-Line-Interfaces" class="headerlink" title="Command Line Interfaces"></a>Command Line Interfaces</h3><p>没错命令行也是……</p>
<p>disadv</p>
<ul>
<li>Commands are issued in a specific language and different across different platforms. </li>
<li>Hard to remember the name of commands and their order (specially for novice users).</li>
<li>Hard to provide users with feedback and handle errors.</li>
</ul>
<p>adv</p>
<ul>
<li>It is more efficient to use by expert users.</li>
<li>It is more efficient to perform repetitive tasks.</li>
<li>Lack of graphical UI elements allows the user to focus on the task.</li>
</ul>
<h3 id="Direct-Manipulation"><a href="#Direct-Manipulation" class="headerlink" title="Direct Manipulation"></a>Direct Manipulation</h3><p>直接操作</p>
<p>其实就是UI点点点这样的</p>
<p>。。。</p>
<h3 id="Fitts’s-Law"><a href="#Fitts’s-Law" class="headerlink" title="Fitts’s Law"></a>Fitts’s Law</h3><p>建议移动到目标区域所需的时间是考虑到<strong>目标的距离</strong>以及<strong>目标的宽度&#x2F;大小</strong>的函数</p>
<p>它是一种预测模型，可用于确定UI元素（如按钮）的正确<strong>大小</strong>和正确<strong>位置</strong></p>
<p><img src="/fit5152-ui-design-notes/image-20210222222651518.png" alt="image-20210222222651518" loading="lazy"><img src="/fit5152-ui-design-notes/image-20210222222656487.png" alt="image-20210222222656487" loading="lazy"></p>
<h3 id="Hick’s-Law"><a href="#Hick’s-Law" class="headerlink" title="Hick’s Law"></a>Hick’s Law</h3><p>用户做出决定所需的时间取决于可能的选择数量</p>
<p>菜单中包含的选择越多，用户做出决定所花费的时间就越长</p>
<p>不确定和不熟悉会增加决策时间</p>
<p>KISS（保持简短和简单）</p>
<p>使用带有较长列表和菜单的图像会很有帮助，并且可以将用户快速定向到正确的内容</p>
<h3 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h3><p>如何选择交互风格</p>
<ul>
<li>Selecting the right input and output devices depends on: 选io设备根据<ul>
<li>Environment and context of use 使用环境</li>
<li>Speed of interaction (Games) 交互速度</li>
<li>Accuracy of actions 准确度</li>
<li>Type of tasks (if it requires entering a large amount of text) 任务类型</li>
<li>Size (of screen) 屏幕大小</li>
<li>Complexity of the system 系统复杂度</li>
<li>Users? <ul>
<li>People with disabilities 残障人士</li>
<li>Their digital skills 用户电子水平</li>
<li>Their previous experience with the device 用户对设备的使用经历</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The most important thing is to meet the users’ goals but user preferences vary.</p>
<p><strong>Interfaces change but principles do not</strong>(所以考guidelines)</p>
<h2 id="S10-Design-Styles"><a href="#S10-Design-Styles" class="headerlink" title="S10 Design Styles"></a>S10 Design Styles</h2><p>UI Design and Usability - Design Languages and Styles</p>
<p>设计语言（也就御三家的玩意……</p>
<p>– Skeuomorphic Design（老罗最爱拟物设计）</p>
<p>– Flat Design （扁平化）</p>
<p>– Metro Design (MDL), MDL2 （时代眼泪）, and Fluent Design （微软biss）</p>
<p>– Material Design （好家伙）</p>
<p>– iOS Design（好看+流畅）</p>
<h2 id="S11-Reports-amp-Error-Messages"><a href="#S11-Reports-amp-Error-Messages" class="headerlink" title="S11 Reports &amp; Error Messages"></a>S11 Reports &amp; Error Messages</h2><p>UI Design and Usability Reports - Error Messages</p>
<h3 id="Report-Guidelines"><a href="#Report-Guidelines" class="headerlink" title="Report Guidelines"></a>Report Guidelines</h3><ul>
<li>Use meaningful titles of the report.</li>
<li>Include meaningful information.</li>
<li>Balance the layout. 框架平衡</li>
<li>Design an easy navigation system for a multi-page report.</li>
<li>All important information should be highlighted. 高亮关键内容</li>
<li>For displaying text in a report, <strong>文字</strong><ul>
<li>use mixed uppercase and lowercase.</li>
<li>void using overly fancy fonts</li>
<li>use enough spacing between paragraphs.</li>
<li>left-justify text and leave a ragged right margin.</li>
<li>use abbreviations and acronyms only when they are widely understood and are significantly shorter than full-text.</li>
</ul>
</li>
<li>For displaying content in tables and lists in a report <strong>表格&#x2F;列表</strong><ul>
<li>all columns and&#x2F;or rows should have meaningful labels 都要有标签</li>
<li>labels should be separated from other content by using highlighting 标签从内容里拎出来且高亮</li>
<li>redisplay labels when the data extend beyond a single screen or page. 别超出屏幕</li>
<li>sort in a meaningful order 排序</li>
<li>avoid using overly fancy fonts 别用浮夸字体</li>
<li>right-justify numeric data 数字数据右对齐</li>
<li>left-justify textual data. 文字数据左对齐</li>
<li>break long sequence of alphanumeric data into small groups of 3 to 4 characters each.用符号分割长数字</li>
<li><img src="/post/fit5152-ui-design-notes/image-20210222223934093.png" class="" title="image-20210222223934093"></li>
</ul>
</li>
<li>For displaying data with visuals, use the right type of visual with the data in the report to turn report data into knowledge.<ul>
<li>Use <strong>line graph</strong> to track <strong>changes</strong> over <strong>a period of time</strong></li>
<li>Use <strong>bar graph</strong> when <strong>comparing</strong> things between different <strong>groups</strong> or when tracking <strong>changes</strong> over <strong>a period of time</strong></li>
<li>Use <strong>pie chart</strong> when <strong>comparing</strong> different <strong>parts of a whole.</strong></li>
<li>If there is a lot of data to display in a report that requires scrolling, apply filters and make use of hierarchies&#x2F;drill-downs.</li>
</ul>
</li>
</ul>
<h3 id="Error-Message"><a href="#Error-Message" class="headerlink" title="Error Message"></a>Error Message</h3><ul>
<li>Be as specific and precise as possible.  尽可能精确详细</li>
<li>Choose user-centred phrasing. State problem, cause, and solution. 向用户表述问题，原因以及解决方案</li>
<li>Consider multiple levels of messages. 考虑多级消息</li>
<li>Use a positive tone. Be courteous. Avoid condemnation. 用积极语气，别骂人</li>
<li>Maintain consistent grammatical forms, terminology, and abbreviations. 用一致的格式术语缩写</li>
<li>Keep error messages next to fields in forms. 将错误消息保留在表单中的字段旁边</li>
<li>Use color to differentiate errors from normal field states 用颜色区分</li>
<li>Add iconography or subtle animation for easy scanning 加icon或动画方便发现</li>
<li>Maintain consistent visual format and placement. 保持一致的视觉格式和位置</li>
<li>Use modal dialogs for important warnings to prevent or correct critical errors 使用对话框显示重要警告，以防止或纠正严重错误<ul>
<li>Use modal dialogs only when there is a need to draw extra attention to an error that can lead to some irreparable consequences. 仅当需要特别注意可能导致某些无法弥补的后果的错误时，才使用对话框。</li>
<li>Modal dialog boxes are disruptive as they disable the main content and do not allow the user to continue interacting with the interface until the dialog box is open, thereby, interrupting the user from completing their task.  模态对话框具有破坏性，因为它们禁用了主要内容，并且在对话框打开之前不允许用户继续与界面进行交互，从而中断了用户完成其任务。</li>
</ul>
</li>
</ul>
<h2 id="S12-CURRENT-TRENDS-IN-HCI"><a href="#S12-CURRENT-TRENDS-IN-HCI" class="headerlink" title="S12 CURRENT TRENDS IN HCI"></a>S12 CURRENT TRENDS IN HCI</h2><p>略</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>UI</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT5195: Business intelligence and data warehousing</title>
    <url>/post/fit5195-bi-notes/</url>
    <content><![CDATA[<p>好家伙这个一上来我就听不懂……当初没分到信息管理现在遭罪……</p>
<span id="more"></span>

<h2 id="S1-Intro"><a href="#S1-Intro" class="headerlink" title="S1 Intro"></a>S1 Intro</h2><p>这门课是基于intro to db的，默认大家都是SQL老手了。同样的，BI和数据仓库也是在DB之上的概念。</p>
<h3 id="Operational-DB"><a href="#Operational-DB" class="headerlink" title="Operational DB"></a>Operational DB</h3><p>企业拿来操作日常行为的数据库（买卖，预约 etc， 用来支持商业行为）</p>
<ul>
<li>使用集中于事务</li>
<li>便于决策制定</li>
<li>但是决策分析能力不够</li>
</ul>
<h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>相比Operational DB加强了决策能力。</p>
<p>数据仓库是数据库的多维视图，具有聚合和预计算的摘要</p>
<h4 id="建立数据仓库"><a href="#建立数据仓库" class="headerlink" title="建立数据仓库"></a>建立数据仓库</h4><p>通过将Operational DB转换为数据仓库来创建数据仓库</p>
<p>转换包括一系列数据操作步骤</p>
<p>所有的数据转换称为Extract-Transform-Load ETL</p>
<img src="/post/fit5195-bi-notes/image-20210110235639103.png" class="" title="image-20210110235639103">



<h4 id="使用数据仓库"><a href="#使用数据仓库" class="headerlink" title="使用数据仓库"></a>使用数据仓库</h4><p>使用数据仓库的手段是从数据仓库提取数据以进行进一步的数据分析</p>
<p>从数据仓库中提取数据的查询是在线分析工具或OLAP</p>
<p>OLAP会捕获原始数据，该原始数据可以使用任何Business Intelligence（BI）工具格式化。<br>在OLAP中，对数据进行集中处理的数据最为重要。BI工具可用于进一步的表示和可视化<br>接收原始数据的BI工具可以任何形式表示数据：报告，图形，仪表板等</p>
<h4 id="数据分析的需要"><a href="#数据分析的需要" class="headerlink" title="数据分析的需要"></a>数据分析的需要</h4><h3 id="BI"><a href="#BI" class="headerlink" title="BI"></a>BI</h3><p>“商务智能”（BI）是指描述用于捕获，收集，集成，存储和分析数据的综合，内聚和集成的工具集和过程，其目的在于生成和呈现信息以支持业务决策。<br>BI是一个框架，可以使企业将数据转换为信息，信息知识和知识能力不足。</p>
<p>一般而言，BI提供以下框架：</p>
<ul>
<li>收集和存储运营数据 </li>
<li>将运营数据汇总为决策支持数据</li>
<li>分析决策支持数据以生成信息</li>
<li>向最终用户显示此类信息以支持业务决策</li>
<li>制定业务决策，从而生成更多收集，存储和不久的数据（重新启动流程）</li>
<li>监视结果以评估业务决策的结果，从而可以收集，存储和存储更多数据</li>
<li>高度准确地预测未来的行为和结果</li>
</ul>
<p>在实践中，第一点是收集和存储操作数据，这不会影响到操作系统的持久性；而恰恰相反，它会损害操作系统的功能。<br>但是，BI系统将使用操作数据作为信息的输入材料。<br>其余的过程和结果将前面的点解释为面向生成知识，并且它们是BI系统的重点</p>
<img src="/post/fit5195-bi-notes/image-20210110235535385.png" class="" title="image-20210110235535385">



<h2 id="S2-星形架构-Star-Schema"><a href="#S2-星形架构-Star-Schema" class="headerlink" title="S2 星形架构 Star Schema"></a>S2 星形架构 Star Schema</h2><h3 id="星形架构"><a href="#星形架构" class="headerlink" title="星形架构"></a>星形架构</h3><p><a href="https://docs.microsoft.com/zh-cn/power-bi/guidance/star-schema" target="_blank" rel="noopener">了解星型架构及其对 Power BI 的重要性 - Power BI | Microsoft Docs</a></p>
<p>Star Schema 是多维视图的一种设计表示形式。是数据建模技术用于将多维决策支持数据映射到关系数据库中。</p>
<p>对于Star Schema的开发主义者来说，关系建模技术是一种错误的解决方案：ER和归一化，无需多余的数据库结构即可处理复杂的数据分析。</p>
<p>Star Schema由三个部件组成：</p>
<ol>
<li>Facts事实（可度量数值，表达特定商业领域或活动）</li>
<li>Dimensions维度（其他属性，提供对Facts额外的视角）</li>
<li>Attributes属性（包含在维度表中）</li>
</ol>
<img src="/post/fit5195-bi-notes/image-20210111002948496.png" class="" title="image-20210111002948496">



<h3 id="转化（ETL）流程"><a href="#转化（ETL）流程" class="headerlink" title="转化（ETL）流程"></a>转化（ETL）流程</h3><p>从ER图转为数据仓库（星形架构）</p>
<p>首先得有个分析点</p>
<h4 id="双列表格法"><a href="#双列表格法" class="headerlink" title="双列表格法"></a>双列表格法</h4><p>创建星型模式时，您需要想象要分析的数据由两列组成。</p>
<p><strong>第一列</strong>是类别（例如A，B，C，D），<strong>第二列</strong>是统计数字（例如 B）。</p>
<p>第二列（例如F）必须在所有两列表中保持一致。</p>
<img src="/post/fit5195-bi-notes/image-20210111003647783.png" class="" title="image-20210111003647783">



<p>多个Facts下措施：</p>
<p>双列表中的第二列是数字事实度量值（例如F列），实际上可以是多列（称它们为：F1，F2， F3）</p>
<p>只要所有这些列（例如F1，F2， F3）涉及所有类别（例如A，B，C，D）。</p>
<img src="/post/fit5195-bi-notes/image-20210111003924868.png" class="" title="image-20210111003924868">

<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ol>
<li>先建立各个维度表</li>
<li>将各个维度的行写入维度表</li>
<li>建立tempfact表：select where A.id&#x3D;B.id将各个事实表<strong>源</strong>的列 as到tempfact表（即完成表建立又同时数据转移）</li>
<li>增加与源数据类型不同的列到tempfact表（例如源中DATE，事实表中NUMBER）</li>
<li>为4中的新列写入数据</li>
<li>最后建立fact表：使用group by从tempfact里把需要的列取出</li>
</ol>
<h2 id="S3-桥接表-Bridge-Tables"><a href="#S3-桥接表-Bridge-Tables" class="headerlink" title="S3 桥接表 Bridge Tables"></a>S3 桥接表 Bridge Tables</h2><p>好鸡儿难日常听不懂……</p>
<h3 id="Bridge-Tables"><a href="#Bridge-Tables" class="headerlink" title="Bridge Tables"></a>Bridge Tables</h3><p>用来连接俩维度表（其中只有一个连接事实）</p>
<p>到Fact source路径上存在N:N关系（可能N:N被分为1:N和N:1）</p>
<p>you first need to identify the attributes required to calculate the fact measures, then circle the tables contain those attributes as a fact source. After that, you identify where the attributes needed to create the dimensions, and assess the relationship between those tables with the fact source table. If there is a many-to-many relationship and the dimension does not contribute directly to the calculation of the fact measure, a bridge table is needed</p>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>好像这个直接默认是已掌握内容……orz</p>
<p>开始的时候，先问问自己</p>
<ol>
<li>How many records in the operational database?</li>
<li>How many records in the data warehouse?</li>
<li>What kind of data is in the operational database?</li>
<li>How do the tables look like in the data warehouse?</li>
</ol>
<p>先做<strong>data exploration</strong>s</p>
<p><del>先对所有的operational database的table都select count(*)一遍</del></p>
<p><del>对比数据仓库和operational database</del></p>
<ol>
<li>一致性检查：根据每个变量的合理取值范围和相互关系，检查数据是否合乎要求，发现超出正常范围、逻辑上不合理或者相互矛盾的数据</li>
<li>无效值和缺失值的处理</li>
</ol>
<h2 id="S4-Multifact"><a href="#S4-Multifact" class="headerlink" title="S4 Multifact"></a>S4 Multifact</h2><p>就讲讲怎么在一个DW里放多个Fact来更好地表达measure</p>
<p><img src="/fit5195-bi-notes/image-20210119153311615.png" alt="image-20210119153311615" loading="lazy"><img src="/fit5195-bi-notes/image-20210119153321174.png" alt="image-20210119153321174" loading="lazy"></p>
<p>我们需要在Fact表中存放一个avg参数么？NO： Average of an Average</p>
<p>在FACT中存放平均值不是个好主意，那我们应该如何处理这些问题？</p>
<p>我们可以存放<strong>总数</strong>（total xxx）以及<strong>数量</strong>（number of xxx）</p>
<h2 id="S5-DW-Architecture"><a href="#S5-DW-Architecture" class="headerlink" title="S5 DW Architecture"></a>S5 DW Architecture</h2><p>Data Warehouse Architecture</p>
<p>根据Tut来看讲的主要是multifact</p>
<h3 id="Level-of-Aggregations"><a href="#Level-of-Aggregations" class="headerlink" title="Level of Aggregations"></a>Level of Aggregations</h3><p>聚合程度，最次是Level0就基本上是从Operational DB里拿的字段，然后1然后2这样往上越大越浓缩就是精华</p>
<p>lower down level方法：</p>
<ol>
<li>加个新DIM （）</li>
<li>Replace an existing DIM with a higher granularity DIM（Fact的measure值也被分割）</li>
</ol>
<h2 id="S6-Temporal-DW"><a href="#S6-Temporal-DW" class="headerlink" title="S6 Temporal DW"></a>S6 Temporal DW</h2><p>Temporal (or historical) aspect of records is incorporated into the data warehouse</p>
<p>记录的时间（或历史）被合并到数据仓库中，比如 书籍价格随时间的变化</p>
<p>也叫做SCD（Slowly Changing Dimensions，缓慢改变的维度）</p>
<h3 id="with-Bridge-Table"><a href="#with-Bridge-Table" class="headerlink" title="with Bridge Table"></a>with Bridge Table</h3><p>使用Bridge的话可以像加个弱实体那样加个DIM</p>
<p>像这样，其中BookID 和俩Date形成composite key</p>
<img src="/post/fit5195-bi-notes/image-20210223222154124.png" class="" title="image-20210223222154124">

<p>如果Book和BookPrice是1：1关系那就可以并到一起</p>
<p>例如<img src="/fit5195-bi-notes/image-20210223223650881.png" alt="image-20210223223650881" loading="lazy">变<img src="/fit5195-bi-notes/image-20210223223700052.png" alt="image-20210223223700052" loading="lazy"></p>
<h3 id="Temporal-Attributes"><a href="#Temporal-Attributes" class="headerlink" title="Temporal Attributes"></a>Temporal Attributes</h3><p>Temporal attribute是一个属性，其值具有生命周期</p>
<p>例如，每个书价都有生命期（即时间限制），即BookPriceDIM表中的StartDate和EndDate</p>
<h3 id="Temporal-Dimensions"><a href="#Temporal-Dimensions" class="headerlink" title="Temporal Dimensions"></a>Temporal Dimensions</h3><p>Temporal Dimensions是其中具有特定生命周期的维度表</p>
<p>例如图中BranchHistoryDIM（MerchandisePriceDIM算Temporal attribute）</p>
<img src="/post/fit5195-bi-notes/image-20210223223251503.png" class="" title="image-20210223223251503">

<h3 id="Slowly-Changing-Dimensions"><a href="#Slowly-Changing-Dimensions" class="headerlink" title="Slowly Changing Dimensions"></a>Slowly Changing Dimensions</h3><p>主要讲SCD的几个种类，定义前面说了。值得一提的是这个Slowly也是很重要的，对于快速改变的值，比如股票价格，车辆位置，需要的是实时(realtime) DW，或者说流式(stream)DW</p>
<h4 id="Type-0"><a href="#Type-0" class="headerlink" title="Type 0"></a>Type 0</h4><p>实际上并不在DIM上存历史数据</p>
<p>建立数据仓库时，DIM存储记录的“原始或初始”的值</p>
<p>例如：book的全价记录在BookDIM中</p>
<img src="/post/fit5195-bi-notes/image-20210223225111085.png" class="" title="image-20210223225111085">

<h4 id="Type-1"><a href="#Type-1" class="headerlink" title="Type 1"></a>Type 1</h4><p>和T0一样实际上并不在DIM上存历史数据</p>
<p>只记录最新值</p>
<p>例如：Book最新价格将记录在BookDIM中</p>
<img src="/post/fit5195-bi-notes/image-20210223225107357.png" class="" title="image-20210223225107357">

<h4 id="Type-2"><a href="#Type-2" class="headerlink" title="Type 2"></a>Type 2</h4><p>从主DIM跟踪历史</p>
<p>例如：更改Book价格后，会创建具有相同详细信息的“另一本书”，有新的BookID和新价格</p>
<img src="/post/fit5195-bi-notes/image-20210223225048177.png" class="" title="image-20210223225048177">

<h4 id="Type-3"><a href="#Type-3" class="headerlink" title="Type 3"></a>Type 3</h4><p>简化版T2</p>
<p>仅保留当前（Cur）和前一个（Prev）的值，而不保留整个历史记录</p>
<p>例如：仅记录书的最后两个价格</p>
<p>基本原理：</p>
<ul>
<li>假设不需要分析完整的历史记录</li>
<li>大多数分析将以当前价格和最多一个过去价格（例如， 与趋势比较</li>
</ul>
<img src="/post/fit5195-bi-notes/image-20210223225531130.png" class="" title="image-20210223225531130">

<h4 id="Type-4"><a href="#Type-4" class="headerlink" title="Type 4"></a>Type 4</h4><p>创建一个新DIM来维护attribute 变更的历史记录</p>
<p>如前面（with Bridge Table那里）的BookPriceDIM</p>
<img src="/post/fit5195-bi-notes/image-20210223222154124.png" class="" title="image-20210223222154124">

<p>主要优势：同一本书无需具有其他BookID。 此外，保留更改的全部历史记录。</p>
<h4 id="Type-6"><a href="#Type-6" class="headerlink" title="Type 6"></a>Type 6</h4><p>T2和T3的结合。同一本书不需要单独的ID（同T3），但是会保留整个历史记录（同T2）</p>
<p>Composite key {BookID, StartDate, EndDate}</p>
<img src="/post/fit5195-bi-notes/image-20210223230148094.png" class="" title="image-20210223230148094">

<p>如果由于Date，BookDIM和BookSalesFACT之间存在M:M关系</p>
<p>Sol1：给BookDIM加个新的surrogate key</p>
<p>Sol2：把StartDate和EndDate加到FACT-&gt;与TimeID混乱</p>
<p>Sol3：加个辅助性的表（或Bridge Table）在BookSalesFACT和BookDIM之间-&gt;也乱</p>
<p>结论：Sol1最佳</p>
<h2 id="S7-Snowflake-Schema"><a href="#S7-Snowflake-Schema" class="headerlink" title="S7 Snowflake Schema"></a>S7 Snowflake Schema</h2><p>给Star的DIM分个层级（Hierarchy）就变Snowflake了</p>
<img src="/post/fit5195-bi-notes/image-20210224001704514.png" class="" title="image-20210224001704514">

<p>注意1:M关系，不能整倒了</p>
<h3 id="Determinant-Dimensions"><a href="#Determinant-Dimensions" class="headerlink" title="Determinant Dimensions"></a>Determinant Dimensions</h3><p>显性维度</p>
<p>在Star schema下检索的所有数据都必须使用此DIM，否则检索的数据将变得毫无意义。例如PetrolType</p>
<p>差不多就是做Schema之前问题里都提到的一个要素吧</p>
<img src="/post/fit5195-bi-notes/image-20210224002158112.png" class="" title="image-20210224002158112">







<h2 id="S8-OLAP"><a href="#S8-OLAP" class="headerlink" title="S8 OLAP"></a>S8 OLAP</h2><p>熟悉的SQL</p>
<p><strong>基础</strong></p>
<p>COUNT([distinct] A)</p>
<p>SUM([distinct] A)</p>
<p>AVG([distinct] A)</p>
<p>MAX(A)</p>
<p>MIN(A)</p>
<p>GROUP BY</p>
<p><strong>进阶</strong></p>
<p>CUBE：扩展GROUP BY子句以在单个查询中生成<strong>交叉表</strong>格式的信息。</p>
<p>ROLLUP：扩展GROUP BY子句以生成从最详细到总计的越来越细粒度的聚合。</p>
<p>GROUPING：与SELECT语句一起使用，以显示有关聚合级别的信息以及每个聚合级别的相关小计。</p>
<p>Partial CUBE：GROUP BY expr1, CUBE (expr2, expr3)</p>
<p>Partial ROLLUP：GROUP BY expr1, ROLLUP (expr2, expr3)</p>
<p><strong>高阶</strong></p>
<p>RANK( ) OVER ([query_partition_clause] order_by_clause)</p>
<p>DENSE_RANK( ) OVER ([query_partition_clause] order_by_clause)</p>
<p>DENSE对于同rank重复情况下只加一</p>
<p>RANK() OVER (PARTITION BY order_by_clause)</p>
<p>例如select RANK() OVER (PARTITION BY channel_desc ORDER BY SUM(amount_sold) DESC) AS RANK_BY_CHANNEL from XXX</p>
<p>如果需要显示多个属性的排名，则需要对聚合进行分区（PARTITION BY），以便可以为每个指定的属性显示适当的排名</p>
<p>select rank() from XXX 外面再套个select * from () where rank&lt;5来实现TopN </p>
<p>ROW_NUMBER函数为分区中的每一行分配一个唯一的编号（依次从1开始，由ORDER BY定义）。有点像sequence。用来手动排rank</p>
<p>ROW_NUMBER() OVER ([query_partition_clause] order_by_clause)</p>
<p>PERCENT RANK</p>
<p>percent_rank() over (order by sum(f.revenue) desc) as “Percent Rank”</p>
<p>Cumulative Aggregates</p>
<p>SUM(SUM(XXX)) OVER (ORDER BY aaa,bbb ROWS UNBOUNDED PRECEDING)</p>
<p>UNBOUNDED表示无界，PRECEDING前</p>
<p>解析函数SUM为每一行定义一个窗口，该窗口从分区的开头（UNBOUNDED PRECEDING）开始，默认情况下在当前行结束。<br>在此示例中，需要嵌套SUM，因为我们正在对本身就是SUM的值执行SUM。<br>嵌套聚合在分析聚合函数中经常使用</p>
<p>SUM(SUM(XXX)) OVER (PARTITION BY aaa ORDER BY aaa,bbb ROWS UNBOUNDED PRECEDING)</p>
<p>Moving Aggregate</p>
<p>(AVG(SUM(XXX)) OVER (ORDER BY aaa,bbb ROWS 2 PRECEDING)</p>
<p>(AVG(SUM(XXX)) OVER (ORDER BY aaa,bbb ROWS 2 PRECEDING)</p>
<p>用两个的平均表现moving</p>
<h2 id="S9-BI"><a href="#S9-BI" class="headerlink" title="S9 BI"></a>S9 BI</h2><h3 id="Navigation-Methods"><a href="#Navigation-Methods" class="headerlink" title="Navigation Methods"></a>Navigation Methods</h3><p>Drill Down</p>
<p>Drill Up (a.k.a. Roll Up)</p>
<p>Drill Through</p>
<p>Drill Across</p>
<h2 id="EXAM"><a href="#EXAM" class="headerlink" title="EXAM"></a>EXAM</h2><p>考试就是1-9的内容。较难，不熟练会时间来不及（就是我）。</p>
<p>考试内容和模拟考形式完全一致</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>database</tag>
        <tag>BI</tag>
        <tag>data warehouse</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT9131: Java</title>
    <url>/post/fit9131-java-bluej-notes/</url>
    <content><![CDATA[<p>学校要求的是使用bluej这个ide&#x2F;editor。这个工具和intellij idea不同，完全是面向教学，写Java有种写script的感觉。可以拿来写各种class但是不能保存各种实例化的object。</p>
<p>到目前（W4）为止，内容都是很简单的。</p>
<p>到W7也還是很簡單……</p>
<p>到W12依然还是很简单……</p>
<p>最后考试大概是没考好，明明ASS全HD但最终只有79没拿到HD太可惜了</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for FIT9132: Intro to DB</title>
    <url>/post/fit9132-db-notes/</url>
    <content><![CDATA[<p>整体难度不大，tutor也很给面子（要是我自己给自己打分肯定更低</p>
<p>建议尽早摘抄知识点并且在Tut&#x2F;Ass时候就用起来，别像我一样前面拍脑子考前总结才发现都在PPT里。</p>
<span id="more"></span>

<h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><p>回顾历史DB发展以及名人</p>
<h2 id="W2-Conceptual-Modelling"><a href="#W2-Conceptual-Modelling" class="headerlink" title="W2 Conceptual Modelling"></a>W2 Conceptual Modelling</h2><p>理论模型</p>
<p>因为是chow’s foot图，所以复合（1：1）、多值（1：N）属性记得加个实体来表述会更直观</p>
<h3 id="理论模型设计"><a href="#理论模型设计" class="headerlink" title="理论模型设计"></a>理论模型设计</h3><p>开发企业数据模型。</p>
<ul>
<li>对应于ANSI &#x2F; SPARC体系结构的概念级别。</li>
<li>独立于所有物理实施注意事项（要使用的数据库类型）。</li>
<li>可以采用各种设计方法，例如UML，ER（实体关系）。</li>
<li>ER由实体之间的<strong>实体</strong>和<strong>关系</strong>组成</li>
</ul>
<p>ENTITY具有属性（我们希望记录的东西），其中一个或多个属性将标识实体实例（称为KEY）</p>
<h3 id="强弱实体"><a href="#强弱实体" class="headerlink" title="强弱实体"></a>强弱实体</h3><p><strong>强实体</strong></p>
<blockquote>
<p>具有可以在不参考其他实体的情况下定义的Key。例如EMPLOYEE实体。</p>
<img src="/post/fit9132-db-notes/image-20210218223640286.png" class="" title="image-20210218223640286">
</blockquote>
<p><strong>弱实体</strong></p>
<blockquote>
<p>具有要求存在一个或多个其他实体的Key。例如FAMILY实体-需要包括员工的KEY才能为家庭创建合适的密钥</p>
<img src="/post/fit9132-db-notes/image-20210218223450092.png" class="" title="image-20210218223450092">
</blockquote>
<p>数据库设计人员通常根据业务规则确定一个实体是否可被描述为弱实体，例如</p>
<blockquote>
<p> 客户每月支付帐款</p>
<p> Key：cust_no，date_paid</p>
<p>或者：payment_no（如果是凭空创造的surrogate Key？- 不属于理论模型）</p>
</blockquote>
<p>理论模型不加surrogate Key！</p>
<table>
<thead>
<tr>
<th>显著Identifying</th>
<th>不显著Non-identifying</th>
</tr>
</thead>
<tbody><tr>
<td>Identifier of A is part of identifier of B.</td>
<td>Identifier of A is NOT part of identifier of B.</td>
</tr>
<tr>
<td>实线</td>
<td>虚线</td>
</tr>
<tr>
<td>ENROLMENT - STUDENT Enrolment key includes student id, which is an identifier of student.<br />CAR - CAR_COLOR<br />存在同样的key</td>
<td>Department no (identifier of department) is not part of Employee’s identifier.</td>
</tr>
</tbody></table>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>类型: 简易，复合，单值，多值，派生</p>
<p>鱼尾纹chow’s foot表示法不支持多值属性。 值被列为单独的属性。</p>
<p>关联（或复合）实体</p>
<h2 id="ERD"><a href="#ERD" class="headerlink" title="ERD"></a>ERD</h2><p>关系数据库模型，即ERM，构成ERD(实体关系图)的基础。<br>ERD代表最终用户查看的概念数据库。<br>ERD描述了数据库的主要组成部分：实体，属性和关系。<br>因为实体代表现实世界中的对象，所以实体和对象一词经常互换使用。 </p>
<p>正好实体关系图也能在vuepress里用markdown+mermaid绘制，所以可以直接画着玩。由于还处于experimental，所以是只能表现实体和关系，并不能展示属性</p>
<p>在mermaid里，几对几这样的关系分成左右两部分描述。</p>
<table>
<thead>
<tr>
<th>左边</th>
<th>右边</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;</td>
<td>o&#96;</td>
<td>&#96;o</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
<td>&#96;</td>
</tr>
<tr>
<td><code>&#125;o</code></td>
<td><code>o&#123;</code></td>
<td>零或多个 (无上限)</td>
</tr>
<tr>
<td>&#96;}</td>
<td>&#96;</td>
<td>&#96;</td>
</tr>
</tbody></table>
<pre class="mermaid">erDiagram
    CUSTOMER ||--o{ ORDER : places</pre>

<p>表示<strong>一个</strong>CUSTOMER强对应<strong>0或多个</strong>ORDER，即一个顾客对应着0个(未点单)或多个其点过的订单</p>
<pre class="mermaid">erDiagram
    ORDER ||--|{ ITEM : contains</pre>

<p>表示<strong>一个</strong>ORDER强对应<strong>0或多个</strong>ITEM，即一份订单上存在一个或多个商品</p>
<pre class="mermaid">erDiagram
    CUSTOMER }|..|{ ADDRESS : uses</pre>

<p>表示<strong>0或多个</strong>CUSTOMER弱对应<strong>0或多个</strong>ADDRESS，即存在多个顾客且存在多个地址，之间存在弱对应关系</p>
<h2 id="W3-Relational-Model"><a href="#W3-Relational-Model" class="headerlink" title="W3 Relational Model"></a>W3 Relational Model</h2><p>Relational Model&amp;Relational Algebra关系模型与代数</p>
<p>这个作业里是用SQL Developer从Logical里生成出来的，所以到SQL（DDL）部分才开始create。</p>
<p>这里主要讲的是</p>
<ul>
<li>用NAME(Attribs…)表示的实体，每个数据都是一个tuple</li>
<li>其中的各种key: SuperKey(一或多个属性，独一无二), CK（一或多个属性）, PK（从CK中选的一个），AK（alternate keys。PK以外的CK）</li>
<li>代数（select，project，join，其他union，diff，div啥的都不用）顺便为后面归一化做准备</li>
</ul>
<p>功能性依赖Functional Dep</p>
<p>如果在任何时候属性（集）A的值都确定单属性B值（当且仅当），则属性B在A上是功能依赖的。</p>
<p>• order_no → order_date<br>• prod_no → prod_desc<br>• order_no, prod_no → ordered_qty</p>
<p>RM 特点：</p>
<ul>
<li>要有独一无二的名字</li>
<li>每个属性要有独一无二名字（用prefix</li>
<li>属性不能多值</li>
<li>所有属性值应当来自同一个域</li>
<li>必须有主键</li>
<li>relations 之间的 Logical (not physical) connections 通过primary&#x2F;foreign keys表示</li>
</ul>
<h2 id="W4-Normalisation"><a href="#W4-Normalisation" class="headerlink" title="W4 Normalisation"></a>W4 Normalisation</h2><p>归一化</p>
<ul>
<li><p>为了避免在插入，更新和删除数据时可能发生的异常，应规范化关系。</p>
</li>
<li><p>规范化是一系列系统步骤，用于逐步完善数据模型。</p>
</li>
<li><p>基于primary key（或候选 candidate keys）分析关系的正式方法 密钥）和功能依赖项。用作：“自下而上设计”的一种设计技术，以及作为一种验证通过“自上而下的设计”产生的结构的方式（将ER模型转换为逻辑模型-参见下周）</p>
</li>
</ul>
<p>更新异常的类型包括：</p>
<p>•插入异常-仅在新员工被分配到项目时才插入</p>
<p>•删除异常-删除分配给项目的唯一员工？</p>
<p>​    –删除特定工作类别的唯一员工？</p>
<p>•修改（或 更新）异常</p>
<p>​    -更新作业类别的每小时费率 - 需要更新多行</p>
<p>归一化目标</p>
<ul>
<li><p>创建有效的关系，即每个关系都符合关系模型的属性。 特别是：–实体完整性–引用完整性–没有多对多关系–每个单元格都包含一个值（是原子的）。</p>
</li>
<li><p>在RDBMS中实施时，实际上：–每个表代表一个主题 –没有数据项 将不必要地存储在多个表中。–可以建立表之间的关系（标识了PK和FK对）。–每个表都没有插入，更新和删除异常。</p>
</li>
</ul>
<p>功能性依赖Functional Dep</p>
<p>参照前面</p>
<p>部分依赖Partial Dep（1-&gt;2）</p>
<p>缺少对多个属性键的完全依赖</p>
<ul>
<li>ORDERNO, PRODNO ➔ PRODDESC, QTY_ORDERED</li>
<li>尽管qty_ordered完全取决于orderno和prodno，但仅需prodno即可确定proddesc</li>
<li>proddesc部分依赖于orderno和prodno</li>
<li>用人话说，就是现在看起来是主键是orderno，但是要是有个prodno也能决定qty ，那就把prodno和qty拎出去</li>
<li>拎出去之后那个新实体的key在原位置保留且<strong>作为key</strong>！</li>
</ul>
<p>传递依赖Transitive Dep（2-&gt;3）</p>
<ul>
<li>当Y取决于X，Z取决于Y时发生</li>
<li>因此Z也取决于X，即。 X➔Y➔Z 并且Y不是候选键（或候选键的一部分）</li>
<li>ORDER_NO➔CUST_NO➔CUST_NAME: CUSTOMER(<u>CUST_NO</u>, CUST_NAME)</li>
<li>emp_no➔job_class➔chg_hour: JOB (<u>job_class</u>, chg_hour)</li>
<li>拎出去之后那个新实体的key在原位置保留但是<strong>不作为key</strong>！</li>
</ul>
<p>UNF-&gt;1NF</p>
<ol>
<li><p>确定重复组的Key。</p>
</li>
<li><p>删除任何重复组以及主要关系的PK。</p>
</li>
<li><p>由于重复组的去除而导致的新关系的PK通常具有由主要关系的PK组成的复合PK 以及上面1.中选择的唯一标识符，但是必须进行检查。说人话就是拎出来的实体要带原来的Key，也要有自己的Key，就反正至少俩</p>
</li>
</ol>
<p>最后写出所有的Partial dependencies</p>
<p>1NF -&gt; 2NF</p>
<p>2NF下的关系</p>
<ul>
<li>继承前面的</li>
<li>把所有Partial dependencies<strong>部分依赖</strong>拎出来</li>
</ul>
<p>最后写出所有的Transitive dependencies</p>
<p>2NF -&gt; 3NF</p>
<p>如果3NF，则存在关系</p>
<ul>
<li>继承前面的</li>
<li>把所有Transitive dependencies<strong>传递依赖</strong>项都拎出来</li>
</ul>
<p>最后要写出所有的Full Dependencies</p>
<h2 id="W5-Logical-Model"><a href="#W5-Logical-Model" class="headerlink" title="W5 Logical Model"></a>W5 Logical Model</h2><p>就是Assignment里让你画在SQL Developer里那个。按实际制作流程来看应该比relational model先讲。</p>
<p>在Conceptual Model正确情况下较简单，但是别像我一样拍脑子做。</p>
<h3 id="逻辑设计（1b）"><a href="#逻辑设计（1b）" class="headerlink" title="逻辑设计（1b）"></a>逻辑设计（1b）</h3><ul>
<li>开发针对特定数据库模型的数据模型（例如关系，分层，网络，面向对象，noSQL）。</li>
<li>独立于任何特定供应商DBMS软件包的任何实施细节。</li>
<li>归一化技术（请参阅w4）用于测试关系逻辑模型的正确性。</li>
</ul>
<h3 id="1-映射常规（强）实体"><a href="#1-映射常规（强）实体" class="headerlink" title="1. 映射常规（强）实体"></a>1. 映射常规（强）实体</h3><p>先是把Conceptual Model里的Key转为PK或者FK，加UQ</p>
<h3 id="2-映射弱实体"><a href="#2-映射弱实体" class="headerlink" title="2. 映射弱实体"></a>2. 映射弱实体</h3><h3 id="3-映射二元关系"><a href="#3-映射二元关系" class="headerlink" title="3. 映射二元关系"></a>3. 映射二元关系</h3><h4 id="1-M"><a href="#1-M" class="headerlink" title="1:M"></a>1:M</h4><p>记得加fk到M那侧</p>
<h4 id="M-N"><a href="#M-N" class="headerlink" title="M:N"></a>M:N</h4><p>Conceptual里的M:N关系需要转为1:N和N:1</p>
<p>例如</p>
<img src="/post/fit9132-db-notes/image-20210217003847464.png" class="" title="image-20210217003847464">

<p>转为</p>
<img src="/post/fit9132-db-notes/image-20210217003857615.png" class="" title="image-20210217003857615">

<p>如图TEAM和EMPLOYEEE之间的leads关系</p>
<img src="/post/fit9132-db-notes/image-20210217225042251.png" class="" title="image-20210217225042251">

<img src="/post/fit9132-db-notes/image-20210217225057637.png" class="" title="image-20210217225057637">

<p>在强制侧的PK变成可选那侧的FK（如emp_no的到了team成了fk，虽然人家是1:M</p>
<p>如果都是可选的，那就加到null最少那侧</p>
<p>如果两边都强制那就考虑合并吧</p>
<h3 id="4-映射关联实体"><a href="#4-映射关联实体" class="headerlink" title="4. 映射关联实体"></a>4. 映射关联实体</h3><p>就类似上面M:N的处理，不过关联实体往往有surrogate key，例如XXX_no，所以就这个no加P别的纯粹F</p>
<h3 id="5-映射一元关系"><a href="#5-映射一元关系" class="headerlink" title="5. 映射一元关系"></a>5. 映射一元关系</h3><p>1:1，1:M 不变</p>
<p>MN：加实体</p>
<img src="/post/fit9132-db-notes/image-20210217230405132.png" class="" title="image-20210217230405132">







<h3 id="6-映射三元关系"><a href="#6-映射三元关系" class="headerlink" title="6. 映射三元关系"></a>6. 映射三元关系</h3><p>拆成三个二元</p>
<h2 id="W6-DDL"><a href="#W6-DDL" class="headerlink" title="W6 DDL"></a>W6 DDL</h2><p>SQL create</p>
<p>uq的constraint写inline</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> unit</span><br><span class="line">(</span><br><span class="line">unit_code <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">unit_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">CONSTRAINT</span> uq_unit_name <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> pk_unit <span class="keyword">PRIMARY</span> KEY (unit_code)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>这里提一下前面W3里的内容，就是FK要么是其他的PK，要么就是NULL，所以就基本上不写NOT NULL。另外FK一般拎出来alter。ON DELETE CASCADE保证引用完整性（感觉一般不用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> enrolment</span><br><span class="line"><span class="keyword">ADD</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_enrolment_student <span class="keyword">FOREIGN</span> KEY (stu_nbr) <span class="keyword">REFERENCES</span> student ( stu_nbr),</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_enrolment_unit <span class="keyword">FOREIGN</span> KEY (unit_code) <span class="keyword">REFERENCES</span> unit (unit_code)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>值的约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">ADD (stu_address varchar(200),</span><br><span class="line">status char(1) DEFAULT &#x27;C&#x27;,</span><br><span class="line">constraint status_chk CHECK (status in (&#x27;G&#x27;,&#x27;C&#x27;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>





<h2 id="W7-SQL"><a href="#W7-SQL" class="headerlink" title="W7 SQL"></a>W7 SQL</h2><p>主要讲的就是select和where</p>
<p>限定词：</p>
<ul>
<li>&#x3D;, !&#x3D;, &lt;&gt;, &lt;, &gt;, &gt;&#x3D;, &lt;&#x3D;</li>
<li>between</li>
</ul>
<p>NOTE: between aaa and bbb时候aaa和bbb<strong>都</strong>是被包括进去的</p>
<ul>
<li>in (‘aaa’, ‘bbb’ …)</li>
<li>like: %表示0+个字符, _表示单字符</li>
<li>is null, is not null (判断null时候不能用&#x3D;或!&#x3D;)</li>
<li>any, all</li>
<li>exists</li>
</ul>
<p>select执行后三种状态：True, False和Unknown（匹配到NULL）。是True才算被检索到。</p>
<p>select 检索时候做运算（如grade+1）则列名变成该算式（”grade+1”），反正就很难看，所以一般用as 重命名一下。当as的新名字有空格，用**” “**去包围（不是单引号！），列名始终用双引号。</p>
<p>NULL算啥都还是NULL，也可以用NVL(原列名, 值)来代替NULL做运算（如NVL(enrol_mark, 0)默认NULL为0）</p>
<p>Order by</p>
<ul>
<li><p>NULL<strong>S</strong> LAST, NULL<strong>S</strong> FIRST</p>
</li>
<li><p>DESC （默认ASC故可省略）</p>
</li>
</ul>
<p>SELECT DISTINCT 去重复行</p>
<p>JOIN</p>
<blockquote>
<p>from aaa JOIN bbb ON aaa.a &#x3D; bbb.b</p>
<p>from aaa JOIN bbb ON aaa.key &#x3D; bbb.key </p>
<p>from aaa JOIN bbb USING (key) </p>
<p>from aaa NATURAL JOIN bbb</p>
</blockquote>
<p>to_char(SYSDATE, ‘dd-Mon-yyyy hh:mi:ss PM’)</p>
<p>反过来就to_date(datetime, ‘dd-Mon-yyyy hh:mi:ss PM’ )</p>
<p>一些系统变量SYSDATE SYSDATETIME USER </p>
<p>另外数字的format里0和9区别: 9占位但不padding（除非小数，但用FM连小数也不），0占位还padding</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL&gt; select to_char(1, &#x27;999.999&#x27;),</span><br><span class="line">  2         to_char(1, &#x27;000.000&#x27;),</span><br><span class="line">  3         to_char(1, &#x27;900.009&#x27;),</span><br><span class="line">  4         to_char(1, &#x27;999.000&#x27;)</span><br><span class="line">  5  from   dual;</span><br><span class="line"></span><br><span class="line">1.000</span><br><span class="line">001.000</span><br><span class="line">01.000</span><br><span class="line">1.000</span><br><span class="line"></span><br><span class="line">select to_char(1, &#x27;FM999.999&#x27;),</span><br><span class="line">       to_char(1, &#x27;FM000.000&#x27;),</span><br><span class="line">       to_char(1, &#x27;FM900.009&#x27;),</span><br><span class="line">       to_char(1, &#x27;FM999.000&#x27;)</span><br><span class="line">from   dual;</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line">001.000</span><br><span class="line">01.00</span><br><span class="line">1.000</span><br></pre></td></tr></table></figure>



<h2 id="W8-DML"><a href="#W8-DML" class="headerlink" title="W8  DML"></a>W8  DML</h2><p>Update, Delete and Transaction Management</p>
<p>记得每个insert&#x2F;update 都要commit！</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>主要讲事务上的读写锁S（shared lock）和X（exclusive lock）</p>
<p>当一个新Tx，</p>
<ul>
<li>读SLock: 更新SLock到S(Tx)</li>
<li>写SLock: 新Tx wait 上个老Tx</li>
<li>读XLock: wait</li>
<li>写XLock: wait</li>
</ul>
<p><strong>最后画个wait的图</strong>，判断是否deadlock（回环）</p>
<h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><p>rolled forward：REDO+after-images</p>
<p>rolled back：UNDO+before-images</p>
<p>checkpoint：就把在checkpoint后fail前commit的重做（REDO），未完成的rollback（UNDO），区间前面完成的也不理</p>
<img src="/post/fit9132-db-notes/image-20210217155937874.png" class="" title="image-20210217155937874">

<p>如图</p>
<p>T1: 无需操作</p>
<p>T3,T5 roll back: 因为没commit</p>
<p>T2 roll forward: 因为在checkpoint点和fail点中间提交的</p>
<p>T4 roll forward: 因为在检查点后开始且fail前提交的</p>
<h2 id="W9-Aggregate-Functions"><a href="#W9-Aggregate-Functions" class="headerlink" title="W9 Aggregate Functions"></a>W9 Aggregate Functions</h2><p>COUNT, MAX, MIN, AVG</p>
<p>COUNT，AVG ignore null rows</p>
<p>GROUP BY -&gt; 合并keys相同的rows，对每个合并后的Aggregate使用Fn</p>
<p>HAVING -&gt; 对Group BY的结果进行约束 </p>
<p>IN</p>
<p>ANY, ALL</p>
<p>extract</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extract(year from ofyear) as year</span><br></pre></td></tr></table></figure>



<p>decode: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">decode (cltype, </span><br><span class="line">  <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;Lecture&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;Tutorial&#x27;</span>) <span class="keyword">as</span> Classtype</span><br></pre></td></tr></table></figure>



<p>lpad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpad(</span><br><span class="line">  extract(year from ofyear) || &#x27; S&#x27; || semester,</span><br><span class="line">  10,&#x27; &#x27;) as offering</span><br></pre></td></tr></table></figure>





<h2 id="W10-Advanced-SQL"><a href="#W10-Advanced-SQL" class="headerlink" title="W10 Advanced SQL"></a>W10 Advanced SQL</h2><p>好家伙分数大头</p>
<h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><ul>
<li>case when expr then val end</li>
<li>case var then val end</li>
</ul>
<h3 id="Subquery"><a href="#Subquery" class="headerlink" title="Subquery"></a>Subquery</h3><p>基本上哪里都能套</p>
<h4 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h4><p>xxx in (select)</p>
<h4 id="correlated"><a href="#correlated" class="headerlink" title="correlated"></a>correlated</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studid, unitcode, mark</span><br><span class="line"><span class="keyword">from</span> uni.enrolment e1</span><br><span class="line"><span class="keyword">where</span> mark <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(mark)</span><br><span class="line">  <span class="keyword">from</span> uni.enrolment e2</span><br><span class="line">  <span class="keyword">where</span> e1.unitcode <span class="operator">=</span> e2.unitcode)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> unitcode, studid;</span><br></pre></td></tr></table></figure>

<p>这个也能用在update，insert这些上（很好用</p>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> studid, e.unitcode, mark</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> unitcode, <span class="built_in">max</span>(mark) <span class="keyword">as</span> max_mark</span><br><span class="line">  <span class="keyword">from</span> uni. enrolment</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> unitcode) max_table</span><br><span class="line"><span class="keyword">join</span> uni.enrolment e <span class="keyword">on</span> e.unitcode <span class="operator">=</span>   max_table.unitcode <span class="keyword">and</span></span><br><span class="line">e.mark <span class="operator">=</span> max_table.max_mark</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> unitcode, studid;</span><br></pre></td></tr></table></figure>

<p>这里max_table就是select出来内容的alia</p>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">grade,</span><br><span class="line"><span class="built_in">count</span>(grade) <span class="keyword">as</span> grade_count,</span><br><span class="line">(<span class="keyword">SELECT</span> </span><br><span class="line">  <span class="built_in">count</span>(grade) <span class="keyword">from</span> uni.enrolment) <span class="keyword">as</span> total_rows,</span><br><span class="line">  <span class="number">100</span><span class="operator">*</span><span class="built_in">count</span>(grade)<span class="operator">/</span>(<span class="keyword">SELECT</span> <span class="built_in">count</span>(grade) <span class="keyword">FROM</span> uni.enrolment</span><br><span class="line">) <span class="keyword">as</span> percentage</span><br><span class="line"><span class="keyword">FROM</span> uni.enrolment</span><br><span class="line"><span class="keyword">where</span> grade <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> grade;</span><br></pre></td></tr></table></figure>

<p>套中套</p>
<h3 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h3><p>基本不用 （因为ass不让</p>
<p>考试应该就可以</p>
<p>但是基本上功能和前面subquery差不多</p>
<h3 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h3><p>natural join, self join, outer join </p>
<p>这个就没前面的natural join那样慈眉善目了，丢分巨头</p>
<h4 id="self-join"><a href="#self-join" class="headerlink" title="self join"></a>self join</h4><p>Show the name of the manager for each employee.</p>
<p>因为manager也是employee，所以就算self join，通过mgrno和empno来对应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM emp.employee e1 JOIN emp.employee e2</span><br><span class="line">ON e1.mgrno = e2.empno;</span><br></pre></td></tr></table></figure>

<p>吓得我去看了眼考试SQL的模型，还好没一元关系</p>
<h4 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h4><p>这个用的比较多</p>
<h5 id="full-outer-join"><a href="#full-outer-join" class="headerlink" title="full outer join"></a>full outer join</h5><p>两边对应不上的都保留</p>
<img src="/post/fit9132-db-notes/image-20210218213524538.png" class="" title="image-20210218213524538">

<p>如图，左边的id&#x3D;3没对应所以右边空null，右边4没对应所以左边空null</p>
<h5 id="left-x2F-right-outer-join"><a href="#left-x2F-right-outer-join" class="headerlink" title="left&#x2F;right outer join"></a>left&#x2F;right outer join</h5><p>left只保证左边的都有对应，因此只保留右边的null</p>
<p>right只保证右边的都有对应，因此只留左边的null。</p>
<p>另外左右是根据join关键词的左边右边决定的，比如上面的full就是<code>id_name full outer join id_subj_mark</code></p>
<h3 id="Set-Operators"><a href="#Set-Operators" class="headerlink" title="Set Operators"></a>Set Operators</h3><p>大前提：列能对的上</p>
<p>Union All 加法（不去重）</p>
<p>Union 加法（去重）</p>
<p>Intersect 重叠部分，即$A \and B$</p>
<p>Minus 减法，即$A-(A \and B)$</p>
<p>另外，union优先级比order by高</p>
<h3 id="Oracle-Functions"><a href="#Oracle-Functions" class="headerlink" title="Oracle Functions"></a>Oracle Functions</h3><p>见文档</p>
<h2 id="W11-BigData"><a href="#W11-BigData" class="headerlink" title="W11 BigData"></a>W11 BigData</h2><p>纯介绍+NoSQL</p>
<p>JSON_OBJECT(‘key’ value val FORMAT JSON)</p>
<p>JSON_ARRAYAGG(JSON_OBJECT(), JSON_OBJECT())</p>
<p>MongoDB</p>
<p>insertOne(), insertMany([])</p>
<p>find({})或者find(匹配, 需要的列)，例如find({_id: 2}, {name: 1})只取id&#x3D;2那列的name</p>
<p>op: </p>
<p>{$and: [{}, {}]}</p>
<p>{$or: [{}, {}]}</p>
<p>updateOne(匹配, {$set: {}})</p>
<p>$ 替代符 placeholder to update the <strong>first element</strong> that matches the query condition，例如 client.$.addr</p>
<p>deleteOne()</p>
<p>deleteMany()</p>
<h2 id="W12"><a href="#W12" class="headerlink" title="W12"></a>W12</h2><p>无Lec</p>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><p>输出<code>   Fri 01 February 2019 RM</code>这样的date str用<code> lpad(rtrim(to_char(ca.carndate, &#39;Dy DD Month&#39;)) || &#39; &#39; || to_char(ca.carndate, &#39;YYYY&#39;),23) AS carnival_date,</code>（人裂开</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>Sample给的这么全面想想也不会考的很简单……</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="Relational-Model-10"><a href="#Relational-Model-10" class="headerlink" title="Relational Model 10"></a>Relational Model 10</h4><ol>
<li>不同attrib（估计考试会换成不同的key）</li>
<li>a. &amp; b. 代数式（一定要记得最后再π一下去掉不必要的列</li>
</ol>
<h4 id="Database-Design-20"><a href="#Database-Design-20" class="headerlink" title="Database Design 20"></a>Database Design 20</h4><p>根据文章徒手撸Logical Model（简易版，其实就和ASS1的Conceptual差不多了）</p>
<p>写纸上</p>
<h4 id="Normalisation-10"><a href="#Normalisation-10" class="headerlink" title="Normalisation 10"></a>Normalisation 10</h4><p>写全过程（记得最后一定要跟上Full Dep</p>
<h4 id="SQL-40"><a href="#SQL-40" class="headerlink" title="SQL 40"></a>SQL 40</h4><p>根据给出的Model写</p>
<ol>
<li>insert，alter还有update</li>
<li>简单select + 巨难的left outer join</li>
<li>又是left outer join再配合having count(distinct ) + select subquery</li>
</ol>
<h4 id="Big-Data-and-No-SQL-10"><a href="#Big-Data-and-No-SQL-10" class="headerlink" title="Big Data and No SQL 10"></a>Big Data and No SQL 10</h4><ol>
<li><p>json和mongodb</p>
</li>
<li><p>神tm名词解释Volume，Velocity，Variety。估计考试要求介绍NOSQL了</p>
</li>
</ol>
<h4 id="Transaction-10"><a href="#Transaction-10" class="headerlink" title="Transaction 10"></a>Transaction 10</h4><ol>
<li>锁</li>
<li>checkpoint</li>
</ol>
<h2 id="Exam-1"><a href="#Exam-1" class="headerlink" title="Exam"></a>Exam</h2><p>题型的确和Sample一模一样</p>
<p>前四个除了第一个问答题以外不用多说，老内容了，而且感觉更简单？（也可能是我掉坑）。</p>
<p>第一个问答题改成了Relation里tuple的特性</p>
<img src="/post/fit9132-db-notes/image-20210219224938123.png" class="" title="image-20210219224938123">

<p>就这部分内容</p>
<p>后面BigData部分，mongodb直接要求写find和insertOne，find有点难因为是在一个list&#x2F;array里找匹配的object。问题没有根据预测考NoSQL，考的是Volume的内容</p>
<img src="/post/fit9132-db-notes/image-20210219225409532.png" class="" title="image-20210219225409532">

<p>checkpoint也变名词解释Write Through和Deferred Write</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>fit5163-sec-notes</title>
    <url>/post/fit5163-sec-notes/</url>
    <content><![CDATA[<p>这门课是Blockchain的前置课。</p>
<p>主要讲的是一些安全方面的内容。</p>
<p>assignment两个，一个是期中考试（15%），一个叫mini research应该是论文解读相关（25%）。</p>
<p>剩下60%是考试。</p>
<p>平时tut主要是带你做题目方式答疑，tut和lec之间每周内容对应（这周lec这周tut讲完</p>
<span id="more"></span>

<h2 id="W1-Intro"><a href="#W1-Intro" class="headerlink" title="W1: Intro"></a>W1: Intro</h2><p>定义了一下各类术语，以及进行一些分类。</p>
<p>考点：标准，<strong>攻击，服务，机制</strong></p>
<h3 id="Security-standards-安全标准"><a href="#Security-standards-安全标准" class="headerlink" title="Security standards 安全标准"></a>Security standards 安全标准</h3><p>网络安全标准Cybersecurity standards: </p>
<p>are techniques set forth in published materials that attempt to protect the cyber environment of a user or organization, 例如AES(from NIST)</p>
<ul>
<li>国际标准International standards: ISO&#x2F;IEC 27000(澳洲用), <strong>ITU-T X.800</strong>, IEC 62443</li>
<li>国家标准: US: NIST, FIPS140; UK: Cyber Essentials</li>
</ul>
<p>术语（会让你说这个事&#x2F;物算哪个，经常问Threat和Vulnerability和Risk）</p>
<ul>
<li><p>Adversary (threat agent, attacker, hacker): Adversary意思是对手</p>
</li>
<li><p>Threat: 违反安全的<strong>可能性（potential）</strong>，当存在可能违反安全并造成伤害的情况、能力、行动或事件时，就存在这种可能性。</p>
</li>
<li><p>Vulnerability: 系统设计、实施或操作和管理中的<strong>缺陷或弱点</strong>，可被利用来违反系统的安全策略。</p>
</li>
<li><p>Attack: 源自智能威胁的对系统安全的攻击； 故意逃避安全服务并违反系统的安全策略</p>
</li>
<li><p>Countermeasure对策: 通过消除或防止威胁、漏洞或攻击，通过最大限度地减少其可能造成的伤害，或通过发现和报告它以便采取纠正措施来减少威胁、漏洞或攻击的行动、设备、程序或技术</p>
</li>
<li><p>Risk: <strong>损失预期</strong>，表示为特定威胁利用特定漏洞并产生特定有害结果的<strong>可能性</strong>。</p>
</li>
<li><p>Security Policy: <strong>一组规则和实践</strong>，指定系统或组织如何提供安全服务以保护敏感和关键系统资源。</p>
</li>
<li><p>System Resource (Asset) - Data: 系统提供的服务； 系统能力； 一项系统设备； 容纳系统操作和设备的设施。</p>
</li>
</ul>
<img src="/post/fit5163-sec-notes/image-20210904214224475.png" class="" title="image-20210904214224475">

<p><strong>信息安全</strong>是关于如何防止攻击，或者如何防止攻击，以检测对基于信息的系统的攻击</p>
<p>信息安全的 3 个方面：</p>
<ul>
<li>安全攻击&#x2F;威胁：可能违反安全策略的一种可能方式（例如，完整性或机密性的丢失）。</li>
<li>安全服务：一种可以用来应对威胁或反击攻击的措施（例如提供保密性）。</li>
<li>安全机制：提供服务的手段（例如加密、数字签名）</li>
</ul>
<h3 id="Security-attacks-安全攻击"><a href="#Security-attacks-安全攻击" class="headerlink" title="Security attacks 安全攻击"></a>Security attacks 安全攻击</h3><p>General Well-Known Threats 常见威胁</p>
<p>• Viruses, worms, trojans </p>
<p>• Malware • Phishing </p>
<p>• Botnets </p>
<p>• Brute-force </p>
<p>• DoS&#x2F;DDoS </p>
<p>• Man-in-the-middle </p>
<p>• SQL injection</p>
<p>Resources&#x2F;Assets</p>
<ul>
<li>Information&#x2F;data: Password, credit card, e-health records </li>
<li>Service: Storage service, data process services </li>
<li>Hardware: RAM, cache, hard disks, branch predictor units, GPU </li>
<li>Software </li>
<li>Firmware: BIOS</li>
</ul>
<p>动机</p>
<ul>
<li>Obtain&#x2F;access private resources → Confidentiality</li>
<li>Bypass authentication for accessing private resources→ Authentication</li>
<li>Break the availability of a service → Availability</li>
<li>Breach the integrity of information → Integrity</li>
</ul>
<p>分类</p>
<p>Passive attacks </p>
<ul>
<li>Interception: an attack on <strong>confidentiality</strong> 只嗅探这样</li>
</ul>
<p>Active attacks </p>
<ul>
<li>Interruption: an attack on availability: DoS这样影响了可用性</li>
<li>Modification: an attack on integrity </li>
<li>Fabrication: an attack on authenticity &amp; integrity </li>
<li>Replay: an attack on freshness</li>
</ul>
<h3 id="Security-services-安全服务"><a href="#Security-services-安全服务" class="headerlink" title="Security services 安全服务"></a>Security services 安全服务</h3><p>旨在对抗安全攻击<br>利用一种或多种安全机制来提供服务<br>6 项主要安全服务&#x2F;财产&#x2F;目标：<br>• <strong>Confidentiality</strong><br>• <strong>Integrity</strong><br>• <strong>Availability</strong><br>• Authentication<br>• Non-repudiation 不可否认性：防止通信中的一方否认<br>• Access control<br>信息安全的主要重点是平衡保护数据的机密性、完整性和可用性（也称为 CIA triad三元组）</p>
<p>技术手段</p>
<ul>
<li>Confidentiality-&gt; encryption</li>
<li>Integrity -&gt; Message Authentication Code (MAC); Message Authentication Code (MAC); Digital signature</li>
<li>Availability-&gt; High availability systems</li>
<li>Authentication -&gt;  <strong>What U know</strong>: PIN, or a password; <strong>What U have</strong>: a driver’s license or a magnetic swipe card; <strong>What U are</strong> biometrics, including palm prints, fingerprints, voice  prints and retina (eye) scans </li>
<li>Non-Repudiation: Digital signature; Message Authentication Code (MAC)</li>
<li>Access Control: File permissions in Unix&#x2F;NT file systems</li>
</ul>
<h3 id="Security-mechanism-安全机制"><a href="#Security-mechanism-安全机制" class="headerlink" title="Security mechanism 安全机制"></a>Security mechanism 安全机制</h3><p><strong>Specific security mechanisms</strong>: 用于提供特定的安全服务</p>
<p><strong>Pervasive security mechanisms</strong>: （遍布的，普适的）不特定于特定服务</p>
<p>Specific Security Mechanisms</p>
<p>• Encipherment (encryption) : hide or covers data</p>
<p>• Data integrity </p>
<p>• Digital signatures </p>
<p>• Access controls </p>
<p>• Authentication exchange: 通过信息交换确保实体的身份</p>
<p>• Traffic padding: 将bits插入数据流中的间隙以阻断流量分析尝试</p>
<p>• Routing control: 选择并不断改变发送方和接收方之间不同的可用路线</p>
<p>• Notarization 公证; 使用受信任的第三方来控制双方之间的通信</p>
<p>Pervasive Security Mechanisms</p>
<p>• Trusted functionality: 可用于扩展范围或建立其他安全机制的有效性; 任何直接提供或提供对安全机制的访问的功能都应该是值得信赖的</p>
<p>• Security labels: 系统资源可能具有与其相关联的安全标签，例如，用于指示敏感度级别（绝密、机密、机密、未分类）; 通常需要在传输数据时传送适当的安全标签</p>
<p>• Event detection: 检测与安全相关的事件</p>
<p>• Security audit trails 安全审计追踪: 过去与安全相关的事件的日志; 允许检测和调查过去的安全漏洞</p>
<p>• Security recovery: 包括处理从安全故障中恢复的请求的机制; 可能包括操作的立即中止、实体的临时失效、将实体添加到黑名单</p>
<img src="/post/fit5163-sec-notes/image-20210904231525896.png" class="" title="image-20210904231525896">



<h3 id="Model-of-system-x2F-inter-network-security-系统-x2F-网络安全模型"><a href="#Model-of-system-x2F-inter-network-security-系统-x2F-网络安全模型" class="headerlink" title="Model of system&#x2F;(inter)network security 系统&#x2F;网络安全模型"></a>Model of system&#x2F;(inter)network security 系统&#x2F;网络安全模型</h3><p>主要会问到底属于 系统&#x2F;网络间&#x2F;网络内 的安全问题</p>
<h4 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h4><img src="/post/fit5163-sec-notes/image-20210905000105744.png" class="" title="image-20210905000105744">

<h3 id="Tut-数学回顾"><a href="#Tut-数学回顾" class="headerlink" title="Tut:  数学回顾"></a>Tut:  数学回顾</h3><p>质数分解，GCD 略</p>
<p>Congruent class of each number每个数字的全等类-&gt;就是算余数</p>
<p>Eulers Totient φ(n) : φ(n) &#x3D; (p − 1) × (q − 1) if p and q are primes.</p>
<p>a truth table: ¯表示取反</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>x + y</th>
<th>x + ¯y</th>
<th>¯x + y</th>
<th>(x + y)(x + ¯y)(¯x + y)</th>
<th>xy</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>⊕表示XOR抑或(&#x3D;  (x!&#x3D;y) )</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>⊕</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<h2 id="W2-加密规则-Principles-of-Encryption"><a href="#W2-加密规则-Principles-of-Encryption" class="headerlink" title="W2: 加密规则 Principles of Encryption"></a>W2: 加密规则 Principles of Encryption</h2><p>加（解）密的一些原理</p>
<p>考点：传统密文（Substitution，Transposition，Product 以及language statistics的安全分析），加密系统特性（Avalanche effect 雪崩效应，Unconditional security，Computational security），加密分析（各种攻击）</p>
<p>术语</p>
<p>• Plaintext – 原始消息</p>
<p>• Ciphertext – 编码&#x2F;加密的消息 </p>
<p>• Cipher –明文和密文之间的转换算法</p>
<p>• Key – 密码中使用的秘密信息，只有发送方和接收方知道</p>
<p>• Encrypt&#x2F;encipher – 明文转换为密文  </p>
<p>• Decrypt&#x2F;decipher – 密文转换为纯文本 </p>
<p>• Cryptography – 安全通信技术的研究 </p>
<p>• Cryptanalysis (codebreaking) – 分析密码技术的研究（不知道密钥） </p>
<p>• Cryptology – 密码学和密码分析领域</p>
<p>Caesar Cipher: 熟悉的置换（<strong>Substitution</strong>）比如ABCD -&gt; EFGH，即</p>
<p>C &#x3D; Enc(k, P) &#x3D; (P + k) mod 26</p>
<p>P &#x3D; Dec(k, C) &#x3D; (C – k) mod 26</p>
<p>如果 (a mod n) &#x3D; (b mod n) ，则 a 和 b 被称为模 n 全等； 等价于 a Ξ b (mod n)</p>
<p>r 称为a mod n 的残差, a &#x3D; qn + r。 通常选择最小的<strong>正余数</strong>作为残差（-12 mod 7 &#x3D; 2 mod 7 &#x3D; 2）</p>
<h3 id="Monoalphabetic-Ciphers-单字母密码"><a href="#Monoalphabetic-Ciphers-单字母密码" class="headerlink" title="Monoalphabetic Ciphers 单字母密码"></a>Monoalphabetic Ciphers 单字母密码</h3><p>单字母密码: 每个明文字母映射到不同的随机密文字母</p>
<p>攻击: 单字母替换密码不会改变相对字母频率</p>
<p>计算密文的字母频率-&gt; 将计数&#x2F;图与已知值进行比较</p>
<p>常见的双&#x2F;三字母表也有帮助-&gt;碰瓷the这类单词</p>
<h3 id="Polyalphabetic-Ciphers-多字母密码"><a href="#Polyalphabetic-Ciphers-多字母密码" class="headerlink" title="Polyalphabetic Ciphers 多字母密码"></a>Polyalphabetic Ciphers 多字母密码</h3><p>多字母密码: 在处理明文消息时使用不同的单字母替换</p>
<p>Vigenère Cipher维吉尼亚密码: 用一个和Ptxt等长的Key，密文Ctxt[i] &#x3D; Ptxt[i] + Key[i] mod 26</p>
<p>• 每个明文字母有多个密文字母, 字母频率被掩盖。但是，并没有完全迷失<br>• 破解密码取决于猜测密钥长度： 例如 “红色”的 2 个实例由 9 个字符位置分隔。<br>• 使用语言频率分别攻击每个单字母密码</p>
<h4 id="具体攻击实现-Kasiski-Method"><a href="#具体攻击实现-Kasiski-Method" class="headerlink" title="具体攻击实现 Kasiski Method"></a>具体攻击实现 Kasiski Method</h4><p>密文中的重复提供有关关键字长度的线索</p>
<p>-&gt;查找重复文本块之间的距离</p>
<p>-&gt;这些块的公约数给出了关键字长度（概率很高）例如重复的“VTW”——建议密钥大小为 3 或 9 </p>
<p>-&gt;然后，使用与以前相同的技术单独攻击每个单字母密码</p>
<p>One-Time Pad: 使用真正随机，与Ptxt等长，的Key</p>
<p>• 始终存在将明文映射到密文的密钥 </p>
<p>• 今天的计算机化应用：明文位与真正随机的密钥位进行异或</p>
<p>缺陷：</p>
<p>• 需要生成很长的密钥 – 同时分发和存储这些长密钥 </p>
<p>• 密钥需要真正随机</p>
<p> • 此外，同一个密钥只能使用一次</p>
<p>Transposition Ciphers换位密码</p>
<p>略</p>
<p>Rail Fence cipher栅栏密码</p>
<p>略</p>
<p>Product Ciphers乘积密码</p>
<p>略</p>
<h3 id="Desirable-Properties-理想的属性"><a href="#Desirable-Properties-理想的属性" class="headerlink" title="Desirable Properties 理想的属性"></a>Desirable Properties 理想的属性</h3><ul>
<li>No information loss: $f^-1(f(x))  \rarr x$</li>
<li>Ciphertext needs to completely <strong>obscure statistical  properties</strong> with respect to the original message: 密文需要完全掩盖原始消息的统计属性<ul>
<li>Confusion: 使密文和密钥之间的统计关系尽可能复杂 &gt; 通过substitution替换实现</li>
<li>Diffusion:  每一位密文都应该受到每一位明文和密钥的影响（复杂的关系应该在所有位之间传播） &gt; 通过transposition&#x2F;permutation转置&#x2F;排列实现</li>
</ul>
</li>
<li><strong>Avalanche effect</strong> 雪崩效应:<br>明文或密钥的微小变化会导致密文发生重大变化<br>一位明文或密钥的变化应该会导致密文的许多位发生变化<br>-&gt;使猜测密钥的尝试变得不可能</li>
<li>From the view of information security we would like to  have <strong>unconditional security</strong>从信息安全的角度，我们希望有无条件的安全: 无论有多少计算机能力可用，密码都无法破解，因为密文提供的信息不足以唯一确定相应的明文</li>
<li>From the view of computational efficiency we would like  to have <strong>computational security</strong>从计算效率的角度来看，我们希望有计算安全性: 计算成本&#x2F;时间&gt;&gt;攻击成本&#x2F;时间</li>
</ul>
<h3 id="General-Attacks"><a href="#General-Attacks" class="headerlink" title="General Attacks"></a>General Attacks</h3><ul>
<li>Cryptanalytic attack 密码分析攻击</li>
<li>Brute-force attack 略</li>
</ul>
<h4 id="Cryptanalytic-attack-密码分析攻击"><a href="#Cryptanalytic-attack-密码分析攻击" class="headerlink" title="Cryptanalytic attack 密码分析攻击"></a>Cryptanalytic attack 密码分析攻击</h4><p>攻击依赖于算法的性质加上对明文一般特征的一些了解</p>
<p>攻击利用算法的特性来尝试推断特定的明文或推断使用的密钥</p>
<ul>
<li><strong>Ciphertext only attack</strong>: 攻击者只能访问密文; 不知道什么明文加密为给定的密文; <strong>最弱的攻击者</strong></li>
<li><strong>Known plaintext attack</strong>: 攻击者可以访问 ( ptxt , ctxt ) 对，其中 ctxt &#x3D;Enc(ptxt); 但是，<strong>不能选择出</strong> (ptxt , ctxt) 对; 目标是破解明文未知的密文或恢复出密钥</li>
<li><strong>Chosen plaintext attack</strong>: 攻击者可以访问 ( ptxt , ctxt ) 对，其中 <strong>ptxt</strong> 由攻击者选择； 与已知明文攻击的目标相同</li>
<li><strong>Chosen ciphertext attack</strong>: 攻击者可以访问 ( ptxt , ctxt ) 对，其中 <strong>ctxt</strong> 由攻击者选择； 与已知明文攻击的目标相同</li>
<li><strong>Chosen text attack</strong>: 攻击者可以访问 ( ptxt , ctxt ) 对，他可以在其中选择 ptxt 或 ctxt； <strong>最强攻击者</strong></li>
</ul>
<p>在所有这些中，始终假设加密&#x2F;解密算法是已知的，但密钥不知道！</p>
<h4 id="Brute-Force-Attack"><a href="#Brute-Force-Attack" class="headerlink" title="Brute-Force Attack"></a>Brute-Force Attack</h4><p>涉及尝试每个可能的密钥，直到获得密文到明文的可理解的翻译</p>
<p>平均而言，必须尝试所有可能的密钥的一半才能成功</p>
<p>为了补充蛮力方法，需要对预期的明文有一定程度的了解，还需要一些自动区分明文和“垃圾”的方法</p>
<h3 id="Tut-Intro"><a href="#Tut-Intro" class="headerlink" title="Tut: Intro"></a>Tut: Intro</h3><p>一堆文字题……</p>
<h2 id="W3-对称加密-Symmetric-Cryptography"><a href="#W3-对称加密-Symmetric-Cryptography" class="headerlink" title="W3: 对称加密 Symmetric Cryptography"></a>W3: 对称加密 Symmetric Cryptography</h2><p>大家熟悉的AES案例</p>
<p>更侧重讲的是Block的，stream的部分是放在了W2结尾</p>
<p>考点：<strong>流密码</strong>（RC4），<strong>块密码DES&#x2F;AES，块密码的模式，MAC</strong></p>
<img src="/post/fit5163-sec-notes/image-20210905013819258.png" class="" title="image-20210905013819258">

<p>规则</p>
<img src="/post/fit5163-sec-notes/image-20210905013846123.png" class="" title="image-20210905013846123">

<ul>
<li>$A$ 与 $B$ 共享一个密钥 $K$，密钥可由密钥分发中心 (KDC, key distribution center) 分发。</li>
<li>$A$ 通过应用<u>加密函数 $E$</u> 和密钥 $K$ 来加密明文消息 $P$ 以创建密文 $C &#x3D; E_K(P)$</li>
<li>$A$ 通过通信信道将密文 $C$ 发送给 $B$。 即使 B 以外的其他人获得了 $C$ 的副本，除非他拥有 $K$，否则他无法解密该消息。</li>
<li>如果密钥分发是完美的，或者 $B$ 没有意外或故意泄露密钥，那么除了$B$ 之外没有人应该拥有密钥 $K$。</li>
<li>在接收到 $C$ 时，$B$ 使用密钥 $K$ 在 $C$ 上应用解密函数 $D$ 以恢复明文消息 P: $D_K(C) &#x3D; D_K(E_K(P)) &#x3D; P$</li>
</ul>
<p>对称密码</p>
<p>Stream cipher: ➢ 连续处理输入元素 ➢ 一次产生一个元素（1 位或 1 字节） ➢ 例如，RC4 和rabbit</p>
<p>Block cipher:➢ 一次处理一个输入块 ➢ 为每个输入块产生一个输出块 ➢ 例如，3DES 和 AES</p>
<h3 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h3><p>流密码属性<br>• 一些设计注意事项是：<br>– <strong>没有重复的密钥流的长周期</strong><br>– 密钥流在<strong>统计上是随机</strong>的<br>– 种子（主密钥）足够长且随机（128-256 位）<br>– KSG 函数很难反转<br>• 如果设计得当，可以像具有相同大小密钥的块密码一样安全<br>• 但通常<strong>更简单、更快</strong><br>• 示例：RC4</p>
<h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>• 目标：为明文的每个字节生成一个字节（8 位）<br>• 主要思想：以“随机”方式从 256 个候选者中挑选一个值</p>
<img src="/post/fit5163-sec-notes/image-20210905020902244.png" class="" title="image-20210905020902244">

<p>• RC4 逐字节加密明文<br>• RC4 提供了一种以“随机”方式从 256（即 $2^8$）个候选中挑选一个值的方法</p>
<ol>
<li>Initialize an array of 256 bytes T (initial state of S &amp; T) S&#x3D;Seed T[i]&#x3D;K[i mod keylen]</li>
<li>KSA(Key Schedule Algorithm, permutation of S), S内部Swap</li>
<li>Key Stream Generation, Ci &#x3D; Mi XOR S[t]</li>
</ol>
<p>由于 RC4 是一种流密码，绝不能重复使用相同的密钥流！– 相同的密钥在 RC4 中提供相同的密钥流！</p>
<p>这个想法是通过诉诸计算安全性使“一次性密码”变得实用<br>• 步骤：<br>1）从一个小密钥（“种子”）生成一个长密钥流<br>2) 将密钥流与消息进行异或<br>• 密钥流称为“伪随机”<br>– 不像一次性纸垫那样真正随机！<br>– 与消息长度相同<br>• 密钥流的随机性破坏了消息中的统计属性</p>
<p>𝑀: 消息<br>𝜅: 主键<br>𝐾: 生成的密钥流<br>𝐼𝑉: 初始化向量，所有人可知非私密<br>• 2 个步骤（形式化）：</p>
<ol>
<li>𝐾 ← 𝐾𝑆𝐺(𝜅,𝐼𝑉)，其中 KSG 是一个“密钥流生成器”</li>
<li>𝐶 &#x3D; 𝑀 ⊕ 𝐾</li>
</ol>
<img src="/post/fit5163-sec-notes/image-20210905115816646.png" class="" title="image-20210905115816646">

<p>密钥流生成器 (KSG) 或伪随机生成器 (PRG) 是一种确定的过程，它将随机种子 (Key) 映射到无法（在计算上）与随机字符串区分开的较长伪随机字符串。</p>
<p>Seed&#x2F;Main Key通常是从均匀分布中随机抽取的短二进制字符串</p>
<h3 id="Block-Cipher"><a href="#Block-Cipher" class="headerlink" title="Block Cipher"></a>Block Cipher</h3><p>Feistel Cipher: 许多分组密码算法，包括 DES（数据加密标准），都具有由 IBM 的 Horst Feistel 于 1973 年首次描述的结构。“Feistel Cipher&#x2F;Network&#x2F;Structure”本身并没有描述具体的分组密码，而是设计分组密码的一般方法</p>
<p>• 将明文分成两等份 (𝐿0, 𝑅0)<br>• 第𝑛 轮次处理二分之一<br>• 对于每一轮 𝑖 &#x3D; 1,2, … , 𝑛<br>𝐿𝑖 &#x3D; 𝑅𝑖−1<br>𝑅𝑖 &#x3D; 𝐿𝑖−1 ⊕ 𝐹(𝑅𝑖−1,𝐾𝑖)<br>其中 𝐹 是轮函数，𝐾𝑖 是子密钥或轮密钥<br>• 在第 𝑛 轮之后，密文是 (𝐿𝑛, 𝑅𝑛)。<br>• 不管函数𝐹，解密是通过<br>𝑅𝑖−1 &#x3D; 𝐿𝑖<br>𝐿𝑖−1 &#x3D; 𝑅𝑖 ⊕ 𝐹(𝐿𝑖 ,𝐾𝑖)<br>• 16 轮的示例图</p>
<p><img src="/fit5163-sec-notes/image-20210905130857579.png" alt="image-20210905130857579" loading="lazy"><img src="/fit5163-sec-notes/image-20210905130903456.png" alt="image-20210905130903456" loading="lazy"></p>
<p>左：加密； 右：解密</p>
<p>Block size块大小：更大的块大小意味着更高的安全性</p>
<p>Key size密钥大小：较大的密钥大小意味着更高的安全性</p>
<p>Number of rounds 轮数：更多轮提供更高的安全性，通常为 16 回合</p>
<p>Subkey generation algorithm子密钥生成算法：复杂度越大，密码分析难度越大</p>
<p>Round function 每轮函数：更大的复杂性意味着更大的阻力</p>
<p>（但是要考虑到convenience</p>
<h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><p>Feistel structure; Cipher: Block; </p>
<p>Block size: 64 bits; (Effective) Key size: 56 bits （&#x3D;64-8）</p>
<p>16 subkeys created for 16  rounds</p>
<img src="/post/fit5163-sec-notes/image-20210905135628189.png" class="" title="image-20210905135628189">

<p>IP初始化置换: 把x整成一个ixj的矩阵（将原块中的第 n 位放入新块的 (8* i+j 位</p>
<p>Round Function: </p>
<ol>
<li>明文被分成 32 位的一半 $L_i$ 和 $R_i$</li>
<li>$R_i$ 被送入函数 f ，然后对其输出进行异或运算<br>与$L_i$</li>
<li>左右半边互换</li>
</ol>
<img src="/post/fit5163-sec-notes/image-20210905143751106.png" class="" title="image-20210905143751106">

<p>函数 f 输入$R_{i-1}$和每轮的key $k_i$:</p>
<ol>
<li><p>扩展E（增加漫射diffusion）: 把一个32bits扩展到48（6x8）bits。n 位于第 i 行第 j 列表示，将原块中的第 n 位放入新块的第 (6* i+j) 位 </p>
</li>
<li><p>与轮key计算异或: 轮密钥和扩展 E 的输出的按位异或; 轮密钥派生自 DES 密钥表中的主密钥（在少数</p>
</li>
<li><p>S-box矩阵替换（DES 安全的关键要素！非线性且抗差分密码分析）: 8个表，6bits输入，4bits输出 </p>
</li>
<li><p>置换（增加漫射diffusion）: 按位排列; 一个 S Box 的输出位会影响下一轮的多个 S Box。<br>E、S 盒和 P 的Diffusion 确保了在第 5 轮之后每一位都是每个密钥位和每个明文位的函数</p>
</li>
</ol>
<p>最后一轮后，进行反向IP操作</p>
<p><strong>DES的Subkey生成</strong></p>
<p>DES 需要 16 个来自原始 56 位密钥的 48 位轮密钥&#x2F;子密钥</p>
<p>输入key大小为 64 位：56 位key和 8 位parity（校验）</p>
<p>步骤：</p>
<ul>
<li>丢弃 8 个校验位</li>
<li>置换bits</li>
<li>分成两个28位</li>
<li>往左旋转<strong>1bit</strong>（在第 1、2、9 和 16 轮的进行1bit；剩余轮次（3,4,5,6,7,8,10, …..15）移动2bits ）</li>
<li>置换并提取 48 位作为子密钥</li>
</ul>
<p>主要问题：密钥长度太小！</p>
<p>S Boxes的设计一直保密</p>
<p>还有密码分析攻击；差分密码分析，线性密码分析，…</p>
<p>它们在实践中不会构成真正的威胁，但对于了解安全方面仍然很重要</p>
<p>如何在不需要大改动的情况下解决这些问题？3DES</p>
<p>3DES</p>
<p>应用DES算法3次；使用 3 个密钥和 3 次执行 DES 算法（加密解密加密）：略</p>
<p>其他加密算法</p>
<p>International Data Encryption Algorithm (IDEA); Blowfish; RC5</p>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>1997年，美国国家标准与技术研究院（NIST）正式启动高级加密标准（AES）比赛，以取代DES。基于：安全性、计算效率、内存要求、软硬件适用性、灵活性</p>
<p>由比利时的 Joan Daemen 和 Vincent Rijmen 开发，也称为 Rijndael 算法</p>
<p>AES 是一种Block cipher</p>
<p>设计简单&#x2F;灵活&#x2F;高效，适用于软件和硬件的实现，以及许多 CPU 上的代码紧凑性。</p>
<p>由于更大的块大小和更长的密钥，AES 提供了更高的安全性。</p>
<p>提供了很大的灵活性：AES 通常足够灵活，可以处理 32 位的<strong>任意倍数的密钥</strong>和<strong>块大小</strong>，最小为 128 位，最大为 256 位。</p>
<p>安全性：抵抗功耗分析和其他实施攻击 </p>
<p>足以满足当今的大多数需求</p>
<p>规格：</p>
<p>固定块长度：128 位</p>
<p>3 种不同的密钥长度：128、192 和 256 位</p>
<p>密码由 N 轮组成，其中轮数取决于密钥长度：16 字节（128 位）密钥 10 轮；24 字节（192 位）密钥 12 轮；32 字节（256 位）密钥的 14 轮。</p>
<p>每个变换都采用一个或多个 4 x 4 矩阵作为输入，并生成一个 4 x 4 矩阵作为输出。 被称为state状态</p>
<p>密钥扩展函数生成 N + 1 个轮密钥，每个轮密钥是一个不同的 4 x 4 矩阵</p>
<p>结构：</p>
<p>前 N-1 轮由 4 个组成部分组成：</p>
<ul>
<li><p>字节替换 Byte substitution（每个字节使用 1 个 S box）</p>
<ul>
<li>每个字节被由 16x16 表的行（左 4 位）和列（右 4 位）索引的字节替换</li>
</ul>
</li>
<li><p>移动行（简单置换 simple permutation）：第 1 行：不移位，第 2 行：1Byte 左循环移位，第 3 行：2Byte 移位，第 4 行：3Byte 移位</p>
<ul>
<li>在 ShiftRows 步骤中，状态的每一行中的字节循环向左移动。 对于每一行，每个字节移位的位置数逐渐不同。</li>
</ul>
</li>
<li><p>混合列（混合state bits)</p>
<ul>
<li>每列都使用固定矩阵进行转换（矩阵左乘以列给出状态中列的新值）</li>
</ul>
</li>
<li><p>添加轮密钥（XOR state矩阵与扩展的key矩阵，每个ij求xor）</p>
</li>
</ul>
<p>最后一轮 N 包含： SubBytes 、 ShiftRows 、（无混合列） 和 AddRoundKey</p>
<p>AES 128 needs 11 round keys</p>
<p>AES 192 needs 13 round keys</p>
<p>AES 256 needs 15 round keys</p>
<p>操作模式</p>
<p>块密码加密固定大小的块，例如 DES 使用 56 位密钥加密 64 位块<br>明文可以是任意长度，可以由多个块组成</p>
<p>在实践中需要某种方式来加密&#x2F;解密任意数量的数据</p>
<p>NIST SP 800 38A 定义了 5 种操作模式</p>
<p>涵盖广泛的应用，可以与任何分组密码一起使用</p>
<p>5 种常用模式，其中明文、密钥和&#x2F;或密文组合以加密&#x2F;解密任意大小的块。每个都有不同的优点&#x2F;缺点</p>
<ul>
<li>电子码本 (ECB) 模式</li>
<li>密码块<strong>链接</strong> (CBC) 模式<ul>
<li>密码<strong>反馈</strong> (CFB) 模式</li>
</ul>
</li>
<li>输出<strong>反馈</strong> (OFB) 模式</li>
<li>计数器 (CTR) 模式</li>
</ul>
<h5 id="ECB-Electronic-Codebook-模式"><a href="#ECB-Electronic-Codebook-模式" class="headerlink" title="ECB (Electronic Codebook) 模式"></a><strong>ECB (Electronic Codebook) 模式</strong></h5><p><strong>最简单</strong>的模式，每个块独立加密和解密</p>
<p>一次处理每个块（64&#x2F;128 位）</p>
<p>输入数据被填充为块大小的整数倍</p>
<p>丢失的数据块不影响其他块的解密</p>
<p>错误不传播，仅限于单个块</p>
<p>所有块都使用相同的密钥加密</p>
<p>缺点：</p>
<ul>
<li>相同的明文产生相同的密文</li>
<li>不隐藏模式</li>
<li>如果消息包含重复元素，则可以识别这些元素</li>
<li>流量分析是可能的</li>
</ul>
<h5 id="CBC-Cipher-Block-Chaining-模式"><a href="#CBC-Cipher-Block-Chaining-模式" class="headerlink" title="CBC (Cipher Block Chaining) 模式"></a><strong>CBC (Cipher Block Chaining) 模式</strong></h5><p><strong>最常用</strong>的模式，每个明文块与前一个密文块进行异或并加密</p>
<p>第一个明文块与初始化向量 (IV) 异或</p>
<p>每个块使用相同的加密密钥</p>
<p>在每个加密步骤之前加扰明文</p>
<p><strong>更安全</strong>：相同密钥的不同消息对应不同的IV； 有效地重复模式不会暴露</p>
<p>缺点：</p>
<ul>
<li>数据块的加密变得依赖于它之前的所有块</li>
<li>丢失的数据块将阻止对下一个数据块的解码</li>
<li>块不能并行加密（可以并行解密</li>
<li>明文的变化在密文中传播</li>
</ul>
<h5 id="CFB-Cipher-feedback-模式"><a href="#CFB-Cipher-feedback-模式" class="headerlink" title="CFB (Cipher feedback) 模式"></a><strong>CFB (Cipher feedback) 模式</strong></h5><p>在第一个块中，初始化向量 (IV) 被加密，然后与明文块进行异或</p>
<p>前一个密文块被加密，然后与每个明文块异或</p>
<p>每个块使用相同的加密密钥</p>
<p>CFB和CBC一样的优缺点</p>
<p>与 CBC 的区别：明文在每个加密步骤后会参与混淆</p>
<h5 id="OFB-Output-feedback-模式"><a href="#OFB-Output-feedback-模式" class="headerlink" title="OFB (Output feedback) 模式"></a><strong>OFB (Output feedback) 模式</strong></h5><p>与CFB的区别：</p>
<ul>
<li>cipher 加密的输出用作下一个块的 IV，而不是最终块的密文</li>
<li>由于明文或密文仅用于最终的异或，因此可以预先执行分组密码操作，一旦有明文或密文可用，就<strong>允许并行执行最后一步</strong>。</li>
</ul>
<h5 id="CTR-Counter-模式"><a href="#CTR-Counter-模式" class="headerlink" title="CTR (Counter) 模式"></a><strong>CTR (Counter) 模式</strong></h5><p>一种“新”模式，虽然很早就提出了</p>
<p>与 OFB 类似，但使用<strong>计数器值</strong>而不是任何反馈值进行加密</p>
<p>每个明文块必须具有不同的计数器&#x2F;随机数值（从未重用）</p>
<ul>
<li><p>𝑂𝑖&#x3D;𝐸𝐾(𝑖)</p>
</li>
<li><p>𝐶𝑖&#x3D;𝑃𝑖⊕𝑂𝑖</p>
</li>
</ul>
<p>用途：高速网络加密</p>
<p>优势：高效率</p>
<ul>
<li>可以在硬件或软件中进行<strong>并行加密</strong></li>
<li>可以在需要之前进行预处理</li>
<li>适用于突发高速链接</li>
<li>随机访问加密数据块</li>
<li>可证明的安全性（与其他模式一样好）</li>
</ul>
<p>缺点</p>
<ul>
<li>但必须确保不重复使用计数器值，否则可能会被破坏（参见 OFB）</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希函数 H 是一种单向函数，它接受消息 M 并产生固定大小（例如 256 位）的输出（称为消息摘要或哈希值或指纹）</p>
<p>对于任何消息 M，很容易计算 h&#x3D;H(M)</p>
<ul>
<li>One way property单向性质：给定 h，找到 x 使得 H(x)&#x3D;h 在计算上是不可行的</li>
<li>Collision resistance抗碰撞性：找到任何一对 (x, y) 使得 H(y)&#x3D;H(x) 在计算上也不可行</li>
<li>Deterministic确定性：相同的消息总是导致相同的散列</li>
</ul>
<p>hash函数只将消息（不需要密钥）作为输入来生成消息摘要，任何人都可以计算任何值的哈希值！</p>
<p>如果输入仅相差 1 位，则输出将完全不同！</p>
<p>可以看作是一个确定性的伪随机函数（生成一个随机数）</p>
<p>包括 MD5、SHA 1、SHA 256 等。</p>
<h4 id="Message-Authentication-Code-MAC"><a href="#Message-Authentication-Code-MAC" class="headerlink" title="Message Authentication Code (MAC)"></a>Message Authentication Code (MAC)</h4><p>（不是网卡那个哦，那个叫**media access control **address</p>
<p>MAC可以提供的服务：</p>
<ul>
<li>完整性：确认消息未被更改</li>
<li>真实性：确认消息来自指定的发件人</li>
</ul>
<p>MAC也作为标签</p>
<p>基于对称加密原型，由 3 部分组成：</p>
<ul>
<li>生成密钥 K，在发送方和接收方之间共享</li>
<li>给定 K 和 m，生成： 𝑀𝐴𝐶&#x3D;𝐶𝐾(𝑚)</li>
<li>给定 K、m 和 MAC，验证：𝑀𝐴𝐶&#x3D;𝐶𝐾(𝑚)</li>
</ul>
<p>MAC属性</p>
<p>将可变长度消息 M 压缩为固定大小的验证器：<br>MAC：{0,1}∗→{0,1}𝑛</p>
<p>是多对一（Many to one）功能：可能许多消息具有相同的 MAC； 但是在计算上很难找到具有相同 MAC 的 2 条消息</p>
<p>MAC 应该平等地依赖于消息的所有位</p>
<p>Message Code 功能</p>
<ul>
<li>HMAC（其实就是hash加盐，把盐拿来当key）</li>
<li>对称密码</li>
<li>基于密码的消息认证代码 (CMAC</li>
<li>认证加密</li>
</ul>
<img src="/post/fit5163-sec-notes/image-20210905155214885.png" class="" title="image-20210905155214885">



<h4 id="为AES加密提供认证（保证integrity"><a href="#为AES加密提供认证（保证integrity" class="headerlink" title="为AES加密提供认证（保证integrity"></a><strong>为AES加密提供认证（保证integrity</strong></h4><p>带有关联数据的身份验证加密 (AEAD) 操作模式</p>
<p>使用 Encrypt then MAC 方法</p>
<p>可以在其内部组件中使用具有 128 位块大小（例如 AES）的块密码</p>
<p>使用计数器模式的变体</p>
<p>提供机密数据的真实性（对称概念）（每次调用最多 64 GB）</p>
<p>在 NIST SP 800 38d 中标准化 GCM 加密：</p>
<ul>
<li><p>加密机密数据</p>
</li>
<li><p>在机密数据和</p>
</li>
<li><p>任何额外的非机密数据</p>
</li>
</ul>
<p>安全考虑：IV 不能被重用（在相同的密钥下）否则消息的保密性可能会受到损害</p>
<h5 id="AES-Counter-Mode-with-CBC-MAC-CCM"><a href="#AES-Counter-Mode-with-CBC-MAC-CCM" class="headerlink" title="AES Counter Mode with CBC MAC (CCM)"></a><strong>AES Counter Mode with CBC MAC (CCM)</strong></h5><p>具有关联数据的经过身份验证的加密</p>
<p>使用 MAC 然后加密方法</p>
<p>加密计数器模式</p>
<p>用于身份验证的 CBC MAC</p>
<p>在 RFC 3610 中提出，在 NIST SP 800 38c 中标准化</p>
<p>Nonce (IV) 不得重复（在同一密钥下），否则会危及安全性</p>
<h3 id="Tut"><a href="#Tut" class="headerlink" title="Tut:"></a>Tut:</h3><p>两个人通过对称密码进行通信需要多少密钥？<br>n个人安全通信需要多少把密钥？<br>答：1个秘钥。 <strong>n(n-1)&#x2F;2</strong> 个密钥</p>
<p>A、B、C 是 n bit string<br>0 是一个 n 位的0<br>1 是一个 n 位的1<br>证明以下：<br>a. (A ⊕ B) ⊕ C &#x3D; A ⊕ (B ⊕ C)<br>b. A ⊕ A &#x3D; 0<br>c. A ⊕ 0 &#x3D; A<br>d. A ⊕ 1 &#x3D; bitwise complement of A &#x3D; A’<br>e. (A ⊕ B)’ &#x3D; A’ ⊕ B &#x3D; A ⊕ B’<br>f. A’ ⊕ B’ &#x3D; A ⊕ B</p>
<img src="/post/fit5163-sec-notes/image-20211116204447836.png" class="" title="image-20211116204447836">
<p>f. 我们还需要等式 A ⊕ B &#x3D; A’ ⊕ B’，这很容易看出为真。（意思就是和e差不多</p>
<p>如果满足以下条件，密文的值是多少：<br>明文：1010101010100<br>密钥流：1100110001001</p>
<p>Ans :Ciphertext &#x3D; Plaintext XOR keystream &#x3D; 0110011011101 （XOR操作是根据图的定义得到的</p>
<p>在ECB模式下，如果传输的密文块中有错误，则只影响对应的明文块。 但是，在 CBC 模式下，此错误会传播。 例如，传输的 <strong>C1 中的错误</strong>（下面的图 6.4）显然会损坏 P1。<br>a. P2 以外的任何块是否受到影响？<br>b. 假设P1的源版本有一点错误。 这个错误通过多少密文块传播？ 接收端的作用是什么？<br>c. 是否可以在 CBC 模式下对多个明文块并行执行加密操作？ 解密呢？<br>d. 假设在使用 CBC 传输的密文块中存在错误，参考下图。 对恢复的明文块产生什么影响？</p>
<p>答：<br>a. 否。例如，假设 C1 已损坏。输出块 P3 仅取决于输入块 C2 和 C3。<br>b. P1 中的错误会影响 C1。但由于 C1 是 C2 计算的输入，因此 C2 受到影响。这种影响无限期地持续下去，因此所有密文块都会受到影响。然而，在接收端，解密算法恢复正确的明文块，除了错误的块。您可以通过写出解密方程来证明这一点。因此，该错误仅影响对应的解密明文块<br>c. 在 CBC 加密中，每个前向密码操作（第一个除外）的输入块取决于前一个前向密码操作的结果，因此前向密码操作不能并行执行。然而，在 CBC 解密中，逆密码函数的输入块（即密文块）是立即可用的，因此可以并行执行多个逆密码操作。<br>d. 如果在密文块 Ci 的传输中发生错误，则该错误会传播（propagates）到恢复的明文块 Pi 和 Pi+1</p>
<p>对于图 6.3、6.4 和 6.7 中分别显示的每种模式 ECB、CBC、CTR：<br>a. 如果传输的密文的块 C4 中存在错误，则确定哪些解密的明文块 Px 将被破坏。<br>b. 假设密文包含N个块，并且P3的源版本有一个位错误，通过多少个密文块来确定这个错误是如何传播的。</p>
<p>Ans：问题假设传输密文的块C4中存在错误。<br>ECB模式：该模式下，密文块Ci仅作为明文块Pi直接加密的输入。 因此，块 C4 中的传输错误只会破坏解密明文的块 P4。<br>CBC模式：在这种模式下，当获得明文块Pi和Pi+1时，密文块Ci作为XOR函数的输入。 因此，块 C4 中的传输错误将破坏解密明文的块 P4 和 P5，但不会传播到任何其他块。<br>CTR 模式：在这种模式下，密文块 Ci 以及加密计数器 ti 仅用作直接解密明文块 Pi 的输入。 因此，块 C4 中的传输错误只会破坏解密明文的块 P4。</p>
<p>是否可以在如图 6.6 所示的 OFB 模式下对多个明文块并行执行加密操作？ 解密呢？</p>
<p>Ans: OFB 模式下的加密和解密都可以并行操作。 要看到这一点，请注意在 OFB 中发生的链接只是对 IV 一遍又一遍地重新加密，每次重新加密都与一个明文块进行异或。 因此，如果 IV 已被加密 h 次，则可以并行处理 h 个密文块。 解密也一样</p>
<p>考虑具有以下属性的分组密码算法：<br>• 输入和输出块长度为 64 位，密钥大小为 56 位<br>• 给定一个密钥 K，密钥调度需要 2 微秒（2 x 10 -6 秒）<br>• 密钥调度生成所有子密钥（如果需要）后，加密单个 64 位块需要 0.5 微秒。<br>计算以下信息：<br>a. 加密 1MB（2^20 字节）数据所需的总时间（当然以微秒为单位）。</p>
<p>Ans：首先我们需要找到 1MByte 数据中 64 位块的数量为<br>1MB 中的位数 &#x3D; 2^20 字节 * 8 位&#x2F;字节 &#x3D; <strong>8,388,608</strong> &#x3D;2^23 位<br>数据块数 &#x3D; <strong>8,388,608</strong> &#x2F; 64 位 &#x3D; 131,072 个块 &#x3D; <strong>217</strong> 个 64 位块</p>
<p>现在只需认识到密钥 K 将仅为此加密安排一次，并且我们需要加密 131,072 个数据块。<br>时间 &#x3D; 2 微秒 + <strong>217</strong> * 0.5 微秒 &#x3D; 65,536 + 2 &#x3D; <strong>65,538 微秒</strong></p>
<p>b. 给定 2 个值 C 和 M，使得 C &#x3D; EK(M) 在未知密钥值 K 下，在单台计算机上破解密码需要多少年（最多）。</p>
<p>Ans : 第二部分寻求破解给定密文C和相关明文M所需的最多时间。为此，需要搜索整个密钥空间。 因为密钥是 56 位长，所以密钥空间是 2^56 &#x3D; 72,057,594,037,927,936<br>现在我们知道在找到正确的键之前需要尝试多少个键，我们必须认识到我们只需要测试单个数据块。 然后每次试验都需要密钥安排加上加密&#x2F;解密的时间（取决于您选择哪一个）。 因此，等式变为 (2^56 (2 微秒 + 0.5 微秒 )) * 0.000001 秒 ~&#x3D; 1.8x 1011 秒<br>将此值转换为年 ~&#x3D; 2,084,999 天 ~&#x3D;5712 年！！</p>
<h2 id="W4-数理-Number-Theory"><a href="#W4-数理-Number-Theory" class="headerlink" title="W4: 数理 Number Theory"></a>W4: 数理 Number Theory</h2><p>考点：IFP，group ring field的概念，费马和欧拉定理 𝝓(n)，CRT，原始根，DLP</p>
<h3 id="整数分解问题"><a href="#整数分解问题" class="headerlink" title="整数分解问题"></a>整数分解问题</h3><p>b|a 表示a可被b整除(abs(a)&gt;&#x3D;abs(b))。quotient为商。</p>
<p>质数是数理的中心，只被1和自身整除的数。非质且&gt;1的数称为composite合数。<br>factor a num分解一个数。factorisation质数分解。</p>
<p>给定一个大正整数n&#x3D;p·q，找到也都是大正整数且为质数的p和q。</p>
<h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><p>GCD(a,b)表示同时能将a，b整除的最大整数。&#x3D;1表示ab互质。</p>
<p>Euclidean Algorithm（欧几里得算法，辗转相除法）<br>就是质数分解之后挑出共有的部分。</p>
<h3 id="群，环，域的概念"><a href="#群，环，域的概念" class="headerlink" title="群，环，域的概念"></a>群，环，域的概念</h3><img src="/post/fit5163-sec-notes/image-20210905161547567.png" class="" title="image-20210905161547567">

<h4 id="群"><a href="#群" class="headerlink" title="群"></a>群</h4><p>具有二元运算·的一组元素 G 将 G 中的每个有序元素对 (a,b) 与 G 中的元素 (a·b) 相关联，从而遵守以下公理</p>
<ul>
<li>(A1) Closure 闭包：<blockquote>
<p>如果 a 和 b 属于 G，则 a·b 也属于 G</p>
</blockquote>
</li>
<li>(A2) Associative 相关：<blockquote>
<p>a·(b·c) &#x3D; (a·b)·c 对于 G 中的所有 a, b, c</p>
</blockquote>
</li>
<li>(A3) Identity element 单位元：<blockquote>
<p>G 中有一个元素 e 使得 a·e &#x3D; e·a &#x3D; a 对于 G 中的所有 a</p>
</blockquote>
</li>
<li>(A4) Inverse element 逆元素：<blockquote>
<p>对于 G 中的每个 a，在 G 中有一个元素 a’ 使得 aa’ &#x3D; a’  a &#x3D; e</p>
</blockquote>
</li>
<li>[Abelian Group] (A5) Commutative 交换律：<blockquote>
<p>a·b &#x3D; b·a 对于所有 a, b 在 G</p>
</blockquote>
</li>
</ul>
<p>(ℤ, +) 是群吗？<br>– (A1) 两个整数之和得到一个整数，即𝑎 + 𝑏 ∈ ℤ 对于任何𝑎，𝑏 ∈ ℤ<br>– (A2) a + (𝑏 + 𝑐) &#x3D; (𝑎 + 𝑏) + 𝑐 对于任何整数𝑎, 𝑏, 𝑐 ∈ℤ<br>– (A3) 0 是关于加法的单位元素<br>– (A4) 对于任何整数 𝑎 ∈ ℤ，−𝑎 是 𝑎 的逆<br>其也为Abelian，因为 𝑎 + 𝑏 &#x3D; 𝑏 + 𝑎 对于任何整数𝑎，𝑏 ∈ ℤ</p>
<h4 id="Rings-环"><a href="#Rings-环" class="headerlink" title="Rings 环"></a>Rings 环</h4><p>有时用 {R , + , × } 表示的环 R 是一组元素，有两个二元运算，称为加法addition 和乘法multiplication，这样对于 R 中的所有 a ， b ， c 都遵守以下公理：</p>
<ul>
<li><p>[A1-A5]</p>
</li>
<li><p>(M1) Closure under multiplication 乘法闭包：如果 a 和 b 属于 R ，则 ab 也在 R 中</p>
</li>
<li><p>(M2) 乘法的结合性：对于 R 中的所有 a  b  c,  a(bc) &#x3D; (ab)c </p>
</li>
<li><p>分配法：对于 R 中的所有 a , b , c</p>
<ul>
<li>a (b + c) &#x3D; ab + ac </li>
<li>(a + b) c &#x3D; ac + bc</li>
</ul>
</li>
</ul>
<p>本质上，环是一个集合，我们可以在其中进行加减 [a - b&#x3D;a + (-b )] 和乘法而不离开该集合</p>
<p>Commutative Ring 可交换环: </p>
<p>• 如果环满足以下附加条件，则称其为可交换环：<br>▪ (M4) 乘法的交换性：对于R内所有a b, ab &#x3D; ba</p>
<p> Integral Domain 积分域</p>
<p>积分域是遵循以下公理的交换环。<br>▪ (M5) 乘法恒等式：对于 R 中的所有 a, R 中有一个元素 e’ 使得 a e’ &#x3D; e’a &#x3D; a<br>▪ (M6) 无零除数：如果 a , b 在 R 中且 ab &#x3D; 0，则 a &#x3D; 0 或 b &#x3D; 0</p>
<h4 id="Field-域"><a href="#Field-域" class="headerlink" title="Field 域"></a>Field 域</h4><p>域 F 有时用 {F, +,×} 表示，是一组具有两个二元运算（称为加法和乘法）的元素，因此对于 F 中的所有 a、b、c，都遵循以下公理：</p>
<ul>
<li>[A1-M6]</li>
<li>(M7) 乘法逆：对于 F 中的每个 a，除了 0，在 F 中存在一个元素 $a^{-1}$ 使得  $aa^{-1}&#x3D;a^{-1}a&#x3D;1$</li>
</ul>
<p>• 本质上，域是一个集合，我们可以在不离开集合的情况下进行加、减、乘、除运算。 除法定义如下： $a&#x2F;b &#x3D; ab^{-1}$</p>
<h4 id="Modular-Arithmetic-算术取模"><a href="#Modular-Arithmetic-算术取模" class="headerlink" title="Modular Arithmetic 算术取模"></a>Modular Arithmetic 算术取模</h4><p>如果a是整数，n是正整数，我们定义模算子“a mod n”为a除以n的余数； 整数 n 称为模数<br>如果 (a mod n) &#x3D; (b mod n) ，则两个整数 a 和 b 被称为congruent modulo n （模 n 全等）；等价于 a ≡ b(mod n)<br>b 被称为 a mod n 的余数<br>– a &#x3D; qn + b<br>– 通常选择最小的正余数作为余数<br>– 过程被称为modulo reduction 模归约</p>
<p>(𝒎𝒐𝒅 𝒏) 运算符将所有整数映射到整数集：{0, 1, … , 𝑛 − 1}<br>• 我们将ℤ𝑛 &#x3D; {0, 1, … , 𝑛 − 1} 定义为残差集<br>• ℤ𝑛 形成一个交换环</p>
<p>注意一些特殊性<br>• 如果 (𝒂 + 𝒃) ≡ (𝒂 + 𝒄) 𝒎𝒐𝒅 𝒏 那么𝒃 ≡ 𝒄 (𝒎𝒐𝒅 𝒏)<br>• 但是如果 (𝒂 × 𝒃) ≡ (𝒂 × 𝒄) (𝒎𝒐𝒅 𝒏) 那么 𝒃 ≡ 𝒄 (𝒎𝒐𝒅 𝒏) 仅当𝒂 相对质数于𝒏</p>
<img src="/post/fit5163-sec-notes/image-20210905162222378.png" class="" title="image-20210905162222378">

<p>Mod 8 Addition</p>
<img src="/post/fit5163-sec-notes/image-20210905162536045.png" class="" title="image-20210905162536045">

<p>Mod 8 Multiplication</p>
<img src="/post/fit5163-sec-notes/image-20210905162552183.png" class="" title="image-20210905162552183">



<h4 id="Finite有限-x2F-Galois域"><a href="#Finite有限-x2F-Galois域" class="headerlink" title="Finite有限&#x2F;Galois域"></a>Finite有限&#x2F;Galois域</h4><p>有限域在密码学中发挥关键作用<br>有限域中的<strong>元素数</strong>必须是<strong>素数的幂</strong> $p^n$ (n 为正整数)<br>也被称为“Galois”域，以纪念首先研究有限域的数学家<br>• 记为 $GF(p^n)$<br>• 特别是，我们经常使用以下域：<br>– $GF(p)$ [本课程最常用的]<br>– $GF(2n)$</p>
<p>GF(p) 是整数 {0,1, … , p-1} 的集合，其具有以 p 为模的算术运算，</p>
<p>因为有乘法逆（Zp 中的所有整数都与 p 互质），这些形成一个有限域<br>因此算术“表现良好”，可以在不离开域 GF(p) 的情况下进行加法、减法、乘法和除法（除了被零除，这是未定义的）</p>
<p>GF(7) Multiplication</p>
<img src="/post/fit5163-sec-notes/image-20210905163049159.png" class="" title="image-20210905163049159">

<p>Modular Exponentiation 模幂运算</p>
<p>假设我们要计算 $a^x \mod n$的大值𝒙<br>• 选项 1：计算 𝒂 ⋅ 𝒂 ⋯ 𝒂 然后 mod n: 非常低效，需要 𝑥 步操作<br>• 选项2：使用<strong>平方乘法算法</strong>！非常高效，只需要 $log_2{x}$ 操作</p>
<p>平方乘法算法</p>
<ol>
<li>找出最接近 𝒙 的 2 的幂，用 𝒓 表示（不应超过𝑥）</li>
<li>计算重复平方模 𝒏 到 $a^r$</li>
<li>将$a^x\ mod\ n$ 相关幂相乘</li>
</ol>
<img src="/post/fit5163-sec-notes/image-20210905163551848.png" class="" title="image-20210905163551848">

<h3 id="Fermat’s-and-Euler’s-Theorems-费马和欧拉定理-𝝓-n"><a href="#Fermat’s-and-Euler’s-Theorems-费马和欧拉定理-𝝓-n" class="headerlink" title="Fermat’s and Euler’s Theorems 费马和欧拉定理 𝝓(n)"></a>Fermat’s and Euler’s Theorems 费马和欧拉定理 𝝓(n)</h3><p>费马小定理<br>• $a^{p-1} ≡ 1 \pmod p$<br>– 其中 p 是素数<br>– a 是一个正整数并且<br>– gcd(a,p)&#x3D;1<br>另一种形式是： $a^p ≡ a \pmod p$<br>在公钥密码学中扮演重要角色</p>
<p>欧拉的 Totient 函数 𝝓(𝒏)<br>• 做算术取模时 𝑛<br>• 余数的完整集合是：{0,1, … , 𝑛-1}<br>• 减少的余数集是那些与 𝑛 相对质数的数字（余数）<br>– 例如，对于 n&#x3D;10，<br>– 完整的余数集是 {0,1,2,3,4,5,6,7,8,9}<br>– 削减余数集是 {1,3,7,9}<br>• 削减余数集合中的元素数量 称为欧拉 Totient 函数 𝝓(𝑛)</p>
<img src="/post/fit5163-sec-notes/image-20210905164150831.png" class="" title="image-20210905164150831">

<p>要计算 𝝓(𝑛) 需要计算要排除的余数数量</p>
<p>一般需要质因数分解，但<br>– 对于 𝑝 (𝑝 质数) ：𝝓(𝑝) &#x3D; 𝑝 − 1<br>– 对于 𝑝𝑞 (𝑝 和 𝑞 为质数) ：𝝓(𝑝𝑞) &#x3D; (𝑝 − 1)(𝑞 − 1)<br>例如<br>𝝓(37) &#x3D; 36<br>𝝓(21) &#x3D; 𝝓(3 × 7) &#x3D; (3– 1) × (7– 1) &#x3D; 2 × 6 &#x3D; 12</p>
<p>欧拉定理<br>• 费马小定理的推广<br>• $a^{𝝓(n)} &#x3D; 1 (mod\ n)$ 对于任何 a,n，其中 gcd(a,n)&#x3D;1<br>例如<br>a&#x3D;3；n&#x3D;10； 𝝓(10)&#x3D;4；因此 $3^4$ &#x3D; 81 &#x3D; 1 mod 10<br>a&#x3D;2；n&#x3D;11； 𝝓(11)&#x3D;10；因此 $2^{10}$ &#x3D; 1024 &#x3D; 1 mod 11</p>
<p><strong>使用欧拉定理求乘法逆</strong>: $a^{-1} &#x3D; a^{𝝓(n)-1} mod\ n$</p>
<p>中国余数定理 (CRT)</p>
<p>如果 𝑛1, … , 𝑛𝑘 是成对互质，并且如果 𝑎1,…, 𝑎𝑘 是任何整数，则系统：</p>
<p>$x ≡ a_1 (mod\ n_1)$ </p>
<p>…</p>
<p>$x ≡ a_k (mod\ n_k)$</p>
<p>有一个或多个解决方案。</p>
<p>解决方案：</p>
<ol>
<li>得到 $N &#x3D; n_1 * ⋯ * n_k$</li>
<li>得到 $N_i &#x3D; \frac{N}{n_i}$</li>
<li>得到 $Y_i$，其中 $ Y_i * N_i ≡ 1\ mod\ n_i$<br> 然后$x ≡ a_1 * N_1 ∗ Y_1 + … +  a_n * N_n ∗ Y_n\ mod\ N$</li>
</ol>
<img src="/post/fit5163-sec-notes/image-20210905165722021.png" class="" title="image-20210905165722021">

<h3 id="Primitive-Roots-原始根"><a href="#Primitive-Roots-原始根" class="headerlink" title="Primitive Roots 原始根"></a>Primitive Roots 原始根</h3><p>原始根<br>• 从欧拉定理有一个 𝝓(n)mod n&#x3D;1<br>• 考虑一个 m&#x3D;1 (mod n), GCD(a,n)&#x3D;1<br>– 存在于 m &#x3D; 𝝓(n) 但可能更小<br>– 一旦幂达到 m，循环将重复<br>• 如果最小的是 m &#x3D; 𝝓(n) 则 a 称为原始根<br>• 如果 n 是素数，则原始根的连续幂“生成”所有余数 mod n<br>• 这些很有用，但相对难以找到</p>
<h3 id="离散对数问题-DLP"><a href="#离散对数问题-DLP" class="headerlink" title="离散对数问题 (DLP)"></a>离散对数问题 (DLP)</h3><p>• 另一个核心密码问题</p>
<p>令𝑮 &#x3D;&lt; 𝒂 &gt; 是一个cyclic group循环群</p>
<p><strong>DLP</strong>：给定𝒂 和随机𝒃 ∈ 𝑮，找到𝒙 使得</p>
<p>$a^x &#x3D; b$</p>
<p>由于𝒂 生成𝑮，我们知道一定有这样一个𝒙</p>
<p>在实践中我们要求群的order是大的, 即，$|𝐺| &gt; 2^{128}$</p>
<p>Miller-Rabin Algorithm</p>
<p>通常用于测试大量数字是否为质数<br>算法是：TEST (n)</p>
<ol>
<li>求整数 k,q,k&gt;0，q为奇数，使得$(n-1)&#x3D;2^kq$</li>
<li>选择一个随机整数a, 1&lt;a&lt;n-1 ;</li>
<li>if $a^q\ mod\ n &#x3D; 1$ then return (“无结果”)；</li>
<li>当 j &#x3D; 0 做 k – 1 </li>
<li>if $(a^{2jq}\ mod\ n &#x3D; n – 1)$ then return (“无结果”) ;</li>
<li>返回（“复合数”）</li>
</ol>
<img src="/post/fit5163-sec-notes/image-20210905170859083.png" class="" title="image-20210905170859083">

<h3 id="Tut-1"><a href="#Tut-1" class="headerlink" title="Tut:"></a>Tut:</h3><p>这周是硬核数学题，gcd，质数分解，找余数规律 略</p>
<p>使用以下数字证明费马定理 $a^p &#x3D; a \mod p$：<br>(a) p&#x3D;5, a&#x3D;3<br>$a^p &#x3D; 3^5 &#x3D; [(3^2 mod 5) × (3^3 mod 5)] mod 5 &#x3D; [(9 mod 5) × (27 mod 5)] mod 5 &#x3D; [(4 mod 5) × (2 mod 5)] mod 5 &#x3D; 8 mod 5 ≡ 3 mod 5 &#x3D; a mod p$<br>(b) p&#x3D;5, a&#x3D;4<br>$a^p &#x3D; 4^5 &#x3D; [(4^2 \mod 5) × (4^2 \mod 5) × (4 \mod 5)] \mod 5 &#x3D; (1 × 1 × 4) mod 5 &#x3D; 4 mod 5$</p>
<p>使用费马定理，求出 $3^{201} \mod 11$。<br>费马定理指出，如果 p 是素数并且 a 是一个不能被 p 整除的正整数，那么<br>$a^{p−1} \mod p ≡ 1$。因此 $3^{10} \mod 11 ≡ 1$。<br>因此 $3^{201} &#x3D; (3^{10})^{20} × 3 \mod 11 &#x3D; 1 × 3 \mod 11 &#x3D; 3$</p>
<p>GF(5)的加法模，乘法模，加法和乘法求逆模</p>
<img src="/post/fit5163-sec-notes/image-20211116214955084.png" class="" title="image-20211116214955084">

<p>加法逆模 $ -w + w \mod p &#x3D; 0$</p>
<p>乘法逆模 表示 $w^{-1} \times w \mod p &#x3D; 1$且$w^{-1}$也在GF(p)上即$\in {0,…,p}$ 如这里2*3 mod 5 &#x3D; 1</p>
<p>以多项式形式表示以下十六进制数字：<br>(a) 1B<br>1B 二进制：00011011<br>所以多项式是 x4 + x3 + x + 1<br>(b) A9<br>二进制 A9：10101001<br>所以多项式是 x7 + x5 + x3 + 1<br>(c) C2<br>二进制 C2：11000010<br>所以多项式是 x7 + x6 + x<br>(四) 95<br>9C 二进制：10010101<br>所以多项式是 x7 + x4 + x2 + 1</p>
<p>反过来多项式转hex略</p>
<h2 id="W5-amp-W6-非对称加密-Asymmetric-Cryptography"><a href="#W5-amp-W6-非对称加密-Asymmetric-Cryptography" class="headerlink" title="W5&amp;W6: 非对称加密 Asymmetric Cryptography"></a>W5&amp;W6: 非对称加密 Asymmetric Cryptography</h2><p>副标题是New era of secure communications(加密传输的新纪元)</p>
<p>DSA&amp;ECDSA: 喊我呢？<br>（其实并没有出现，这俩主要用于数字签名，然而课程专注于的是加密所以是RSA</p>
<p>考点：为啥要公钥？，RSA，高效操作，RSA安全，混合系统；公钥分发，DH 密钥交换协议 和Advanced asymmetric cryptosystem（IBE，ABE），Hash</p>
<p>私有&#x2F;对称密钥密码的问题</p>
<p>• 要使用私钥密码（例如 DES&#x2F;AES）进行安全通信，首先必须在发送方和接收方之间共享密钥。问题：如果他们以前从未见过面怎么办？<br>• 如果爱丽丝希望与 100 个不同的人进行保密通信，她需要保留 100 个不同的密钥（一般而言，𝑛 不同的密钥与 𝑛 不同的各方进行安全通信<br>• 如果任何密钥被泄露，通信就会受到损害<br>• 不保护 Alice（发件人）免遭 Marvin（攻击者）伪造消息并声称是 Alice（发件人）发送的</p>
<h3 id="公钥密码系统原理"><a href="#公钥密码系统原理" class="headerlink" title="公钥密码系统原理"></a>公钥密码系统原理</h3><p>公钥密码学的概念源于试图解决与对称加密相关的两个最困难的问题：</p>
<ul>
<li>Key distribution 密钥分发</li>
<li>Digital signatures 数字签名</li>
</ul>
<p>公钥&#x2F;双密钥&#x2F;非对称密码术涉及使用两个密钥（一个密钥对）：</p>
<ul>
<li>任何人都可能知道的<strong>公钥</strong>，可用于加密消息和验证签名</li>
<li><strong>私钥</strong>，仅由所有者拥有，用于解密消息和签署（创建）消息（签名）</li>
<li>但是，不是两个独立的Key！</li>
</ul>
<p>不对称，是因为各方不平等，因为 加密消息 或 验证签名 的人不能分别 解密消息 或 创建签名</p>
<p>理想的功能</p>
<p>• 攻击者无法从公钥中找出私钥（秘密）。<br>• Alice 和 Bob 无需事先分发共享密钥！<br>• 每个用户只需要一对公钥和私钥！( Alice 可以用一对钥匙与 100+ 人交流！！</p>
<p>公钥要求(必须满足的条件：</p>
<ul>
<li>一方生成密钥对（公钥$PU_b$，私钥$PR_b$）在计算上很容易</li>
<li>发送者 A 知道公钥和要加密的消息，在计算上很容易生成相应的密文，C &#x3D; E($PU_b$, M)</li>
<li>接收者 B 使用私钥解密生成的密文以恢复原始消息在计算上很容易，D[$PR_b$, E($PU_b$, M)] &#x3D; M</li>
<li>对于知道公钥 $PU_b$的对手来说，确定私钥 $PR_b$ 在计算上是<strong>不可行的</strong></li>
<li>对于知道公钥和密文的对手来说，恢复原始消息 M 在计算上是<strong>不可行的</strong></li>
</ul>
<p>公钥密码系统的应用</p>
<p>• 公钥密码系统可用于：</p>
<ul>
<li>Encryption&#x2F;decryption: </li>
<li>Digital signature: 发件人用他的私钥“签署”一条消息</li>
<li>Key exchange: 双方合作交换会话密钥</li>
</ul>
<p>• 一些算法适用于所有 3 种应用程序，而其他算法只能用于一两个应用程序</p>
<img src="/post/fit5163-sec-notes/image-20210905200105145.png" class="" title="image-20210905200105145">



<p>单向函数</p>
<p>单向函数是将一个域映射到一个范围，使得每个函数值都有一个唯一的逆函数，条件是函数的计算很容易，而逆函数的计算是不可行的<br>$Y &#x3D; f(X)$ 容易； $X &#x3D; f^{–1}(Y)$ 不可行（实践中很难）</p>
<p>trap-door（活板门）单向函数是一系列可逆函数 fk，使得<br>− $Y &#x3D; fk(X)$ 容易，如果 k 和 X 已知<br>− $X &#x3D; fk^{–1}(Y)$ 容易，如果 k 和 Y 已知<br>− $X &#x3D; fk^{–1}(Y)$ 不可行，如果 Y 已知，但 k 未知</p>
<p>实用的公钥方案取决于合适的trap-door单向函数</p>
<p>如何构建公钥密码系统？</p>
<p>今天的公钥系统依赖于两个基本的数论假设（问题）：</p>
<ul>
<li><strong>整数分解问题（IFP）</strong>示例：<strong>RSA</strong> </li>
<li><strong>离散对数问题 (DLP)</strong>  示例：<strong>Diffie-Hellman (DH) 密钥交换</strong>，ElGamal 加密</li>
</ul>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>它是一种密码，其中明文和密文是 0 到 n – 1 之间的整数，其中某些 n<br>− n 的典型大小为 2048 位（今天，必须至少使用 2048 位才能获得可靠的安全性<br>• n 称为 RSA 模数</p>
<p>• RSA 使用带指数的表达式<br>• 明文以块为单位加密，每个块的二进制值小于某个数 n<br>• 加密和解密的形式如下，对于一些明文块 M 和密文块 C<br>$C &#x3D; M^e \mod n$<br>$M &#x3D; C^d \mod n &#x3D; (M^e)^d \mod n &#x3D; M^{ed} \mod n$<br>• 发送方和接收方都必须知道 n 的值<br>• 发送者知道 e 的值，只有接收者知道 d 的值<br>• 这是一种公钥加密算法，公钥为PU&#x3D;{e,n}，私钥为PR&#x3D;{d}</p>
<h4 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a><strong>Key Generation</strong></h4><p>选择 p, q p 和 q 都是素数，p ≠ q</p>
<p>计算 $n &#x3D; p \times q$</p>
<p>计算 $𝝓(n) &#x3D; (p – 1)(q – 1)$</p>
<p>选择整数 e:  $gcd(𝝓(n), e) &#x3D; 1; 1 &lt; e &lt; 𝝓(n)$</p>
<p>计算 d: $d ≡ e^{-1}\pmod{𝝓(n)}$ </p>
<p>简单来说就是(e * d) mod n &#x3D;1,倒推一个d （e 和 d 的值很大，否则很容易受到蛮力攻击和其他形式的密码分析</p>
<p>公钥 PU &#x3D; {e, n}</p>
<p>私钥 PR &#x3D; {d}</p>
<h4 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a><strong>Encryption</strong></h4><p>明文：M &lt; n (消息 m 必须是范围 [1, n] 之间的整数，可以通过将明文分割成小于n的块来实现</p>
<p>密文：$C &#x3D; M^e \mod n$</p>
<h4 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h4><p>密文：C</p>
<p>明文：$M &#x3D; C^d \mod n$</p>
<h4 id="证明-RSA-有效"><a href="#证明-RSA-有效" class="headerlink" title="证明 RSA 有效"></a>证明 RSA 有效</h4><p>欧拉定理：$a^{𝝓(n)} mod n &#x3D; 1$，其中 gcd(a,n)&#x3D;1<br>在 RSA 中有：<br>− $n&#x3D;p \times q$<br>− $𝝓(n)&#x3D;(p-1)(q-1)$<br>− $e \times d &#x3D;1 \mod 𝝓(n)$ → $e \times d&#x3D;1+k \times 𝝓(n)$对于某个整数 k<br>• 因此：$C^d &#x3D; (M^e)^d &#x3D; M^{ed} &#x3D; M^{1+k𝝓(n)} \&#x3D; M^1(M^{𝝓(n)})^k \mod n &#x3D; M^1*(1)^k \&#x3D; M^1 &#x3D; M \mod n$</p>
<p>为了加密长消息，我们可以使用混合密码系统</p>
<ol>
<li>使用非对称密码（如 RSA）就对称密钥达成一致<br>− 例如，一个用户生成一个随机对称密钥，用另一方的公钥对其进行加密并通过<br>− 或者双方运行密钥协商协议，例如 Diffie-Hellman 协议（下一讲）<br>2）使用对称密码（如AES）使用商定的对称密钥在其余部分进行加密<br>无需事先达成密钥协议！</li>
</ol>
<p>平方和乘法算法<br>• 加密和解密都涉及求幂<br>$c &#x3D; m^e (\mod n)$</p>
<p>$m &#x3D; c^d (\mod n)$<br>可以使用平方和乘法算法计算取幂</p>
<ol>
<li>将指数转换为二进制。</li>
<li>对第一个1，只需列出数字</li>
<li>对于每个随后的0，做<strong>平方</strong>运算</li>
<li>对于每个随后的1，做<strong>平方和乘法</strong>运算</li>
</ol>
<p> 示例：𝑵𝟑𝟕，仅 7 个步骤</p>
<img src="/post/fit5163-sec-notes/image-20210905204328085.png" class="" title="image-20210905204328085">

<p>使用公钥高效操作</p>
<p>• 为了加快使用公钥的 RSA 算法的操作，通常对 e 进行特定选择<br>• 最常见的选择是 65537 ($2^{16} + 1$)<br>• 另外两个流行的选择是 e&#x3D;3 和 e&#x3D;17<br>− 这些选择中的每一个都<strong>只有两位 1</strong>，因此执行幂运算所需的<strong>乘法次数被最小化</strong><br>− 使用非常小的公钥，例如 e &#x3D; 3，RSA 变得容易受到简单攻击<br>− 所以，e&#x3D;3（甚至 e&#x3D;17）不是一个安全的选择！</p>
<p>使用私钥高效操作<br>• 解密使用幂运算为 d 提供幂<br>− 较小的 d 值容易受到蛮力攻击和其他形式的密码分析<br>• 可以使用中国剩余定理 (CRT) 来加速解密计算<br>− 计算$d_p &#x3D; d \mod (p-1)$和$d_q &#x3D;d \mod (q-1)$<br>− 解密𝐶：计算 $M_p &#x3D; C^{d_p} \mod p$; 计算$M_q &#x3D; C^{d_q}\mod q$<br>由于</p>
<p>$M ≡M_p \mod p$</p>
<p>$M≡M_q \mod q$</p>
<p>我们可以通过 𝑀𝑝 &amp; 𝑀𝑞使用 CRT 来找到 𝑀 使得 $M&#x3D;C^d \mod n$ （比直接快~4 倍</p>
<p>if p&#x3D;5, q&#x3D;11, e&#x3D;3, d&#x3D;27, C&#x3D;52 -&gt; $M&#x3D;C^d \pmod n &#x3D; 52^{27} \mod 55$</p>
<p>快速计算M:</p>
<p>$d_p&#x3D;27 \mod (5-1)&#x3D; 3$ ;$d_q&#x3D; 27 \mod (11-1)&#x3D;7$</p>
<p>$M_p&#x3D;52^{3} \mod 5 &#x3D; 3$ ;$M_q&#x3D;52^{7} \mod 11&#x3D;2$ </p>
<p>得到</p>
<p>$M ≡ 3 \mod 5 $</p>
<p>$M ≡ 2 \mod 11 $</p>
<p>N&#x3D;pq&#x3D;55; </p>
<p>N_1&#x3D;N&#x2F;5&#x3D;11; </p>
<p>N_2&#x3D;55&#x2F;11&#x3D;5; </p>
<p>Y1*11 ≡ 1 mod 5; Y1&#x3D;(1+5*2)&#x2F;11&#x3D;1; </p>
<p>Y2*5 ≡ 1 mod 11;Y2&#x3D;(1+11*4)&#x2F;5&#x3D;9;</p>
<p>M ≡ (3*11*1 + 2*5*9) mod 55≡(101)mod 55&#x3D;13</p>
<p>M &#x3D; 13</p>
<h3 id="攻击RSA"><a href="#攻击RSA" class="headerlink" title="攻击RSA"></a>攻击RSA</h3><p>Brute force</p>
<p>Mathematical attacks: 有几种方法，都等价于对两个素数的乘积进行因式分解</p>
<p>Side-channel attacks, e.g., timing attacks: 这取决于解密算法的运行时间</p>
<p>Hardware fault-based attack: 这涉及在生成数字签名的处理器中引发硬件故障</p>
<p>Chosen ciphertext attacks: 这种类型的攻击利用了 RSA 算法的特性</p>
<p>整数分解问题<br>• RSA 的安全性严重依赖于整数因式分解问题<br>• 我们可以从数学上确定 3 种攻击 RSA 的方法：<br>− 将 n 分解为其两个质因数。 这可以计算 ø(n) &#x3D; (p – 1) x (q – 1)，进而确定 d &#x3D; e-1 (mod ø(n))<br>− 直接确定 ø(n) 而不先确定 p 和 q。 同样，这可以确定 d &#x3D; e-1(mod ø(n))<br>− 不先确定 ø(n) 直接确定 d</p>
<p>侧信道攻击：定时攻击<br>• 窥探者可以通过跟踪计算机解密消息所需的时间来确定私钥<br>• 利用算法运行时间的密钥依赖性<br>• 示例：平方和乘法算法</p>
<ol>
<li>将指数转换为二进制。</li>
</ol>
<p>2.对于前1，只需列出数字<br>3.对于每个随后的0，做平方运算<br>4. 对于每个随后的 1，做平方和乘法运算<br>• 该攻击不仅适用于 RSA，还适用于其他密码系统</p>
<p>时序攻击对策<br>常数取幂时间<br>• 确保所有求幂在返回结果之前花费相同的时间； 这是一个简单的修复，但确实会降低性能<br>随机延迟<br>• 通过向取幂算法添加随机延迟以混淆时序攻击，可以获得更好的性能</p>
<p>基于故障的攻击<br>• 对生成 RSA 数字签名的处理器的攻击<br>− 通过降低处理器的功率来导致签名计算中的错误<br>− 故障导致软件产生无效签名，然后攻击者可以分析这些签名以恢复私钥<br>• 攻击算法涉及引入单位错误并观察结果<br>• 攻击者需要物理访问目标机器和直接控制处理器输入功率的能力</p>
<p>选择密文攻击 (CCA)<br>• CCA：对手 Eve 选择一些密文，然后给出相应的明文，用目标的私钥解密<br>− 假设目标消息是 t，Eve 只知道它的密文 𝐶,𝑤ℎ𝑒𝑟𝑒𝐶 &#x3D;𝑡𝑒 mod n<br>− Eve 可以选择 2 作为明文，得到 𝐶𝑎 &#x3D;2𝑒𝑚𝑜𝑑𝑛，求 𝐶𝑏 &#x3D;𝐶∗𝐶𝑎 &#x3D; 2∗𝑡 𝑒𝑚𝑜𝑛的明文<br>− 给定 𝑚&#x3D;2∗𝑡，t&#x3D;m&#x2F;2<br>• 为应对此类攻击，RSA Security Inc. 建议使用称为最佳非对称加密填充 (OAEP) 的程序修改明文</p>
<p>私钥密码<br>• 优势:  </p>
<ul>
<li>使用成本低; </li>
<li>快; </li>
<li>提供低成本硬件芯片</li>
</ul>
<p>• 弱点</p>
<ul>
<li>密钥分发是个问题</li>
<li>安全所需的密钥数量</li>
<li>一对用户之间安全通信所需的密钥数量与用户数量成正比</li>
</ul>
<p>公钥密码<br>• 优势</p>
<ul>
<li>密钥分发不是问题</li>
<li>与 n 个用户通信只需要 2 个密钥</li>
</ul>
<p>• 弱点</p>
<ul>
<li>使用相对昂贵</li>
<li>相对较慢</li>
<li>硬件芯片不可用或成本相对较高</li>
</ul>
<h3 id="Key-management"><a href="#Key-management" class="headerlink" title="Key management"></a>Key management</h3><p>Key</p>
<p>• 用于一对方（人员、系统等）之间对称加密的单个密钥<br>• 一对密钥（公共和私人）用于您和任何其他人（人、系统）之间的非对称加密。<br>• 公钥加密有助于解决对称加密的密钥分发问题<br>– 使用公钥密码术来分发秘密密钥<br>– 公钥的分发</p>
<h4 id="Distribution-of-public-keys-公钥分发"><a href="#Distribution-of-public-keys-公钥分发" class="headerlink" title="Distribution of public keys 公钥分发"></a>Distribution of public keys 公钥分发</h4><p>公钥分发<br>• 公告<br>• 公开目录<br>• 公钥授权和证书</p>
<h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>用户将公钥分发给收件人或向整个社区广播<br>– 例如 将密钥附加到电子邮件或发布到新闻组或电子邮件列表</p>
<p>主要<strong>弱点</strong>是伪造&#x2F;制造（伪装、冒充）攻击<br>– 任何人都可以创建一个声称是其他人的密钥并广播它<br>– 在发现伪造之前，他们可以伪装成声称的用户</p>
<p>为了防止攻击：<br>– 在 Bob 为 Alice 加密消息之前，他必须确保他拥有 Alice 的正确公钥（而不是伪造的）。<br>– Bob 需要一种方法来测试任何将 Alice 的公钥通知给 Bob 的“Alice 的密钥消息”的真实性。<br>– 除了 Alice 之外，没有人应该能够产生这样的消息，以便它通过 Bob 的测试。</p>
<p>用于实现公钥完整性的一种加密工具是“证书颁发机构”（Certificate Authorities，CA）</p>
<h5 id="公开目录"><a href="#公开目录" class="headerlink" title="公开目录"></a>公开目录</h5><p>• 可以通过向公共目录注册密钥来获得更高的安全性<br>• 目录必须具有以下属性信任：<br>– 包含 {name, public-key} 条目<br>– 参与者通过目录安全注册<br>– 参与者可以随时更换钥匙<br>– 目录定期发布<br>– 可以电子方式访问目录<br>• 公共目录的维护和分发必须由某个受信任的实体或组织负责<br>• 仍然容易被篡改或伪造</p>
<h5 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h5><p>• 证书允许在不实时访问公钥授权的情况下交换密钥<br>• 证书将身份与公钥绑定，证明公钥的所有权（通常带有其他信息，例如有效期、使用权等<br>• 所有内容均由受信任的公钥或证书颁发机构 (CA) 签名<br>• 任何知道证书颁发机构 (CA) 公钥的人都可以验证<br>• 大多数网络安全应用程序中使用的 X.509 证书</p>
<p>信任链：实际中存在多个Root CA。如果你信任一个Root CA，那么你就会信任它生成的证书</p>
<h4 id="Diffie-Hellman-key-exchange-DH-密钥交换"><a href="#Diffie-Hellman-key-exchange-DH-密钥交换" class="headerlink" title="Diffie-Hellman key exchange (DH) 密钥交换"></a>Diffie-Hellman key exchange (DH) 密钥交换</h4><p>回忆前面提到的混合系统<br>– 公钥算法很慢<br>– 我们通常使用对称加密来保护消息内容<br>– 使用公钥算法共享对称密钥</p>
<p>协商合适的<strong>会话密钥</strong>的替代方法：<strong>Diffie-Hellman (DH) 密钥交换</strong><br>– 密钥协商方案可以建立一个只有参与者知道的公共密钥<br>– 依赖于<strong>离散对数问题 (DLP)</strong></p>
<p>离散对数问题 (DLP)<br>• 令𝑮是一个带有生成元𝒈的循环群： 𝐺 &#x3D;&lt;𝑔&gt;<br>• DLP：给定𝒈、𝑮和一些𝒉∈𝑮，很难找到𝒙使得𝒈𝒙 &#x3D;𝒉。<br>– 一定有这样的𝒙，因为𝐺中的每一个元素都可以写成𝑔的幂</p>
<p>• 可以在任何组中定义 DLP<br>• 两种著名方案：</p>
<ol>
<li>在 ℤ𝑛 中（更准确地说，是它的一个循环子群）<br>-&gt; 由于安全要求需要大𝑛<br>-&gt; 较大的参数 → 效率较低</li>
<li>在“椭圆曲线”组中（不就是ECDH） -&gt; 更小的参数→更高效</li>
</ol>
<p>目前，我们将重点关注ℤ𝒏</p>
<p>所有用户都认可的全局参数：<br>– 大素数整数（或多项式）p<br>– g 是 p 的原始根</p>
<p>用户生成自己的密钥</p>
<ol>
<li>选择一个密钥（数字）：<br>-&gt; Alice:𝑎&lt;𝑝<br>-&gt; Bob：𝑏&lt;𝑝</li>
<li>计算并发布他们各自的<strong>公钥</strong>：<br>-&gt; Alice:$y_A &#x3D; g^a \mod p$<br>-&gt; Bob:$y_B &#x3D; g^b \mod p$</li>
<li>计算共享<strong>会话密钥 K</strong><br>-&gt; Alice: $K &#x3D; (y_B)^a &#x3D; g^{ab} \mod p$<br>-&gt; Bob: ：$K &#x3D; (y_A)^b &#x3D; g^{ab} \mod p$<br>K 在 Alice 和 Bob 之间的对称加密中用作会话密钥</li>
</ol>
<p>中间人攻击：<br>由于DH方案中Alice和Bob之间没有身份验证，攻击者可以伪装成Alice&#x2F;Bob来创建会话密钥并获取Alice和Bob之间的所有通信消息</p>
<h3 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h3><p>• 哈希函数 H 是一种单向函数，它接受消息 M 并产生固定大小（例如 256 位）的输出（称为消息摘要或哈希值或指纹）<br>– 很容易为任何消息 M 计算 h&#x3D;H(M)<br>• 单向性质：给定 h，找到 x 使得 H(x)&#x3D;h 在计算上是不可行的<br>• 抗碰撞性：找到任何一对 (x, y) 使得 H(y)&#x3D;H(x) 在计算上也不可行<br>• 确定性：相同的消息总是产生相同的散列</p>
<p>• 哈希函数仅将消息（不需要密钥）作为输入来生成消息摘要<br>– 任何人都可以计算任何值的哈希值！<br>• 如果输入仅相差 1 位，则输出将完全不同！<br>• 可视为确定性伪随机函数（生成随机数）<br>• 示例包括 MD5、SHA-1、SHA-256 等。</p>
<p>用途</p>
<ol>
<li><p>常用于创建单向密码文件</p>
<ul>
<li>当用户输入密码时，将该密码的哈希值与存储的哈希值进行比较以进行验证</li>
<li>大多数操作系统都使用这种密码保护方法</li>
</ul>
</li>
<li><p>可用于入侵和病毒检测</p>
<ul>
<li>为系统上的每个文件存储 H(F) 并保护散列值</li>
<li>稍后可以通过重新计算 H(F) 来确定文件是否已被修改</li>
<li>入侵者需要在不改变 H(F) 的情况下改变 F</li>
</ul>
</li>
<li><p>可用于构造伪随机函数 (PRF) 或伪随机数生成器 (PRNG)</p>
<ul>
<li>基于散列的 PRF 的一个常见应用是生成对称密钥</li>
</ul>
</li>
</ol>
<h4 id="要求和安全"><a href="#要求和安全" class="headerlink" title="要求和安全"></a>要求和安全</h4><p>原像(Preimage)<br>• x 是哈希值 h 的原像 h &#x3D; H(x) 是一个数据块，其哈希函数，使用函数 H，是 h<br>• 因为 H 是多对一映射，对于任何给定的哈希值 h，通常会有多个原像Preimage碰撞<br>• 在我们有 x ≠ y 且 H(x) &#x3D; H(y) 时发生<br>• 因为我们使用散列函数来保证数据完整性，所以冲突显然是不可取的</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><ul>
<li>Brute-Force Attacks</li>
<li>Cryptanalysis （MD5 and SHA-1 are  broken by cryptanalysis,）</li>
</ul>
<h4 id="Birthday-Attacks"><a href="#Birthday-Attacks" class="headerlink" title="Birthday Attacks"></a>Birthday Attacks</h4><p>• “如果有 23 人的房间，他们的生日完全随机，则该房间中的任何 2 个人有 50 到 50 次生日相同的机会”<br>• 生日悖论：如果你从一组𝑁元素中随机选择大约 𝑁元素，你很可能会选择相同的元素两次<br>• 生日攻击：对手希望找到两个产生相同哈希函数的消息或数据块<br>• 生日攻击的工作原理：</p>
<ul>
<li>随机生成一系列明文X1,X2…</li>
<li>对每个Xi计算hash测试是否存在相同</li>
<li>当碰撞就停</li>
</ul>
<h3 id="Advanced-asymmetric-cryptosystems"><a href="#Advanced-asymmetric-cryptosystems" class="headerlink" title="Advanced asymmetric cryptosystems"></a>Advanced asymmetric cryptosystems</h3><p>传统的公钥密码学需要一个基础设施（有CA的存在）来确保公钥的真实性<br>• 它还需要昂贵的通信和计算（获取证书 + 验证证书）<br>• 不需要这种昂贵过程的新密码系统——基于身份的加密 (IBE)</p>
<h4 id="Identity-Based-Encryption-IBE-基于身份的加密"><a href="#Identity-Based-Encryption-IBE-基于身份的加密" class="headerlink" title="Identity Based Encryption (IBE) 基于身份的加密"></a>Identity Based Encryption (IBE) 基于身份的加密</h4><p>• IBE，每个用户都由一个身份代表——可以是电子邮件地址、姓名、身份证号码等。<br>• 加密只需要收件人的身份（例如电子邮件地址）<br>• 私钥生成器 (PKG)，受信任的第 3 方，发布所有用户的私钥<br>• 不需要公钥或证书！</p>
<p>系统设置过程：PKG 生成自己的主密钥 (msk) 和主公钥 (mpk)<br>– msk 只有 PKG 知道<br>– mpk 作为公共参数发布</p>
<p>密钥生成过程：</p>
<ol>
<li>用户去PKG（带有一些带照片的ID或物理文件，其中包含用户的身份作为物理认证过程）</li>
<li>PKG 使用其 msk 为该用户生成与用户身份相关联的用户密钥。</li>
</ol>
<p>加密过程：</p>
<ol>
<li>发送方只需要知道接收方的身份（以及系统参数mpk）</li>
<li>发送者从(m, ID, mpk)生成密文，其中m为明文消息，ID为接收者身份，mpk为系统参数</li>
</ol>
<p>解密过程：</p>
<ol>
<li>接收者使用他&#x2F;她的用户密钥来解密密文</li>
</ol>
<p>安全性：<br>– 如果密文是为 <a href="mailto:&#97;&#108;&#105;&#x63;&#x65;&#x40;&#97;&#98;&#x63;&#x2e;&#x63;&#111;&#109;">&#97;&#108;&#105;&#x63;&#x65;&#x40;&#97;&#98;&#x63;&#x2e;&#x63;&#111;&#109;</a> 加密的，除了与 <a href="mailto:&#97;&#108;&#x69;&#x63;&#x65;&#x40;&#x61;&#x62;&#x63;&#46;&#99;&#111;&#109;">&#97;&#108;&#x69;&#x63;&#x65;&#x40;&#x61;&#x62;&#x63;&#46;&#99;&#111;&#109;</a> 关联的密钥的所有者之外，没有人可以解密此密文<br>– 这里不存在PKI（无证书）中的伪造攻击！ -&gt; Marvin 无法从 PKG 获取私钥</p>
<p>IBE 需要一个称为双线性配对的数学函数（基于椭圆曲线）<br>• 它是两组之间的单向映射函数：G 和 GT，使得 G 和 GT 中的离散对数很难<br>• 表示为一个映射<br>$e: G \times G →G_T$<br>它取 G 组中的两个元素并输出 $G_T$ 组中的一个元素</p>
<p>双线性配对<br>• 假设$g$是具有群序$p$的$G$生成器（即，$G$具有$p$个元素：$|G| &#x3D;p$）<br>• 我们有以下属性：<br>– Bilinear双线性：$e(g^x,g^y)&#x3D;e(g,g)^{xy}$, 对于$x \in Z_p &gt; e(g^x,g)&#x3D;e(g,g^x)&#x3D;e(g,g)^x$<br>– Non-degenerate 非退化：$e(g,g)\neq1$</p>
<p>第一个实用的 IBE 方案是由 Dan Boneh 和 Matthew K. Franklin 在 2001 年（我们称之为 Boneh-Franklin 计划）</p>
<p>设置：<br>– 双线性配对 $e: G \times G →G_T$ 群序为 p<br>– g 是 G 中的生成器<br>– PKG 选择$s \in Z_p$ 作为主密钥<br>– PKG 计算$K &#x3D; g^s$ 作为主公钥（mpk）<br>– 选择两个哈希函数：<br>-&gt; $H_1: { 0,1 }^∗ →G$<br>-&gt; $H_2: G_T → {0,1}^n$ 对于一些固定的 n<br>– 输出系统参数：{e, G, GT, K, H1, H2}</p>
<p>密钥生成：<br>为一个 $ID \in {0, 1}^*$，发布一个密钥PKG 计算：</p>
<ol>
<li>$Q_{ID} &#x3D;H_1(ID)$</li>
<li>用户密钥$d_{ID}&#x3D;(Q_{ID})^s $, 该密钥以𝐼𝐷身份提供给用户</li>
</ol>
<p>加密<br>给定一个消息$m \in {0, 1}^n$，以及一个身份$ID \in {0, 1}^*$​, 计算：</p>
<ol>
<li>$Q_{ID} &#x3D;H_1(ID)$</li>
<li>选择一个随机数$r \in _RZ_p$</li>
<li>计算$T_{ID} &#x3D; e(Q_{ID}, K)$, K 即 mpk</li>
<li>计算$c &#x3D; (g^r, m⊕H_2(T_{ID}^r)) &#x3D; (u, v)$</li>
</ol>
<p>解密<br>给定 $c &#x3D; (u,v)$, 可以使用与 𝐼𝐷 关联的密钥检索明文：<br>$m &#x3D; v⊕H_2(e(d_{ID}, u))$<br>• 由于$v&#x3D;m⊕H_2(T_{ID}^r)$ ，我们只需要验证是否$T_{ID}^r &#x3D; e(d_{ID}, u)$?<br>• 回忆：<br>– PKG 的公钥𝐾 &#x3D;𝑔𝑠<br>– Alice 的密钥 $d_{ID} &#x3D; Q_{ID}^s$<br>– 密文$u &#x3D; g^r$<br>– 𝑇𝐼𝐷 &#x3D;𝑒(𝑄𝐼𝐷,𝐾)<br>正确性：<br>$e(d_{ID}, u) &#x3D; e(Q_{ID}^s, g^r) \&#x3D;e(Q_{ID},g)^{sr} &#x3D; e(Q_{ID},g^s)^r \ &#x3D; T_{ID}^r$</p>
<p>IBE 消除了证书的使用, 然而，它仍然是一对一的加密<br>– 即，每个密文的目标是由单方解密<br>• 是否可以进行一对多加密？<br>– 广播加密<br>– 基于属性的加密 (ABE)</p>
<h4 id="Attribute-Based-Encryption-ABE-基于属性的加密"><a href="#Attribute-Based-Encryption-ABE-基于属性的加密" class="headerlink" title="Attribute Based Encryption (ABE) 基于属性的加密"></a>Attribute Based Encryption (ABE) 基于属性的加密</h4><p>• 1 个权限和具有不同属性的用户<br>• 属性可以是：<br>– {男，学生，计算机科学，莫纳什大学}<br>– {女性，会计师，ABC 公司}<br>– {日本人，1980-1989 年间出生，博士}<br>• 用户通过他&#x2F;她的属性来识别，而不是公钥或身份<br>• 用户根据他&#x2F;她的属性从权限获取密钥</p>
<p>• 用户是否可以根据他&#x2F;她的属性是否满足访问策略来解密密文，例如<br>– { 学生 AND 计算机科学 AND 莫纳什大学}</p>
<p>基于属性的加密 (ABE) 2 种类型：</p>
<ol>
<li>密钥策略 ABE (KP-ABE)<br>-&gt; 根据访问策略生成用户的密钥<br>-&gt; 数据使用一组属性加密</li>
<li>密文策略 ABE (CP-ABE)<br>-&gt; 用户的密钥是通过一组属性生成的<br>-&gt; 数据使用访问策略加密</li>
</ol>
<p>特性<br>• 一对多<br>• 公共参数、加密&#x2F;解密复杂度、密钥大小、密文大小都与用户（解密者）数量无关<br>• 加密者不需要知道解密者的身份（只需设置策略）<br>• 如果有很多用户（例如一家公司有 100 万员工），优势将非常显着</p>
<h3 id="Tut-2"><a href="#Tut-2" class="headerlink" title="Tut:"></a>Tut:</h3><p>在 RSA 密钥生成中，为什么我们需要 gcd(e,ø(n))&#x3D;1？<br>如果 gcd(e,ø(n)) 不等于 1，则不可能找到整数 d 使得 d.e &#x3D;1 mod φ(n)</p>
<p>使用 RSA 算法，其中：<br>p 和 q 是素数，n &#x3D; p q<br>φ(n) &#x3D; (p-1)(q-1) 而 ed mod φ(n) &#x3D; 1<br>密文 C &#x3D; Me mod n 和明文 M &#x3D; Cd mod n<br>(e,n) 和 (d,n) 分别是公钥和私钥<br>对以下内容进行加解密</p>
<p>(a) p&#x3D;3, q&#x3D;11, e &#x3D; 7, M &#x3D; 5<br>n &#x3D; p × q &#x3D; 33; e &#x3D; 7; M &#x3D; 5; φ(n) &#x3D; 2 × 10 &#x3D; 20; e × d mod 20 &#x3D; 1; hence d &#x3D; 3<br>Encryption:<br>C &#x3D; M^e mod n &#x3D; 5^7 mod 33 &#x3D; 14<br>Decryption<br>M &#x3D; C^d mod n &#x3D; 14^3 mod 33 &#x3D; 5 &#x3D; M</p>
<p>在使用 RSA 的公钥密码系统中，您截获发送给公钥为 e &#x3D; 5, n &#x3D; 35 的用户的密文 C &#x3D; 10。明文 M 是什么？</p>
<p>n &#x3D; 35 &#x3D; 7 × 5; φ(n) &#x3D; 6 × 4 &#x3D; 24<br>e × d mod 24&#x3D; 1; d &#x3D; 5<br>M &#x3D; C^d mod n &#x3D; 10^5 mod 35 &#x3D; 5 &#x3D; 5 mod 35</p>
<p>假设我们有一组用 RSA 算法编码的块，但我们没有私钥。假设 n &#x3D; p × q，e 是公钥。假设还有人告诉我们他们知道其中一个明文块与 n 有一个公因子。这对我们有任何帮助吗？</p>
<p>假设 M &#x3D; kp（即明文块 M 与 n 有一个公因子，这意味着它有 p 或 q 作为其因子之一，我们知道 M &lt; n 所以它不能同时是 p 和 q，我们假设它是 p 并且同样的论点也适用于 q)。<br>C &#x3D; Me mod n &#x3D; (kp)e mod pq &#x3D; kepe mod pq &#x3D; r<br>其中 r 是除法 kepe 的余数<br>r &#x3D; kepe − xpq 对于某些 x 作为商所以 r &#x3D; p(kepe−1 − xq) pq<br>所以余数有 p 作为它的因数之一，或者 r 是素数，在这种情况下它只能是 p 或者它是合数，在这种情况下，r 很可能有小素数，所以用小素数试除我们可以轻松分解 r 并获得 p（使用素性检验）并使用它分解 n 并获得 q 并使用 p 和 q 计算 φ(n) 然后 d<br>为了避免这种情况，我们可以为 M 选择合适的块大小，使得 M &lt; p 和 M &lt; q 并且由于 p 和 q 是素数，那么 GCD(M, p) &#x3D; 1 和 GCD(M, q) &#x3D; 1。例如，使用 1024 位 RSA 密钥，我们可以使用任何小于 512 位的块大小。</p>
<p>假设 Bob 使用具有非常大模数 n 的 RSA 密码系统，在合理的时间内无法找到因式分解。 假设 Alice 向 Bob 发送一条消息，将每个字母字符表示为 0 到 25 之间的整数（A ← 0, . . ., Z ← 25），然后使用具有大 e 和大 n 的 RSA 分别加密每个数字。 这种方法安全吗？ 如果不是，请描述针对此加密方法的最有效攻击</p>
<p>考虑一组字母字符{A, B, . . ., Z}。 对应的整数，代表每个字母字符在字母表中的位置，形成一组消息块值SM&#x3D;{0, 1,2, . . ., 25}。<br>对应的密文块值集合 SC &#x3D;{0^e mod n, 1^e mod n, . . ., 25^e mod n}，每个人都可以在知道 Bob 的公钥的情况下计算出来。 因此，针对问题中描述的方案最有效的攻击是计算 M 的所有可能值的 Me mod n，然后创建一个以密文作为索引的查找表，以及相应的明文作为适当的值 表中的位置。</p>
<p>CRT RSA：在RSA密码方案中，使用了三个n位数字，公共模数n、公钥e和私钥d。 设 n &#x3D; p ⋅ q 其中 p, q 是秘密素数。 还让 e ⋅ d &#x3D; 1 mod(p − 1)(q − 1)。<br>假设 m 是要加密的消息（明文），RSA 加密的结果（密文）是 c &#x3D; m𝑒 mod n，解密的结果是 m &#x3D; cd modN。 CRT 通常用于 RSA 解密，因为私钥 d 的位长必然很长。 在 CRT RSA 中，我们计算 S𝑝 &#x3D; cdp modp 和 𝑆𝑞 &#x3D; 𝑐𝑑𝑞 𝑚𝑜𝑑𝑞，其中 𝑑𝑝 &#x3D; 𝑑 𝑚𝑜𝑑 (𝑝𝑑 (𝑝) -1)。 然后，根据我们在中国剩余定理中遵循的高斯组合算法计算最终结果</p>
<p>CRT：</p>
<img src="/post/fit5163-sec-notes/image-20211116225336933.png" class="" title="image-20211116225336933">
<p>转为</p>
<img src="/post/fit5163-sec-notes/image-20211116225200274.png" class="" title="image-20211116225200274">

<img src="/post/fit5163-sec-notes/image-20211116225306744.png" class="" title="image-20211116225306744">

<p>鉴于上述情况，假设公钥为 e&#x3D;3，私钥为 d&#x3D;27，则使用 CRT RSA 解密密文 c&#x3D;52，其中 n&#x3D;55 p&#x3D;5 和 q&#x3D;11。</p>
<p>$𝑑_𝑝 &#x3D; 𝑑 \mod (𝑝 − 1) &#x3D; 27 𝑚𝑜𝑑 4 &#x3D; 3$<br>$𝑑_𝑞 &#x3D; 𝑑 \mod (𝑞 − 1) &#x3D; 27 𝑚𝑜𝑑 10 &#x3D; 7$<br>$𝑀_𝑝 &#x3D; 𝐶^{𝑑_𝑝} \mod 𝑝 &#x3D; 523 𝑚𝑜𝑑 5 &#x3D; (5 ∗ 10 + 2)3 𝑚𝑜𝑑 5 &#x3D; 23 𝑚𝑜𝑑 5 &#x3D; 3$<br>$𝑀_𝑞 &#x3D; 𝐶^{𝑑_𝑞} \mod 𝑞 &#x3D; 527 𝑚𝑜𝑑 11 &#x3D; (4 ∗ 11 + 8)7 &#x3D; 87 𝑚𝑜𝑑 11 &#x3D; 643 ∗ 8 𝑚𝑜𝑑 11 &#x3D; 93 ∗ 8 𝑚𝑜𝑑 11 &#x3D; 81 ∗ 9 ∗ 8 𝑚𝑜𝑑 11 &#x3D; 4 ∗ 72 𝑚𝑜𝑑 11 &#x3D; 2$</p>
<p>为了使用 CRT 计算 RSA 结果，我们有两个 ai：Mp 和 Mq 以及两个ni: n1&#x3D;p 和 n2&#x3D;q<br>因此 CRT 重建公式变为</p>
<p>N1 &#x3D; N&#x2F;n1 &#x3D; (p·q)&#x2F;p &#x3D; q; N2&#x3D;N&#x2F;n2&#x3D; (p·q)&#x2F;q &#x3D; p<br>y1&#x3D;N1^-1 mod n1 &#x3D; q^-1 mod p; y2 &#x3D; N2^-1 mod n2 &#x3D; p^-1 mod q</p>
<p>则</p>
<p>$x &#x3D; \Sigma_{i&#x3D;1}^k a_i \cdot N_i \cdot y_i modN$ for k&#x3D;2</p>
<p> $x &#x3D; M &#x3D; (a_1· N_1·y_1+a_2·N_2·y_2) modN &#x3D; (M_p·q·y_1+M_q·p·y_2)modn$</p>
<p>要找到 𝑞−1𝑚𝑜𝑑𝑝，我们需要解方程</p>
<p>$𝑞 ⋅ 𝑞^{−1}𝑚𝑜𝑑𝑝 &#x3D; 1 → 11 ⋅ 𝑞^{−1}𝑚𝑜𝑑5这可以很容易地发现是 $$𝑞^{−1} &#x3D; 1$</p>
<p>为了找到 𝑝−1𝑚𝑜𝑑𝑞 我们需要解方程</p>
<p>𝑝 ⋅ 𝑝−1𝑚𝑜𝑑𝑞 &#x3D; 1 → 5 ⋅ 𝑝−1𝑚𝑜𝑑11这可以被发现是 $𝑝^{−1} &#x3D; 9$</p>
<p>𝑀 &#x3D; (𝑀𝑝 ⋅ 𝑞 ⋅ 𝑦1 + 𝑀𝑞 ⋅ 𝑝 ⋅ 𝑦2)𝑚𝑜𝑑𝑛 &#x3D; (3 ⋅ 11 ⋅ 1 + 2 ⋅ 5 ⋅ 9)𝑚𝑜𝑑55 &#x3D;&#x3D; (33 + 90)𝑚𝑜𝑑55 &#x3D; 123𝑚𝑜𝑑55 &#x3D; <strong>13</strong></p>
<h2 id="Mid-term"><a href="#Mid-term" class="headerlink" title="Mid term"></a>Mid term</h2><p>比较简单，全选择题，时间足够</p>
<h2 id="W7-amp-8-数字签名-Digital-Signature"><a href="#W7-amp-8-数字签名-Digital-Signature" class="headerlink" title="W7&amp;8: 数字签名 Digital Signature"></a>W7&amp;8: 数字签名 Digital Signature</h2><p>考试来了。W7是考试。</p>
<p>BTC: 老本行了</p>
<p>考点：基础签名方案（RSA，schnorr），高级（Threshold，Aggregate，区别），匿名（Group，Ring，区别，Linkable Ring）；5个Attack模型，4个伪造方式，RSA上的Attack，Blind签名；ECDLP，为什么ECC的密钥长度比RSA和DH短？，椭圆曲线上的点加法，标量乘法，ECDSA</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>用途</p>
<ul>
<li>对等实体（Peer entity）身份验证：验证用户的身份</li>
<li>数据源认证： 验证数据来源</li>
<li>数据的完整性：确保收到的数据是由授权实体发送的</li>
<li>不可否认性：防止通信中的一方否认</li>
</ul>
<p>要求</p>
<ul>
<li>必须取决于签名的消息： 消息无法替换</li>
<li>必须使用发起者（发送者）独有的信息<br>  – 防止伪造和否认</li>
<li>必须相对容易生产和验证</li>
<li>在计算上无法伪造<br>– 现有数字签名的新消息<br>– 对给定消息使用欺诈性数字签名</li>
<li>将数字签名保存在存储中是切实可行的</li>
</ul>
<h4 id="直接数字签名-Direct-Digital-Signature"><a href="#直接数字签名-Direct-Digital-Signature" class="headerlink" title="直接数字签名 Direct Digital Signature"></a>直接数字签名 Direct Digital Signature</h4><p>指<strong>仅涉及通信方</strong>的数字签名方案</p>
<ul>
<li>假设目标知道源的公钥</li>
<li>可以通过使用共享密钥加密整个消息和签名来提供机密性</li>
<li>首先执行签名功能，然后执行外部机密功能很重要<br>– 如有争议，某些第三方必须查看消息及其签名</li>
<li>方案的有效性取决于发送方私钥的安全性<br>– 如果发件人稍后希望拒绝发送特定消息，则发件人可以声称私钥丢失或被盗，并且其他人伪造了他或她的签名<br>– 阻止或至少削弱这种策略的一种方法是要求每条签名消息都包含时间戳，并要求将泄露的密钥迅速报告给中央机构</li>
</ul>
<p>步骤：</p>
<p>• 设置和密钥生成：假设签名者是 Bob<br>– 准备一对公钥和私钥&#x2F;私钥<br>– 发布公钥<br>– 保留密钥<br>• 签名：使用密钥对文档进行签名<br>– 文件和签名对是 Bob 已签署文件的证明。<br>• 验证：任何一方都可以通过使用 Bob 的公钥来验证这对文档和签名</p>
<img src="/post/fit5163-sec-notes/image-20211113093636596.png" class="" title="image-20211113093636596">

<img src="/post/fit5163-sec-notes/image-20211113094700192.png" class="" title="image-20211113094700192">

<img src="/post/fit5163-sec-notes/image-20211113094723829.png" class="" title="image-20211113094723829">

<p>优点：</p>
<ul>
<li>不可伪造<br>  — 需要10亿年才能刻意伪造一个签名！</li>
<li>签字人不可否认</li>
<li>普遍可验证</li>
<li>文档不同而签名不同</li>
<li>易于实现<br>– 纯软件 或<br>– 纯硬件 或<br>– 软件 + 硬件</li>
</ul>
<h4 id="Schnorr-签名方案"><a href="#Schnorr-签名方案" class="headerlink" title="Schnorr 签名方案"></a>Schnorr 签名方案</h4><p>• 基于 DL 的签名方案<br>• 设置：<br>– 定义一个质数阶为 q 的群 G，生成器为 g，其中假设离散对数问题是困难的。<br>– 定义一个哈希函数𝐻：0,1 ∗ → 𝑍𝑞<br>• 密钥生成：<br>– 用户选择一个秘密密钥 𝑥 ∈ 𝑍𝑞 并计算公钥 𝑦 &#x3D; 𝑔^𝑥</p>
<p>签名：使用密钥 x 对消息 m 进行签名：</p>
<ol>
<li>随机选择 $k \in_R Z_q$</li>
<li>计算 $𝑹 &#x3D; 𝒈^𝒌$</li>
<li>计算 $e &#x3D; H(R || m)$</li>
<li>计算 𝒔 &#x3D; 𝒌 − 𝒙𝒆 mod q</li>
<li>输出签名𝜎 &#x3D; (𝒔, 𝒆)</li>
</ol>
<p>验证：使用公钥 (𝒚, 𝒈) 验证签名 𝜎 &#x3D; (𝒔, 𝒆) ：</p>
<ol>
<li>计算 $𝑅^\prime &#x3D; 𝑔^s𝑦^e$</li>
<li>计算 $e^\prime &#x3D; H(R^\prime || m)$</li>
<li>如果 e&#x3D;e’，则输出有效。 否则输出无效</li>
</ol>
<h4 id="高级签名方案"><a href="#高级签名方案" class="headerlink" title="高级签名方案"></a>高级签名方案</h4><p>如果消息来自一个组，谁签名？<br>• 信任一个人签字是很危险的<br>• 签名者可能会修改文档</p>
<p>如果每个用户使用他&#x2F;她的密钥对消息进行一次签名<br>– Bob 必须验证消息 N 次</p>
<p>因此我们需要高级的签名方案处理这类问题</p>
<ul>
<li>Threshold Signature 阈值签名<br>– 至少有 n 个签名者，对应 到一个公钥，在一条消息上<br>– 需要一个“领导者”在 n 个签名者之间分发密钥</li>
<li>Aggregate Signature 聚合签名<br>– n 个签名者，对应 n 个不同的公钥，在 n 个不同的消息上签名</li>
<li>都仅验证一次！</li>
</ul>
<p>Threshold Signature</p>
<img src="/post/fit5163-sec-notes/image-20211113192659577.png" class="" title="image-20211113192659577">

<p>Aggregate Signature（就是这次BTC taproot升级带来的schnorr支持的功能</p>
<img src="/post/fit5163-sec-notes/image-20211113192727695.png" class="" title="image-20211113192727695">

<h4 id="匿名签名-Anonymous-Signature"><a href="#匿名签名-Anonymous-Signature" class="headerlink" title="匿名签名 Anonymous Signature"></a>匿名签名 Anonymous Signature</h4><ul>
<li>组签名 Group Signature：<br>– 允许群组成员代表群组匿名签署消息</li>
<li>环签名 Ring Signature：</li>
</ul>
<h5 id="组签名"><a href="#组签名" class="headerlink" title="组签名"></a>组签名</h5><p>• 有一个组长 (GM)<br>• 设置<br>– GM 生成 GM 私钥和组公钥<br>• 如何加入群组？<br>– 联系GM<br>– GM 为用户颁发私钥（注意：没有个人公钥！）<br>• 签名（代表小组）<br>– 用户使用他的私钥对消息进行签名</p>
<p>• 验证：任何人都可以使用组公钥验证签名，并且：<br>– 确认签名者是组内的用户之一<br>– 不知道真正的签名者是谁<br>• 开放<br>– GM可以撤销匿名！<br>– 无条件 GM 只使用他的 GM 私钥，他可以计算任何签名的实际签名者是谁</p>
<p>总结：</p>
<p>• 匿名签名<br>• 没有人（除了 GM）知道实际签名者是谁&#x2F;链接任何两个签名<br>• 只能确认签名者在组内<br>• 组经理职责：<br>– 组的形成（组pk<br>– 发行个人私钥<br>– 撤销或公开匿名（对任何行为不端的用户）<br>• 需要信任 GM</p>
<h5 id="环签名"><a href="#环签名" class="headerlink" title="环签名"></a>环签名</h5><p>也是一种匿名签名，– 验证者只知道签名者是组中的用户之一，但不知道谁是真正的签名者</p>
<p>• 环签名和群签名的区别<br>– 没有组经理GM<br>– 每个用户生成他&#x2F;她自己的私钥&#x2F;公钥对，就像一个普通的公钥密码系统</p>
<p>• 如何组建&#x2F;加入小组？<br>– 只需包含其他人的公钥！<br>– 特设小组（Ad hoc group）自发</p>
<p>• 如何撤销&#x2F;开放匿名？不可能的！<br>– 没有人（真实签名者除外）可以计算&#x2F;找出实际签名者是谁<br>– 甚至无法检测两个签名是由同一签名者还是不同签名者生成的（不可链接性）</p>
<p>• 设置：（与 Schnorr 签名相同）<br>– 签名方案的所有用户都同意质数阶为 q 的群 G 与生成器 g ，其中假设离散对数问题是困难的。<br>– 定义一个哈希函数 $H:{0,1}^* \rightarrow Z_q$</p>
<p>• 密钥生成：（与 Schnorr 签名相同）<br>– 用户选择一个私钥$x \in Z_q$并计算公钥$y &#x3D; g^x$</p>
<p><strong>签名</strong></p>
<p>– 实际签名者通过包含他们的公钥$Y&#x3D;{y_1,…,y_n}$<strong>（假设组&#x2F;环中有 n 个用户）</strong>来选择一组用户（以形成组）<br>– 让实际签名者的索引为 <strong>𝝅</strong><br>– 要签署消息 m，请执行以下步骤：</p>
<ol>
<li>随机选择 $u \in_R Z_p$ </li>
<li>计算 $c_{𝝅+1} &#x3D; H(Y,m,g^u)$</li>
<li>对于$i&#x3D;\pi +1,…,n,1,…,\pi−1$，随机选择 $s_i \in_R Z_q$并计算 $c_{i+1} &#x3D; H(Y,m,g^{s_i}y_i^{c_i})$</li>
<li>计算 $s_\pi &#x3D; u-x_\pi c_\pi \mod q$<br> – 签名是 $\sigma&#x3D;(c_1, s_1, …, s_n)$</li>
</ol>
<p><strong>验证</strong>：在输入时 ( 𝒀, 𝒎, 𝝈),</p>
<ol>
<li>对于$i &#x3D; 1, …, n$ 计算<br>$z_i^\prime &#x3D;g^{S_i}y_i^{c_i}$ 然后 $c_{i+1}&#x3D;H(Y,m,z_i^\prime)$ 如果 $i \not&#x3D; n$</li>
<li>检查是否$c_1&#x3D;H(Y,m,z_n^\prime)$. 如果是，接受。 否则，拒绝。<br>这个想法是为了证明签名者知道 n 个公钥中的秘密密钥 (DL) 之一。</li>
</ol>
<h5 id="可链接的环签名"><a href="#可链接的环签名" class="headerlink" title="可链接的环签名"></a>可链接的环签名</h5><p>• 普通环签名不可链接<br>– 没有人可以检测两个签名是否由同一签名者生成<br>• 在某些情况下，这种“匿名性”可能太强了，例如 投票<br>• 可链接性是一个不错的选择！<br>– 任何人都知道两个签名是否由同一签名者生成<br>– 然而没有人知道真正的签名者是谁</p>
<p>• 设置<br>– 与（正常）环签名相同<br>• 密钥生成<br>– 与（正常）环签名相同<br>• 标志<br>– 首先设计可链接的级别：群组链接 Group Linkable，事件链接 Event Linkable，一次性链接One time Linkable</p>
<p><strong>签名</strong>：假设是事件可链接的</p>
<ol>
<li>计算 $\textcolor{red}{h &#x3D; H^\prime(event)}$ 和链接标签 $\textcolor{red}{\tilde{y}&#x3D; h^{x_\pi}}$ </li>
<li>随机选择 $u \in_R Z_p$ </li>
<li>计算 $c_{𝝅+1} &#x3D; H(\textcolor{red}{event},Y,m,g^u, \textcolor{red}{h^u})$</li>
</ol>
<p>4.对于$ i&#x3D;\pi +1,…,n,1,…,\pi−1$，随机选择 $s_i \in_R Z_q$ 并计算 $c_{i+1} &#x3D; H(\textcolor{red}{event},Y,m,g^{S_i}y_i^{c_i},\textcolor{red}{ h^{s_i}\tilde{y}^{c_i}})$<br>5. 计算 $s_\pi &#x3D; u-x_\pi c_\pi \mod q$<br>– 签名是 $\sigma&#x3D;(c_1, s_1, …, s_n, \textcolor{red}{\tilde{y}})$</p>
<p><strong>验证</strong>： 当输入 ( 𝑒𝑣𝑒𝑛𝑡,𝒀,𝒎,𝝈),</p>
<ol>
<li>对于$i &#x3D; 1, …, n$，计算<br>$z_i^\prime &#x3D;g^{s_i}y_i^{c_i}$ ; $\textcolor{red}{z_i^{\prime\prime}&#x3D;h^{s_i}\tilde{y}<em>i^{c_i}}$  然后 $c</em>{i+1}&#x3D;H(\textcolor{red}{event}, Y,m,z_i^\prime,\textcolor{red}{z_i^{\prime\prime}})$</li>
<li>检查是否 $c_{1}&#x3D;H(\textcolor{red}{event}, Y,m,z_n^\prime,\textcolor{red}{z_n^{\prime\prime}})$。如果是，则接受。否则，拒绝。</li>
</ol>
<p>关联</p>
<p>– 检查链接标签 $\textcolor{red}{\tilde{y}}$ 是否相同</p>
<p>这个想法是为了证明签名者知道 n 个公钥中的一个秘密密钥 (DL) <strong>并且</strong> <strong>已知</strong> 私有密钥 等于  $\textcolor{red}{\tilde{y}}$ 到基数h的DL（回忆： $\textcolor{red}{\tilde{y} &#x3D; h^{x_\pi}}$ 且  $\textcolor{red}{h &#x3D; H^\prime(event)}$ 以及 $y_\pi &#x3D; g^{x_\pi}$）</p>
<h3 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h3><h4 id="攻击模型"><a href="#攻击模型" class="headerlink" title="攻击模型"></a>攻击模型</h4><p>Key only 攻击：C 只知道 A 的公钥</p>
<p>Known message 已知消息攻击：C 被授予访问一组消息及其签名的权限</p>
<p>Generic chosen message 通用选择消息攻击：C 在尝试破解 A 的签名方案之前选择一个消息列表，与 A 的公钥无关； C 然后从 A 获得所选的有效签名</p>
<p>Directed chosen message 定向选择消息攻击：类似于通用攻击，不同之处在于要签名的消息列表是在 C 知道 A 的公钥之后但在看到任何签名之前选择的</p>
<p>Adaptive chosen message自适应选择消息攻击：C 可以从 A 请求依赖于先前获得的消息签名对的消息签名</p>
<h4 id="伪造-Forgeries"><a href="#伪造-Forgeries" class="headerlink" title="伪造 Forgeries"></a>伪造 Forgeries</h4><p>Total break 整体截断: C 确定 A 的私钥</p>
<p>Universal forgery 通用伪造: C 找到了一种有效的签名算法，该算法提供了在任意消息上构造签名的等效方法</p>
<p>Selective forgery 可选伪造: C 为 C 选择的特定消息伪造签名</p>
<p>Existential forgery 既存伪造: C 为至少一条消息伪造签名；但是C 无法控制消息</p>
<h3 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h3><p>为什么是椭圆曲线密码术？<br>• 较短的密钥长度<br>• 计算复杂度较低<br>• 低功耗要求<br>• 更安全</p>
<p>介绍<br>• 让p &gt; 3 为素数。$\mathbb{Z}_p$上的椭圆曲线 $y^2 &#x3D; x^3 + ax + b$ 是同余解的集合 $(x, y) \in \mathbb{Z}_p$</p>
<p>$y^2 \equiv x^3 + ax + b \pmod p$</p>
<p>其中 $a \in \mathbb{Z}_p$, $b \in \mathbb{Z}_p$, 是常数使得 $4a^3 + 27b^2  \not\equiv 0 \pmod p$<br>0 (mod p)，连同一个特殊的点 O 称为无穷远点</p>
<p>椭圆曲线的特点<br>– 形成一个阿贝尔群 abelian group<br>– 关于 x 轴对称<br>– 指向无穷大作为单位元素：P+O&#x3D;P</p>
<p>密码学椭圆曲线例子：在 $\mathbb{Z}_{11}$上的 $y^2 &#x3D; x^3 + x + 6$ </p>
<p>则我们有一个有 13 个点的组（包括无穷远 O 处的点）</p>
<table>
<thead>
<tr>
<th>x</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>$x^3+x+6 \mod 11$</td>
<td>6</td>
<td>8</td>
<td>5</td>
<td>3</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>9</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>QR?</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>Y</td>
<td></td>
<td></td>
<td>4,7</td>
<td>5,6</td>
<td></td>
<td>2,9</td>
<td></td>
<td>2,9</td>
<td>3,8</td>
<td></td>
<td>2,9</td>
</tr>
</tbody></table>
<h4 id="ECC计算"><a href="#ECC计算" class="headerlink" title="ECC计算"></a>ECC计算</h4><p>• 加点<br>– 添加位于椭圆曲线上的两个点 – 导致曲线上的第三个点</p>
<p>• 标量乘法<br>– 点乘法是重复加法<br>– 如果 P 是曲线上的已知点（又名基点；域参数的一部分），Q&#x3D;kP 是 P + P + P + P… +P 相加的运算（k 次，k 是标量）<br>– Q 是生成的公钥，k 是公钥-私钥对中的私钥</p>
<p>• 在曲线上添加两个点<br>• P 和 Q 相加得到 P+Q，它是 R 沿 X 轴的反射<br>• 延长 P 处的切线以在一点处切割曲线； 它的反射是2P<br>• P 和 2P 相加得到 3P<br>• 同样，可以根据需要多次执行此类操作以获得 Q &#x3D; kP</p>
<h4 id="ECC-中的离散对数问题"><a href="#ECC-中的离散对数问题" class="headerlink" title="ECC 中的离散对数问题"></a>ECC 中的离散对数问题</h4><p>• ECC 中的 DLP：如果 Q&#x3D;kP，给定 P 和 Q，很难得到 k<br>• 解决方法包括：蛮力攻击, Pollard’s Rho攻击（两者在计算上都是昂贵的或不可行的<br>• 适用于 ECC 的版本称为椭圆曲线离散对数问题 (ECDLP , Elliptic Curve Discrete Log Problem)</p>
<h4 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h4><p>Elliptic Curve Schemes<br>• Elliptic Curve Digital Signature Algorithm (ECDSA)</p>
<img src="/post/fit5163-sec-notes/image-20211114020431144.png" class="" title="image-20211114020431144">

<p>$Q_A &#x3D;d_A G$</p>
<h5 id="ECDSA签名"><a href="#ECDSA签名" class="headerlink" title="ECDSA签名"></a>ECDSA签名</h5><ol>
<li>选择一个随机数k，1≤k≤n-1</li>
<li>计算 kG &#x3D; (x1, y1)</li>
<li>计算 r &#x3D; x1 mod n</li>
<li>计算 k-1 mod q</li>
<li>e &#x3D; Hash(m) 其中 m 是要签名的消息</li>
<li>$s &#x3D; k^{-1}(e + d_Ar) \mod n$</li>
</ol>
<p>我们的签名为 (r, s)</p>
<p>注意 e 不能长于 n。 如果是这样，只有e的最左边的$L_n$位是有符号的，其中𝐿#是n的位长</p>
<h5 id="ECDSA验证"><a href="#ECDSA验证" class="headerlink" title="ECDSA验证"></a>ECDSA验证</h5><ol>
<li>验证 r 和 s 是否属于区间 [1, n-1] 以使签名有效。</li>
<li>计算 e &#x3D; Hash(m)</li>
<li>计算 $w &#x3D; s^{-1} \mod n$</li>
<li>计算 u1 &#x3D; ew mod n 和 u2 &#x3D; rw mod n</li>
<li>计算 (x1,y1) &#x3D; u1G + u2Q。</li>
<li>r &#x3D; x1 mod n 时签名有效，否则无效</li>
</ol>
<h3 id="Tut-3"><a href="#Tut-3" class="headerlink" title="Tut"></a>Tut</h3><p>文字题</p>
<h2 id="W9-Lightweight-Security"><a href="#W9-Lightweight-Security" class="headerlink" title="W9: Lightweight Security"></a>W9: Lightweight Security</h2><p>超乎想象的内容，原以为只是介绍，没想到内容和算法都挺多</p>
<p>考点：TMD tradeoff attack，流密码上的TMD，在&#x2F;离线签名，在&#x2F;离线加密</p>
<p>Lightweight Security研究<strong>在资源受限环境下</strong>的安全性</p>
<p>• 轻量级密码学<br>• 验证：轻量级身份验证协议 Lightweight authentication protocols ; 轻量级密钥协商协议 Lightweight key agreement protocols<br>• 保密：轻量级块&#x2F;流密码 Lightweight block&#x2F;stream cipher ; 轻量级认证加密 Lightweight authenticated encryption<br>• 完整性：轻量级消息身份验证代码 Lightweight message authentication codes (MACs)</p>
<p>区别：</p>
<p>• 迄今为止，我们看到的传统算法并非为资源受限的设备量身定制<br>• 不是 RSA<br>• 不是 Diffie-Hellman<br>• 甚至不是 AES（它已经比 RSA&#x2F;Diffie-Hellman 高效得多）<br>• 如果我们不做好研究，事情就会出错……<br>• 工业与学术</p>
<p>案例： 1. KeeLoq 2. Mifare …</p>
<p>好的算法：</p>
<p>学术界对过去十年开发的轻量级算法进行了大量研究</p>
<p>轻量级分组密码：<br>• PRINCE – Asiacrypt 2012<br>• Midori – Asiacrypt 2015<br>• SIMECK – CHES 2015<br>• 还有很多…</p>
<p>轻量级流密码：<br>• Sprout – Fast Software Encryption (FSE) 2015<br>• Plantlet – Transactions On Symmetric Cryptology 2017<br>• Lizard – Transactions On Symmetric Cryptology 2017<br>• 仅此而已！</p>
<p><strong>为什么有这么多块密码而不是流密码？时间&#x2F;内存&#x2F;数据 权衡 TIME&#x2F;MEMORY&#x2F;DATA (TMD) TRADEOFF 攻击！</strong></p>
<img src="/post/fit5163-sec-notes/image-20211114141023629.png" class="" title="image-20211114141023629">

<p>在这种情况下，我们可以以时间和数据为代价来降低内存复杂性。 但是，我们不能一起降低所有的（T&amp;M&amp;D）复杂性！</p>
<h3 id="TMD-权衡攻击"><a href="#TMD-权衡攻击" class="headerlink" title="TMD 权衡攻击"></a>TMD 权衡攻击</h3><p>两个极端：</p>
<p>• 蛮力：实时（在线）尝试所有可能性并找到正确的可能性。<br>• T &#x3D; N<br>• P ≈ M ≈ D ≈ 0</p>
<p>• 完整词典：预先计算所有可能性并将它们放在（排序的）表中。 只需实时查找正确的候选即可。<br>• P &#x3D; M &#x3D; N<br>• T ≈ D ≈ 0</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>N</td>
<td>搜索空间大小</td>
</tr>
<tr>
<td>T</td>
<td>在线阶段所需<strong>时间</strong></td>
</tr>
<tr>
<td>P</td>
<td><strong>预计算</strong>阶段所需<strong>时间</strong></td>
</tr>
<tr>
<td>M</td>
<td>所需的<strong>内存</strong>量</td>
</tr>
<tr>
<td>D</td>
<td>可用的在线<strong>数据</strong>量</td>
</tr>
</tbody></table>
<p>攻击分为<strong>两个阶段</strong>：</p>
<p>预计算（离线）阶段：<br>• 此时的攻击者无法访问实时（在线）数据。所以，目前还没有目标密文。<br>• 此阶段仅针对所有可能要攻击的目标执行一次！<br>• 因此，该阶段的时间复杂度相对较小。</p>
<p>在线阶段（实时）：<br>• 现在，攻击者拥有使用未知密钥加密的实时数据。<br>• 必须对每个目标重复此阶段！<br>• 因此，在线时间复杂度非常重要！</p>
<p>例如：<br>攻击 I：• 离线阶段需要 1 个月。• 在线阶段需要 1 分钟。<br>攻击 II：• 离线阶段需要 1 天。• 在线阶段需要 1 天。</p>
<p>当破解 100 个密文<br>• 使用攻击 I：1 个月 + 100 分钟 &#x3D; ~30 天<br>• 使用攻击 II：1 天 + 100 天 &#x3D; 101 天</p>
<p>当破解 1000 个密文<br>• 攻击 I：1 个月 + 1000 分钟 &#x3D; ~31 天<br>• 使用攻击 II：1 天 + 1000 天 &#x3D; 1001 天</p>
<p>密钥流生成器<br>• 正如我们之前所见，流密码的工作原理如下：<br>𝐶 &#x3D; 𝑀⊕𝐾<br>其中 𝐾 是密钥流，𝑀 是要加密的明文。<br>• 攻击者的目标可能是恢复给定一部分的所有密钥流序列。<br>• 结果，分析简化为密钥流生成器（生成𝐾的算法）的分析。</p>
<h4 id="对-流密码-的-Babbage-Golic-权衡攻击"><a href="#对-流密码-的-Babbage-Golic-权衡攻击" class="headerlink" title="对 流密码 的 Babbage-Golic 权衡攻击"></a>对 流密码 的 Babbage-Golic 权衡攻击</h4><p>• 假设攻击者可以访问密钥流的一部分。<br>• 攻击者的目标是恢复正确的内部状态。<br>• 请注意，状态更新中没有使用密钥。<br>• 一旦内部状态恢复，您就可以生成整个密钥流。<br>• N&#x3D;2s，其中s 是内部状态大小。</p>
<img src="/post/fit5163-sec-notes/image-20211114141911262.png" class="" title="image-20211114141911262">

<p>预计算（离线）阶段<br>• 取 M 个随机内部状态 S1,…,SM<br>• 计算 s 位对应的密钥流 Zi<br>• 将 (Si,Zi) 对存储在根据 Zi 排序的表中</p>
<p>在线阶段<br>• 取大约 D 位的密钥流<br>• 将其分成 D 个 s 位的块（通过重叠）<br>• 搜索表中的每个密钥流块<br>• 如果找到匹配项，则表中对应的内部状态是正确的内部状态</p>
<p>切割密钥流keystream</p>
<p>假设我们总共有 12 位并且想要将其分成 4 位的块</p>
<img src="/post/fit5163-sec-notes/image-20211115221133109.png" class="" title="image-20211115221133109">



<p>复杂度</p>
<p>• 根据生日悖论，如果 D*M &#x3D; N，则匹配很可能在在线阶段被发现。<br>• T &#x3D; D 因为我们在在线阶段总共使用 D 个块。<br>• P &#x3D; M 因为我们在离线阶段总共使用 M 个块。<br>• 从这里开始，T*M &#x3D; N。<br>• 我们可以通过设置来最小化所有的复杂性<br>$T &#x3D; D &#x3D; M &#x3D; P &#x3D; N^{1&#x2F;2}&#x3D;2^{s&#x2F;2}$<br>其中 s 是内部状态大小。</p>
<h4 id="流密码的经验法则"><a href="#流密码的经验法则" class="headerlink" title="流密码的经验法则"></a>流密码的经验法则</h4><p>• 如果您想要 k 位安全性，则内部状态大小必须<strong>至少为 2k 位</strong>。<br>• 在这种情况下，Babbage-Golic 攻击变得无效：<br>• 搜索空间 N &#x3D; 22k<br>• T &#x3D; M &#x3D; D &#x3D; P &#x3D; 2k<br>• 另请注意，此攻击是通用的。<br>• 也就是说，攻击的适用独立于特定设计的内部结构。</p>
<h3 id="在线-x2F-离线签名"><a href="#在线-x2F-离线签名" class="headerlink" title="在线&#x2F;离线签名"></a>在线&#x2F;离线签名</h3><p>目标再次相同：<br>使实时（在线）签名尽可能高效<br>• 回想一下，对于传统签名，我们使用散列和签名范式。<br>• 也就是说，我们首先对消息进行散列，然后对散列值进行签名。<br>• 如果我们也这样做，但添加一点“作弊”如何？</p>
<h4 id="Trapdoor-陷门哈希函数"><a href="#Trapdoor-陷门哈希函数" class="headerlink" title="Trapdoor 陷门哈希函数"></a>Trapdoor 陷门哈希函数</h4><p>• 就像我们之前看到的散列函数一样，但有一个关键的区别 —— 散列函数有一个陷门Key。<br>• 没有陷门Key很难发现碰撞。<br>• 很容易发现与陷门Key的碰撞。</p>
<p>离散对数的陷门哈希<br>• 设 $p$ 为一个安全的质数, 也就是说，$q &#x3D; \frac{p-1}{2}$ 是个质数。<br>• 让$ g  \in {2,3,…, 𝑝 − 1}$ 使得$ g^q &#x3D; 1 \mod p$<br>• 选择一个随机 $ a \in  {1,2,…, q−1 }$<br>• 设 $ y &#x3D; g^a \mod p $<br>• $ H(m;r) &#x3D; g^my^r \mod p $ 用于一些消息 𝑚 和随机值 𝑟。</p>
<p>当$a$给出：</p>
<p>假设$H(m_1;r_1)$是给定的且我们想要找到一个在$m_1 \not&#x3D; m_2$的$时m_1$和$m_2$的碰撞。<br>设$r_2&#x3D;a^{-1}(m_1-m_2)+r_1 \mod q$</p>
<p>$H(m_2;r_2) &#x3D; g^{m_2}y^{r_2} &#x3D; g^{m_2}g^{ar_2}\&#x3D;g^{m_2}g^{a(a^{-1}(m_1-m_2)+ r_1)} &#x3D; g^{m_2+m_1-m_2+ar_1}\&#x3D;g^{m_1}g^{ar_1}&#x3D;H(m_1;r_1)$</p>
<p>当$a$未给出（见tut：基于不给定 α 的离散对数问题，证明 H 是抗碰撞的）</p>
<h4 id="基于-Trapdoor-哈希函数的在线-x2F-离线签名"><a href="#基于-Trapdoor-哈希函数的在线-x2F-离线签名" class="headerlink" title="基于 Trapdoor 哈希函数的在线&#x2F;离线签名"></a>基于 Trapdoor 哈希函数的在线&#x2F;离线签名</h4><p>离线签名：<br>• 签署带有一些随机性𝜌 的随机消息𝑣。</p>
<p>在线签约：<br>• 收到实际消息𝑚<br>• 找到 𝑚 的taproot碰撞：即，设 $ r &#x3D; a^{-1}(v-m)+ 𝜌$</p>
<img src="/post/fit5163-sec-notes/image-20211114144347337.png" class="" title="image-20211114144347337">

<h3 id="在线-x2F-离线方案"><a href="#在线-x2F-离线方案" class="headerlink" title="在线&#x2F;离线方案"></a>在线&#x2F;离线方案</h3><p>考虑计算加密算法（加密、签名等）的设备功耗低的情况。<br>希望能够在消息到达之前预先计算一部分计算（即独立于消息！）。<br>• 可以进行预计算：要么提前通过另一个（更强大的）设备，并将结果嵌入到轻量级设备中；或当轻型设备连接到电源时<br>• 实时计算会更快，确保及时交付。</p>
<p>这种在线&#x2F;离线设置主要用于非对称加密，因为它具有更繁重的运算，例如求幂和配对。<br>同样，我们有两个阶段：离线和在线。<br>• 离线阶段：在知道消息之前执行繁重的操作<br>• 在线阶段：使用给定的消息执行较轻的运算（乘法、加法等）</p>
<p>我们将重点关注两种特殊情况：<br>• Online&#x2F;offline Identity-based Encryption (IBE) by Guo, Mu and Chen 基于 Boneh-Boyen IBE<br>• Shamir 和 Tauman 的在线&#x2F;离线签名</p>
<h4 id="Online-x2F-offline-Identity-based-Encryption"><a href="#Online-x2F-offline-Identity-based-Encryption" class="headerlink" title="Online&#x2F;offline Identity-based Encryption"></a>Online&#x2F;offline Identity-based Encryption</h4><p>循环群</p>
<p>• 如果存在生成整个群𝐺的𝑔 ∈ 𝐺，则将群𝐺称为循环群<br>• 也就是说，$𝐺 &#x3D; {1, 𝑔, 𝑔^2, 𝑔^3,…, 𝑔^n}$ 那么用$𝐺 &#x3D;&lt;𝑔&gt;$ 表示<br>• 例如，𝐺 &#x3D; {1,2,…, 6} 是关于乘法的循环群，则存在<br>$3^0 &#x3D; 1,3^1 &#x3D; 3, 3^2 &#x3D; 2 \pmod 7\ 3^3 &#x3D; 6, 3^4 &#x3D; 4, 3^5 &#x3D; 5 \pmod 7$</p>
<p>Diffie-Hellman 相关难题</p>
<p>设 G 是质数阶 p 的循环群，g 是 G 的生成器。</p>
<ul>
<li>离散对数问题 (Discrete Logarithm Problem, <strong>DLP</strong>)：如果 $h &#x3D; g^x$，给定 h 和 g，很难得到 x</li>
<li>计算性 Computational Diffie-Hellman (<strong>CDH</strong>) 问题&#x2F;假设：给定 $g^x$ 和 $g^y$，很难计算 $g^{xy}$</li>
<li>决策性Decisional Diffie-Hellman (<strong>DDH</strong>) 问题&#x2F;假设：给定 $g^x$, $g^y$ 和 $g^z$ ，很难判断是否 $g^{xy} &#x3D; g^z$</li>
</ul>
<p>其中𝑥, 𝑦, 𝑎𝑛𝑑 𝑧 ∈ {1,…, p−1}</p>
<p>双线性配对 Bilinear pairings</p>
<p>令𝐺和𝐺是素数阶𝑝的循环群。 另外，让𝑔成为<br>𝐺的生成器。 那么，映射𝑒：$G \times G \rightarrow G_T$，是一个双线性对，如果满足以下条件：<br>• $e(u^a, v^b) &#x3D; e(u,v)^{ab}$ 对于任何 𝑢，𝑣 ∈ 𝐺 和 $a,b \in \mathbb{Z}_p$。<br>• $e(g,g) \not&#x3D; 1$。<br>• 映射 $e(\cdot,\cdot)$是有效地可计算的</p>
<h5 id="Boneh-Boyen-IBE"><a href="#Boneh-Boyen-IBE" class="headerlink" title="Boneh-Boyen IBE"></a>Boneh-Boyen IBE</h5><p>• Boneh-Boyen IBE 使用一次性签名方案，我们将用$𝑆𝑖𝑔𝑛_{sk}(m)$ 和$Verify_{pk}(\sigma)$ 表示（签名方案的公钥和私钥用𝑝𝑘 和𝑠𝑘 表示。<br>• 安全性基于Diffie-Hellman 问题的变体，称为Decisional Bilinear Diffie-Hellman 问题。<br>• 令 G 和 $𝐺_T$ 是 q 阶循环群，g 是 G 的生成器<br>• 让映射e: $G\times G \rightarrow G_T$ 是一个双线性对。<br>• 给定$𝑔^x$, $g^y$ 和$g^z$，很难判断是否 $h &#x3D; e(g, g)^{xyz}$ ，其中h 是$G_T$ 中的随机元素， x, y 和 z ∈ {1, …, q-1}</p>
<p><strong>设置</strong></p>
<p>（红色部分为私密值</p>
<p>• 选择一个随机私密数 $a \in \mathbb{Z}_p (\mathbb{Z}_p&#x3D;{0, 1, …, p-1})$<br>• 从G中随机选择$g$, $g_1$, $g_2$, $h_1$, $h_2$<br>• 设置 $g_1 &#x3D; g^\textcolor{red}{a}$<br>• 输出：公共参数 $\text{public params} &#x3D; (g, g_1, g_2, h_1, h_2)$ 和主密钥 $\textcolor{red}{K} &#x3D; g_2^\textcolor{red}{a}$</p>
<p><strong>密钥生成</strong><br>假设我们要为 $ID \in \mathbb{Z}$ 生成一个私钥。<br>• 随机选择一个 $\textcolor{red}{r} \in \mathbb{Z}$<br>• 计算 $\textcolor{red}{d_1} &#x3D; \textcolor{red}{K} (\cdot ℎ_1𝑔<em>1^{ID})^\textcolor{red}{r}$<br>• 计算$\textcolor{red}{d_2} &#x3D; g^\textcolor{red}{r}$<br>• 输出：$\textcolor{red}{d</em>{ID} &#x3D; (d_1, d_2)}$</p>
<p><strong>加密</strong></p>
<p>假设我们想要加密消息𝑚 ∈ 𝐺，对于某些身份𝐼𝐷 ∈ ℤ&#x2F;。</p>
<p>• 选择一个随机 $\textcolor{red}{s} \in \mathbb{Z}<em>p$<br>• 计算$c_1 &#x3D; (ℎ_1g_1^{ID})^\textcolor{red}{r}$ 和 $c_2 &#x3D; (h_2g_1^{pk})^\textcolor{red}{s}$<br>• 计算$c_3 &#x3D; g^\textcolor{red}{s}$ 和 $c^4 &#x3D; e(g_1, g_2)^\textcolor{red}{s}\cdot m$<br>• 计算$\sigma &#x3D; Sign</em>{\textcolor{red}{sk}}(c_1, c_2, c_3, c_4)$<br>• 输出：$ 𝐶 &#x3D; (c_1, c_2, c_3, c_4, \sigma, pk)$</p>
<h4 id="一个自然的在线-x2F-离线版本"><a href="#一个自然的在线-x2F-离线版本" class="headerlink" title="一个自然的在线&#x2F;离线版本"></a>一个自然的在线&#x2F;离线版本</h4><p>• 我们可以预先计算所有不依赖于 𝑚 和 𝐼𝐷 的组件。<br>• 即预先计算：$h_1^s, g_1^s, c_2, c_3, e(g_1, g_2)^s$<br>• 剩余计算：$\textcolor{grey}{h_1^s}\cdot\textcolor{grey}{(g_1^s)}^{ID}, \textcolor{grey}{e(g_1,g_2)^s}\cdot m, Sign_{sk}$</p>
<h4 id="改进的在线-x2F-离线-Boneh-Boyen-IBE"><a href="#改进的在线-x2F-离线-Boneh-Boyen-IBE" class="headerlink" title="改进的在线&#x2F;离线 Boneh-Boyen IBE"></a>改进的在线&#x2F;离线 Boneh-Boyen IBE</h4><p>加密 - 离线阶段（消息m 和 ID 未知）：</p>
<p>• 选择一个随机 $\textcolor{red}{\alpha, \beta, s} \in \mathbb{Z}<em>p$<br>• 计算 $c_1 &#x3D; (h_1g_1^\textcolor{red}{\alpha})^\textcolor{red}{s}$, $c_2&#x3D; g_1^{\textcolor{red}{s\beta}}$以及$c_4&#x3D;(h_2g_1^{pk})^\textcolor{red}{s}$<br>• 计算 $c_5&#x3D;g^\textcolor{red}{s}$以及$c_6^{\prime}&#x3D;e(g_1,g_2)^\textcolor{red}{s}$<br>• 计算 $\sigma</em>{off} &#x3D; Sign_{sk}(c_1,c_2, c_4, c_5,c_6^{\prime})$<br>• 输出$C&#x3D; (c_1, c_2, c_4, c_5, c_6^{\prime}, \sigma_{off})$</p>
<p>加密 - 在线阶段（现在知道消息和 ID）：</p>
<p>• 计算 $c_3&#x3D;\textcolor{red}{\beta}^{-1}(ID-\textcolor{red}{\alpha})$<br>• 计算 $c_6 &#x3D; c_6^{\prime}\cdot m$<br>• 计算 $\sigma_{on} &#x3D; Sign_{\textcolor{red}{sk}}(c_1, c_2, c_3, c_4, c_5, c_6)$<br>• 输出：$C&#x3D;(c_1, c_2, c_3,  c_4, c_5, c_6, \sigma_{off}, \sigma_{on}, pk)$</p>
<p>对应$C&#x3D;(c_1, c_2, c_3,  c_4, c_5, c_6, \sigma_{off}, \sigma_{on}, pk)$的解密</p>
<p>• 检查是否 $Verify_{pk}(\sigma_{off}, \sigma_{on}) &#x3D; 1$<br>• 满足则计算 $c_0&#x3D;c_1\cdot c_2^{c_3} &#x3D; (h_1g_1^\alpha)^s \cdot (g_1^{s\beta})^{\beta^{-1}(ID-\alpha)} &#x3D; (h_1g_1^{ID})^s$<br>• 然后，我们就拥有与普通 Boneh-Boyen 加密相同的值$(c_0, c_4, c_5, c_6) &#x3D; \Big( (h_1g_1^{ID})^s, (h_2g_1^{pk})^s, g^s, e(g_1, g_2)^s\cdot m \Big)$<br>• 因此，其余的解密与原始 Boneh-Boyen 解密相同</p>
<p>在线&#x2F;离线方案在计算效率方面最重要的优势是什么？答：在线阶段不求幂（exponentiation）！</p>
<h3 id="Tut-4"><a href="#Tut-4" class="headerlink" title="Tut"></a>Tut</h3><p>文字题略</p>
<p>以下哪项可以代表权衡攻击的复杂性？ 为什么？<br>（T &#x3D; 时间复杂度，M &#x3D; 内存复杂度，D &#x3D; 数据复杂度）</p>
<ol>
<li>$T &#x3D; 2^d, M &#x3D; 2^{100−d}, D &#x3D; 2^{d+10}$</li>
<li>$T &#x3D; 2^{d−7}, M &#x3D; 2^{72−d}, D &#x3D; 2^d$</li>
<li>$T &#x3D; 2^{d−5}, M &#x3D; 2^{d+10}, D &#x3D; 2^d$</li>
</ol>
<p>只有 (3) 是不正确的，因为在这种情况下所有复杂性都随着 d 增加&#x2F;减少。</p>
<p>假设A1是一个权衡攻击，离线时间复杂度为1天，在线时间复杂度为1分钟。 此外，让 A2 成为另一种权衡攻击，离线时间复杂度为 1 小时，在线时间复杂度为 1 小时。 计算两种攻击打破所需的时间<br>(a) 10 个密文，<br>(b) 120 个密文，<br>(c) 1200 个密文。<br>如果您是一个试图查看所有社交媒体用户之间交换的所有消息的恶意对手，您更喜欢哪种攻击？</p>
<p>(a) A1：以小时为单位的总时间 &#x3D; 24 + 10 * 1&#x2F;60 &lt; 25。<br>A2：以小时为单位的总时间 &#x3D; 1 + 10 * 1 &#x3D; 11。<br>(b) A1：以小时为单位的总时间 &#x3D; 24 + 120 * 1&#x2F;60 &#x3D; 26。<br>A2：以小时为单位的总时间 &#x3D; 1 + 120 * 1 &#x3D; 121。<br>(c) A1：以小时为单位的总时间 &#x3D; 24 + 1200 * 1&#x2F;60 &#x3D; 44。<br>A2：以小时为单位的总时间 &#x3D; 1 + 1200 * 1 &#x3D; 1201。<br>在给定的场景中，攻击者希望破解大量密文。 因此，对于给定的场景，A1 将是首选，因为破解大量密文所需的总时间会少得多。</p>
<p>假设您要设计一个更新功能不使用密钥的密钥流生成器 (KSG)，并且您需要 256 位的安全性。 以下哪项可能是可接受的内部状态大小？</p>
<p>由于流密码设计的经验法则（在状态更新函数中不使用密钥），内部状态大小必须至少是所需安全级别的两倍。 因此，内部状态大小必须至少为 512 位，并且只有 (c) 和 (d) 是可以接受的</p>
<p>让 Tiny 成为具有 64 位内部状态的轻量级流密码。 此外，假设 Tiny 在其状态更新函数中没有生成密钥。 给定一个密钥流序列，假设我们想要恢复正确的内部状态。<br>(a) 如果我们发起暴力攻击，所需的总时间、内存和数据是多少？ 假设尝试一个候选内部状态需要 1 微秒。<br>(b) 如果我们发起时间&#x2F;内存&#x2F;数据 (TMD) 权衡攻击，所需的总时间、内存和数据是多少？ 假设尝试一个候选内部状态需要 1 微秒</p>
<p>对于 (a)，内存和数据的复杂性可以忽略不计（大约为 64 位）。<br>时间 Ta 将是<br>Ta &#x3D; 264 · 10−6 秒 ≈ 244 秒 &gt; 500.000 年。<br>另一方面，如果我们对 (b) 应用简单的 Babbage-Golic 权衡攻击，时间 Tb、内存 Mb 和数据 Db 复杂度将与整个搜索空间的平方根成正比 2 ^ {64&#x2F;2} &#x3D; 2^32。 更准确地说，我们将有<br>Tb &#x3D; 2^32 · 10^{−6} 秒 ≈ 72 分钟<br>Mb &#x3D; 2^32 · 2 · 64 位 &#x3D; 236 字节 &#x3D; 64 GB（存储了 2^32 个 64 位状态和 64 位密钥流块）<br>Db &#x3D; 2^32 + 64 位 ≈ 2^29 字节 &#x3D; 512 MB<br>请注意，通过在连续块中重叠 63 位，我们可以从 2^32 + 64 位的密钥流中得到 2^32 个 64 位的块。 另请注意，<strong>以预计算时间和内存复杂性为代价，可以降低数据复杂性（在攻击者无法访问大量数据的情况下）</strong>。</p>
<p>比较原始 Boneh-Boyen 基于身份的加密 (BB-IBE)、自然在线&#x2F;离线 BB-IBE 和 改进的在线&#x2F;离线 BB-IBE 的在线时间复杂度（在操作数量方面），如下所示。 确定哪一种最有效。</p>
<img src="/post/fit5163-sec-notes/image-20211116154049070.png" class="" title="image-20211116154049070">

<p>回想一下，“自然线上&#x2F;线下”的第二步配对操作是在离线阶段完成的，在线阶段只有乘法。 另外，请注意，“改进的在线&#x2F;离线”的 β-1 可以在离线阶段计算，而 c3 的计算是整数。 因此，可以非常有效地计算 c3，因此我们可以忽略</p>
<table>
<thead>
<tr>
<th>Scheme</th>
<th>Pairing</th>
<th>Exponentiation</th>
<th>Signing</th>
<th>Group Multiplication</th>
</tr>
</thead>
<tbody><tr>
<td>Original</td>
<td>1</td>
<td>6</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Natural</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Improved</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>回忆一下讲座中介绍的基于离散对数问题的陷门哈希函数。 设 p, q 是 q &#x3D; (p−1)&#x2F;2 的素数，g ∈ G 的阶为 q（即 gq &#x3D; 1）。 设置 y &#x3D; gα 为一些随机 α ∈ {1, . . . , q − 1}。 定义散列函数 H(m; r) &#x3D; gmyr。<br>(a) 基于不给定 α 的离散对数问题，证明 H 是抗碰撞的。<br>(b) 当给定 α 时，它是否抗碰撞？</p>
<p>(a) 假设已知 H(m1; r1) &#x3D; H(m2; r2). Then<br>$g^{m1}y^{r1} &#x3D; g^{m2}y^{r2}\g^{m1}g^{\alpha r1}&#x3D;g^{m2}g^{\alpha r2} &amp; \text{since } y &#x3D; g^\alpha \ g^{m1+\alpha r1} &#x3D;g^{m2+\alpha r2}\ m1+\alpha r1 &#x3D; m2+ \alpha r2 \ \alpha(r1-r2)&#x3D;m2-m1\ \alpha&#x3D; (m2-m1)(r1-r2)^{-1} $</p>
<p>因此，只要发现碰撞使得 $m2 \not&#x3D; m1$，就可以很容易地找到 y 相对于 g 的离散对数 $(log_g{y} &#x3D; \alpha)$。 因此，如果我们假设离散对数问题很难，那么没有人应该能够轻松恢复，因此 H 必须是抗碰撞的。<br>(b) 否。当已知时，可以很容易地发现讲座中所示的碰撞。 例如，选取 $m1;m2; r1 (m1 \not&#x3D; m2)$ 并设 $r2 &#x3D; \alpha^{-1}(m1 - m2) + r1$。 那么，H(m1;r1) &#x3D; H(m2;r2)。</p>
<h2 id="W10-DB-Security-Searchable-Encryption-可搜索加密"><a href="#W10-DB-Security-Searchable-Encryption-可搜索加密" class="headerlink" title="W10: DB Security - Searchable Encryption 可搜索加密"></a>W10: DB Security - Searchable Encryption 可搜索加密</h2><p>考点：可搜索加密，类别&amp;查询类型，2个典型原型（Deterministic，Order preserving），泄露，泄露滥用攻击，更强安全保障是原型（CryptDB，FHE）</p>
<p>External adversary 外部对手</p>
<ul>
<li>访问控制：用户名密码</li>
<li>防火墙：防止 DoS 攻击</li>
<li>软件补丁：防止 SQL 注入</li>
</ul>
<p><strong>Internal adversary</strong></p>
<ul>
<li><strong>加密：最后的“门户”！ （前提是密钥是安全的！）</strong></li>
</ul>
<p>可搜索加密</p>
<p>普通加密，例如 AES 和 RSA，不起作用（有效地）：</p>
<ul>
<li>没有可搜索性</li>
<li>需要解密密文</li>
<li>将敏感数据暴露给云服务器是不安全的</li>
</ul>
<p>可搜索加密</p>
<ul>
<li>允许从加密数据中搜索关键字</li>
<li>用户从关键字生成搜索标记</li>
<li>搜索请求的令牌发送到服务器，服务器返回一组包含此关键字的加密文档</li>
<li>服务器对关键字一无所知，只知道包含该关键字的加密文档的数量（理想情况下）</li>
</ul>
<p><strong>类别</strong></p>
<p>支持的操作</p>
<ul>
<li>静态 SE：仅搜索查询</li>
<li>动态 SE：插入、删除、更新和搜索查询</li>
</ul>
<p>密钥管理</p>
<ul>
<li>单用户</li>
<li>单个数据写入器和多个数据读取器</li>
<li>多个数据写入器和多个数据读取器</li>
</ul>
<p>加密原语</p>
<ul>
<li>对称 SE (SSE)</li>
<li>公钥 SE (PKSE)</li>
</ul>
<p>威胁模型</p>
<ul>
<li>SE → 诚实但好奇的对手（半信任）</li>
<li>可验证的 SE → 恶意对手</li>
</ul>
<p><strong>查询类型</strong></p>
<ul>
<li>单关键字搜索，例如，keyword&#x3D;”searchable encryption”</li>
<li>范围查询，例如 年龄 &gt;18</li>
<li>布尔查询，例如“蒙纳士大学”和“学生”</li>
<li>排名搜索，例如 查找与“SE”最相关的文档</li>
</ul>
<p>更复杂的查询，例如 count、max 和 group by，可能需要依赖</p>
<ul>
<li>同态加密 (HE)</li>
<li>可信执行环境 (TEE)</li>
</ul>
<h3 id="Searchable-Encryption-Primitive"><a href="#Searchable-Encryption-Primitive" class="headerlink" title="Searchable Encryption Primitive"></a>Searchable Encryption Primitive</h3><h4 id="确定性加密-Deterministic-Encryption-DE"><a href="#确定性加密-Deterministic-Encryption-DE" class="headerlink" title="确定性加密 Deterministic Encryption (DE)"></a>确定性加密 Deterministic Encryption (DE)</h4><p>相同的输入（明文），相同的输出（密文）：即没有随机性，例如 AES-ECB（相同的IV），</p>
<p>最简单的方案：客户端使用 DE 方案使用每列密钥 K 加密数据库的每一列</p>
<p>DE 保留明文的平等性并允许简单有效的搜索</p>
<p>许多行业兴趣和一些用途（例如 CryptDB</p>
<h4 id="保序加密-Order-Preserving-Encryption-OPE"><a href="#保序加密-Order-Preserving-Encryption-OPE" class="headerlink" title="保序加密 Order Preserving Encryption (OPE)"></a>保序加密 Order Preserving Encryption (OPE)</h4><p>DE 快速、简单且与现有 DBMS 兼容</p>
<p>但是，问题：如何搜索范围？如果使用普通 DE 则不可能</p>
<p>例如。 如果我们使用 AES 加密 (1,2,3)，我们可能会得到：<br>— 8493540201039434290 &#x3D; ENC(1)<br>— 2939025796054939211 &#x3D; ENC(2)<br>— 1040304585702197218 &#x3D; ENC(3)</p>
<p>每个密文看起来像一个随机数<br>明文顺序之间没有关系</p>
<p>一种特殊类型的 DE 称为**保序加密 (OPE)**，即满足 如果 x &lt; y 那么 Enc( x ) &lt; Enc y</p>
<p>希望查询范围 [ a, b ] 的客户端改为向服务器发送范围 [ Enc(a),  Enc(b)] 的查询</p>
<p>例如。<br>— 142321645 &#x3D; ENC(1)<br>— 232402329 &#x3D; ENC(2)<br>— 520403567 &#x3D; ENC(3)<br>— 593029476 &#x3D; ENC(4)<br>— 934820471 &#x3D; ENC(5)</p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>DE 保留密文空间中明文的频率<br>假设攻击者有辅助信息——对明文分布的合理准确的估计。</p>
<p>CryptDB 正面临这个问题！</p>
<p>对服务器的泄漏对于 OPE 来说会更大<br>服务器不仅知道频率，而且知道明文的顺序！</p>
<p>例如。<br>– 第 1 列：学生证<br>– 第 2 栏：考试成绩</p>
<p>尽管服务器不知道任何标记的确切学生 ID，但服务器可能知道：<br>– 标记分布<br>– 学生的表现如何</p>
<h3 id="CryptDB"><a href="#CryptDB" class="headerlink" title="CryptDB"></a>CryptDB</h3><p>第一个功能齐全的加密数据库系统， 由麻省理工学院的一组研究人员于 2011 年设计<br>Raluca Ada Popa , Catherine M. S. Redfield, Nickolai Zeldovich , and Hari Balakrishnan , CryptDB : Processing Queries on an Encrypted Database , In Proceedings of the 23rd ACM Symposium on Operating Systems Principles (SOSP ), 2011<br>代码：<a href="https://github.com/CryptDB/cryptdb" target="_blank" rel="noopener">https://github.com/CryptDB/cryptdb</a></p>
<p>数据库中的机密数据泄露</p>
<p>威胁 1：被动（内部的）数据库服务器攻击<br>威胁 2：对所有服务器的任何攻击（外部）</p>
<p>目标：保护数据的机密性</p>
<img src="/post/fit5163-sec-notes/image-20211115163856961.png" class="" title="image-20211115163856961">

<ol>
<li>处理对加密数据的SQL查询</li>
<li>使用细粒度的键（fine grained keys）； 根据访问控制将这些密钥链接到用户密码</li>
</ol>
<p>贡献：</p>
<ol>
<li>第一个实用的 DBMS 来处理对加密数据的大多数 SQL 查询 → Hide DB from sys. admins ., 将数据库外包到云端</li>
<li>保护在攻击期间注销的用户数据，即使所有服务器都受到威胁</li>
<li>适度的开销：TPC C 26% 的吞吐量损失</li>
<li>DBMS（例如 Postgres、MySQL）没有变化，对于威胁 1，应用没有变化</li>
</ol>
<p>Threat 1: Passive attacks to DB Server</p>
<img src="/post/fit5163-sec-notes/image-20211115164544909.png" class="" title="image-20211115164544909">

<p>处理对加密数据的 SQL 查询 （本质就是用上面的OPE处理值</p>
<p>两种技术</p>
<ol>
<li>使用 SQL 感知加密方案集</li>
<li>根据查询调整数据库加密</li>
</ol>
<p>加密模式</p>
<p>列名： 模式 | 构造器 | 功能</p>
<p>功能性Functionality与安全性反向</p>
<img src="/post/fit5163-sec-notes/image-20211115165101506.png" class="" title="image-20211115165101506">

<p>JOIN</p>
<p>攻击者不知道列要加入先验（就是图中的key for col）！</p>
<img src="/post/fit5163-sec-notes/image-20211115170341919.png" class="" title="image-20211115170341919">

<ul>
<li>KeyGen (sec. param ): SK (最左边黄Key)</li>
<li>Encrypt (SK, m, col i ): $C_m^i$ (使用私钥（不在图中）) → deterministic</li>
<li>Token (SK, col i , col j): $t_i$ , $t_j$（使用左二红Key）</li>
<li>Adjust( $t_i$ , $C_m^i$):  $C_m$ (使用最右灰Key)</li>
</ul>
<p>正确性：调整产生正确的Join关系</p>
<p>安全性：无法得知没有令牌的连接关系</p>
<p>实现：192 位长，0.52 毫秒加密，0.56 毫秒调整</p>
<p>如何加密每个数据项？需要的加密方案取决于查询，提前可能不知道查询， 如图在使用rank时候在OPE阶段泄露了值的顺序</p>
<img src="/post/fit5163-sec-notes/image-20211115171400444.png" class="" title="image-20211115171400444">

<p>因此需要加密“洋葱”模式Onions of encryptions，通过包裹加密来保证安全</p>
<img src="/post/fit5163-sec-notes/image-20211115171608724.png" class="" title="image-20211115171608724">

<p>同一洋葱层的列中所有项目使用相同的Key<br>以最安全的加密方案启动数据库</p>
<p>例如：<code>SELECT * FROM emp WHERE rank = &#39;CEO&#39;</code>修改为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table1 <span class="keyword">SET</span> col1 OnionEq Decrypt_RND(key, col1 OnionEq); <span class="operator">/</span><span class="operator">/</span> 使用新<span class="keyword">table</span>存放RND值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> col1 OnionEq <span class="operator">=</span> xda5c0407; <span class="operator">/</span><span class="operator">/</span> xda5c0407 为 CEO对应值</span><br></pre></td></tr></table></figure>

<p>DB Implementation</p>
<img src="/post/fit5163-sec-notes/image-20211115172013464.png" class="" title="image-20211115172013464">

<p>DBMS 层 没有变化<br>便携：从 Postgres 到 MySQL 86 行<br>威胁 1 解决方案： 无需更改应用程序</p>
<p>性能损失26%</p>
<h3 id="Searchable-Encryption中的泄漏"><a href="#Searchable-Encryption中的泄漏" class="headerlink" title="Searchable Encryption中的泄漏"></a>Searchable Encryption中的泄漏</h3><p>如果我们使用概率加密来加密记录和查询会怎样？ 可以隐藏频率和订单信息</p>
<p>访问模式泄漏：<br>• 有多少记录匹配每个查询（大小模式泄漏<br>• 哪些记录与每个查询匹配<br>• 查询是否匹配相同的记录</p>
<h4 id="Leakage-abused-Attacks-泄漏滥用攻击"><a href="#Leakage-abused-Attacks-泄漏滥用攻击" class="headerlink" title="Leakage-abused Attacks 泄漏滥用攻击"></a>Leakage-abused Attacks 泄漏滥用攻击</h4><p>被动攻击</p>
<ul>
<li>IKK （访问模式</li>
<li>计数攻击Count attack（大小模式</li>
<li>频率分析攻击Frequency Analysis Attack（频率信息。</li>
<li>。。。</li>
</ul>
<p>主动攻击</p>
<ul>
<li>文件注入攻击 （访问模式</li>
<li>选择文档攻击（访问模式</li>
<li>记录注入攻击（访问模式</li>
<li>。。。</li>
</ul>
<h4 id="可搜索加密的权衡"><a href="#可搜索加密的权衡" class="headerlink" title="可搜索加密的权衡"></a>可搜索加密的权衡</h4><p>理想位置如图五角星处，右上是被泄漏滥用攻击广泛破坏的，左下是完全同态加密，功能性加密，遗忘内存</p>
<img src="/post/fit5163-sec-notes/image-20211115200422317.png" class="" title="image-20211115200422317">

<p>同态性质</p>
<p>$E(p_0 ) \bigotimes E(p_1) &#x3D; E(p_0 \cdot p_1)$</p>
<p>其中 • 是明文域中的一些操作，$\bigotimes$ 是密文域中的一些操作</p>
<p>• 有助于获得隐私保护财产<br>• 对加密数据的计算<br>• 节省隐私保护网络应用程序的通信成本</p>
<p>例如RSA的同态性 RSA is homomorphic</p>
<p>使$E(p_0 ) \times E(p_1) &#x3D; E(p_0 \times p_1)$ 其中 x 表示乘法，在RSA的加密$c &#x3D; E(p, pk) &#x3D;p^{pk} \mod n$</p>
<p>则可得$E(p_0)\times E(p_1) &#x3D; p_0^{pk}\mod n \times p_1^{pk}\mod n&#x3D; (p_0\times p_1)^{pk} \mod n &#x3D; E(p_0 \times p_1)  $</p>
<h3 id="Tut-5"><a href="#Tut-5" class="headerlink" title="Tut"></a>Tut</h3><p>文字题略</p>
<h2 id="W11-Implementing-and-Protecting-Cryptographic-primitives-实施和保护加密原型"><a href="#W11-Implementing-and-Protecting-Cryptographic-primitives-实施和保护加密原型" class="headerlink" title="W11: Implementing and Protecting Cryptographic primitives 实施和保护加密原型"></a>W11: Implementing and Protecting Cryptographic primitives 实施和保护加密原型</h2><p>算法、攻击和对策</p>
<p>review里只有三类attacks（Non-, Semi-, invasive）</p>
<h3 id="费马小定理寻找乘法逆"><a href="#费马小定理寻找乘法逆" class="headerlink" title="费马小定理寻找乘法逆"></a>费马小定理寻找乘法逆</h3><p>设 p 为质数，元素 a &lt; p；<br>然后 $a^{p-1} \mod p &#x3D; 1$ 否则 $a^p \mod p &#x3D; a$<br>我们可以找到 a 的倒数（假设是 x，这样 $ax \mod p &#x3D; 1$）<br>$a \in (Z_p)^*$ ⇒ $a⋅a^{p-2} \mod p &#x3D; 1$ ⇒ $ a−1 &#x3D; a^{p-2} \mod p$ ($a^{p-2 }$在$Z_p$上)<br>例如</p>
<p>3 mod 5 的乘法逆<br>即$ 3^{-1} \mod 5 &#x3D; 3^{5-2 } \mod 5$</p>
<p>$3^3 \mod 5 &#x3D; 27 \mod 5 &#x3D; Q &#x3D; 5，R &#x3D; 2$</p>
<p>验证：$2^{5-2} \mod 5 &#x3D; 2^3 \mod 5 &#x3D; 8 \mod 5 &#x3D; 3$</p>
<p>(为了使定理有效，组中的所有元素必须有一个乘法逆，即。 Gcd(a,p)&#x3D;1)</p>
<h3 id="使用扩展欧几里得算法查找乘法逆"><a href="#使用扩展欧几里得算法查找乘法逆" class="headerlink" title="使用扩展欧几里得算法查找乘法逆"></a>使用扩展欧几里得算法查找乘法逆</h3><p>为了解决欧几里德算法非常数轮问题，我们使用扩展的欧几里德算法来计算 gcd(a,p) 使用以下公式：<br>$a \cdot x + y \cdot p &#x3D; gcd(a, p)$<br>然而，如果 gcd(a, p)&#x3D;1，如 Ζp 的情况，则：<br>$a \cdot \alpha^{-1} + y \cdot p &#x3D; 1$<br>因此我们可以找到 $\alpha$ 的乘法逆</p>
<p>Euclid (a, p)<br>1 (X1,X2,X3) ← (1, 0, p); (Y1, Y2, Y3) ← (0, 1, a)<br>2 IF Y3 &#x3D; 0, RETURN X3 &#x3D; GCD (a, p); No inverse<br>3 If Y3 &#x3D; 1, RETURN Y3 &#x3D; GCD (a, p); Y2 &#x3D; a-1 mod f<br>4 Q &#x3D; X3&#x2F;Y3<br>5 (T1,T2,T3) ← (X1 - QY1, X2 - QY2, X3 - QY3)<br>6 (X1,X2,X3) ← (Y1,Y2,Y3)<br>7 (Y1,Y2,Y3) ←  (T1,T2,T3)<br>8 GOTO 2</p>
<p>在计算过程中，必须始终为True：<br>fT1 + dT2 &#x3D; T3； fX1 + dX2 &#x3D; X3； fY1 + dY2 &#x3D; Y3</p>
<p>有限域（回顾）</p>
<p>有限元素个数 GF(p) &#x3D; {0, 1, …, p-1}。<br>p：称为有限域字符 GF p 特征的素数<br>扩展有限域<br>当 q &#x3D; p k 时，GF q 在 GF p 上<br>• k &#x3D; 1: 质数场，GF(p)<br>• p &#x3D; 2: 二元扩展有限域，$GF (2^k)$<br>如何实现模运算？</p>
<p>GF(p) 字段（加减）: 在 GF(p) 中定义为模加减法。</p>
<p>$(a+b) \mod p &#x3D; \begin{cases} a+b &amp; \text{if }a+b&lt;p\ a+b-p &amp; \text{if } a+b \ge p\end{cases} $</p>
<p>$(a-b) \mod p &#x3D; a-b$</p>
<p>整数加法或减法<br>对于硬件：加减的相关架构是：Ripple Carry, Carry Lookahead, Carry Save, Carry Select ή Carry Skip adders</p>
<p>GF(p) 场（模乘）$(x \cdot y)\mod p$</p>
<p>步骤 1. 整数乘法（Karatsuba - Ofman<br>步骤 2. 对步骤 1 的整数乘法结果进行模 p 运算（Barret’s Reduction，Montgomery Reduction）</p>
<p>或者直接 整数乘法与模 p 约简</p>
<p>Montgomery 蒙哥马利算法：𝑐 &#x3D; 𝑥 ⋅ 𝑦 ⋅ 𝑟^−1 mod 𝑝<br>Μodulo squareing : 模乘法适当简化，因为对于 𝒄 &#x3D; 𝒙 ⋅ 𝒚 𝐦𝐨𝐝 𝒑 有 x &#x3D; y。</p>
<h3 id="蒙哥马利模乘法（MontM-x-y-p-函数）"><a href="#蒙哥马利模乘法（MontM-x-y-p-函数）" class="headerlink" title="蒙哥马利模乘法（MontM(x,y,p) 函数）"></a>蒙哥马利模乘法（MontM(x,y,p) 函数）</h3><p>输入：$ x &#x3D; {x_{n-1},…,x_2, x_1, x_0 }<em>b &lt; p,\ y &#x3D; {y</em>{n-1},…,y_2, y_1 , y_0 }<em>b &lt; p,\ p &#x3D; {p</em>{n-1},…, p_1, p_0 }_b,\ r &#x3D; b^n, p^\prime &#x3D; -p^{-1} \mod b$ b: 一个常数（通常是 2 的幂）<br>输出：$c  &#x3D; x \cdot y \cdot r^{-1} \mod p$ </p>
<ol>
<li>c &#x3D; 0</li>
<li>对于 i&#x3D;0 到 n-1 做</li>
</ol>
<p>2.1. $q&#x3D;(c_0+x_i\cdot y_0)p^\prime \mod b$<br>2.2. $c&#x3D;\frac{c+x_i\cdot y+q\cdot p}{b}$<br>3. 如果 $c \ge p$ 那么 c &#x3D; c – p<br>4. 返回 c.</p>
<p>蒙哥马利域</p>
<p>有一个数字 $X_R &#x3D; X ⋅ 𝑟 \mod 𝑝$，而不是数字 X </p>
<p>在蒙哥马利域中的数字之间执行蒙哥马利乘法产生也在蒙哥马利域中的结果</p>
<h3 id="模幂算法-Modular-Exponentiation-Algorithm"><a href="#模幂算法-Modular-Exponentiation-Algorithm" class="headerlink" title="模幂算法 Modular Exponentiation Algorithm"></a>模幂算法 Modular Exponentiation Algorithm</h3><p>输入：g in G and x&gt;0 ; 输出： G 中的 $g^x$<br>表示 $x &#x3D; (x_n x_{n-1} … x_2 x_1 x_0)_2$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y ⟵ g, z ⟵ 1</span><br><span class="line">for i = 0 to n：</span><br><span class="line">	if (x[i] == 1): z ⟵ z⋅y</span><br><span class="line">	y ⟵ y2</span><br><span class="line">output z</span><br></pre></td></tr></table></figure>

<p>例如</p>
<img src="/post/fit5163-sec-notes/image-20211115024145749.png" class="" title="image-20211115024145749">

<h3 id="高效的模幂算法"><a href="#高效的模幂算法" class="headerlink" title="高效的模幂算法"></a>高效的模幂算法</h3><p>蒙哥马利模幂（MontMexp(x,e,p) 函数）</p>
<p>输入：$ x &#x3D; {x_{n-1},…,x_2, x_1, x_0 }<em>2 &lt; p,\ y &#x3D; {y</em>{n-1},…,y_2, y_1 , y_0 }<em>2 &lt; p,\ p &#x3D; {p</em>{n-1},…, p_1, p_0 }_2,\ r &#x3D; b^n $ （通常 b&#x3D;2 或 2 的幂）<br>输出：$c  &#x3D; x^e \mod p$ </p>
<ol>
<li>$ c&#x3D; r\mod p $</li>
<li>$g &#x3D; r^2 \mod p $</li>
<li>$\bar{x} &#x3D; x \cdot g \cdot r^{-1} \mod p $</li>
<li>For i in (n-1) to 0:<ol>
<li>$c &#x3D; c \cdot c \cdot r^{-1} \mod p $</li>
<li>if $e_i &#x3D; 1$ then $c&#x3D;c\cdot \bar{x} \cdot r^{-1} \mod p$</li>
</ol>
</li>
<li>$ c &#x3D;c \cdot 1 \cdot r^{-1} \mod p$</li>
<li>Return c</li>
</ol>
<p>转换为蒙哥马利格式：<br>如果 G 中的 x（例如 GF(p) ή Ζp*）然后我通过在 a 和 r^2 mod p 之间执行蒙哥马利乘法来归一化 𝑥 ⋅ 𝑟 𝑚𝑜𝑑 𝑝（蒙哥马利格式）中的 x。 为什么？</p>
<p>如何从蒙哥马利格式转换为常规 G 元素？</p>
<p>基于离散对数问题的密码系统怎么样？<br>离散对数计算实际上是模幂运算蒙哥马利模幂运算算法也适用于此。</p>
<h3 id="攻击模型-1"><a href="#攻击模型-1" class="headerlink" title="攻击模型"></a>攻击模型</h3><p>安全设备存储和处理机密信息。<br>主要的秘密是私钥或公钥<br>密码学是安全应用程序（硬件或软件）中的关键点</p>
<p>目标：<br>查找使用的密钥<br>通过检索会话密钥来利用安全协议</p>
<h4 id="Non-invasive-attacks-low-cost-非侵入式攻击（低成本）"><a href="#Non-invasive-attacks-low-cost-非侵入式攻击（低成本）" class="headerlink" title="Non-invasive attacks (low-cost) 非侵入式攻击（低成本）"></a>Non-invasive attacks (low-cost) 非侵入式攻击（低成本）</h4><p>• 观察或操作设备，<strong>无需物理修改</strong><br>• <strong>不留下篡改证据</strong>——难以发现<br>• 只需要中等复杂的设备和知识即可实施<br>• 示例：功率分析攻击power analysis attacks、时序攻击 timing attack</p>
<h4 id="Invasive-attacks-expensive-侵入性攻击（昂贵）"><a href="#Invasive-attacks-expensive-侵入性攻击（昂贵）" class="headerlink" title="Invasive attacks (expensive) 侵入性攻击（昂贵）"></a>Invasive attacks (expensive) 侵入性攻击（昂贵）</h4><p>• 几乎无限的能力从芯片中提取信息并了解其功能<br>• 需要直接访问设备的内部组件<br>• 通常需要昂贵的设备、知识渊博的攻击者和时间<br>• 示例：微测 microprobing</p>
<h4 id="Semi-invasive-attacks-affordable-半侵入式攻击（经济实惠）"><a href="#Semi-invasive-attacks-affordable-半侵入式攻击（经济实惠）" class="headerlink" title="Semi-invasive attacks (affordable) 半侵入式攻击（经济实惠）"></a><strong>Semi-invasive attacks (affordable) 半侵入式攻击（经济实惠）</strong></h4><p>• 我们可以在计算过程中注入故障并观察故障结果。 系统内部结构<strong>保持完整</strong><br>• 填补了非侵入性和侵入性类型之间的空白，既便宜又易于重复</p>
<h3 id="抗侵入性攻击（防篡改antitampering）"><a href="#抗侵入性攻击（防篡改antitampering）" class="headerlink" title="抗侵入性攻击（防篡改antitampering）"></a>抗侵入性攻击（防篡改antitampering）</h3><p>• 将整个安全核心包裹在细粒度的电子网格中<br>• 将核心包裹在环氧树脂中<br>• 光敏二极管、温度传感器、篡改传感器<br>• 检测电压和电流变化的传感器<br>• 当检测到攻击时，芯片应用数据归零，或者芯片变得无用</p>
<p>防篡改级别：<br>• 零级<br>• 级别低<br>• 关卡模型<br>• 关卡模组<br>• 级别模式<br>• 级别高</p>
<h3 id="非侵入性（侧信道）攻击-SCA"><a href="#非侵入性（侧信道）攻击-SCA" class="headerlink" title="非侵入性（侧信道）攻击 SCA"></a>非侵入性（侧信道）攻击 SCA</h3><p>安全模型：黑盒<br>攻击数学算法<br>控制输入&#x2F;输出<br>但是：内部计算和密钥完全隐藏</p>
<p>现实：<br>攻击整个实现<br>实现泄漏了有关内部的部分信息<br>泄漏：例如功耗、运行时间、电磁辐射</p>
<h4 id="side-channel-侧信道"><a href="#side-channel-侧信道" class="headerlink" title="side-channel 侧信道"></a>side-channel 侧信道</h4><p>• 针对不同计算时间的定时攻击<br>– 不正确的密码验证：在不正确的字节上终止，不同的计算<br>不正确字节的长度<br>– 加密算法的错误实现：性能优化、缓存<br>内存使用，非固定时间操作<br>• 今天：传统的计时攻击变得更难应用<br>– 制造商修复了常见错误<br>– 内部时钟源和 PLL 的使用使分析变得困难<br>– 对策已到位：随机时钟、虚拟周期<br>– 仔细选择硬件可消除许多问题<br>但…。 由于处理器使用缓存内存导致的时序泄漏！！</p>
<p><strong>功耗分析 Power analysis</strong>：及时测量功耗<br>– 非常简单的一套设备 – 一台带有示波器和电源线中的小电阻的 PC；对许多密码算法和密码验证方案非常有效<br>– 需要电气工程和数字信号处理方面的一些知识<br>– 两种基本方法：简单（SPA）和差分（DPA）<br>**电磁分析 Electro-magnetic analysis (EMA)**：测量发射<br>– 类似于功率分析，但不是电阻器，而是使用小型磁性线圈，允许在芯片上进行精确定位<br><strong>今天：SPA&#x2F;DPA 和 EMA 变得更具挑战性</strong><br>– 更高的工作频率和噪音：需要更快的设备<br>– 电源从 5V 降至 1V：信号更低，噪声更大<br>– 8 位数据与 32 位数据：更难区分单位变化<br>– 更复杂的电路：来自其他部件的噪声更高，因此需要更多的信号平均和数字信号处理<br>– 许多密码算法的有效对策</p>
<h4 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h4><h5 id="简易攻击"><a href="#简易攻击" class="headerlink" title="简易攻击"></a>简易攻击</h5><p>攻击者直接使用来自一次测量的旁道信息来确定（部分）密钥。 简单的分析攻击利用了执行的操作和侧信道信息之间的关系。</p>
<h5 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h5><p>• 使用许多测量来滤除噪声。 差分分析攻击利用了处理过的数据和侧信道信息之间的关系。<br>• 被攻击设备的假设模型：该模型用于预测<br>• 设备边信道信息的几个值。<br>• 将这些预测与实际测量的设备侧信道信息进行比较。 通过对数据应用统计方法进行比较。</p>
<h5 id="时序攻击"><a href="#时序攻击" class="headerlink" title="时序攻击"></a>时序攻击</h5><p><strong>基本思想</strong>：通过观察执行各种计算需要多长时间来了解系统的秘密</p>
<p><strong>典型目标</strong>：提取私钥</p>
<p>非常强大，因为隔离无济于事<br>• 受害者可能是远程的<br>• 受害者可能在自己的虚拟机中<br>• 钥匙可以放在防篡改存储或智能卡中<br>攻击者只需测量响应时间即可获胜</p>
<h5 id="缓存攻击"><a href="#缓存攻击" class="headerlink" title="缓存攻击"></a>缓存攻击</h5><p>• 缓存攻击：通过缓存地址泄漏进行密码分析<br>• 纯软件<br>• 无特殊特权<br>• 不与加密代码交互<br>• 非常高效<br>• 在 65 毫秒内从 Linux 加密分区中提取完整的 AES 密钥<br>• 损害其他安全性良好的系统<br>• “商品化”侧信道攻击：<br>• 易于部署的软件会破坏许多常见系统</p>
<p>Address leakage 地址泄露</p>
<p>• 缓存是共享资源：<br>• 缓存大小有限：L1 缓存限制在 8 KB 到 64 KB 之间<br>• 进程&#x2F;线程争夺缓存<br>• 缓存状态影响并受所有进程&#x2F;线程的影响，导致进程&#x2F;线程之间的串扰<br>• 缓存数据受内存保护……<br>• 未受攻击<br>• 但是“元数据”会泄露有关内存访问模式的信息：正在访问哪些地址。</p>
<h5 id="差分侧信道攻击"><a href="#差分侧信道攻击" class="headerlink" title="差分侧信道攻击"></a>差分侧信道攻击</h5><p>• DPA （differential power analysis）统计原理<br>– 收购程序<br>– 选择和预测<br>– 微分运算符和曲线<br>– 使用 DPA 指标进行逆向工程</p>
<p>案例：微分功耗攻击的步骤</p>
<ol>
<li>在设备上随机消息的正常加密&#x2F;解密过程中收集电源跟踪</li>
<li>对Key进行假设，并基于该假设密钥上的已知功率模型收集功率轨迹</li>
<li>对各种关键位重复假设</li>
</ol>
<p>4.对未知正确密钥的假设密钥功率迹线和实测功率迹线之间进行统计分析（例如相关性）。<br>5. 提取加密&#x2F;解密密钥。</p>
<p>案例：使用垂直（相关分析）攻击攻击 AES 硬件易受攻击的实现</p>
<p>功耗模型</p>
<p>● 功耗如何取决于中间值<br>● 单位模型——例如。 最低位(v)<br>● Hamming weight： HW(v)<br>○ 主要适用于处理器、带上拉的总线等。<br>● Hamming distance：$HD(v ,v’ )&#x3D; HW(v \bigoplus v’ )$<br>○ 也适用于 ASIC、FPGA<br>○ v’ 是前一个值（在寄存器中，在总线上，在门中）<br>○ 如果 v’ 是常数或不均匀分布，通常 HW 也能工作</p>
<p>计算相关性Correlation<br>● 存在多种方法<br>○ 均值差、均值距离、相关系数<br>● 相关系数<br>● 更精确的点估计<br>● 范围</p>
<h3 id="半侵入式攻击（故障注入）"><a href="#半侵入式攻击（故障注入）" class="headerlink" title="半侵入式攻击（故障注入）"></a>半侵入式攻击（故障注入）</h3><p>紧急故障Glitch Faults<br>• 时钟<br>• 电压<br>• 数据损坏<br>激光束、聚焦离子束等<br>目标：<br>• 随机字节或位翻转<br>• 字节中的特定位<br>• 在选定的时间内随机或特定位或字节翻转</p>
<p>故障注入安全错误</p>
<p>蒙哥马利功耗梯故障注入安全错误</p>
<h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><h4 id="SCA侧信道攻击对策"><a href="#SCA侧信道攻击对策" class="headerlink" title="SCA侧信道攻击对策"></a>SCA侧信道攻击对策</h4><p>• 算法变异对策<br>– 掩蔽&#x2F;致盲 → 随机化可与敏感信息相关联的数据<br>– 提供最终消除盲区的方法（在算法内）。</p>
<p>• 基于实施的对策<br>– 隐藏：使泄漏跟踪独立于中间值和执行的操作。<br>– 使泄漏迹线无法与噪声区分开来<br>– 使泄漏跟踪恒定（例如双轨逻辑、预充电逻辑、互补电路）</p>
<h4 id="故障注入攻击对策"><a href="#故障注入攻击对策" class="headerlink" title="故障注入攻击对策"></a>故障注入攻击对策</h4><p>• 故障检测机制<br>– 面向实现（类似于防篡改）<br>– 面向算法（观察中间值数学或二进制值的一致性）<br>– 时间冗余<br>– 硬件冗余<br>– 信息冗余</p>
<p>• 确保故障始终传播<br>– 不要使用虚拟操作（与秘密数据相关）<br>– 感染计算原理：用一些隐藏数据感染计算，使故障注入无用<br>– 随机化</p>
<h3 id="Tut-6"><a href="#Tut-6" class="headerlink" title="Tut"></a>Tut</h3><p>基本上是内容回顾了</p>
<p>Using <strong>Fermat’s theorem</strong>, find 3^2001 mod 11</p>
<p>Fermat’s Theorem states<br>if p is prime and a is a positive integer not divisible by p, then a^{p−1} mod p ≡ 1. Therefore 3^10 mod 11 ≡ 1.<br>Therefore 3^2001 &#x3D; (3^10)^200 × 3 mod 11 &#x3D; 1 × 3 mod 11 &#x3D; 3</p>
<p>Using <strong>Multiplicative inverses Fermat little Theorem</strong>, find the multiplicative inverse of 3 mod 5?<br>The multiplicative inverse of 3 mod 5 is 3^{-1} mod 5 &#x3D; 3^{5-2} mod 5<br>Therefore 3^3 mod 5 &#x3D; 27 mod 5 &#x3D; <strong>2</strong></p>
<p>Using <strong>Multiplicative inverses Fermat little Theorem</strong>, find the multiplicative inverse of 8 mod 17?<br>8^{-1} mod 17<br>8^{17-2} mod 17 &#x3D; 8^15 mod 17 &#x3D; 8^7 * 8^8 mod 17 &#x3D; 15 * 1 mod 17 &#x3D; 15</p>
<p>文字题略</p>
<h2 id="W12-Blockchain"><a href="#W12-Blockchain" class="headerlink" title="W12: Blockchain"></a>W12: Blockchain</h2><p>密码学集大成者</p>
<p>似乎不在考试范围中！（至少review里没</p>
<p>因为太懂了所以略</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>• 20道选择题（共10分，每道0.5分）<br>• 6-8 道小作文题（共 50 分）<br>• 2 小时 + 10 分钟</p>
<p>哪种密码块操作模式（ECB 或 <strong>CBC</strong>）更常用？ 给出使用 CBC 优于 ECB 的一项优势和使用 CBC 优于 ECB 的一项劣势。</p>
<p>回想一下，对称密钥密码系统由三个函数组成：密钥生成器 G、加密函数 E 和解密函数 D。对于任意一对用户，例如 Alice (A) 和 Bob (B)，G 将 a 作为输入 随机位串并产生共享密钥 KAB 作为输出。 Alice 或 Bob 都可以获取明文消息 x 并产生密文消息 y ← E(x, KAB)。 密文 y 可以通过不安全的通道发送，接收者可以恢复 x ← D(y, KAB)。</p>
<p>a) 简要说明此类系统安全的三个基本要求。（可能是安全服务3目标，也可能是MAC部分提到的三原型<br>b) 为什么对称密钥密码学不足以作为安全互联网通信的基础，尤其是安全的基于 Web 的商务？（W5&amp;W6开头有写对称的缺点</p>
<p>Mock里最后一题有点难，估计会出类似题目（换公式</p>
<img src="/post/fit5163-sec-notes/image-20211116234057460.png" class="">

<p><a href="https://www.famnit.upr.si/sl/resources/files/knjiznica/studijsko-gradivo/epasalic-hashfunc-zbirka-nalog-2.pdf" target="_blank" rel="noopener">这里</a>(第9页)有个类似的答案<br>可能文不对题但是思路应该是一样的（Protocol A一致B不一致，答案对应的是</p>
<p>(a) 提供接收者在收到 y 时所做的事情的逐步描述:</p>
<p>解决方案:<br>接收方执行以下操作，协议 A：<br>• 使用k1 解密并获得x||H(k2||x)。 提取 x。<br>• 散列k2||x 并与H(k2||x) 进行比较。<br>对于协议 B（完全有缺陷）：<br>• 使用k_priv 解密并获得H(x)。 提取 x。<br>• 散列 x 并与 H(x) 进行比较</p>
<p>(b) 说明是否有以下安全服务：<br>• 保密<br>• 正直<br>• 不可否认性<br>为前一问题中给出的两个协议中的每一个给出。</p>
<p>解决方案:<br>在协议 A 的情况下：<br>• 保密性 - 是通过加密<br>• 完整性 - 是通过散列<br>• 不可否认性——双方都不能声称对方已经创建了消息。<br>在协议 B 的情况下：<br>• 机密性 - 不，没有加密<br>• 完整性 - 不，因为任何人都可以替换消息并计算散列<br>• 不可否认性- 没有人可以创建这样的消息。</p>
<p>（原题答案应该B是三性都有的，本质就是类似 AES_共有密钥(原文+签名)</p>
]]></content>
  </entry>
  <entry>
    <title>Notes for FIT9136: algo &amp; python</title>
    <url>/post/fit9136-algo-and-python-notes/</url>
    <content><![CDATA[<p>相对简单</p>
<span id="more"></span>

<h2 id="W5"><a href="#W5" class="headerlink" title="W5"></a>W5</h2><p>OOP</p>
<p>py3直接用<code>class XXX:</code>而不是2的<code>class XXX(object):</code> (3里俩写法等价) </p>
<h2 id="W6"><a href="#W6" class="headerlink" title="W6"></a>W6</h2><p>Stack: LIFO</p>
<p>Queue: FIFO</p>
<p>Heap: 就是一种特殊的树Tree。顶部（root）为一个极值（子树也是）。其中Node之间的连接叫Edge</p>
<h2 id="W7"><a href="#W7" class="headerlink" title="W7"></a>W7</h2><h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h3><p>复杂度这个概念和后面的各个算法都有关，所以挺重要的。</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210216001214995.png" class="" title="image-20210216001214995">

<p>计算方法是：</p>
<p>把算法函数内每个步骤的复杂度取出来，然后<code>+</code>起来</p>
<p>比如</p>
<blockquote>
<p> 2N + 2 -&gt; O(n)</p>
<p>n^2 + n + 1 -&gt; O(n^2)</p>
<p>log(n) + n + a -&gt; O(n)</p>
</blockquote>
<p>本质就是留下复杂度最大的那个（瓶颈）</p>
<p>这里1，N，N^2，N^N这些复杂度都很好理解。</p>
<p>但是log(N)是什么情况？</p>
<p><a href="https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly" target="_blank" rel="noopener">stackoverflow</a>这里给的例子就比较全面。</p>
<p><strong>O(log n):</strong> 选择要在其上执行某些动作的下一个元素是几种可能性之一，并且仅需要选择一个。</p>
<p>例如：给定一个人的名字，找到他的电话号码。所用方法是在尚未搜索的那本书（有序！）的一半左右随机选择一个点，然后检查该人的名字是否在该点上。 然后在此人名字所在的部分的一半左右重复该过程。（即对人名的binary search，二分法）</p>
<p><strong>O(n log n):</strong> 打印机办公室里有些混乱，我们的电话簿中的所有页面都是<strong>随机插入</strong>的。 通过查看每个页面上的名字，然后将该页面放在新的空电话簿中的适当位置，可以更正顺序，使其正确无误。</p>
<h3 id="Searching-Algorithm"><a href="#Searching-Algorithm" class="headerlink" title="Searching Algorithm"></a>Searching Algorithm</h3><p>Linear Search太简单，就一个个代，略</p>
<p>Binary Search参考上面O(log n)解析</p>
<h3 id="Sorting-Algorithm"><a href="#Sorting-Algorithm" class="headerlink" title="Sorting Algorithm"></a>Sorting Algorithm</h3><p>Bubble Sort: 就左右互换直到所有 左&lt;右。一般就先把最大&#x2F;最小挪到位然后再排。平均和最坏都是O(n^2)，最好是O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">the_list</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i): <span class="comment">#上个for从maxIndex到0,就是为了在这里省的写[0,index]直接range表示了</span></span><br><span class="line">            <span class="keyword">if</span> the_list[j] &gt; the_list[j+<span class="number">1</span>]:</span><br><span class="line">                temp = the_list[j]</span><br><span class="line">                the_list[j] = the_list[j+<span class="number">1</span>]</span><br><span class="line">                the_list[j+<span class="number">1</span>] = temp</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> the_list</span><br></pre></td></tr></table></figure>



<p>Selection Sort: 找index后面最小的然后互换。O(𝑛^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">the_list</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> the_list[j] &lt; the_list[smallest]:</span><br><span class="line">                smallest = j</span><br><span class="line"></span><br><span class="line">        the_list[smallest], the_list[i] = the_list[i], the_list[smallest] <span class="comment">#交换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> the_list</span><br></pre></td></tr></table></figure>



<p>Insertion Sort: 把每个源数组的元素有序地丢到新数组里。（比如先丢5，然后看见8了再丢5后面，看见7了确定丢5和8中间）。O(𝑛^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">the_list</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        current = the_list[i]</span><br><span class="line">        pos = i</span><br><span class="line">        <span class="keyword">while</span> pos &gt; <span class="number">0</span> <span class="keyword">and</span> the_list[pos-<span class="number">1</span>] &gt; current:</span><br><span class="line">            the_list[pos] = the_list[pos-<span class="number">1</span>]</span><br><span class="line">            pos -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        the_list[pos] = current <span class="comment">#丢</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> the_list</span><br></pre></td></tr></table></figure>



<h2 id="W8"><a href="#W8" class="headerlink" title="W8"></a>W8</h2><p>二叉树和二叉搜索树</p>
<p>二叉树本身不带规则，只规定这形状，要用起来就得自己给它加点规则</p>
<p>二叉搜索树就是带了“<em>左边小于右边</em>”这个规则</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210216010832615.png" class="" title="image-20210216010832615">



<p>Breadth（宽度） First Search (BFS)，即优先找横的（跨node！）</p>
<p>Depth First Search (DFS)，即优先找竖的（顺藤摸瓜）</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210216010612186.png" class="" title="image-20210216010612186">

<p>这些1234是查找时候的序列，不是值</p>
<p>另外还有个平衡Balance的概念，就把深度对对齐（±1）。</p>
<p>Balance有助于减少搜索步数N -&gt; logN </p>
<h2 id="W9"><a href="#W9" class="headerlink" title="W9"></a>W9</h2><p>测试，错误处理和外部库（讲的标准库，numpy，pandas和matplotlib）</p>
<p>assert onFalse, “err”</p>
<p>对于代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mark = <span class="number">0</span> <span class="comment"># variable to change</span></span><br><span class="line"><span class="keyword">if</span> mark &gt;= <span class="number">50</span> <span class="keyword">and</span> mark &lt;= <span class="number">100</span>:</span><br><span class="line">    grade = <span class="string">&quot;Passed&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    grade = <span class="string">&quot;Failed&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(grade)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="blue">Valid (positive) cases</font>:</p>
<ul>
<li>Based upon “correct” input data</li>
<li>Examples: 55, 60, 65, …, 85, 90, 95, …</li>
</ul>
</li>
<li><p><font color="blue">Invalid (negative) cases</font>:</p>
<ul>
<li>Based upon “incorrect” input data</li>
<li>Examples: -1, 0, 5, …, 45, 49, 101, 200, …</li>
</ul>
</li>
<li><p><font color="blue">Boundary cases</font>:</p>
<ul>
<li>Boundary values of the “equivalence class” for valid cases</li>
<li>Examples: (49, 50) and (100, 101)</li>
<li>即一个pair，其中元素一个能success一个就fail</li>
</ul>
</li>
</ul>
<h2 id="W10"><a href="#W10" class="headerlink" title="W10"></a>W10</h2><p>文件，库和包（RegExp）</p>
<h2 id="W11"><a href="#W11" class="headerlink" title="W11"></a>W11</h2><p>11和12有点难，Quiz11-12直接大意失荆州。</p>
<h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide-and-Conquer"></a>Divide-and-Conquer</h3><p>大意就是将func中任务细分（divide）然后逐个解决（conquer）最后合并（combine）</p>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>Binary Search是作为Divide-and-Conquer的例子出现的，并不是之前的BST（Binary Search Tree，w8内容）</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">the_list, target_item</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(the_list)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> the_list[mid] == target_item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target_item &lt; the_list[mid]:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rec_binary_search</span>(<span class="params">the_list, target_item</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(the_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(the_list) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> the_list[mid] == target_item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target_item &lt; the_list[mid]:</span><br><span class="line">            smaller_list = the_list[:mid]</span><br><span class="line">            <span class="keyword">return</span> rec_binary_search(smaller_list, target_item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            larger_list = the_list[mid+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">return</span> rec_binary_search(larger_list, target_item)</span><br></pre></td></tr></table></figure>

<h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><p>递归，简单，略</p>
<h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p>Merge Sort是作为Recursive的例子出现。</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210215085536597.png" class="" title="image-20210215085536597">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">the_list</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(the_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        mid = n //<span class="number">2</span> </span><br><span class="line"></span><br><span class="line">        left_sublist = the_list[:mid]</span><br><span class="line">        right_sublist = the_list[mid:]</span><br><span class="line"></span><br><span class="line">        merge_sort(left_sublist)</span><br><span class="line">        merge_sort(right_sublist)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># index for left sublist</span></span><br><span class="line">        j = <span class="number">0</span> <span class="comment"># index for right sublist</span></span><br><span class="line">        k = <span class="number">0</span> <span class="comment"># index for main list</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_sublist) <span class="keyword">and</span> j &lt;<span class="built_in">len</span>(right_sublist):</span><br><span class="line">            <span class="keyword">if</span> left_sublist[i] &lt;= right_sublist[j]:</span><br><span class="line">                the_list[k] = left_sublist[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                the_list[k] = right_sublist[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_sublist):</span><br><span class="line">            the_list[k] = left_sublist[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_sublist):</span><br><span class="line">            the_list[k] = right_sublist[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>Quick Sort也是作为Recursive的例子出现。</p>
<ul>
<li><font color="blue">Divide</font>: Select a “<strong>pivot</strong>” to serve as the partition point<ul>
<li>Elements smaller than the pivot are relocated to the left of the pivot</li>
<li>Elements greater than the pivot are relocated to the right</li>
</ul>
</li>
<li><font color="blue">Conquer</font>: Recursively partition the sublists based on the pivot chosen for each sublist</li>
<li><font color="blue">Combine</font>: No computation needed</li>
<li><font color="blue">Base case</font>: A sublist with length of one (considered sorted) or with zero length</li>
<li>Best case: O(n*log(n)) Worst case: O(n^2)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">the_list</span>):</span><br><span class="line">    first = <span class="number">0</span></span><br><span class="line">    last = <span class="built_in">len</span>(the_list)-<span class="number">1</span></span><br><span class="line">    quick_sort_aux(the_list, first, last)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort_aux</span>(<span class="params">the_list, first, last</span>):</span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        part_point = partitioning(the_list, first, last)</span><br><span class="line"></span><br><span class="line">        quick_sort_aux(the_list, first, part_point-<span class="number">1</span>)</span><br><span class="line">        quick_sort_aux(the_list, part_point+<span class="number">1</span>, last)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partitioning</span>(<span class="params">the_list, first, last</span>):</span><br><span class="line">    pivot_value = the_list[first]</span><br><span class="line"></span><br><span class="line">    left_index = first + <span class="number">1</span></span><br><span class="line">    right_index = last</span><br><span class="line">    </span><br><span class="line">    complete = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> complete:</span><br><span class="line">        <span class="keyword">while</span> left_index &lt;= right_index <span class="keyword">and</span> \</span><br><span class="line">            the_list[left_index] &lt;= pivot_value:</span><br><span class="line">                left_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right_index &gt;=  left_index <span class="keyword">and</span> \</span><br><span class="line">            the_list[right_index] &gt;= pivot_value:</span><br><span class="line">                right_index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right_index &lt; left_index:</span><br><span class="line">            complete = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            the_list[left_index], the_list[right_index] \</span><br><span class="line">            = the_list[right_index], the_list[left_index]</span><br><span class="line">                </span><br><span class="line">    the_list[first], the_list[right_index] \</span><br><span class="line">                = the_list[right_index], the_list[first]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> right_index</span><br></pre></td></tr></table></figure>

<h2 id="W12"><a href="#W12" class="headerlink" title="W12"></a>W12</h2><h3 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h3><ul>
<li>适合通常不会产生最佳解决方案的情况（就是没法直接一个solution直接撸</li>
<li>解决背包问题（Knapsack，即怎么把东西放到容量有限的背包里能收益最大化）</li>
<li>greedy不会先想着去满足最优，而是先想着把要求（塞满背包）给优先满足</li>
<li>有时，任何一种立马得出的解决方案都比几天之内才想出来的的最佳解决方案要好。</li>
<li>通常，某些算法会在运行时找到最佳解决方案，但需要一种假设的解决方案才能开始工作。 Greedy可以很容易地做到这一点。</li>
</ul>
<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute-Force"></a>Brute-Force</h3><ul>
<li>保证算出最优解Brute force guarantees the <font color="blue">optimal</font> result will be discovered because it explores every possibility.</li>
<li></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">brute_force</span>(<span class="params">solution, N</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(solution) == N:</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        options = getOptions()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> option <span class="keyword">in</span> options:</span><br><span class="line">            brute_force(solution + option, N)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getOptions</span>():</span><br><span class="line">    <span class="keyword">return</span> [ <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>) ]</span><br></pre></td></tr></table></figure>



<h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><ul>
<li>Backtracking is an improvement on Brute-force. It ensures that only solutions that are possible are generated.</li>
<li>Backtracking is a more elegant brute force. Behold(看作) what happens when brute force attempts to find a solution.</li>
</ul>
<p>用来解决类似N皇后（N*N的棋盘上放N个皇后）问题。本质也是暴力穷举</p>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><blockquote>
<p>What is the name of the following sort algorithm?</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210215081745028.png" class="" title="image-20210215081745028">

<p>Select one:</p>
<p>A. Merge Sort</p>
<p>B. Selection sort</p>
<p>C. Quick sort</p>
<p>D. Bubble sort</p>
<p>A:  Quick sort</p>
</blockquote>
<blockquote>
<p>What is the name of the algorithm for the following method ?</p>
<img src="/post/fit9136-algo-and-python-notes/image-20210215144139053.png" class="" title="image-20210215144139053">


<p>Select one:</p>
<p>A. Backtracking</p>
<p>B. Boyer - Moore</p>
<p>C. Greedy</p>
<p>D. Bruce Force</p>
<p>A: Bruce Force</p>
</blockquote>
<blockquote>
<p>Which of the problems or puzzles cannot be solved by backtracking method?</p>
<p>Select one or more:</p>
<p>A. travelling salesman problem</p>
<p>B. Knapsback</p>
<p>C. crossword</p>
<p>D. n-queen problem</p>
<p>A: A&amp;B</p>
</blockquote>
<p>只选了A，因为当时quiz时候找不到A。现在找发现好像C也找不到。</p>
<p>Crossword是通过边上给的提示来猜出一个N*N矩阵上的每个英文字母（含黑块，不用填）。因为和N-Queen一样只要得到一个解就能结束所以就能用backtrack。</p>
<p>Knapsback是背包问题，Greedy的案例。</p>
<p>travelling salesman problem根据Wikipedia解释就是解决*Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?*差不多就多点路线规划，个人理解应该需要Greedy</p>
<blockquote>
<p>In Brute Force, the best-case running time is O ( nm )</p>
<p>A: F</p>
</blockquote>
<p>The time complexity of brute force is <strong>O(mn)</strong>, which is sometimes written as <strong>O(n*m)</strong> . So, if we were to search for a string of “n” characters in a string of “m” characters using brute force, it would take us n * m tries. 另外没有best-case的说法</p>
<blockquote>
<p>Which of the following problems can be solved using a backtrack problem ?</p>
<p>Select one or more:</p>
<p>A. M colour map</p>
<p>B. N-Queen Problem</p>
<p>C. Knapsack</p>
<p>D. Tower of hanoi</p>
<p>A: A&amp;B&amp;D</p>
</blockquote>
<p>相比上面的又多了俩游戏。</p>
<p>M colour map，没找到，但是个人理解应该指的是<a href="https://en.wikipedia.org/wiki/Four_color_theorem" target="_blank" rel="noopener">Four color theorem</a>。用M种颜色不接触地涂满全部。</p>
<p><a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" target="_blank" rel="noopener">Tower of hanoi</a>，汉诺塔。找出方法从左搬到右<img src="/post/fit9136-algo-and-python-notes/300px-Tower_of_Hanoi.jpeg" class="" title="img"></p>
<blockquote>
<p>Which of the following is true about Quick and Merge sort</p>
<p>Select one or more:</p>
<p>A. The quick sort is an internal sorting method where the data is sorted in main memory.</p>
<p>B. None of the above</p>
<p>C. Quick sort is more efficient and works faster than merge sort in case of smaller array size or datasets.</p>
<p>D. Merge sort is more efficient and works faster than quick sort in case of larger array size or datasets.</p>
<p>A: A&amp;C&amp;D</p>
</blockquote>
<p>Quick Sort是一种内部排序方法（大概是说它不引入别的所以是内部？），其中数据在主内存中排序。√</p>
<p>在较小的数组或数据集的情况下，Quick Sort比Merge sort更有效且工作更快。√</p>
<p>在较大数组大小或数据集的情况下，Merge sort比Quick Sort更有效且工作更快。√</p>
<blockquote>
<p>Which of the following is the most stable sort and has less time complexity ?</p>
<p>Select one:</p>
<p>A. Merge Sort</p>
<p>B. Quick Sort</p>
<p>C. None.</p>
<p>D. Bubble Sort</p>
<p>A: Merge Sort</p>
</blockquote>
<p>Merge Sort的复杂度见下面</p>
<blockquote>
<p>The average case and worst case complexities for Merge sort algorithm are</p>
<p>Select one:</p>
<p>A. O ( n^2 ), O ( n^2 )</p>
<p>B. O ( n^2 ), O ( nlog2(n) )</p>
<p>C. O ( nlog2(n) ), O ( nlog2(n) )</p>
<p>D. O ( nlog2(n) ), O ( n^2 )</p>
<p>A: C. O ( nlog2(n) ), O ( nlog2(n) )</p>
</blockquote>
<p>Merge sort总是要迭代到<img src="/post/fit9136-algo-and-python-notes/image-20210216000638777.png" class="" title="image-20210216000638777"></p>
<p>这样全部打散</p>
<blockquote>
<p> For two objects x and y:</p>
<ul>
<li>x is y is True<br>if and only if</li>
<li>id(x) &#x3D;&#x3D; id(y)</li>
</ul>
<p>A: T</p>
</blockquote>
<p>if and only if表示当且仅当所以正确</p>
<blockquote>
<p>What things is an object associated with ?</p>
<p>Select one or more:</p>
<p>A. Value</p>
<p>B. Element</p>
<p>C. Object type</p>
<p>D. Data type</p>
<p>A: Data type , Object type</p>
</blockquote>
<p>Val &amp; Elem都与Obj无关</p>
<blockquote>
<p>What are the main applications of tree data structure?</p>
<ol>
<li>Manipulate hierarchical data</li>
<li>Make information easy to search (see tree traversal).</li>
<li>Manipulate sorted lists of data</li>
<li>Router algorithms</li>
<li>Form of a multi-stage decision-making, like Chess Game.</li>
<li>As a workflow for compositing digital images for visual effects</li>
</ol>
<p>Select one:</p>
<p>A. 1, 2, 3, 4 and 6</p>
<p>B. 1, 3, 4, 5 and 6</p>
<p>C. 1, 2, 3, 4, 5 and 6</p>
<p>D. 1, 2, 3, 4 and 5</p>
<p>A: C. 1, 2, 3, 4, 5 and 6</p>
</blockquote>
<p>答案是全对。当时没选6，没注意主语是workflow。用Tree来表示workflow是可以的</p>
<blockquote>
<p>What does “+” mode mean, while working with files?</p>
<p>a. Append</p>
<p>b. Write</p>
<p>c. Read</p>
<p>d. Read and Write</p>
<p>A: d. Read and Write</p>
</blockquote>
<p>选错选了a. Append。Append应该是”a” mode</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>总体简单，大量送分，全程基本都是写写写没选择</p>
<p>考了Depth First Inorder&#x2F;Preorder&#x2F;Postorder Tree 和Breadth First的List View（始料未及</p>
<p>还有手撸的selection sort</p>
<p>另外之前关注的valid&#x2F;invalid&#x2F;boundary test果然成考点</p>
<p>最后只有75，感觉考试扣分还是很严重</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Interesting</title>
    <url>/post/go-interesting/</url>
    <content><![CDATA[<p>这里记录一些golang使用中的小细节，每次都像cgo那样单独写一篇有点太水了。</p>
<span id="more"></span>

<h2 id="go-build"><a href="#go-build" class="headerlink" title="go:build"></a>go:build</h2><p><a href="https://stackoverflow.com/questions/68360688/whats-the-difference-between-gobuild-and-build-directives" target="_blank" rel="noopener">https://stackoverflow.com/questions/68360688/whats-the-difference-between-gobuild-and-build-directives</a></p>
<p>起因是用vscode上编辑boltdb的代码，每次ctrl+s保存之后就会在<code>// +build xxx, xxx</code>前面加一句语义相同的<code>//go:build blahblah</code></p>
<p><code>//go:build</code> 是 Go 1.17 中引入的新条件编译指令。</p>
<p>它旨在替换<code>// +</code>这个build tag，因为新语法带来了一些关键改进：</p>
<p>与其他现有 Go 指令和编译指示的一致性，<br>例如<code>//go:generate</code>支持标准布尔表达式，<br>例如<code>//go:build foo &amp;&amp; bar</code>，而旧的 <code>// +build</code> 注释的语法不太直观。例如 AND 用逗号表示 <code>// +build foo, bar</code> 和 OR 用空格 <code>// +build foo bar</code><br>go fmt 支持自动修复源文件中指令的错误位置，从而避免在指令和包语句之间不留空行的常见错误。<br>这两个构建指令将在几个 Go 版本中共存，以确保平滑过渡，如相关提案文件中所述（在 N &#x3D; 17 以下，重点是我的）：</p>
<p>Go 1.N 将开始转换。在 Go 1.N 中：</p>
<p>构建将开始更喜欢 <code>//go:</code> 用于文件选择的构建行。如果没有 <code>// go: build</code> 在一个文件中，那么任何 <code>// +</code> 构建行仍然适用。</p>
<p>如果Go文件包含<code>//go: build</code> 而没有 <code>// +build</code>，构建将不再失败。</p>
<p>如果Go或程序集文件包含 <code>// go: build</code> 在文件中太过靠后，则构建将失败。 Gofmt 会将错位的 <code>//go: build</code> 和 <code>// +build</code> 行移动到文件中的正确位置。</p>
<p>Gofmt 将使用与其他 Go 布尔表达式（所有 &amp;&amp; 和 || 运算符周围的空格）相同的规则来格式化<code>//go:build</code> lines 中的表达式。</p>
<p>如果文件只包含<code>// +build</code>行，gofmt 将在它们上方添加一个等效的<code>//go:build</code>行。</p>
<p>如果文件同时包含 <code>//go:build</code> 和 <code>// +build</code> 行，gofmt 将考虑 <code>//go:build</code> 的真实来源并更新 <code>// +build</code> 行以匹配，从而保持与早期版本的 Go 的兼容性。 Gofmt 也会拒绝 <code>//go:build</code> 被认为太复杂而无法转换为 <code>// +build</code> 格式的行，尽管这种情况很少见。 （注意此项目符号开头的“If”。Gofmt 不会将 <code>// +build</code>行添加到只有 <code>//go:build</code> 的文件中。）</p>
<p>go vet中的构建标签检查将添加对<code>//go:build</code>约束的支持。当 Go 源文件包含 <code>// go:build</code> 和 <code>// +build</code> 具有不同含义时，它将失败。如果检查失败，可以运行 gofmt -w。</p>
<p>当 Go 源文件包含<code>//go:build</code>, 但不包含<code>//+build</code>, 且它的包含模块有一个go line列出 Go 1.N 之前的版本时，构建标签检查也会失败。如果检查失败，可以添加任何<code>// +build</code>行，然后运行 ​​gofmt -w，它将用正确的行替换它。或者可以将 go.mod go 版本升级到 Go 1.N。</p>
]]></content>
  </entry>
  <entry>
    <title>Notes for FIT9137: Arch and Net notes</title>
    <url>/post/fit9137-arch_and_net-notes/</url>
    <content><![CDATA[<p>虽然在定义上是个基础课，但是实际上比国内的大计基深入的不是一点点。如果不是前阵子因为cryptocurrency mining的研究一直都在钻研底层，估计还挺难消化的。即便如此，不仔细的我到现在的quiz还是没能拿到过100……</p>
<span id="more"></span>

<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>w1 到 w3 是非常快速且底层的计算机（与系统）架构介绍。</p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>w4 开始讲的就是Netowork的内容，直到w12，所以可以认为是整个课其实重点就在这里……</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>网络的基本组成部分：Client，Sever，Router，Comm-Links（inter-connects network devices，换句话说就是medium）</p>
<p>网络的形式（规模）：LAN（本地网络），BN（主干网），MAN（城域网），WAN（广域网）</p>
<p>还有个大一统的Internet</p>
<h4 id="消息的传输"><a href="#消息的传输" class="headerlink" title="消息的传输"></a>消息的传输</h4><p>基于包交换的网络： 消息被分割为多个包packets</p>
<h5 id="传输速率："><a href="#传输速率：" class="headerlink" title="传输速率："></a>传输速率：</h5><p>home2ISP: 1Mbps</p>
<p>home2home: 10-20Mbps</p>
<p>WLAN: 50-500Mbps</p>
<p>LAN: 1Gbps</p>
<p>BN: 10Gbps</p>
<p>光纤: Tbps</p>
<h5 id="层级（Layers）与协议（Protocols）"><a href="#层级（Layers）与协议（Protocols）" class="headerlink" title="层级（Layers）与协议（Protocols）"></a>层级（Layers）与协议（Protocols）</h5><p>TCP&#x2F;IP模型</p>
<table>
<thead>
<tr>
<th>Layers</th>
</tr>
</thead>
<tbody><tr>
<td>5. Application (App)</td>
</tr>
<tr>
<td>4. Transport (Logical conn)</td>
</tr>
<tr>
<td>3. Network (Routing)</td>
</tr>
<tr>
<td>2. Datalink (Low-level conn)</td>
</tr>
<tr>
<td>1. Physical (Hardware)</td>
</tr>
</tbody></table>
<p>Switch: 1+2</p>
<p>Router: 1+2+3</p>
<p>Protocol Data Unit (PDU): </p>
<ol start="5">
<li><p>Message (HTTP)</p>
</li>
<li><p>Segment (TCP)</p>
</li>
<li><p>Packet (IP)</p>
</li>
<li><p>Frame (Ethernet)</p>
</li>
<li><p>Bit</p>
</li>
</ol>
<p>每一层都对数据会进行调制&#x2F;解调（en&#x2F;decapsulate），就类似tcp conn里套socks5再套ss&#x2F;ssr一样</p>
<p>模块化设计</p>
<p>优秀的协议栈有三种特征：</p>
<p>低耦合（Low Coupling）高聚合（High Cohesive）无信息（Information Hiding）</p>
<h3 id="Physical-x2F-DataLink-Layer"><a href="#Physical-x2F-DataLink-Layer" class="headerlink" title="Physical&#x2F;DataLink Layer"></a>Physical&#x2F;DataLink Layer</h3><p>Intro</p>
<p>物理层：直接连接设备</p>
<p>数据链接层：管理俩设备间的物理连接</p>
<p>物理层：主要焦点于如何将bits转换为信号以及转回bits</p>
<p>数据链接层：</p>
<ul>
<li>Media Access Control：在设备发送时控制</li>
<li>Error Control：确保数据正确到达</li>
<li>Protocols：同步与异步传输</li>
<li>Transmission Efficiency：消息长度vs错误率</li>
</ul>
<h5 id="数字信号与模拟信号"><a href="#数字信号与模拟信号" class="headerlink" title="数字信号与模拟信号"></a>数字信号与模拟信号</h5><p>老古董POTS: Plain Old Telephone Service</p>
<ul>
<li><p>语音在电话之间传递</p>
</li>
<li><p>声音（模拟）转换成电波（麦克风）</p>
</li>
<li><p>电波通过铜线传播</p>
</li>
<li><p>电波（扬声器）转回声音</p>
</li>
</ul>
<p>通过使用Modem来将数字信号转换成模拟信号</p>
<p>Modem（<strong>Mo</strong>dulator&#x2F;<strong>Dem</strong>odulator）</p>
<p>这里我们都使用正弦（sin）波。y &#x3D; A * sin(f*2πX+φ) 波具有三个属性：</p>
<ul>
<li>振幅A</li>
<li>频率f</li>
<li>相位φ</li>
</ul>
<h3 id="数据链接层"><a href="#数据链接层" class="headerlink" title="数据链接层"></a>数据链接层</h3><p>两个子层</p>
<h4 id="逻辑链接控制（LLC）"><a href="#逻辑链接控制（LLC）" class="headerlink" title="逻辑链接控制（LLC）"></a>逻辑链接控制（LLC）</h4><ul>
<li>处理PDU头</li>
<li>错误控制</li>
<li>定义与网络层的接口</li>
</ul>
<h4 id="媒体访问控制（MAC）"><a href="#媒体访问控制（MAC）" class="headerlink" title="媒体访问控制（MAC）"></a>媒体访问控制（MAC）</h4><ul>
<li>在与物理层符号和frame之间编码&#x2F;解码</li>
<li>错误检测</li>
<li>当设备传输时控制</li>
</ul>
<p>[WIP]</p>
<h3 id="LAN-amp-WLAN"><a href="#LAN-amp-WLAN" class="headerlink" title="LAN &amp; WLAN"></a>LAN &amp; WLAN</h3><p>Why use a LAN</p>
<p>信息共享（文件，数据库，email等交流），资源共享（打印机等硬件，软件授权，公网连接）</p>
<h4 id="LAN的类型"><a href="#LAN的类型" class="headerlink" title="LAN的类型"></a>LAN的类型</h4><p>专用服务器LAN</p>
<ul>
<li><p>网络包含服务器和客户端</p>
</li>
<li><p>每个服务器有一个或多个<strong>特定任务</strong>（e.g. DHCP，email…）</p>
</li>
<li><p>是<strong>最流行</strong>的企业网络</p>
</li>
</ul>
<p>P2P LAN（例如家庭LAN，更便宜但性能更差）</p>
<ul>
<li><p>无专用服务器</p>
</li>
<li><p>所有的计算机都作为服务端也作为客户端</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>专用服务器LAN</th>
<th>P2P LAN</th>
</tr>
</thead>
<tbody><tr>
<td>成本</td>
<td>贵（需要更多硬件）</td>
<td>便宜（重用存在的硬件）</td>
</tr>
<tr>
<td>性能</td>
<td>很高，可拓展</td>
<td>第，不太能拓展</td>
</tr>
<tr>
<td>可靠性</td>
<td>很高（企业级组件）</td>
<td>低</td>
</tr>
<tr>
<td>管理</td>
<td>更简单（中心化）</td>
<td>更困难</td>
</tr>
</tbody></table>
<h4 id="基础LAN组件"><a href="#基础LAN组件" class="headerlink" title="基础LAN组件"></a>基础LAN组件</h4><p>NOS（Network Operating System）</p>
<p>NIC（Network Interface Card）网卡</p>
<p>Switch</p>
<p>Cable</p>
<p>Client，Server</p>
<h5 id="NIC网卡"><a href="#NIC网卡" class="headerlink" title="NIC网卡"></a>NIC网卡</h5><p>实现了物理层与数据链接层</p>
<ul>
<li><p>包括独一无二的数据链接层地址（MAC Address）</p>
</li>
<li><p>提供到网络的物理连接（socket插座或antenna天线）</p>
</li>
<li><p>实现了协议（错误检测，frame构建，调制解调等等）</p>
</li>
</ul>
<p>连接到电脑</p>
<ul>
<li>通常内置于主板</li>
<li>或者通过USB&#x2F;PCI-Express等接口连接</li>
</ul>
<h5 id="Network-Cables网线"><a href="#Network-Cables网线" class="headerlink" title="Network Cables网线"></a>Network Cables网线</h5><p>网络设备间的物理连接</p>
<p>不同的类别：</p>
<ul>
<li><p>UTP （LAN最常用类型）</p>
</li>
<li><p>STP （防护双绞线）</p>
</li>
<li><p>光纤 （当前LAN不常用）</p>
</li>
<li><p>同轴线 （只有老LAN在用）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>品名</th>
<th>数据速率</th>
<th>网线</th>
</tr>
</thead>
<tbody><tr>
<td>10BASE-T</td>
<td>10Mbps</td>
<td>UTP cat3 &#x2F; cat5，三类线五类线</td>
</tr>
<tr>
<td>100BASE-T</td>
<td>100Mbps</td>
<td>UTP cat5</td>
</tr>
<tr>
<td>1000BASE-T</td>
<td>1Gbps</td>
<td>UTP 5e，6 &lt;-现在常用</td>
</tr>
<tr>
<td>1000BASE-X</td>
<td>1Gbps</td>
<td>光纤 （单模式或多模式）</td>
</tr>
<tr>
<td>10GbE</td>
<td>10Gbps</td>
<td>UTP cat6，ca7，光纤</td>
</tr>
<tr>
<td>40GbE&#x2F;100GbE</td>
<td>40Gbps&#x2F;100Gbps</td>
<td>光纤</td>
</tr>
</tbody></table>
<h5 id="NOS网络操作系统"><a href="#NOS网络操作系统" class="headerlink" title="NOS网络操作系统"></a>NOS网络操作系统</h5><p>用来访问与控制LAN的软件</p>
<ul>
<li>服务端NOS提供网络管理工具与网络服务</li>
<li>客户端NOS提供访问网络服务的方式</li>
</ul>
<p>由服务端NOS提供的服务</p>
<ul>
<li>文件夹服务</li>
<li>网络与用户描述</li>
<li>文件，web，打印，email服务器等等</li>
</ul>
<p>NOS服务端软件</p>
<p>处理网络功能</p>
<ul>
<li>全协议栈（数据链接，网络，传输，应用层）</li>
<li>包括应用软件如HTTP，FTP，SMTP，DHCP，LDAP，DHCP，DNS，SQL…</li>
</ul>
<p>替代或加强普通操作系统</p>
<ul>
<li>可以得到服务器性能上的优化而非用户程序</li>
</ul>
<p>例如</p>
<ul>
<li>Linux</li>
<li>Microsoft Windows Server</li>
</ul>
<p>NOS客户端软件</p>
<p>处理网络连接</p>
<ul>
<li>数据连接层，网络层，传输层</li>
<li>和应用层交互</li>
<li>曾经是分离的系统</li>
<li>现在被整合进了所有的主流操作系统</li>
</ul>
<p>客户端现在可以查阅与获取网络资源</p>
<ul>
<li>现在客户端可用的服务</li>
</ul>
<h3 id="以太网，集线器与交换机"><a href="#以太网，集线器与交换机" class="headerlink" title="以太网，集线器与交换机"></a>以太网，集线器与交换机</h3><p>主流LAN技术</p>
<ul>
<li>标准化如IEEE802.3</li>
<li>被几乎所有LAN使用</li>
<li>1973年开发，1980年被标准化</li>
</ul>
<p>物理层</p>
<ul>
<li>起初是基于共享媒介的同轴电缆，10Mbps</li>
<li>现在大多转换成了基于UTP的100Mbps或1Gbps网络</li>
<li>光纤的标准能最高100Gbps</li>
</ul>
<p>以太网<br>拓扑结构：</p>
<ol>
<li>共享线路</li>
<li>星状（P2P）</li>
<li>多hub设计</li>
</ol>
<p>以太网MAC（扼要重述）</p>
<p>基于意图的媒体获取</p>
<ul>
<li>设备间资源获取上的竞争</li>
<li>如果设备同时发送frame会发生冲突</li>
</ul>
<p>冲突</p>
<ul>
<li>没有被避免，但是可容忍可检测</li>
<li>在小型和中型网络里非常高效</li>
</ul>
<p>媒体获取控制（Media Access Control）：CSMA&#x2F;CD</p>
<ul>
<li>事件感知（CS）：在线路上侦听，只在没有其他型号被感知时传输</li>
<li>多重获取（MA）：多个设备访问同一个介质</li>
<li>冲突检测（CD）：当非己信号被检测到<br>传输拥挤信号（因此所有其他设备检测冲突）<br>都在重新发送前等待随机时间</li>
</ul>
<p>共享以太网中的问题<br>半双向：同一时间只有一个设备能够发送</p>
<h2 id="W8"><a href="#W8" class="headerlink" title="W8"></a>W8</h2><p>又到了不温习就不会做作业的地步了……</p>
<p>网络层： Routing</p>
<p>A router is a layer 3 device</p>
<ul>
<li><p>one IP address per interface, i.e. typically per subnet it is connected to</p>
</li>
<li><p>Clients send packets to routers if destination is outside their own subnet</p>
</li>
<li><p>Routers use IP address to determine over where the packet is sent next</p>
</li>
</ul>
<p>For each incoming packet, the router</p>
<ul>
<li>looks at the packet’s destination IP<br>address</li>
<li>consults the routing table:<br><em>to which other router should I send a packet for this destination, or can I deliver it directly?</em></li>
<li>if destination not in table: send to default gateway</li>
<li>if no default gateway configured: packet can’t be routed</li>
</ul>
<p>Three components:</p>
<ul>
<li>The routing protocol:<br>how to find the best route between a sender and a receiver through the network</li>
<li>The routing table:<br>the best routes currently known are stored in a lookup table for fast access</li>
<li>The routing decisions:<br>deciding for each incoming packet where it is sent next</li>
</ul>
<p>Types of routing</p>
<ol>
<li>Centralized<ul>
<li>All clients connect to central computer, which makes the routing decisions</li>
<li>Used on small, host-based networks</li>
</ul>
</li>
<li>Decentralized<ul>
<li>Each device makes its own decisions</li>
<li>Information needs to be exchanged to prepare routing tables</li>
<li>Used on the Internet</li>
</ul>
</li>
</ol>
<p>Decentralized routing:</p>
<p>Static routing:</p>
<ul>
<li>Network manager prepares <strong>fixed routing tables</strong></li>
<li>Manually updated when the network changes</li>
<li>Used in simple networks that don’t change a lot</li>
</ul>
<h2 id="IP-subnets"><a href="#IP-subnets" class="headerlink" title="IP subnets"></a>IP subnets</h2><p>mask 计算方式就是bin对比，比如&#x2F;20表示<code>&quot;1&quot;*20+&quot;0&quot;*(32-20)</code>，mask则是取ip（每个数字分开LE encode，从右往左写）与这个的&amp;值（即上下都是1就取1否则0）</p>
<p>要看清楚到底是ip还是mask。X.X.0.0这种就是mask，因为可以作为一个subnet的Network(gateway) address。作为mask的ip可能不带<code>/20</code>这样的后缀（因为人家能表达了）</p>
<p>X.X.X.X(&#x2F;XX)在mask &#x2F;XX（或者X.X.X.X）有几个subnet？先算前面那个的<code>/XX</code>比如20。再算后面那个的那比如24。那么subnet个数就是2^(24-20) &#x3D; 16个。每个subnet里的ip数就是2^(32-24)&#x3D;256，其中host ip数就是256-2 &#x3D; 254</p>
<h2 id="错题集！"><a href="#错题集！" class="headerlink" title="错题集！"></a>错题集！</h2><blockquote>
<p>Q: An access point ensures that all computers within range of the access point can communicate with each other</p>
<p>A: T</p>
</blockquote>
<p>做的时候选了F，想的是没准就有内网隔离你访问个锤子。看到答案可能应该是想表达在一个LAN的意思。</p>
<blockquote>
<p>Q: IPv6 is backwards compatible with IPv4.</p>
<p>A: F</p>
</blockquote>
<p>做的时候以为是v6兼容不兼容v4，那肯定兼容啊。2002就是划给v4的（<a href="https://en.wikipedia.org/wiki/6to4" target="_blank" rel="noopener">6to4</a>）。直到看到答案才意识到问题意思应该是<strong>直接兼容</strong>。6to4毕竟是走了个转换通道的。而且google之后有明确答案。</p>
<blockquote>
<p>Q: What is the main advantage of fibre-optic cables over copper cables?</p>
<p>Select one:</p>
<p>a. Higher latency</p>
<p>b. All of the other answers</p>
<p>c. Cheaper</p>
<p>d. Lower resistance</p>
<p>e. Much faster data rates</p>
<p>A: e</p>
</blockquote>
<p>本来想想光纤无敌无脑选b。现在想想应该是铜在工艺和成本上来说是更便宜的，latency的话查了是copper更快（<a href="https://www.arista.com/assets/data/pdf/Copper-Faster-Than-Fiber-Brief.pdf" target="_blank" rel="noopener">This is close to the oft-quoted <strong>5 ns</strong> per meter for <strong>fiber</strong>. The <strong>latency</strong> for the twinax <strong>copper</strong> cables shown is <strong>4.60</strong> ns per meter</a>）</p>
<blockquote>
<p>An advantage of centralized routing is:</p>
<p>Select one:</p>
<p>a. routing does reflect changing network conditions, such as computers that are overloaded by many messages</p>
<p>b. if anything happens to the computer developing the routing table, the routing tables cannot be changed until that computer is fixed, or until a new computer is selected to perform the function</p>
<p>c. it requires more processing by each computer or router in the network than dynamic routing</p>
<p>d. the routing tables are stored at all computers in the network</p>
<p>e. routing decisions are simple</p>
<p>A: e</p>
</blockquote>
<p>不懂，背一下吧</p>
<blockquote>
<p>How can a set of 802.11b access points be configured to operate without interference?</p>
<p>Select one:</p>
<p>a. assign the same channel to no more than two access points</p>
<p>b. assigning each access point a different channel to communicate with clients</p>
<p>c. none of the above</p>
<p>d. separate each access point by more than 10 meters</p>
<p>e. use omnidirectional antennas on some access points and directional on others.</p>
<p>A: b</p>
</blockquote>
<p>很果断地选c，因为觉得肯定得首先不一样其次要1，6，11三个选。答案b其实就是不一样的意思，1，6，11应该只是最优情况。</p>
<p><a href="http://www.wireless-nets.com/resources/tutorials/assign_ap_channels.html" target="_blank" rel="noopener">http://www.wireless-nets.com/resources/tutorials/assign_ap_channels.html</a></p>
<blockquote>
<p>_____ indicates what resources on each server are available on the network for use by other computers and what people are allowed what access to the network.</p>
<p>Select one:</p>
<p>a. server allocation list</p>
<p>b. network profile</p>
<p>c. network operating system</p>
<p>d. user access log</p>
<p>e. user profile</p>
<p>A: e</p>
</blockquote>
<p>完全不记得啥时候讲了user profile。用Acrobat搜了一下在W6（LAN&amp;WAN）。</p>
<p>就user profile是一个Server NOS（Network OS）的一个service</p>
<p>总的来说就这几个</p>
<ul>
<li>directory service</li>
<li>network &amp; user profiles</li>
<li>file, web, print, email server etc</li>
</ul>
<p>然而后面就没具体介绍了……这题就当介绍一下（别的几个知道的</p>
<blockquote>
<p>How many bits are required to sample an incoming signal 4000 times per second using 64 different amplitude levels?</p>
<p>A: 6</p>
</blockquote>
<p>写了是64的我一脸懵逼。现在来复盘一下。先用Acrobat定位了一下知识点在W6。$s(t) &#x3D; A sin(2\pi ft + \phi)$。这里$f$已经确定了是个常量<em>4000 times per second</em>，$\phi$没提到，变的应该只有A，有64个不同的值。<del>首先已知了我们64错了。</del></p>
<img src="/post/fit9137-arch_and_net-notes/image-20210212012622535.png" class="" title="image-20210212012622535">

<p>题目说了有64个amplitude的值，另外求的是可以代表bit的数量。意思应该就是64个值可以用几个bit概括？一个bit可以表示0，1。两个就是00，01，10，11四个，以此类推就是n个bit代表$2^n$个。$64 &#x3D; 2^6$。所以是6。（要注意审题啊完全没意识到是bit）</p>
<blockquote>
<p>Which of the following is <strong>not</strong> a controlled access method of media access control?</p>
<p>Select one:</p>
<p>a. CSMA&#x2F;CD</p>
<p>b. hub polling</p>
<p>c. roll call polling</p>
<p>d. Token passing</p>
<p>e. polling</p>
<p>A: a. CSMA&#x2F;CD</p>
</blockquote>
<p>相关知识忘得差不多了，只记得CSMA&#x2F;CD是和Media有关的。CSMA&#x2F;CD也是W6（LAN&amp;WLAN）的内容。</p>
<p>CSMA&#x2F;CD是一个Media Access Control。</p>
<ul>
<li>Carrier Sense (CS):<br>listen on bus, only transmit if no other signal is “sensed”</li>
<li>Multiple Access (MA):<br>several devices access the same medium</li>
<li>Collision Detection (CD):<br>when signal other than own is detected:<ul>
<li>transmit jam signal (so all other devices detect collision)</li>
<li>both wait random time before re-transmitting</li>
</ul>
</li>
</ul>
<p>CSMA&#x2F;CD limits size of collision domain</p>
<p>而那些Polling是W5（Physical &amp; DataLink Layer）的内容。</p>
<ol>
<li>Roll Call Polling （类hub）</li>
<li>Hub Polling &#x2F; Token Passing （P2P）</li>
</ol>
<p>人家都叫Controlled Access。</p>
<blockquote>
<p>Errors normally appear in ？？？, which is when more than one data bit is changed by the error-causing condition.</p>
<p>A: burst</p>
</blockquote>
<p>我tm写的DataLink Layer……找了一圈也没看见这个in burst的说法，背一下吧</p>
<blockquote>
<p>_____ controls errors by detecting and correcting them at the receiving end without retransmission of the original message.</p>
<p>Select one:</p>
<p>a. Hamming code</p>
<p>b. Wave division multiplexing</p>
<p>c. Huffman encoding</p>
<p>d. Hub polling</p>
<p>e. Front end processing</p>
<p>A: Hamming code</p>
</blockquote>
<p>Hamming code出现在W5（Phy&amp;DL Layer）的Forward Error Correction的example里。example分别为</p>
<ul>
<li>Hamming code 汉明码 (used e.g. in error correcting memory)</li>
<li>Reed-Solomon codes  里德-所罗门码 (CDs, DVDs, Blue-ray, QR Codes, Digital TV broadcast, DSL)</li>
</ul>
<p>其他的Wave division multiplexing没找到，但是multiplex应该是多路复用和error关系不大</p>
<p>Huffman encoding没找到</p>
<p>Hub polling前面说了是个Controlled Access</p>
<p>Front end processing前端处理？听着就不靠谱，也没找到。</p>
<blockquote>
<p>In ARQ, a NAK:</p>
<p>Select one:</p>
<p>a. is sent by the sender at the same time as it sends a data packet</p>
<p>b. refers to non-asynchronous Kermit technique</p>
<p>c. means that the sender should continue with sending the next message</p>
<p>d. is sent by the recipient if the message contains an error</p>
<p>e. is sent by the recipient if the message was received without error</p>
<p>A: d</p>
</blockquote>
<p>ARQ（包括NAK）也在W5.</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210212020517127.png" class="" title="image-20210212020517127">

<img src="/post/fit9137-arch_and_net-notes/image-20210212020527545.png" class="" title="image-20210212020527545">

<p><strong>acknowledgement</strong> (<strong>ACK</strong>) <strong>negative-acknowledgement</strong> (<strong>NAK</strong> or <strong>NACK</strong>)</p>
<p>这里干脆吧<a href="https://en.wikipedia.org/wiki/Automatic_repeat_request" target="_blank" rel="noopener">ARQ（Automatic Repeat Request&#x2F;automatic repeat query)</a>也看掉。ARQ是一种用于数据传输的错误控制方法，它使用确认（接收方发送的消息，表明它已正确接收到一个数据包）和超时（在接收确认之前经过了指定的时间段）来实现可靠的数据传输 通过不可靠的通信渠道。 如果发送方在超时之前未收到确认，则通常会重新传输数据包，直到发送方收到确认或超过预定义的重传次数为止。（就等于是一直ping你直到ping通或者次数到</p>
<blockquote>
<p>A _____ is a user’s connection into a packet switched service.</p>
<p>Select one:</p>
<p>a. packet asynchronous&#x2F;discrete device</p>
<p>b. packet asymmetric&#x2F;data transmission device</p>
<p>c. packet analyzer&#x2F;decoder device</p>
<p>d. packet assembly&#x2F;disassembly device</p>
<p>e. packet analog&#x2F;digital device</p>
<p>A: d. packet assembly&#x2F;disassembly device</p>
</blockquote>
<p>W11(Backbones MAN WAN)里WAN Packet Switched Services讲到的packet assembly&#x2F;disassembly （简称PAD）。如图，背一背吧</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210212021401150.png" class="" title="image-20210212021401150">





<blockquote>
<p>_____ refers to changing the shape of a wave in different ways to represent a 1 or a 0.</p>
<p>Select one:</p>
<p>a. demodulation</p>
<p>b. modulation</p>
<p>c. digitizing.</p>
<p>d. sampling</p>
<p>e. shaping</p>
<p>A: a. demodulation</p>
</blockquote>
<p>脑补的是调制解调器，网线（01）到电话线（wave）是调制，回来解调。这里要求的是wave → 01所以是解调。（看反了</p>
<blockquote>
<p>Web-based e-mail like Hotmail is an example of three-tier client-server architecture that provides access to e-mail messages.</p>
<p>A: T</p>
</blockquote>
<p>想的是B&#x2F;S，通过<em>three-tier client-server architecture</em>关键词查了下看见<a href="https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture" target="_blank" rel="noopener">Wikipedia</a>里说: <em>In the <a href="https://en.wikipedia.org/wiki/Web_development" target="_blank" rel="noopener">web development</a> field, three-tier is often used to refer to <a href="https://en.wikipedia.org/wiki/Website" target="_blank" rel="noopener">websites</a>, commonly <a href="https://en.wikipedia.org/wiki/Electronic_commerce" target="_blank" rel="noopener">electronic commerce</a> websites</em></p>
<blockquote>
<p>In unix or Linux Operating System, the most common types of files are ____________.</p>
<p>Select one:</p>
<p>a. device file</p>
<p>b. directory file</p>
<p>c. ordinary file and directory file</p>
<p>d. ordinary file</p>
<p>A: d. ordinary file</p>
</blockquote>
<p>错两次了不应该</p>
<blockquote>
<p>Which of the following technique is used for encapsulation?</p>
<p>Select one:</p>
<p>a. one of the pieces that results when an IP gateway divides an IP datagram into smaller pieces for transmission across a network that cannot handle the original datagram size</p>
<p>b. the technique used by protocols in which a lower level protocol accepts a message from a higher level protocol and places it in the data portion of the low level frame</p>
<p>c. the technique used in best-effort delivery systems to avoid endlessly looping packets</p>
<p>d. all of these options</p>
<p>A: b</p>
</blockquote>
<p>encapsulation封装的定义</p>
<blockquote>
<p>In which type of routing do computers or routers count the number of hops along a route and periodically exchange information on the hop count with their neighbors?</p>
<p>Select one:</p>
<p>a. circuitous</p>
<p>b. decentralized</p>
<p>c. distance vector</p>
<p>d. link state</p>
<p>e. indirect</p>
<p>A: distance vector</p>
</blockquote>
<p>W8 Routing的内容</p>
<p>Distance vector 交换目的地距离，选择最短路径（RIP (Routing Information Protocol) BGP(Border Gateway Protocol)）</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224213438907.png" class="" title="image-20210224213438907">

<p>link state 交换链接质量消息，选最快路径（OSPF）</p>
<p>别的都没出现。</p>
<blockquote>
<p>An exception condition in a computer system caused by an event external to the CPU is known as?</p>
<p>Select one:</p>
<p>a. Halt</p>
<p>b. Process</p>
<p>c. Interrupt</p>
<p>d. None of above</p>
<p>A: c</p>
</blockquote>
<p>Halt虽然也是停，但真没东西叫这个</p>
<blockquote>
<p>An interrupt is a signal to the processor to suspend its current tasks and deal with whatever caused the interrupt. Which of the following method cannot be classified as Interrupts?</p>
<p>Select one:</p>
<p>a. Program&#x2F;Software triggered</p>
<p>b. Timer triggered</p>
<p>c. I&#x2F;O operation triggered</p>
<p>d. Other Hardware triggered</p>
<p>e. Page fault triggered</p>
<p>A: e</p>
</blockquote>
<img src="/post/fit9137-arch_and_net-notes/image-20210224214502048.png" class="" title="image-20210224214502048">

<p>PageFault是后面（内存）才出现的</p>
<blockquote>
<p>A solution to resolve the problem of external fragmentation is to _________________</p>
<p>Select one:</p>
<p>a. permit the logical address space of a process to be non contiguous</p>
<p>b. permit smaller processes to be allocated memory at last</p>
<p>c. permit larger processes to be allocated memory at last</p>
<p>d. All of these options</p>
<p>A: a</p>
</blockquote>
<img src="/post/fit9137-arch_and_net-notes/image-20210224214748781.png" class="" title="image-20210224214748781">

<p>解决方案：paging</p>
<blockquote>
<p>For purposes of routing, the Internet is divided into ___________.</p>
<p>Select one:</p>
<p>a. wide area networks</p>
<p>b. autonomous networks</p>
<p>c. autonomous systems</p>
<p>d. none of these options</p>
<p>A:  c. autonomous systems</p>
</blockquote>
<p>W8的内容，自治系统（差不多就ISP的网）</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224215420764.png" class="" title="image-20210224215420764">



<blockquote>
<p>In 802.3, the address consisting of all 1 bits is reserved for ___________________.</p>
<p>Select one:</p>
<p>a. Unicast</p>
<p>b. Multicast</p>
<p>c. Broadcast</p>
<p>d. Ordinary</p>
<p>A: c. Broadcast</p>
</blockquote>
<p>802.3是以太网的协议。从Ethernet Frame里根本没找到这个……背吧</p>
<blockquote>
<p>In IEEE802.11, the addressing machanism can include upto ________________ addresses.</p>
<p>Select one:</p>
<p>a. four</p>
<p>b. five</p>
<p>c. six</p>
<p>d. none of these options</p>
<p>A: a. four</p>
</blockquote>
<p>IEEE802.11 是WLAN的协议。</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224220918086.png" class="" title="image-20210224220918086">

<blockquote>
<p>OC-3072 has a data rate of</p>
<p>Select one:</p>
<p>a. 1.244 Gbps</p>
<p>b. 159.25 Gbps</p>
<p>c. 39.813 Gbps</p>
<p>d. 1.544 Mbps</p>
<p>e. 100 Mbps</p>
</blockquote>
<p>OC-X &#x3D; X * 51.84 Mbps</p>
<blockquote>
<p>Both the _____ layer perform error checking.</p>
<p>Select one:</p>
<p>a. presentation and transport</p>
<p>b. application and presentation</p>
<p>c. transport and data link</p>
<p>d. physical and data link</p>
<p>e. network and physical</p>
<p>A: c. transport and data link</p>
</blockquote>
<blockquote>
<p>_____ is a line-of-sight type of wireless media.</p>
<p>Select one:</p>
<p>a. microwave</p>
<p>b. radio</p>
<p>c. twisted pair</p>
<p>d. coaxial cable</p>
<p>e.  fiber optic</p>
<p>A: microwave</p>
</blockquote>
<img src="/post/fit9137-arch_and_net-notes/image-20210224225948321.png" class="" title="image-20210224225948321">

<p>直接拿来覆盖范围的，就好像学校到处有的校园网</p>
<blockquote>
<p>Which of the following is not true about CSMA&#x2F;CD?</p>
<p>Select one:</p>
<p>a. It is used in token ring protocol LANs</p>
<p>b. It is a contention-based media access control technique</p>
<p>c. When a collision has occurred, the computers that wish to transmit wait a random amount of time after a colliding message before attempting to retransmit</p>
<p>d. Computers on the circuit ‘listen’ before transmitting</p>
<p>e. The acronym refers to Carrier Sense Multiple Access with Collision Detection</p>
<p>A: a. It is used in token ring protocol LANs</p>
</blockquote>
<p>CSMA&#x2F;CD是W6 Ethernet内容</p>
<p>前面只有hub，hub的逻辑拓扑是shared bus，物理拓扑是star</p>
<blockquote>
<p>The probability of detecting an error, provided that one has occurred, using cyclic redundancy checking is about</p>
<p>Select one:</p>
<p>a. &gt;99%</p>
<p>b. 75%</p>
<p>c. 0%</p>
<p>d. 50%</p>
<p>e. exactly 100%</p>
<p>A: a. &gt;99%</p>
</blockquote>
<p>cyclic redundancy checking 就是CRC。W5里的。</p>
<img src="/post/fit9137-arch_and_net-notes/image-20210224232144187.png" class="" title="image-20210224232144187">

<p>所以就相当于$ 99% &lt; \frac{\infin-1}{\infin} &lt; 100% $</p>
<p>Breaking a network into smaller parts is called  Network Segmentation  -&gt; W6</p>
<p>dynamic routing -&gt; W8</p>
<p>drawback: The transmission of status information “wastes” network capacity that could be used to send user messages</p>
<p>Many organizations today are installing traditional wired Ethernet for desktop users and install Wi-Fi as <strong>overlay networks</strong></p>
<p>Layer-2地址：L2即DL层，真实网卡MAC地址</p>
<p>Layer-3：L3即Net层，logical address，arp得到L2</p>
<p>802.11b?</p>
<p>802.11g?</p>
<p>802.3</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>architecture</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>How to create a temporary NGIN network</title>
    <url>/post/how-to-create-a-temp-ngin-network/</url>
    <content><![CDATA[<p>This is the tutorial material for dev building a temporary NGIN network through ngcore’s regression testnet flag.</p>
<span id="more"></span>

<h2 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h2><p>Before we start, we should create two different folder to keep the chain data. </p>
<p>I will suggest using <code>--in-mem</code> flag which can reach the same goal.</p>
<p>If you dislike that, for example, you can create <code>./dataFolder1</code> and <code>dataFolder2</code>.<br>On the following ngcore command, you should add <code>--db-folder dataFolder1</code> for the first node<br>and <code>--db-folder dataFolder2</code> for the second one</p>
<h2 id="Node-0"><a href="#Node-0" class="headerlink" title="Node #0"></a>Node #0</h2><p>let we start a regression testnet ngcore node with <code>--reg-testnet</code> only first. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ngcore --reg-testnet --db-folder ./env/1 --p2p-key ./env/1.p2pkey </span><br></pre></td></tr></table></figure>

<p>The node will serve its p2p service on 52520 and rpc service on 52521.</p>
<p>Write down this node’s p2p address like <code>16Uiu2HAmL6ojX5jgxJsoo55suHxM8HocaLuMx4uLSfHpER9rTYtJ</code> , which will be used in the connecting step.</p>
<h2 id="Node-1"><a href="#Node-1" class="headerlink" title="Node #1"></a>Node #1</h2><p>Now we need to start another one on different port</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ngcore --reg-testnet --db-folder ./env/2 --p2p-key ./env/2.p2pkey --p2p-port 62620 --rpc-port 62621</span><br></pre></td></tr></table></figure>

<p>The node will serve its p2p service on 62620 and rpc service on 62621.</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>To build a small network, we should use rpc command to manually connect them.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;method&quot;: &quot;addPeer&quot;, &quot;params&quot;: &#123;&quot;peerMultiAddr&quot;: &quot;/ip4/127.0.0.1/tcp/52520/p2p/16Uiu2HAmL6ojX5jgxJsoo55suHxM8HocaLuMx4uLSfHpER9rTYtJ&quot;&#125; &#125;&#x27;</span> http://127.0.0.1:62621</span><br></pre></td></tr></table></figure>

<p><code>16Uiu2HAmL6ojX5jgxJsoo55suHxM8HocaLuMx4uLSfHpER9rTYtJ</code> is the p2p address of node #0 in my machine. You should replace it with yours.</p>
<h2 id="Startup"><a href="#Startup" class="headerlink" title="Startup"></a>Startup</h2><p>Finally, you should let one of your node start mining, to import blocks into your chain.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;method&quot;: &quot;switchMining&quot;, &quot;params&quot;: &#123;&quot;mode&quot;: &quot;on&quot;&#125; &#125;&#x27;</span> http://127.0.0.1:62621</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
        <tag>NGIN</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title>How does Monero pick fake inputs?</title>
    <url>/post/how-xmr-pick-fake-inputs/</url>
    <content><![CDATA[<p>门罗在生成交易时如何选择ringCT中除真实inputs以外的假inputs？</p>
<p>门罗的交易虽然被ringCT和bulletproof协议保护，但是内在仍然是遵守着bitcoin的UTXO模型。即每次交易的实际input，都需要对应上一个交易的output。</p>
<p>但是又由于ringCT的存在，门罗的交易需要选择之前出现过的他人的output来掩盖自己的output。</p>
<span id="more"></span>

<p>因为monerod本身不具备生成交易功能，我们可以确定这个pick过程发生并不在monerod中，而是在monero-wallet-rpc与monero-wallet-cli中。</p>
<p>由于cli（即simplewallet）操作较为直观因此从cli中的<code>transfer</code>命令作为切入点。</p>
<p>cli的源码在<code>src/simplewallet/simplewallet.cpp</code>。</p>
<p>可以看到它直接调用了<code>transfer_main</code>，这个函数也在这个cpp源码中，主要负责的是对arguments的parsing，最后调用wallet的<code>create_transactions_2</code>。</p>
<p>wallet对应的就是源码wallet模块，位于<code>src/wallet/wallet2.cpp</code>。</p>
<p>接着我们逐行查看这个<code>create_transactions_2</code>在做什么</p>
<p>首先是函数头：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;wallet2::pending_tx&gt; <span class="title">wallet2::create_transactions_2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;cryptonote::tx_destination_entry&gt; dsts, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">size_t</span> fake_outs_count, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint64_t</span> unlock_time, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> priority, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; extra, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> subaddr_account, </span></span></span><br><span class="line"><span class="params"><span class="function">    std::set&lt;<span class="type">uint32_t</span>&gt; subaddr_indices)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>dsts</code>是指定的转账目标，可能有多个</li>
<li><code>fake_outs_count</code>是指定的（除真实上个output以外）假output的数量，</li>
<li><code>unlock_time</code>是指定的交易解锁时间（区块高度</li>
<li><code>priority</code>是指定的交易优先级，钱包内部的</li>
<li><code>extra</code>是指定的交易额外信息</li>
<li><code>subaddr_account</code>是指定的转账子地址账户，仅一个。但是一个账户内可能有多个地址（对应多个index</li>
<li><code>subaddr_indices</code>是指定的转账子地址的index，一个交易中可能有多个</li>
</ul>
<p>然后我们直接跳到它使用<code>fake_outs_count</code>的地方</p>
<p>第一处：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// early out if we know we can&#x27;t make it anyway</span></span><br><span class="line"><span class="comment">// we could also check for being within FEE_PER_KB, but if the fee calculation</span></span><br><span class="line"><span class="comment">// ever changes, this might be missed, so let this go through</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> min_fee = (fee_multiplier * base_fee * <span class="built_in">estimate_tx_size</span>(use_rct, <span class="number">1</span>, fake_outs_count, <span class="number">2</span>, extra.<span class="built_in">size</span>(), bulletproof, clsag));</span><br><span class="line"><span class="type">uint64_t</span> balance_subtotal = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> unlocked_balance_subtotal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> index_minor : subaddr_indices)</span><br><span class="line">&#123;</span><br><span class="line">  balance_subtotal += balance_per_subaddr[index_minor];</span><br><span class="line">  unlocked_balance_subtotal += unlocked_balance_per_subaddr[index_minor].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(needed_money + min_fee &gt; balance_subtotal, error::not_enough_money,</span><br><span class="line">  balance_subtotal, needed_money, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// first check overall balance is enough, then unlocked one, so we throw distinct exceptions</span></span><br><span class="line"><span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(needed_money + min_fee &gt; unlocked_balance_subtotal, error::not_enough_unlocked_money,</span><br><span class="line">    unlocked_balance_subtotal, needed_money, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i : subaddr_indices)</span><br><span class="line">  <span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;Candidate subaddress index for spending: &quot;</span> &lt;&lt; i);</span><br></pre></td></tr></table></figure>
<p>这里是利用<code>fake_outs_count</code>计算出最小fee，然后检查账户余额是否足够发起交易（&gt;fee+amount）。</p>
<p>紧跟着是两次调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// determine threshold for fractional amount</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> tx_weight_one_ring = <span class="built_in">estimate_tx_weight</span>(use_rct, <span class="number">1</span>, fake_outs_count, <span class="number">2</span>, <span class="number">0</span>, bulletproof, clsag);</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> tx_weight_two_rings = <span class="built_in">estimate_tx_weight</span>(use_rct, <span class="number">2</span>, fake_outs_count, <span class="number">2</span>, <span class="number">0</span>, bulletproof, clsag);</span><br><span class="line"><span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(tx_weight_one_ring &gt; tx_weight_two_rings, error::wallet_internal_error, <span class="string">&quot;Estimated tx weight with 1 input is larger than with 2 inputs!&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> tx_weight_per_ring = tx_weight_two_rings - tx_weight_one_ring;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> fractional_threshold = (fee_multiplier * base_fee * tx_weight_per_ring) / (use_per_byte_fee ? <span class="number">1</span> : <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>这两次都是用在了estimate_tx_weight函数上，计算出了tx_weight_one_ring和tx_weight_two_rings两个值，用来得到fractional_threshold。</p>
<p>这个阈值在后面被拿来筛选outs</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gather all dust and non-dust outputs belonging to specified subaddresses</span></span><br><span class="line"><span class="type">size_t</span> num_nondust_outputs = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> num_dust_outputs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_transfers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> transfer_details&amp; td = m_transfers[i];</span><br><span class="line">  <span class="keyword">if</span> (m_ignore_fractional_outputs &amp;&amp; td.<span class="built_in">amount</span>() &lt; fractional_threshold)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">MDEBUG</span>(<span class="string">&quot;Ignoring output &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; of amount &quot;</span> &lt;&lt; <span class="built_in">print_money</span>(td.<span class="built_in">amount</span>()) &lt;&lt; <span class="string">&quot; which is below fractional threshold &quot;</span> &lt;&lt; <span class="built_in">print_money</span>(fractional_threshold));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_spent</span>(td, <span class="literal">false</span>) &amp;&amp; !td.m_frozen &amp;&amp; !td.m_key_image_partial &amp;&amp; (use_rct ? <span class="literal">true</span> : !td.<span class="built_in">is_rct</span>()) &amp;&amp; <span class="built_in">is_transfer_unlocked</span>(td) &amp;&amp; td.m_subaddr_index.major == subaddr_account &amp;&amp; subaddr_indices.<span class="built_in">count</span>(td.m_subaddr_index.minor) == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (td.<span class="built_in">amount</span>() &gt; m_ignore_outputs_above || td.<span class="built_in">amount</span>() &lt; m_ignore_outputs_below)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">MDEBUG</span>(<span class="string">&quot;Ignoring output &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; of amount &quot;</span> &lt;&lt; <span class="built_in">print_money</span>(td.<span class="built_in">amount</span>()) &lt;&lt; <span class="string">&quot; which is outside prescribed range [&quot;</span> &lt;&lt; <span class="built_in">print_money</span>(m_ignore_outputs_below) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">print_money</span>(m_ignore_outputs_above) &lt;&lt; <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> index_minor = td.m_subaddr_index.minor;</span><br><span class="line">    <span class="keyword">auto</span> find_predicate = [&amp;index_minor](<span class="type">const</span> std::pair&lt;<span class="type">uint32_t</span>, std::vector&lt;<span class="type">size_t</span>&gt;&gt;&amp; x) &#123; <span class="keyword">return</span> x.first == index_minor; &#125;;</span><br><span class="line">    <span class="keyword">if</span> ((td.<span class="built_in">is_rct</span>()) || <span class="built_in">is_valid_decomposed_amount</span>(td.<span class="built_in">amount</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> found = std::<span class="built_in">find_if</span>(unused_transfers_indices_per_subaddr.<span class="built_in">begin</span>(), unused_transfers_indices_per_subaddr.<span class="built_in">end</span>(), find_predicate);</span><br><span class="line">      <span class="keyword">if</span> (found == unused_transfers_indices_per_subaddr.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        unused_transfers_indices_per_subaddr.<span class="built_in">push_back</span>(&#123;index_minor, &#123;i&#125;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        found-&gt;second.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      ++num_nondust_outputs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> found = std::<span class="built_in">find_if</span>(unused_dust_indices_per_subaddr.<span class="built_in">begin</span>(), unused_dust_indices_per_subaddr.<span class="built_in">end</span>(), find_predicate);</span><br><span class="line">      <span class="keyword">if</span> (found == unused_dust_indices_per_subaddr.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        unused_dust_indices_per_subaddr.<span class="built_in">push_back</span>(&#123;index_minor, &#123;i&#125;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        found-&gt;second.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      ++num_dust_outputs;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如注释所述，这段代码开始收集属于指定的子地址的所有dust和非dust的outs</p>
<p>有关于什么是dust，可以看这个<a href="https://web.getmonero.org/es/resources/research-lab/pubs/MRL-0004.pdf" target="_blank" rel="noopener">MRL-0004</a>，举个例子就是发103.32111111时候有个0.00111111的output。</p>
<p>这里主要是统计出这些dust数量。当然这个算是个历史遗留问题了，现在的ringct上amount已经不可见所以不存在根据dust反推的问题。</p>
<p>暂时不管这个，继续看fake_outs_count的调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for rct, since we don&#x27;t see the amounts, we will try to make all transactions</span></span><br><span class="line"><span class="comment">// look the same, with 1 or 2 inputs, and 2 outputs. One input is preferable, as</span></span><br><span class="line"><span class="comment">// this prevents linking to another by provenance analysis, but two is ok if we</span></span><br><span class="line"><span class="comment">// try to pick outputs not from the same block. We will get two outputs, one for</span></span><br><span class="line"><span class="comment">// the destination, and one for change.</span></span><br><span class="line"><span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;checking preferred&quot;</span>);</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; preferred_inputs;</span><br><span class="line"><span class="type">uint64_t</span> rct_outs_needed = <span class="number">2</span> * (fake_outs_count + <span class="number">1</span>);</span><br><span class="line">rct_outs_needed += <span class="number">100</span>; <span class="comment">// some fudge factor since we don&#x27;t know how many are locked</span></span><br><span class="line"><span class="keyword">if</span> (use_rct)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// this is used to build a tx that&#x27;s 1 or 2 inputs, and 2 outputs, which</span></span><br><span class="line">  <span class="comment">// will get us a known fee.</span></span><br><span class="line">  <span class="type">uint64_t</span> estimated_fee = <span class="built_in">estimate_fee</span>(use_per_byte_fee, use_rct, <span class="number">2</span>, fake_outs_count, <span class="number">2</span>, extra.<span class="built_in">size</span>(), bulletproof, clsag, base_fee, fee_multiplier, fee_quantization_mask);</span><br><span class="line">  preferred_inputs = <span class="built_in">pick_preferred_rct_inputs</span>(needed_money + estimated_fee, subaddr_account, subaddr_indices);</span><br><span class="line">  <span class="keyword">if</span> (!preferred_inputs.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: preferred_inputs) s += boost::<span class="built_in">lexical_cast</span>&lt;std::string&gt;(i) + <span class="string">&quot; (&quot;</span> + <span class="built_in">print_money</span>(m_transfers[i].<span class="built_in">amount</span>()) + <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    <span class="built_in">LOG_PRINT_L1</span>(<span class="string">&quot;Found preferred rct inputs for rct tx: &quot;</span> &lt;&lt; s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bring the list of available outputs stored by the same subaddress index to the front of the list</span></span><br><span class="line">    <span class="type">uint32_t</span> index_minor = m_transfers[preferred_inputs[<span class="number">0</span>]].m_subaddr_index.minor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; unused_transfers_indices_per_subaddr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (unused_transfers_indices_per_subaddr[i].first == index_minor)</span><br><span class="line">      &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(unused_transfers_indices_per_subaddr[<span class="number">0</span>], unused_transfers_indices_per_subaddr[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; unused_dust_indices_per_subaddr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (unused_dust_indices_per_subaddr[i].first == index_minor)</span><br><span class="line">      &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(unused_dust_indices_per_subaddr[<span class="number">0</span>], unused_dust_indices_per_subaddr[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;done checking preferred&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对于 rct，由于我们没有看到金额，我们将尝试使所有交易看起来都相同，具有 1 或 2 个输入和 2 个输出。 1个input是可取的，因为这可以防止通过出处分析链接到另一个，但是如果我们尝试选择不是来自同一个块的输出，2个input也是可以的。 我们将得到两个输出，一个用于目的地，一个用于更改。</p>
<p>这里对fake_outs_count的利用是先计算出了rct_outs_needed，然后使用estimate_fee函数得到了预计的fee</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while:</span></span><br><span class="line"><span class="comment">// - we have something to send</span></span><br><span class="line"><span class="comment">// - or we need to gather more fee</span></span><br><span class="line"><span class="comment">// - or we have just one input in that tx, which is rct (to try and make all/most rct txes 2/2)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> original_output_index = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt;* unused_transfers_indices = &amp;unused_transfers_indices_per_subaddr[<span class="number">0</span>].second;</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt;* unused_dust_indices      = &amp;unused_dust_indices_per_subaddr[<span class="number">0</span>].second;</span><br><span class="line"></span><br><span class="line">hwdev.<span class="built_in">set_mode</span>(hw::device::TRANSACTION_CREATE_FAKE);</span><br><span class="line"><span class="keyword">while</span> (</span><br><span class="line">  (!dsts.<span class="built_in">empty</span>() &amp;&amp; dsts[<span class="number">0</span>].amount &gt; <span class="number">0</span>) || adding_fee || </span><br><span class="line">  !preferred_inputs.<span class="built_in">empty</span>() || </span><br><span class="line">  <span class="built_in">should_pick_a_second_output</span>(use_rct, txes.<span class="built_in">back</span>().selected_transfers.<span class="built_in">size</span>(), *unused_transfers_indices, *unused_dust_indices)</span><br><span class="line">) &#123;</span><br><span class="line">  TX &amp;tx = txes.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>
<p>后面的在这个while里，这个while实在是太大了所以先看看头部。</p>
<p>&#x2F;&#x2F; while：<br>&#x2F;&#x2F; - 我们有东西要发送<br>&#x2F;&#x2F; - 或者我们需要收取更多费用<br>&#x2F;&#x2F; - 或者我们在该 tx 中只有一个输入，即 rct（尝试使所有&#x2F;大多数 rct txes 为 2&#x2F;2）</p>
<p>这里就是在把以前交易的outputs一条条理过去，看需要哪几个以前的outputs能支持这次transfer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">estimate_tx_weight</span>(use_rct, tx.selected_transfers.<span class="built_in">size</span>(), fake_outs_count, tx.dsts.<span class="built_in">size</span>()+<span class="number">1</span>, extra.<span class="built_in">size</span>(), bulletproof, clsag) &lt; <span class="built_in">TX_WEIGHT_TARGET</span>(upper_transaction_weight_limit)</span><br></pre></td></tr></table></figure>

<p>while中是使用了estimate_tx_weight来判断tx的weight是否超出限制</p>
<p>最后使用transfer_selected_rct（如果不用ringCT那就是transfer_selected，但是现在怎么可能不rct）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transfer_selected_rct</span>(tx.dsts,                    <span class="comment">/* NOMOD std::vector&lt;cryptonote::tx_destination_entry&gt; dsts,*/</span></span><br><span class="line">                      tx.selected_transfers,      <span class="comment">/* const std::list&lt;size_t&gt; selected_transfers */</span></span><br><span class="line">                      fake_outs_count,            <span class="comment">/* CONST size_t fake_outputs_count, */</span></span><br><span class="line">                      tx.outs,                    <span class="comment">/* MOD   std::vector&lt;std::vector&lt;tools::wallet2::get_outs_entry&gt;&gt; &amp;outs, */</span></span><br><span class="line">                      unlock_time,                <span class="comment">/* CONST uint64_t unlock_time,  */</span></span><br><span class="line">                      tx.needed_fee,              <span class="comment">/* CONST uint64_t fee, */</span></span><br><span class="line">                      extra,                      <span class="comment">/* const std::vector&lt;uint8_t&gt;&amp; extra, */</span></span><br><span class="line">                      test_tx,                    <span class="comment">/* OUT   cryptonote::transaction&amp; tx, */</span></span><br><span class="line">                      test_ptx,                   <span class="comment">/* OUT   cryptonote::transaction&amp; tx, */</span></span><br><span class="line">                      rct_config);</span><br></pre></td></tr></table></figure>
<p>这个是个将近300行的相比上一个“较为简单的”函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (outs.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">get_outs</span>(outs, selected_transfers, fake_outputs_count, all_rct); <span class="comment">// may throw</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prepare inputs</span></span><br><span class="line"><span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;preparing outputs&quot;</span>);</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>, out_index = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;cryptonote::tx_source_entry&gt; sources;</span><br><span class="line">std::unordered_set&lt;rct::key&gt; used_L;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> idx: selected_transfers)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(outs.<span class="built_in">size</span>() &lt; out_index + <span class="number">1</span> ,  error::wallet_internal_error, <span class="string">&quot;outs.size() &lt; out_index + 1&quot;</span>); </span><br><span class="line">  <span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(outs[out_index].<span class="built_in">size</span>() &lt; fake_outputs_count ,  error::wallet_internal_error, <span class="string">&quot;fake_outputs_count &gt; random outputs found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">typedef</span> cryptonote::tx_source_entry::output_entry tx_output_entry;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">0</span>; n &lt; fake_outputs_count + <span class="number">1</span>; ++n)</span><br><span class="line">  &#123;</span><br><span class="line">    tx_output_entry oe;</span><br><span class="line">    oe.first = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(outs[out_index][n]);</span><br><span class="line">    oe.second.dest = rct::<span class="built_in">pk2rct</span>(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(outs[out_index][n]));</span><br><span class="line">    oe.second.mask = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(outs[out_index][n]);</span><br><span class="line">    src.outputs.<span class="built_in">push_back</span>(oe);</span><br><span class="line">  &#125;</span><br><span class="line">  ++i;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>所以我们基本上可以确定了outs是从函数get_outs中得到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wallet2::get_outs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  std::vector&lt;std::vector&lt;tools::wallet2::get_outs_entry&gt;&gt; &amp;outs, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> std::vector&lt;<span class="type">size_t</span>&gt; &amp;selected_transfers, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">size_t</span> fake_outputs_count, </span></span></span><br><span class="line"><span class="params"><span class="function">  std::vector&lt;<span class="type">uint64_t</span>&gt; &amp;rct_offsets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br></pre></td></tr></table></figure>
<p>源码里有俩get_outs，千万别看错<br>transfer_selected_rct调用的第四个参数是all_rct，为一个vec<br>transfer_selected调用的第四个参数是false，为bool</p>
<p>这个函数非常nb的有将近600行……当然主要是因为兼顾了各个fork</p>
<p>主要的选妃流程差不多就这么点代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make sure the real outputs we asked for are really included, along</span></span><br><span class="line"><span class="comment">// with the correct key and mask: this guards against an active attack</span></span><br><span class="line"><span class="comment">// where the node sends dummy data for all outputs, and we then send</span></span><br><span class="line"><span class="comment">// the real one, which the node can then tell from the fake outputs,</span></span><br><span class="line"><span class="comment">// as it has different data than the dummy data it had sent earlier</span></span><br><span class="line"><span class="type">bool</span> real_out_found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">0</span>; n &lt; requested_outputs_count; ++n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i = base + n;</span><br><span class="line">  <span class="keyword">if</span> (req.outputs[i].index == td.m_global_output_index)</span><br><span class="line">    <span class="keyword">if</span> (daemon_resp.outs[i].key == boost::<span class="built_in">get</span>&lt;txout_to_key&gt;(td.m_tx.vout[td.m_internal_output_index].target).key)</span><br><span class="line">      <span class="keyword">if</span> (daemon_resp.outs[i].mask == mask)</span><br><span class="line">        <span class="keyword">if</span> (daemon_resp.outs[i].unlocked)</span><br><span class="line">          real_out_found = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(!real_out_found, error::wallet_internal_error,</span><br><span class="line">    <span class="string">&quot;Daemon response did not include the requested real output&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pick real out first (it will be sorted when done)</span></span><br><span class="line">outs.<span class="built_in">back</span>().<span class="built_in">push_back</span>(std::<span class="built_in">make_tuple</span>(td.m_global_output_index, boost::<span class="built_in">get</span>&lt;txout_to_key&gt;(td.m_tx.vout[td.m_internal_output_index].target).key, mask));</span><br><span class="line"></span><br><span class="line"><span class="comment">// then pick outs from an existing ring, if any</span></span><br><span class="line"><span class="keyword">if</span> (td.m_key_image_known &amp;&amp; !td.m_key_image_partial)</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint64_t</span>&gt; ring;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">get_ring</span>(<span class="built_in">get_ringdb_key</span>(), td.m_key_image, ring))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint64_t</span> out: ring)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (out &lt; num_outs)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (out != td.m_global_output_index)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">size_t</span> o = <span class="number">0</span>; o &lt; requested_outputs_count; ++o)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="type">size_t</span> i = base + o;</span><br><span class="line">            <span class="keyword">if</span> (req.outputs[i].index == out)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; requested_outputs_count &lt;&lt; <span class="string">&quot;: idx &quot;</span> &lt;&lt; req.outputs[i].index &lt;&lt; <span class="string">&quot; (real &quot;</span> &lt;&lt; td.m_global_output_index &lt;&lt; <span class="string">&quot;), unlocked &quot;</span> &lt;&lt; daemon_resp.outs[i].unlocked &lt;&lt; <span class="string">&quot;, key &quot;</span> &lt;&lt; daemon_resp.outs[i].key &lt;&lt; <span class="string">&quot; (from existing ring)&quot;</span>);</span><br><span class="line">              <span class="built_in">tx_add_fake_output</span>(outs, req.outputs[i].index, daemon_resp.outs[i].key, daemon_resp.outs[i].mask, td.m_global_output_index, daemon_resp.outs[i].unlocked);</span><br><span class="line">              found = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">THROW_WALLET_EXCEPTION_IF</span>(!found, error::wallet_internal_error, <span class="string">&quot;Falied to find existing ring output in daemon out data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then pick others in random order till we reach the required number</span></span><br><span class="line"><span class="comment">// since we use an equiprobable pick here, we don&#x27;t upset the triangular distribution</span></span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; order;</span><br><span class="line">order.<span class="built_in">resize</span>(requested_outputs_count);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> n = <span class="number">0</span>; n &lt; order.<span class="built_in">size</span>(); ++n)</span><br><span class="line">  order[n] = n;</span><br><span class="line">std::<span class="built_in">shuffle</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), crypto::random_device&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;Looking for &quot;</span> &lt;&lt; (fake_outputs_count+<span class="number">1</span>) &lt;&lt; <span class="string">&quot; outputs of size &quot;</span> &lt;&lt; <span class="built_in">print_money</span>(td.<span class="built_in">is_rct</span>() ? <span class="number">0</span> : td.<span class="built_in">amount</span>()));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> o = <span class="number">0</span>; o &lt; requested_outputs_count &amp;&amp; outs.<span class="built_in">back</span>().<span class="built_in">size</span>() &lt; fake_outputs_count + <span class="number">1</span>; ++o)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i = base + order[o];</span><br><span class="line">  <span class="built_in">LOG_PRINT_L2</span>(<span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; requested_outputs_count &lt;&lt; <span class="string">&quot;: idx &quot;</span> &lt;&lt; req.outputs[i].index &lt;&lt; <span class="string">&quot; (real &quot;</span> &lt;&lt; td.m_global_output_index &lt;&lt; <span class="string">&quot;), unlocked &quot;</span> &lt;&lt; daemon_resp.outs[i].unlocked &lt;&lt; <span class="string">&quot;, key &quot;</span> &lt;&lt; daemon_resp.outs[i].key);</span><br><span class="line">  <span class="built_in">tx_add_fake_output</span>(outs, req.outputs[i].index, daemon_resp.outs[i].key, daemon_resp.outs[i].mask, td.m_global_output_index, daemon_resp.outs[i].unlocked);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (outs.<span class="built_in">back</span>().<span class="built_in">size</span>() &lt; fake_outputs_count + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  scanty_outs[td.<span class="built_in">is_rct</span>() ? <span class="number">0</span> : td.<span class="built_in">amount</span>()] = outs.<span class="built_in">back</span>().<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// sort the subsection, so any spares are reset in order</span></span><br><span class="line">  std::<span class="built_in">sort</span>(outs.<span class="built_in">back</span>().<span class="built_in">begin</span>(), outs.<span class="built_in">back</span>().<span class="built_in">end</span>(), [](<span class="type">const</span> get_outs_entry &amp;a, <span class="type">const</span> get_outs_entry &amp;b) &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(a) &lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(b); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">base += requested_outputs_count;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>monero</tag>
        <tag>ringct</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS TLS JA3</title>
    <url>/post/https-tls-ja3/</url>
    <content><![CDATA[<p>JA3能不能用来识别纯tls链接数据？</p>
<span id="more"></span>

<p>JA3(S)的原理是计算握手最后Hello包的信息，那对于纯TLS，非HTTPS的流是否可以获得JA3？</p>
<p>这个问题是因为在查看挖矿软件走TLS的时候发现了Wireshark的JA3插件并没有对其握手计算JA3的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JA3S=md5(</span><br><span class="line">    server_handshake.tls_version + &quot;,&quot; + </span><br><span class="line">    server_handshake.cipher_suites + &quot;,&quot; +</span><br><span class="line">    &quot;-&quot;.join(server_handshake.extensions)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>依然能在包里找到对应的握手内容</p>
<img src="/post/https-tls-ja3/handshake.png" class="">

<p>因此应该是扩展限定了端口的问题</p>
<p>我这边用的Wireshark插件是<a href="https://github.com/fullylegit/ja3/blob/master/ja3.lua" target="_blank" rel="noopener">https://github.com/fullylegit/ja3/blob/master/ja3.lua</a></p>
<p>可以看到在最后它加了443端口的限制</p>
<p>这样在最后加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp_dissector_table:add( 5555, proto_ja3 )</span><br></pre></td></tr></table></figure>

<img src="/post/https-tls-ja3/ja3.png" class="">

<p>这样就可以看到在5555端口上的JA3S值了</p>
]]></content>
  </entry>
  <entry>
    <title>Idea on edX&#39;s Blockchain Technology</title>
    <url>/post/idea-on-edx-blockchain-tech/</url>
    <content><![CDATA[<p>Some writes for edx blockchain course</p>
<span id="more"></span>

<h2 id="What-is-PoW"><a href="#What-is-PoW" class="headerlink" title="What is PoW"></a>What is PoW</h2><p>The idea for Proof of Work(PoW) was first published in 1993 by Cynthia Dwork and Moni Naor and was later applied by Satoshi Nakamoto in the Bitcoin paper in 2008. Proof of Work consensus is the mechanism of choice for the majority of cryptocurrencies currently in circulation. The term “proof of work” was first used by Markus Jakobsson and Ari Juels in a publication in 1999. Nowadays, it is widely used in public chain projects especially bitcoin and ethereum codebased ones</p>
<p>The goal of PoW is to maintain the p2p network, defending from DoS attacks, and gurantee the value’s safety on chain. PoW imposes some restrictions on operations in the network. They need to put a lot of effort into execution. Effective attacks require a lot of computing power and a lot of time to calculate. Therefore, an attack is possible, but it is useless because the cost is too high. And it is important to have strong computing power to solve difficult problems and form new obstacles no matter how much money in the wallet. Therefore, the holders of huge amounts of funds are not responsible for the decision of the entire network. It is more like a “two factor authorization”, because it uses non-service-ralated factors, like CPU computation, to gurantee datastore in the chain is safe. For example, in bitcoin, coins are “mined” using the Hashcash proof-of-work function by individual miners and verified by the decentralized nodes in the P2P bitcoin network. And the difficulty is periodically adjusted to keep the block time around a target time.</p>
<h2 id="The-Understanding-on-Proof-of-Work"><a href="#The-Understanding-on-Proof-of-Work" class="headerlink" title="The Understanding on Proof of Work"></a>The Understanding on Proof of Work</h2><p>The defination of PoW is well-known, so I wont repeat these basic infomation. On the other hand, as an experienced PoW(mining) project host and user, I would argue more personal opinion about the “shortages” of PoW ecosystem.</p>
<p>0x01 Energy really is wasted on PoW?</p>
<p>Almost all opponents of PoW are focus on the usage of electricity, and then comparing to their home electricity price to conclude a huge lost result. But the fact is, the waste is less than they imagine, even no actual loss. </p>
<p>I have to answer, no, PoW is not a waste of electricity.</p>
<p>As a Chinese, I know how a miner or a mining farm manager controls his cost on electric - find the cheapest electricity source. In China, you can find excess hydropower in wide Southern area, and wind power in West. If there is no mining pool, the cheap electricity will have to be moved to the national power grid and add the high transportation cost to its price. Thus in large cities, like Shanghai, electricity price is much higher. But with mining, the value of electricity can be converted into the coin value on the first time, and we just need to move the necessary part to maintain the power grid. So we can avoid the power loss on transportation, we can avoid the value loss on transportation, even we can avoid the extra cost on electricity management.</p>
<p>And also, the cost of PoW is not more than the triditional economy. We always call cryptocurrency “the new money”, and it represents that the cryptocurrency itself can be a standalone economic system. You can google how many resources are wasted by the “old moneys”, the cost of every banks, clearing houses, finance brokers etc. The answer is that it must be larger than PoW. I am used to worked in Citibank, I saw the stuffs never turn off their computers after work, I saw the sub-branch was open but did not serve anyone, I saw stuffs competing with each other by food-wasting Chinese style dinners. So why their work is not resource-consuming, but PoW is?</p>
<p>0x01 PoW is worse than other consensus?</p>
<p>Nowadays it is a trend that desperating PoW in blockchain developing, and the projects which still uses PoW are all treated as a “Bitcoin style”, “Old style”, “Out of date style”, regardless of whether it is really a bitcoin fork.</p>
<p>But I have to answer again, no, PoW is never worse than anyone, especially for public chain.</p>
<p>I had maintained one cryptocurrency project. Maybe beacase of the situation which was fulfilled with eth tokens or the token-style project name, my project was always treated as a token. After publishing on bitcointalk forum, tons of vendors sent me message - provide ICO(initial coin offering) service, provide advertisement service, provide exchange service, provide google rank service, provide youtube interview service, etc. But all of them were charging 0.5-2BTC which I cannot afford as a small technical project. The fact was that we were a PoW mining project having a great scene application. I felt failure at first becasue I cannot afford services. However, after mainnet igniting, the hashrate of the network was pumping and the coin price was pumping. Then I started reviewing bitcoin, ethereum, and projects born from ethereum like EOS.</p>
<p>It is clear that, PoW leads to the bitcoin’s successful. Without it, there will be nobody who are willing to pay their fiat currency to a useless unreliable coin whose founder disappering. </p>
<p>As for ethereum, though Vitalik Buterin says PoS is a better, without Ethash, ethereum wont ignite its mainnet and pump its coin price. </p>
<p>Some will argue that ethereum’s success is from its decentralized applications, which is not depending on mainnet coin price nor PoW consensus. Maybe it’s right, it is true that PoW is not fit for private chain or union chain, becasue it needs other factors to keep the network safety instead of electricity. But the opponents still have to approve that the PoW guarantee the robust of ethereum’s, as a public chain, “value network”. And also, with this, ethereum is able to serve the well-known token publish services. Provided with no PoW gurantee, ethereum will be hard to serve at beginning. After all, bitcoin network, or bitcoin forks can also privide token services, and projects like EOS would be ICOed in bitcoin network not ethereum.</p>
<h2 id="What-is-consensus"><a href="#What-is-consensus" class="headerlink" title="What is consensus?"></a>What is consensus?</h2><p>There is <a href="https://godoc.org/github.com/libp2p/go-libp2p-consensus" target="_blank" rel="noopener">an abstract go lib</a> which is great for understanding what consensus is</p>
<p>And its theorical raft implement is <a href="https://godoc.org/github.com/libp2p/go-libp2p-raft" target="_blank" rel="noopener">here</a>, practical raft implement is <a href="https://godoc.org/github.com/ipfs/ipfs-cluster/consensus/raft" target="_blank" rel="noopener">here</a></p>
<p>So, in short, consensus is a manager of state, which ensures the state’s unify among p2p network, accepting and execuating continuous opeartions on state. </p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>edx</tag>
      </tags>
  </entry>
  <entry>
    <title>LELTS Notes</title>
    <url>/post/ielts-notes/</url>
    <content><![CDATA[<p>雅思笔记</p>
<span id="more"></span>

<h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h2 id="题目对应文章内容顺序"><a href="#题目对应文章内容顺序" class="headerlink" title="题目对应文章内容顺序"></a>题目对应文章内容顺序</h2><table>
<thead>
<tr>
<th>题型</th>
<th>顺序？</th>
</tr>
</thead>
<tbody><tr>
<td>选择</td>
<td>顺序</td>
</tr>
<tr>
<td>填空（段落概括）</td>
<td>个别答案乱序</td>
</tr>
<tr>
<td>填空（其他）</td>
<td>简答，句子填卡，表格填卡，笔记填空，流程图填空，示意图填空均顺序</td>
</tr>
<tr>
<td>配对</td>
<td>乱序</td>
</tr>
<tr>
<td>总体</td>
<td>跨题型不一定顺序</td>
</tr>
</tbody></table>
<h1 id="L-听力"><a href="#L-听力" class="headerlink" title="L: 听力"></a>L: 听力</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p>考试时间30min+10填卡，共4*10问</p>
<p>题型</p>
<ul>
<li>信息表题</li>
<li>分类比较表</li>
<li>笔记填空</li>
<li>单句填空</li>
<li>简答填空</li>
<li>分类配对</li>
<li>单选多选</li>
<li>(地图流程)</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>要点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>租房住宿</strong></td>
<td>房价水电煤价(数字)，地理位置，家具，花园，车库，厨房设施</td>
</tr>
<tr>
<td><strong>旅行</strong></td>
<td>度假地，娱乐内容，交通工具，住处，人数，价格，预定机票房价(细节)</td>
</tr>
<tr>
<td>购物</td>
<td>优缺点，价格，个人信息，专家意见</td>
</tr>
<tr>
<td>地理</td>
<td>地点，人名，气候，语言，当地主要产业，主要景点，优缺点</td>
</tr>
<tr>
<td>图书馆</td>
<td>办证所需材料，使用须知等</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>题号</th>
<th>场景类别</th>
</tr>
</thead>
<tbody><tr>
<td>L1</td>
<td>日常活动</td>
</tr>
<tr>
<td>L2</td>
<td>新生入学</td>
</tr>
<tr>
<td>L3</td>
<td>选课，论文研究</td>
</tr>
<tr>
<td>L4</td>
<td>学术讲座: 野生动物，地理</td>
</tr>
</tbody></table>
<h3 id="信息表"><a href="#信息表" class="headerlink" title="信息表"></a>信息表</h3><h4 id="人名"><a href="#人名" class="headerlink" title="人名"></a>人名</h4><ol>
<li>拼写</li>
</ol>
<ul>
<li>大小写</li>
<li>辨析l&#x2F;o m&#x2F;n t&#x2F;s a&#x2F;i&#x2F;r</li>
<li>fullname (first-last, given-family, fore-sur)</li>
</ul>
<ol start="2">
<li>名字格式</li>
</ol>
<p>Title: Mr.&#x2F;Mrs.&#x2F;Miss&#x2F; Ms.(发音类Mizi)&#x2F;Dr.&#x2F;Prof. + 姓氏</p>
<ol start="3">
<li>常见名字</li>
</ol>
<p>默认考生会写</p>
<p>Kevin, Helen, Mike, John, Lee</p>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><ul>
<li><strong>英式</strong>: DD&#x2F;MM&#x2F;YY &#x3D;&gt; 8th March, 2004</li>
<li>美式: MM&#x2F;DD&#x2F;YY &#x3D;&gt; March 8th, 2004</li>
</ul>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>纯数字:</p>
<ul>
<li>Telephone number</li>
<li>Fax number </li>
<li>Account number</li>
<li>Credit card number</li>
</ul>
<p>数字字母组合:</p>
<ul>
<li>Driver’s license number</li>
<li>Passport number</li>
<li>Flight number</li>
<li>Membership number</li>
<li>Student ID number</li>
<li>Postcode</li>
</ul>
<p>Tricks:</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>两个或三个数字重复</td>
<td>double&#x2F;triple</td>
</tr>
<tr>
<td>0</td>
<td>o, zero, nought&#x2F;naught</td>
</tr>
<tr>
<td>18003456000</td>
<td>800 &#x3D;&gt; eight hundred, 6000 &#x3D;&gt; six thousand, 其他逐个</td>
</tr>
<tr>
<td>电话</td>
<td>出现area code或country code必须加上</td>
</tr>
</tbody></table>
<h4 id="国籍"><a href="#国籍" class="headerlink" title="国籍"></a>国籍</h4><p>必须形容词形式 e.g. London &#x3D;&gt; British |</p>
<h4 id="受教育水平"><a href="#受教育水平" class="headerlink" title="受教育水平"></a>受教育水平</h4><p>Undergraduate &#x3D;&gt; Postgraduate</p>
<h4 id="教职"><a href="#教职" class="headerlink" title="教职"></a>教职</h4><p>学院: faculty&#x2F;department</p>
<h4 id="主修"><a href="#主修" class="headerlink" title="主修"></a>主修</h4><p>subject&#x2F;major</p>
<h3 id="考察频率"><a href="#考察频率" class="headerlink" title="考察频率"></a>考察频率</h3><p>最常: Social&#x2F; Environment&#x2F; Science</p>
<p>不常: Crime&#x2F; Culture&#x2F; Language&#x2F; Celebrity</p>
<h2 id="分类比较表"><a href="#分类比较表" class="headerlink" title="分类比较表"></a>分类比较表</h2><p>扫描横纵轴&#x3D;&gt;表格整体内容</p>
<p>听前: 根据已知信息&#x3D;&gt; 预判缺失信息</p>
<p>听时: &#x3D;&gt; 定位未知信息 (顺序)</p>
<p>所听即所得。</p>
<p>注意点：</p>
<ul>
<li>题目要求(words&amp;number count)&amp;拼写规律</li>
<li>n. 单复数</li>
<li>v. 时态</li>
<li>adj. 比较级最高级(上下一致)</li>
</ul>
<h2 id="单句填空"><a href="#单句填空" class="headerlink" title="单句填空"></a>单句填空</h2><ol>
<li>获取背景</li>
<li>画出信号词&#x3D;&gt;预测词性</li>
<li>注意多个信息同时给出情况</li>
<li>注意：<strong>时间， 人名，数字，专有书写</strong></li>
<li>首字母大写</li>
</ol>
<p>信号词后置情况</p>
<ol>
<li>被动 A include B &#x3D;&gt; B is included in A</li>
<li>形容词结构 Excellent XX &#x3D;&gt; I thought sth was excellent</li>
<li>介词+n. A+of&#x2F;for&#x2F;about&#x2F;in&#x2F;on&#x2F;to+B&#x3D; B A  e.g. the habit of animals &#x3D; animals habit</li>
</ol>
<p>aaa’s xxx : aaa有生命</p>
<p>xxx of bbb : bbb无生命</p>
<p>key <strong>to</strong></p>
<p>solution <strong>to</strong> </p>
<ol start="4">
<li>修饰词后置 goods made of aaa &amp; bbb: The tech they introduced meant that <em>metal</em> and <em>leather</em> goods were produced …</li>
<li>位置拆分: xxx is header of ____? A: Yes she is in Computer center B: She is header now.</li>
</ol>
<h2 id="笔记填空"><a href="#笔记填空" class="headerlink" title="笔记填空"></a>笔记填空</h2><p>一般L3，L4，题材为lecture</p>
<p>所听即所得</p>
<p>信号词</p>
<ul>
<li>实词(adj. n. v.) or 其替换词</li>
<li>逻辑关系</li>
<li><strong>转折</strong></li>
<li>顺序，序列</li>
<li>解释</li>
<li>因果</li>
</ul>
<p>and&#x2F; in addition&#x2F; one more thing&#x2F; what’s more&#x2F; besides&#x2F; either&#x2F; also</p>
<p>too&#x2F; as well &#x2F; moreover &#x2F; together&#x2F; further more</p>
<p>for instance&#x2F; for example &#x2F; such as &#x2F; like &#x3D; <strong>saying</strong></p>
<p>likewise&#x2F; similary</p>
<p>Although&#x2F; by(in) contrast&#x2F; as a matter of fact&#x2F; nevertheless&#x2F; instead&#x2F; however&#x2F; otherwise&#x2F; while&#x2F; but &#x2F; despite &#x2F; on the contrary&#x2F; on the other hand &#x2F; in spite of &#x2F; whereas</p>
<p>顺序序列:<br>first&#x2F; in the first place&#x2F; first of all&#x2F; to begin with&#x2F; previously&#x2F; second&#x2F; then&#x2F; subsequently&#x2F; last but not least&#x2F; third&#x2F; in the middle&#x2F; after&#x2F; between&#x2F; before&#x2F; meanwhile&#x2F; after&#x2F; between&#x2F; before&#x2F; meanwhile&#x2F; until</p>
<p>for a start&#x2F; afterward&#x2F; finally&#x2F; for one thing&#x2F; for another</p>
<p>解释强调:<br>That is&#x2F; particular&#x2F; I mean&#x2F; namely&#x2F; especially&#x2F; actually&#x2F; specially&#x2F; equally&#x2F; in other words&#x2F; that is to say&#x2F; another way of saying</p>
<p>因果关系-&gt;(果)<br>as a result&#x2F; therefore&#x2F; so&#x2F; for this reason&#x2F; consquently&#x2F; thus&#x2F; because of &#x2F; for &#x2F; since</p>
<p>总结<br>as a result in short&#x2F; in sum&#x2F; on the whole&#x2F; in concluction&#x2F; in brief&#x2F; to conclude&#x2F; in a word&#x2F; to sum up&#x2F; to summarize&#x2F; altogether&#x2F; finally&#x2F; consequently&#x2F; thus&#x2F; therefore&#x2F; overall</p>
<p>预示关键信息到来<br>What I mean is xxx &#x2F; and I will xxx &#x2F; before I move on to xxx &#x2F; no. sorry</p>
<p>场景词(图书馆+论文)</p>
<ul>
<li>questionaire 问卷&#x2F;调查对象</li>
<li>wording 措辞</li>
<li>response rate 回收率</li>
<li>car park &#x3D; parking lot &#x3D; 停车场</li>
<li>respondents 调查对象</li>
</ul>
<p>身体部位:<br>skin&#x2F; fur&#x2F; feather&#x2F; quill&#x2F; hair&#x2F; wing&#x2F; claw&#x2F; hoof&#x2F; paw&#x2F; front feet&#x2F; back leg&#x2F; muscle&#x2F; lip&#x2F; membrane(膜)&#x2F; beak&#x2F; nose hole&#x3D; nostril&#x2F; neck&#x2F; back&#x2F; skull&#x2F; skeleton&#x2F; tail&#x2F; bladder(膀胱) &#x2F; scale(鳞片)&#x2F; nail </p>
<p>prevent from predator&#x2F; prey&#x2F; squirrel松鼠&#x2F; squid乌贼&#x2F; raccoon狸</p>
<p>maintain  the group&#x2F;unity</p>
<p>camouflage</p>
<p>feed&#x2F;breed offsprings</p>
<p>move underground</p>
<p>adapt to harsh env</p>
<h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><p>who&#x2F;when&#x2F;where&#x2F;what&#x2F;why</p>
<h3 id="分类配对"><a href="#分类配对" class="headerlink" title="分类配对"></a>分类配对</h3><ul>
<li>题干展开</li>
<li>选项展开</li>
</ul>
<p>不要忽略I agree with&#x2F; it is the same as …</p>
<h3 id="地图流程题"><a href="#地图流程题" class="headerlink" title="地图流程题"></a>地图流程题</h3><h3 id="单选-x2F-多选"><a href="#单选-x2F-多选" class="headerlink" title="单选&#x2F;多选"></a>单选&#x2F;多选</h3><p>L2&#x2F;L3</p>
<ul>
<li><strong>补全式选择</strong></li>
<li>问答式选择</li>
</ul>
<p>选项</p>
<ul>
<li>短: 只需比较之间相同与不同之处做纵向扫描</li>
<li>长: 至少把最长选项划出核心词</li>
</ul>
<p>原则<br>顺序: 最后一个往往正确<br>同性相斥: 俩同一概念则都不正确<br>陌生词汇: 陌生词汇往往不是答案<br>绝对性: only must只要注意材料里有没有绝对判断，往往不是答案<br>最近答案: 不要看到选项文字一致就选择，答案往往是同义表达(trap)。</p>
<p>陷阱</p>
<ul>
<li>v. n. 替换</li>
<li>形容词 副词 替换</li>
</ul>
<p>数字替换</p>
<ul>
<li>a quarter &#x3D; 25% &#x3D; 1&#x2F;4 &#x3D; 15min &#x3D; 3month</li>
<li>in the 1980s &#x3D; in the 20th centry</li>
<li>fortnight &#x3D; 14d &#x3D; 2week</li>
<li>couple &#x3D; 2</li>
<li>dozen &#x3D; 12</li>
<li>decade &#x3D; 10y</li>
<li>century &#x3D; 100y</li>
<li>1980s &#x3D; 1980~1989</li>
</ul>
<p>同义词，同义词组 替换</p>
<ul>
<li>approach &#x3D;&gt; method</li>
<li>assistance &#x3D;&gt; help</li>
<li>travel &#x3D;&gt; goto</li>
<li>A rather than B &#x3D;&gt; prefer A to B</li>
</ul>
<p>句式转换</p>
<ul>
<li>双重否定 &#x3D;&gt; 肯定</li>
<li>主动 &#x3D;&gt; 被动</li>
</ul>
<p>fee &#x3D;&gt; charge<br>permit &#x3D;&gt; allow<br>scientist &#x3D;&gt; reseacher<br>disadv &#x3D;&gt; downside<br>sign &#x3D;&gt; dication</p>
<h1 id="S-口语"><a href="#S-口语" class="headerlink" title="S: 口语"></a>S: 口语</h1><h1 id="S1"><a href="#S1" class="headerlink" title="S1"></a>S1</h1><p>It is important to do … for undergraduate</p>
<p>How + adj + 主 + 谓 &#x3D;&gt; How excited we are</p>
<p>be disappointed <strong>at</strong> </p>
<p>whether to do (or not)</p>
<p>look forwarding to <strong>doing</strong></p>
<p>insist on <strong>doing</strong>&#x2F; sth&#x2F; one’s doing</p>
<p>He insists on <strong>our</strong> accepting the xxx</p>
<ul>
<li>hear sb. doing</li>
<li>find sb. done</li>
</ul>
<p>sth 介词短语 in order 处于状态</p>
<p>类型</p>
<ul>
<li><strong>喜好</strong></li>
<li><strong>个人习惯</strong></li>
<li><strong>个人偏好</strong></li>
<li>比较</li>
<li>观点</li>
<li>解释</li>
<li>未来计划</li>
<li>大群体问题</li>
<li>问题解决方案</li>
<li>引子（引导）</li>
</ul>
<p>WH: sb. do sth + 人 + 时 + 地 + 目的</p>
<p>I always <strong>go</strong> swimming <strong>when</strong> I have free time <strong>on</strong> local swimming stadium <strong>to</strong> practice my swimming rings</p>
<h3 id="喜好"><a href="#喜好" class="headerlink" title="喜好"></a>喜好</h3><ul>
<li>I like </li>
<li>I’m really into</li>
<li>I’m fond of</li>
<li>I enjoy</li>
</ul>
<p>人的需求(meet)</p>
<ul>
<li>social needs</li>
<li>material&#x2F;phyical needs</li>
<li>spritual needs</li>
</ul>
<p>套路：</p>
<ol>
<li>Although:</li>
</ol>
<p>[direct answer] + although 反面 + I still like xxx bacause xxx</p>
<ol start="2">
<li>Direct answer + e.g. (swimming) + WH (I always …)</li>
<li>Direct answer (dislike) + 反面opinion + bad experience</li>
</ol>
<h3 id="Usually-通常题"><a href="#Usually-通常题" class="headerlink" title="Usually 通常题"></a>Usually 通常题</h3><p>问法 </p>
<ul>
<li>usually&#x2F;like to do during xxx</li>
<li>how do you spend during xxx</li>
</ul>
<p>套路</p>
<ol>
<li><p>时间利用型<br>Sometimes WH1; Other times WH2</p>
</li>
<li><p>分类讨论型<br>It depends, if xxx then I will xxxx; but if yyy, then I will yyyy</p>
</li>
</ol>
<h3 id="频率题"><a href="#频率题" class="headerlink" title="频率题"></a>频率题</h3><ul>
<li>low often</li>
<li>everyday</li>
<li>weekly&#x2F;once a week</li>
<li>annally&#x2F;once a year</li>
</ul>
<p>套路</p>
<ol>
<li>(经常) I do sth a lot + e.g.(细分种类) + WH</li>
</ol>
<h3 id="个人偏好"><a href="#个人偏好" class="headerlink" title="个人偏好"></a>个人偏好</h3><p>Do you prefer A or B</p>
<p>like A or B</p>
<p>which better A or B</p>
<p>套路:<br>I would prefer A over B because xxxA√ whereas xxxB√ but </p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol>
<li>A &amp; B difference</li>
</ol>
<p>What are the difference between A &amp; B</p>
<p>please compare A and B</p>
<p>Do you think A &amp; B feel the same about sth</p>
<p>套路<br>Compared to A, B is xxx for example yyy. On the other hand, A is xxx for example yyy (xxx必须为同一点)</p>
<ol start="2">
<li>past&#x2F;present comperesion</li>
</ol>
<p>difference between sth in past and now</p>
<p>套路<br>In the past, [Topic] was xxx for example , but after a few years, [Topic] started, xxx and now it is xxx</p>
<h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><p>Do you think sth is good &#x2F; necessary</p>
<p>What is the benefits of sth</p>
<p>Would you say its good for someone to do sth</p>
<p>套路</p>
<ul>
<li>[direct answer] + 正面opinion + although + 反面opinion</li>
<li>[direct answer] + 客观opinion + 个人经历</li>
</ul>
<h3 id="万能观点"><a href="#万能观点" class="headerlink" title="万能观点"></a>万能观点</h3><ol>
<li>便宜</li>
<li>方便</li>
<li>交友 their custom cultures and histories share th same love for xxx</li>
<li>放松 xxx can help me relax and relieve the pressure from work and study (after a day’s hard work) I feel like my fatigue stress and depress are gone.</li>
</ol>
<h3 id="万能句型"><a href="#万能句型" class="headerlink" title="万能句型"></a>万能句型</h3><ol>
<li>xxx can enhance someone’s xxx, becasue …</li>
</ol>
<p>enhance &#x3D;&gt; cultivate &#x3D;&gt; develop &#x3D;&gt; improve &#x3D;&gt; build up</p>
<p>技能<br>hands on skill&#x2F; independent</p>
<p>运动<br>physical ability&#x2F; coordination skill</p>
<p>艺术<br>artistic&#x2F;creativity talent&#x2F;taste</p>
<p>文艺<br>mental develop&#x2F; knowledge of xxx</p>
<p>social skills&#x2F; teamwork ability&#x2F; sense of responsibility</p>
<ol start="2">
<li><p>xxx keeps someone posted(了解) about the xxx(文化传播类)</p>
</li>
<li><p>xxx helps someone get a better picture of xxx</p>
</li>
<li><p>xxx brings someone sth(convenient&#x2F; happiness&#x2F; sense of achievement&#x2F; relaxation)</p>
</li>
<li><p>xxx is good&#x2F;bad for someone’s sth(health&#x2F; growth&#x2F; future development&#x2F; career&#x2F; studies)</p>
</li>
<li><p>xxx has a positive&#x2F;negitive influence&#x2F;effect on xxx</p>
</li>
<li><p>xxx is a good way to express someone’s 某种心情(emotions&#x2F; love&#x2F; care&#x2F; respect&#x2F; gratitude(谢意)&#x2F; passion)</p>
</li>
<li><p>xxx add spice(给生活加乐趣) to someone’s life</p>
</li>
<li><p>xxx is a necessary part of life</p>
</li>
<li><p>xxx can fulfill people’s 某需求(spirtual&#x2F;material&#x2F;physical&#x2F;social&#x2F;curiosity needs)</p>
</li>
</ol>
<h3 id="人物类"><a href="#人物类" class="headerlink" title="人物类"></a>人物类</h3><ol>
<li><p>家人&#x2F;老师 某次没考好&#x3D;&gt; frustrated &#x3D;&gt; 鸡汤 &#x3D;&gt; 总结</p>
</li>
<li><p>名人</p>
</li>
<li><p>外表描述</p>
</li>
</ol>
<h3 id="地点类"><a href="#地点类" class="headerlink" title="地点类"></a>地点类</h3><ul>
<li>风景</li>
<li>放松</li>
<li>室内装修</li>
</ul>
<p>树: birch 桦 maple 枫 ork 橡 pine 松 willow 柳 carnation 康乃馨 tulip 郁金香 lotus 莲 Yellowstone  </p>
<p>Academy &#x3D;&gt; art school</p>
<h3 id="物品类"><a href="#物品类" class="headerlink" title="物品类"></a>物品类</h3><h3 id="事件-x2F-媒体"><a href="#事件-x2F-媒体" class="headerlink" title="事件&#x2F;媒体"></a>事件&#x2F;媒体</h3><p>-&gt; 运动</p>
<p>agility 柔韧性</p>
<p>vital capacity 肺活量</p>
<ul>
<li>好处</li>
<li>危险项目</li>
<li>经过</li>
</ul>
<p>natatorium &#x3D; swimming stadium</p>
<h3 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h3><p>spendid sights</p>
<p>skyscrapers</p>
<p>it has improve effiency</p>
<p>choose to live </p>
<p>spacious</p>
<p>friend in need is a friend indeed</p>
<p>uni<strong>v</strong>ersity</p>
<p><strong>ch</strong>aracteristic (|k|)</p>
<p><strong>stay up</strong> late at night 熬夜</p>
<p>refresh my mind</p>
<p>be refreshed and energetic</p>
<ul>
<li>Shanghai Tower</li>
<li>The Oriental Pearl Radio &amp; TV Tower</li>
<li>Global Center</li>
<li>The Tower of World Trade Center</li>
<li>CBD - Central Business District</li>
</ul>
<p>have a face-to-face communication with sb</p>
<p>have a quickj bite 边走边啃</p>
<p>intimate亲密的</p>
<h3 id="Novel"><a href="#Novel" class="headerlink" title="Novel"></a>Novel</h3><ul>
<li>classic</li>
<li>Romance</li>
<li>Horror</li>
<li>Detective</li>
<li>science-fiction</li>
<li>auto-biography 自传</li>
</ul>
<h3 id="Movie"><a href="#Movie" class="headerlink" title="Movie"></a>Movie</h3><ul>
<li>classic </li>
<li>Romance</li>
<li>Thriller</li>
<li>Detective</li>
<li>science movie</li>
<li>auto-biography 自传</li>
<li>action</li>
</ul>
<p>fight against xxx and protect xxx, try to make a living</p>
<p>enrich vocal</p>
<h3 id="Edu"><a href="#Edu" class="headerlink" title="Edu"></a>Edu</h3><p>tedious 繁重的</p>
<p>fax </p>
<p>online course</p>
<p>distract走神  &#x3D; absent-mind</p>
<p>nearsighted 近视</p>
<p>cervical problem 颈椎病</p>
<p>unchecked infomation</p>
<p>plot情节</p>
<p>tell right分辨是非</p>
<p>campus bullying 校园霸凌</p>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><ul>
<li>校园学习</li>
<li>教育</li>
<li>环保</li>
</ul>
<h3 id="校园学习"><a href="#校园学习" class="headerlink" title="校园学习"></a>校园学习</h3><p>小组讨论&#x2F;辩论好处 </p>
<p>CN: </p>
<ul>
<li>lecture</li>
<li>tutorial</li>
</ul>
<p>US:</p>
<ul>
<li>seminar</li>
<li>group discussion&#x2F; debate</li>
<li>presentation</li>
<li>case study</li>
<li>role play</li>
</ul>
<p>教育 carmming 填鸭式 priority</p>
<p>擅长 be gifted for&#x2F; talented in&#x2F; skilled in</p>
<p>(diff 后加复数)<br>diff stu have diff talents, some xxx, some yyy</p>
<p>Art &#x3D; painting music instument sports gymnastics(体操)</p>
<h3 id="环保"><a href="#环保" class="headerlink" title="环保"></a>环保</h3><ul>
<li>污染现状</li>
<li>措施</li>
<li>种树</li>
</ul>
<p>现状</p>
<ul>
<li><strong>water</strong></li>
<li><strong>air</strong></li>
<li>pollution</li>
<li>soil</li>
<li>light</li>
<li>noise</li>
</ul>
<p>encourage 滋生</p>
<p>greenhouse effect</p>
<p>gases: carbon dioxide&#x2F; mathane&#x2F; ozone</p>
<p>haze雾霾(smog)</p>
<p>措施</p>
<ul>
<li>个人</li>
<li>政府: enact&#x2F;introduce 颁布</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>Why …</p>
<ul>
<li>大群体问题 we …</li>
<li>问题解决方案</li>
<li>比较</li>
</ul>
<p>Why … ?</p>
<p>套路</p>
<ol>
<li>one of the main reasons is that that … and also …</li>
<li>Firstly I think it is coz … and also …</li>
</ol>
<p>2 reason * 2 sentences</p>
<p>For starters, xxx. Plus&#x2F;More importantly</p>
<p>未来计划plan</p>
<p>大群体:</p>
<p>套路</p>
<ol>
<li><p>people 喜欢&#x2F;习惯 xxx for example xxx. On the other hand, xxx people 喜欢&#x2F;习惯 xxx for example xxx.</p>
</li>
<li><p>Most people xxx for example xxx , but personally speaking I think [对大群体做出批判] so I xxxx (特例)</p>
</li>
</ol>
<p>解决方案:</p>
<p>How … &#x2F; Advise for …</p>
<p>套路 </p>
<ol>
<li>As a xxx, xxx. As a xxx, xxx. (2*solution)</li>
<li>It would really be helpful if sb. did sth, you know right now, [现状], so if someone did sth(深层次拓展solution), [问题如何得到解决]</li>
</ol>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>Do you have …</li>
<li>Do you know …</li>
<li>Do you have done xxx before …</li>
</ul>
<h2 id="S3-1"><a href="#S3-1" class="headerlink" title="S3"></a>S3</h2><ul>
<li>风景</li>
<li>室内装修</li>
<li>人物</li>
<li>运动</li>
<li>科技</li>
<li>工作</li>
<li>小说</li>
<li>电影</li>
<li>艺术</li>
</ul>
<h3 id="风景-1"><a href="#风景-1" class="headerlink" title="风景"></a>风景</h3><p>as beautiful as a picture &#x3D;&gt; picturesque (如画的) </p>
<p>attraction scenic spot</p>
<p>birch 桦 tulip 郁金香</p>
<p>around the lake</p>
<p>live a xxx life</p>
<p>go for a sightseeing</p>
<h3 id="interior-design-x2F-decoration-室内设计"><a href="#interior-design-x2F-decoration-室内设计" class="headerlink" title="interior design&#x2F;decoration 室内设计"></a>interior design&#x2F;decoration 室内设计</h3><p>patio umbrella set 遮阳伞下桌椅 &#x3D; outdoor</p>
<p>well-furnished</p>
<p>sun-shading</p>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><ul>
<li>play + 球类</li>
<li>go + ving</li>
<li>do + 非老外原生运动</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="发音"><a href="#发音" class="headerlink" title="发音"></a>发音</h2><p>暂略</p>
<h1 id="W-写作"><a href="#W-写作" class="headerlink" title="W: 写作"></a>W: 写作</h1><h2 id="基础信息-1"><a href="#基础信息-1" class="headerlink" title="基础信息"></a>基础信息</h2><h3 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h3><p>20min写150，建议不超过180</p>
<p>段落分布</p>
<ol>
<li>Intro</li>
<li>Summary</li>
<li>Body1</li>
<li>Body2</li>
</ol>
<h4 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h4><ol>
<li>Type- line graph, pie chart, bar chart, table</li>
<li>give&#x2F;show&#x2F;illurstrate&#x2F;display&#x2F;compare info about …</li>
<li>限定词from 1980 to 2030, between 1xxx and 1yyy, from the year until aaaa, over a period of 50y</li>
</ol>
<p>e.g. C9-T1-W1</p>
<p>The line graph illurstrates consumption of energy of the USA from a 2008 report between 1980 and 2030.</p>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><ul>
<li>It is clear that</li>
<li>We can clear see that</li>
<li>Overall</li>
</ul>
<p>TA(task achievement): </p>
<ul>
<li>list figures -&gt; 多组数据优先考虑最大值</li>
<li>compare figures</li>
<li>report figures -&gt; general trend + the most obvious features</li>
</ul>
<p>CC(cohesion and coherence):</p>
<ul>
<li>显性: conversely&#x2F; by contrast&#x2F; on the other hand&#x2F; (不用however) </li>
<li>隐性: likewise&#x2F; similarly&#x2F; also</li>
</ul>
<p>e.g.</p>
<pre><code>29m ton petrol was consumed in 1980, this figure rose to 90m tons

followed by Solar energy(12m ton)

half of which was Solar energy

as much as Solar energy

followed by a rise of 12m tons in 2000
</code></pre>
<p>LR(Lexical resources):</p>
<ul>
<li>rise&#x2F; increase&#x2F; grow&#x2F; ascend (rose&#x2F; increased&#x2F; grew&#x2F; ascended)</li>
<li>fall&#x2F; drop&#x2F; decrease&#x2F; dip(fell&#x2F; dropped&#x2F; decreased&#x2F; dipped)</li>
<li>Dramatically&#x2F; sharply&#x2F; hugely</li>
<li>Slightly&#x2F; gradually&#x2F; slowly</li>
</ul>
<p>GRA(Grammatical range and accuary):</p>
<ul>
<li>Introduction+summary -&gt; present tense</li>
<li>Body (1980xxx) -&gt; past tense</li>
<li>Body (2030xxx) -&gt; future tense</li>
<li>Body (no time) -&gt; present tense</li>
</ul>
<p>趋势类动词句式:</p>
<ul>
<li>xxx increase to 20% in 1990</li>
<li>, reaching 20%</li>
<li>, with a peak at 20%</li>
<li>xxx decrease, with a bottom at 20%</li>
<li>xxx increase, from 20% in 1990 to 30% in 2000</li>
<li>xxx increased by 20 % in 2000</li>
</ul>
<p>趋势类名词句式:</p>
<ul>
<li>rise&#x2F; increase&#x2F; growth</li>
<li>fall&#x2F; decrease&#x2F; drop</li>
<li>soar&#x2F; plunge</li>
</ul>
<p>xxx experience(witness&#x2F; saw) an increase(rise&#x2F; growth) in yyyyy</p>
<pre><code>错误: xxx had an increase
正确: had an upword
</code></pre>
<ul>
<li>to&#x2F;with a peak at 20%</li>
<li>reaching 20%</li>
<li>see an increase in xxx of yyy</li>
<li>see an increase of xxx in yyy</li>
</ul>
<p>趋势（预测）</p>
<ul>
<li><p>will be expected to</p>
</li>
<li><p>will be thought</p>
</li>
<li><p>be predicted to</p>
<p>  错误: saw an increase for<br>  正确: saw an increase in</p>
</li>
</ul>
<p>粗略性表达:</p>
<p>About&#x2F; approximately&#x2F; generally&#x2F; nearly</p>
<ul>
<li>4.9% &#x3D;&gt; just under 5%</li>
<li>5.1% &#x3D;&gt; just over </li>
<li>98% &#x3D;&gt; the majority(priority)</li>
<li>25% &#x3D;&gt; one quarter</li>
</ul>
<p>百分比下的单复数</p>
<ul>
<li>30% of <strong>student</strong> <strong>achieve</strong> a high score</li>
<li>30% of <strong>water</strong> <strong>comes</strong> from sea</li>
</ul>
<p>句式的改写</p>
<ol>
<li>35% of xxx was consumed, followed by&#x2F;compared to xxx</li>
<li>xxx saw an increase in consumption of xxx had the largest consumption, at xxx</li>
<li>xxx equaled 45 xxx</li>
<li>xxx be equal to 45 xxx</li>
<li>xxx be as much&#x2F;many as xxx</li>
</ol>
<p>6.5以上，要求each sentence is new</p>
<ul>
<li>old people &#x3D;&gt; elder people &#x3D;&gt; people aged 65+</li>
<li>v+adv &#x3D;&gt; adj+n</li>
<li>The figure for xxx &#x3D; the contribution of xxx</li>
</ul>
<p>Pie chart的重要表述: 占据</p>
<ul>
<li>account(v.) for</li>
<li>make up </li>
<li>represent 5% of the total&#x2F;totality</li>
</ul>
<p>Pie chart中的最显著特征: <strong>最大面积</strong></p>
<h4 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h4><p>summary:</p>
<ol>
<li>极值 especially xxx</li>
</ol>
<p>A大， B小。 剩下such dramatic differences are not seen when we compare the figure for xxx</p>
<p>个体过多(&gt;&#x3D;3) &#x3D;&gt; 描述<strong>最中之最</strong> less (&lt;12%) -&gt; least at 5% xxx in xxx</p>
<p>波动:<br>It <strong>fluctuated</strong> (and repeat), from the highest of xxx in 1990 to the lowest of xxx in 2000 </p>
<p>It rose from xxx in 1990 to xxx in 2000</p>
<h4 id="工艺流程图"><a href="#工艺流程图" class="headerlink" title="工艺流程图"></a>工艺流程图</h4><p>Flow chart intro + summary</p>
<p>The diagram illurstrates the way in which xxx is produced by xxx</p>
<p>It is clear that the whole process consists of (1&#x2F;2&#x2F;3) stages, including A B and C</p>
<p>It is clear that the whole process involves xxx stages</p>
<p>Body(全被动):</p>
<p>Beginning with the first stage, called xxx, [detail1], when it comes to the second stage, [detail2]</p>
<p>Then &#x3D;&gt; , before &#x3D;&gt; , followed by &#x3D;&gt; , after which &#x3D;&gt; . At that time, &#x3D;&gt; , at which time &#x3D;&gt; which is in order to ensure&#x2F;gurantee that …</p>
<p>最后<br>xxx will be delivered to xxx</p>
<p>俩流程时需要做出比较</p>
<h2 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h2><p>It is clear that although xxx, it saw a decrease xxx </p>
<p>Body2 开头</p>
<pre><code>Regarding xxx, 

With the respect to/Enperienced the less main reason, they xxx
</code></pre>
<p>xxx rose, before falling to 5% &#x3D;&#x3D; xxx rose and then fall xxx &#x3D; After rising to 6%, this figure fell to 5%</p>
<h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><table>
<thead>
<tr>
<th>错误情况</th>
<th>正确</th>
</tr>
</thead>
<tbody><tr>
<td>the figure of</td>
<td>the figure for</td>
</tr>
<tr>
<td>xxx. Then xxx</td>
<td>改用,after xxx&#x2F;,compared to xxx&#x2F;, followed by (a rise to 40…)</td>
</tr>
<tr>
<td>占大多数描述方式过少</td>
<td>take the majority. the proportion of xxx was the largest. take the largest share</td>
</tr>
<tr>
<td>句式不全面</td>
<td>-ing&#x2F;-ed, clause(条件约束), There be, v.-&gt;n., positive-&gt;active</td>
</tr>
<tr>
<td>同时写两个不分开</td>
<td>A and B xxx respectively. the absence of Shaun Derry and Adel Taarabt because of illness and injury respectively.</td>
</tr>
<tr>
<td>占据用词过少</td>
<td>occupy &#x3D; account for … of the (total) &#x2F; represent&#x2F; constitude</td>
</tr>
<tr>
<td>句子之间连贯性不足</td>
<td>Regrading …&#x2F; … is used for … &#x2F; compared to … &#x2F; … for …</td>
</tr>
<tr>
<td>表达都高</td>
<td>Both rank first</td>
</tr>
<tr>
<td>贼少</td>
<td>merely 2%</td>
</tr>
<tr>
<td>百分比表述</td>
<td>with % of &#x2F; at %</td>
</tr>
<tr>
<td>数字表达过多</td>
<td>用背后含义表述(e.g. 人口百分比-&gt;人数)，数-&gt;量&#x2F;concept, percentage &#x3D;&gt; frequency.</td>
</tr>
<tr>
<td>then 不能用作连词</td>
<td>,and then &#x3D;&gt; , before …</td>
</tr>
</tbody></table>
<p>采分点</p>
<ul>
<li>v. n. 趋势 in …</li>
<li>被动×1; 主动×1</li>
<li>分词(ing×1,过去分词×1)</li>
<li>介词短语</li>
<li>从句(让步状语，定语从句，时间状语从句)</li>
<li>There be</li>
</ul>
<h4 id="地图题"><a href="#地图题" class="headerlink" title="地图题"></a>地图题</h4><p>The map illustrates the layout of xxx in yyyy and its development in yyyy</p>
<p>It is clear that xxx change considerablly and xxx main features can be seen. During the development, some facilities are available to visitors.</p>
<p>Body Types:</p>
<ul>
<li>Imporovement: expansion + addition + reduction</li>
<li>Relocation: e.g. Western -&gt; Eastern</li>
<li>Function: eduactional xxx</li>
</ul>
<p>sentence pattern</p>
<ul>
<li>be built</li>
<li>be added</li>
<li>be established</li>
<li>be constructed</li>
</ul>
<p>junction 十字路口&#x2F; three branches</p>
<p>be replaced by &#x3D; be deminished in order to </p>
<p>onthe either side &#x3D; on both side</p>
<p>be expanded&#x2F; extended&#x2F; enlarged</p>
<p>be reduced in size</p>
<p>The reduction of school is in order to make way for xxx</p>
<p>expansion&#x2F;extension</p>
<p>run&#x2F;go from … to … 延伸: e.g. the road goes from east to west. The road goes from the main entrance to the xxx</p>
<p>link with</p>
<p>branch(split) off from</p>
<p>accomodation un.&#x2F; equipment un.&#x2F; studio -&gt; studios</p>
<h3 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h3><p>40min写250，建议不超过300</p>
<p>_____ it means that _____, such as _____ , _____  and _____ . In addition, __________ . In fact, __________ , for instance _______________</p>
<p>On the other hand, __________, which means __________ . For example, __________ . Moreover, __________  such as _____ , _____ and _____.</p>
<p>Best &#x3D;&gt; +可替换方案</p>
<p>salary 可数-&gt; salaries</p>
<p>such as &#x2F; including …</p>
<p>abundant fund</p>
<p>cram xxx into</p>
<p>intensive courses &#x3D; lots of courses</p>
<p>arouse interest</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>陈述段<br>Topic sentence + explaination + examples &#x2F; Topic sentence + examples + explaination</p>
<h4 id="题型-最终奥义"><a href="#题型-最终奥义" class="headerlink" title="题型+最终奥义"></a>题型+最终奥义</h4><ol>
<li>both views &#x3D;&gt; agree 1, agree 2, my opinion</li>
<li>agree&#x2F;disagree &#x3D;&gt; agree reason 1, agree reason 2, disagree 3 but agree.</li>
<li>advantage overweigh disadv? 如上</li>
<li>Reasons? Solution. &#x3D;&gt; (Reason1 + Reason2) + (Sol1 + Sol2)</li>
<li>Reasons? Pos&#x2F;Neg? &#x3D;&gt; (Reason1 + Reason2) + (Pos1 + Pos2)</li>
<li>Solutions? &#x3D;&gt; S1 + S2 + S3</li>
</ol>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>notes</tag>
        <tag>exam</tag>
        <tag>IELTS</tag>
      </tags>
  </entry>
  <entry>
    <title>libp2p notes</title>
    <url>/post/libp2p-notes/</url>
    <content><![CDATA[<p>因为ng的整个P2P都是依赖于libp2p的，所以这里记录一下使用libp2p的一些经验。</p>
<span id="more"></span>

<p>先这边记录一下各类子库，因为我这边是用go的,所以都是根据<a href="https://github.com/libp2p/go-libp2p" target="_blank" rel="noopener">go的库</a>来介绍</p>
<h2 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h2><p><code>go-libp2p</code> 作为整个libp2p的进入点，没多少代码，但是主要的函数都在；<code>go-libp2p-core</code>核心库，包含了核心接口、类型和抽象。其他所有内容都得跟着这两个库（尤其是core）一起更新，否则依赖会出现问题<br><code>go-libp2p-blankhost</code>是host的最小实现不包含任何身份识别，转发或NAT遍历代码。一般测试才用。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><code>go-libp2p-swarm</code> 是使用给定libp2p网络的“低级”接口。它可以在系统的各个方面提供更细的控制。大多数应用程序不需要这种访问级别，因此Swarm通常被抽象包装在Host里以提供更友好的接口。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><code>go-ws-transport</code> WS<br><code>go-tcp-transport</code> TCP<br><code>go-libp2p-quic-transport</code> QUIC<br><code>go-udp-transport</code> UDP<br><code>go-utp-transport</code> 这里utp指的是uTorrent transport<br><code>go-libp2p-circuit</code> relay传输<br><code>go-libp2p-transport-upgrader</code> 将multiaddr-net的连接升级到完整的libp2p传输<br><code>go-reuseport-transport</code> 为自动（智能地）重用 TCP 端口提供了基本的传输层</p>
<h2 id="加密通道"><a href="#加密通道" class="headerlink" title="加密通道"></a>加密通道</h2><p><code>go-libp2p-noise</code> 基于<a href="https://noiseprotocol.org/" target="_blank" rel="noopener">noise协议</a>的加密通道。这个暂时我还未使用过，github介绍也说没在生产环境试过（<br><code>go-libp2p-tls</code> tls<br><code>go-conn-security-multistream</code> 为mux stream提供加密通道，目前支持tls和secio<br><code>go-libp2p-secio</code> <strong>官方不建议用了</strong>，以前是标配</p>
<h2 id="私有网络"><a href="#私有网络" class="headerlink" title="私有网络"></a>私有网络</h2><p><code>go-libp2p-pnet</code> 简易的private net实现，需要一个go-libp2p-core&#x2F;pnet.PSK才能加入网络建立Conn。</p>
<h2 id="流复用器-Mux"><a href="#流复用器-Mux" class="headerlink" title="流复用器 Mux"></a>流复用器 Mux</h2><p><code>go-libp2p-yamux</code> <a href="https://github.com/hashicorp/yamux" target="_blank" rel="noopener">YAMUX</a>是hashicorp做的一个muxer<br><code>go-libp2p-mplex</code> <a href="https://github.com/libp2p/specs/tree/master/mplex" target="_blank" rel="noopener">MPLEX</a>是libp2p自己做的一个muxer</p>
<h2 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h2><p><code>go-libp2p-nat</code> 本质上是用了github.com&#x2F;fd&#x2F;go-nat，在github.com&#x2F;libp2p&#x2F;go-libp2p&#x2F;p2p&#x2F;host&#x2F;basic的NATManager里被引入。在host里有个看起来很像的<code>go-libp2p-autonat</code>，但是并不是做穿透的，而是通过同样用AutoNAT的Peer使用测试回拨来确定他们的 NAT 可拨情况。</p>
<h2 id="Peer存储"><a href="#Peer存储" class="headerlink" title="Peer存储"></a>Peer存储</h2><p><code>go-libp2p-peerstore</code> peer管理器，一般没用(因为host自带有简易的存储了)</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><code>go-libp2p-connmgr</code> pubsub的test里有用到</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><code>go-libp2p-record</code> 路由记录<br><code>go-libp2p-kad-dht</code> 类Kademlia的路由实现,非常的重,但是在公网寻址上<strong>必用</strong><br><code>go-libp2p-kbucket</code> 为<code>go-libp2p-kad-dht</code>提供类型<br><code>go-libp2p-coral-dht</code> Coral DHT,<strong>官方弃坑</strong><br><code>go-libp2p-pubsub-router</code> 利用pubsub请求路由,当前ipfs用这个做IPNS</p>
<h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p><code>go-libp2p-consensus</code> 共识抽象层<br><code>go-libp2p-raft</code> 用的hashicorp家的raft库<code>github.com/hashicorp/raft</code></p>
<h2 id="Pubsub"><a href="#Pubsub" class="headerlink" title="Pubsub"></a>Pubsub</h2><p><code>go-libp2p-pubsub</code> p2p网络上<a href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85" target="_blank" rel="noopener">Pub&#x2F;Sub</a>消息范式的实现</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><code>go-libp2p-gorpc</code> 等于<code>net/rpc</code>放到p2p</p>
<h2 id="工具-x2F-杂项"><a href="#工具-x2F-杂项" class="headerlink" title="工具&#x2F;杂项"></a>工具&#x2F;杂项</h2><p>许多实用的小功能实现,值得学习但是需要注意依赖版本</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>go-libp2p-testing</code> 官方自己用的套件,没用过且不建议用(没文档)</p>
]]></content>
  </entry>
  <entry>
    <title>Linguaskill</title>
    <url>/post/linguaskill-notes/</url>
    <content><![CDATA[<p>記錯考試日期了，所以有了多的時間來總結</p>
<span id="more"></span>

<h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>(L-&gt;R), (S), (W)</p>
<p>括號表示一個科目。</p>
<p>科目之間自由選擇哪個先考。</p>
<p>LR不卡時間(好像,反正沒倒計時)</p>
<p>S每題卡對應時間。</p>
<p>W總計45min倒計時。</p>
<h2 id="Writing-1"><a href="#Writing-1" class="headerlink" title="Writing #1"></a>Writing #1</h2><h3 id="Keypoints"><a href="#Keypoints" class="headerlink" title="Keypoints"></a>Keypoints</h3><p>B2 Keypoints:</p>
<ul>
<li><strong>suggestions</strong>(我們做啥啥怎麽樣) and <strong>offers</strong>(我可以做啥啥，你怎麽看)</li>
<li>not required accuracies</li>
<li>vocabulary is used appropriately</li>
<li>no significant issue</li>
<li>informal lang, fixed phrases idioms and questions are used effectively</li>
<li>positive effect on the reader</li>
<li>well-organized, straightforward ideas ppt</li>
<li>cohesion</li>
</ul>
<p>C1 Keypoints:</p>
<ul>
<li>full control of the grammar</li>
<li>wide variety of structures, flexibility and accuracy</li>
<li>accurate and appropriate volcabulary</li>
<li>some good examples of collections</li>
<li>no spelling or punctuation problem</li>
<li>其他基本上同B2，要求informal和positive</li>
<li>use cohesive devices like substitution(&#x3D;backup solution,plan B), and phrases that signpost the current stage of diz and shared knowledge(&#x3D;通報情況之後再下建議).</li>
</ul>
<h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>You have recieved this email from a friend who you want to college with.</p>
<blockquote>
<p>Do you know it will soon be 5 years since we finished college? I think we should contact our old friends and arrange to meet again. Have you got any ideas about what we could do to celebrate and when?</p>
<p>Write and tell me</p>
<p>Jan</p>
</blockquote>
<p>Write at least 50 words.</p>
<h3 id="C1-範文"><a href="#C1-範文" class="headerlink" title="C1 範文:"></a>C1 範文:</h3><blockquote>
<p>Hi Jan,</p>
<p>So nice to hear from you! How are you doing?</p>
<p>It would be great to meet and celebrate with our friends from college. How about meeting in London sometimes next month? We could meet in a pub, have dinner, and then go to a club, like in the old days?</p>
<p>I think that Saturday 20th would work best for everyone: I know that the Ruth is on holiday next weekend , and I will be away the following one  (on a business trip to Japan, I will tell you more about it when we meet!), If I remember well, you are busythe weekendof the 27th, as you are attending your sister-in-law’s wedding, aren’t you? Taking all that into account, Saturday 20th Looks like the best option. We would have to ask Sean, Mary and Alex if they are available though.</p>
<p>If you want, I could send an email to everyone, to check that we are all free on Saturday 20th, and suggest that we meet in London. I’ll tell them about my idea of going to a pub and then to a club, but maybe someone (May always has grerat ideas!). Then we can talk about hotel bookings, as most of us have to stay the night, I guess.</p>
<p>I’m really looking forward to it, thanks a lot for suggesting it!</p>
<p>See you soon,</p>
<p>MY_NAME</p>
</blockquote>
<h2 id="Writing-2"><a href="#Writing-2" class="headerlink" title="Writing #2"></a>Writing #2</h2><h3 id="Keypoints-1"><a href="#Keypoints-1" class="headerlink" title="Keypoints"></a>Keypoints</h3><p>和其他考試寫作差不多，也是通過説明事情發表觀點。不過就比較貼近生活，而且思路也給出了。瞎jb腦補吧。</p>
<h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p>The town where you live has a website where local people can discuss local issues. You are concerned about the increase in car and truck traffic in the twon and have decided to post your comments on the website.</p>
<p>Write your <strong>comments</strong> for the town website</p>
<p>Write about:</p>
<ul>
<li>Why you think the amount of traffic is increasing in your town</li>
<li>What problems the increased traffic is causing in your town</li>
<li>how the amount of traffic in your town could be reduced</li>
</ul>
<p>and any other points you think are important.</p>
<p>Write at least 180 words.</p>
<h3 id="C1-範文-1"><a href="#C1-範文-1" class="headerlink" title="C1 範文"></a>C1 範文</h3><blockquote>
<p>[Grammerly Optimized]</p>
<p>I am writing this comment to complain about the worrying increase in car and lorry traffic in our town lately.</p>
<p>As far as I am concerned, the main reason for this issue is that a 40-block building is being constructed in our neighborhood. Lorries need to function at full speed to carry necessary material for the construction. Moreover, the main road that leads to the center of the city is banned for decoration of the coming festival. People whose workplaces are located in the town not only endure the syren that is made by the vehicles, but also suffer from illnesses caused by air-polluted, especially the elderly. They cannot sleep well at night since the lorries work 24 hours per day. Everything is dusty because of carelessly covered containers of lorries, We cannot let our children play at the playground of the town for the fear that they can put themselves in danger. Furthermore, we are usually late for work and school because of traffic jams in rush hours.</p>
<p>As a citizen of the town, I think the authority should take action to reduce the amount of traffic that travels to our town every day. Lorries must be banned in crush hours. Moreover, the container of lorries should be covered carefully in order not to drop any material that they are carrying. Last but not least, people should be shown other ways that lead to the center so that they do not put pressure on our infrastructure.</p>
<p>I hope that my complaint can be taken into consideration so that our town can become an enjoyable place to live again.</p>
</blockquote>
<h2 id="Speaking"><a href="#Speaking" class="headerlink" title="Speaking"></a>Speaking</h2><h3 id="Part1-8Q"><a href="#Part1-8Q" class="headerlink" title="Part1 - 8Q"></a>Part1 - 8Q</h3><p>8個簡單問題，同雅思p1。1-4說10s，5-8說20s。</p>
<p>據(萬象教育B站視頻)説1&amp;2不計分，反正10s就兩句話報姓名再spell很快的。</p>
<p>後面預計就是3,4個人情況補充，5-8問喜好經歷</p>
<h3 id="Part2-Read-8-sentences"><a href="#Part2-Read-8-sentences" class="headerlink" title="Part2 - Read 8 sentences"></a>Part2 - Read 8 sentences</h3><p><strong>簡單句務必慢點讀</strong></p>
<p>技術角度看很可能是機改。從speakingandimprove.com測試來看，斷句和發音很重要。</p>
<p>個人經歷：測試的時候讀太快(無語氣無斷句)直接讀到了B1……</p>
<h3 id="Part3-Topic"><a href="#Part3-Topic" class="headerlink" title="Part3 - Topic"></a>Part3 - Topic</h3><p>類似雅思P2，具體需要回答的點會給出。40s read 1min speak。</p>
<h3 id="Part4-看圖説話"><a href="#Part4-看圖説話" class="headerlink" title="Part4 - 看圖説話"></a>Part4 - 看圖説話</h3><p>看見過的有，流程圖，事物對比給建議。1min read 1min speak</p>
<h3 id="Part5-記者瞎jb5問"><a href="#Part5-記者瞎jb5問" class="headerlink" title="Part5 - 記者瞎jb5問"></a>Part5 - 記者瞎jb5問</h3><p>給出各個問題的觀點。40s準備每個問題答20s也就是說100s。</p>
<h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>因爲口語一直被壓分所以反思一下</p>
<p>P1 - 流利度</p>
<p>P3 - 选择说，扩写</p>
<h2 id="Reading-amp-Listening"><a href="#Reading-amp-Listening" class="headerlink" title="Reading &amp; Listening"></a>Reading &amp; Listening</h2><p><del>EZ Game</del></p>
<p>好吧，就跪在這個EZ裏了。</p>
<p>L拿了C1還挺給面子，R直接B1……</p>
<p>R考察的點就比較神奇，不像其他等級測試，更像高考英語。</p>
<p>閲讀比較正常，但是體量占比沒特別大。</p>
<p>選詞題(就那個4選1)考察的是詞匯搭配，建議查cambridge dictionary。</p>
<p>填空題比較搞，這裏得注意基本上不寫實詞，也就是說沒指望你看全文，只要你讓他通順就行，就看看前後巨型和特殊單詞，想想填which, more, than, since, after這樣的。</p>
<p>還有理解題，比較繞，建議排除法，不然一個選項看久了就容易繞進去。記得要的是本意不是表面縮寫。</p>
<p>最後强調一下前面別連錯，不然像我一樣直接掉進低分檔。</p>
<h2 id="特殊服務"><a href="#特殊服務" class="headerlink" title="特殊服務"></a>特殊服務</h2><p>可提供題目*2 :-)</p>
<p>非售賣，僅作考後討論</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>notes</tag>
        <tag>exam</tag>
        <tag>Linguaskill</tag>
      </tags>
  </entry>
  <entry>
    <title>LucidiTEE: 基于策略的规模化公平计算（摘要）</title>
    <url>/post/luciditee/</url>
    <content><![CDATA[<p>这个是LucidiTEE的paper的intro部分，因为知乎上有人问起所以就边看边了解边回答。这个和区块链不是一个东西，是对于硬件层面的计算可信度的保障，像我的AMD1600也有这样的可信计算功能。</p>
<p>受大肆滥用个人信息的现状启发，我们通过将信息绑定在策略上，允许用户去控制他们个人信息的分享与使用，即便是在离线的时候。一个策略制定了一个被允许的函数，策略包含了防止对输入提供者与输出接收人的执行（基于有关该数据的所有先前计算的历史记录）和识别。为了达到这个级别的控制，我们的目标是建立一个能够确保策略与输入提供者保持一致，对输出接收方的公平和公正（即，所有一方或没有一方获取输出），而无需这些方彼此信任或与计算主机信任的计算系统。</p>
<span id="more"></span>

<p>最近，受信任的执行环境（TEE），例如英特尔SGX和Sanctum enclaves，正在敏感数据的外包计算中找到应用程序。 但是，由于TEE受到不受信任的主机托管用于存储和网络通信，因此它们无法执行依赖历史的策略或公平性。 例如，与用户只希望揭示其整个数据上的汇总函数的愿望相反，对抗主机可以在其数据集的不同子集上反复评估该汇总函数，并学习单个记录。 对手还可能串通并将输出仅传递给输出接收者的子集，从而违反了公平性。</p>
<p>本文介绍了LucidiTEE，这是第一个使多方可以联合计算大规模私有数据的系统，同时确保即使输入提供者处于脱机状态也可以强制执行上述策略，并保证对所有输出接收者的公平性。 为此，LucidiTEE在TEE网络和共享的仅限追加的分类帐之间开发了一套新颖的协议。LucidiTEE仅使用分类帐执行策略； 它不会在账本上存储输入，输出或状态，也不会在参与者之间重复执行，这使其可以扩展到大数据和大量参与者。</p>
<p>我们演示了几种基于策略的应用程序，包括个人理财，联合机器学习，公平N方信息交换和医疗记录中私有集之间的交集。</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>翻译</tag>
        <tag>TEE</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>ml-notes</title>
    <url>/post/ml-notes/</url>
    <content><![CDATA[<p>发现不记笔记又不操练太容易忘了。ml和dl都学了好几遍了……</p>
<span id="more"></span>

<ul>
<li>TP(True Positive) 真阳性：预测为正，实际也为正</li>
<li>FP(False Positive) 假阳性：预测为正，实际为负</li>
<li>FN(False Negative) 假阴性：预测与负，实际为正</li>
<li>TN(True Negative) 真阴性：预测为负，实际也为负</li>
</ul>
<p>精确率：<br>Precision&#x3D;TP&#x2F;(TP+FP)</p>
<p>召回率<br>Recall&#x3D;TP&#x2F;(TP+FN)</p>
<p>F1&#x3D;2*(Precision*Recall)&#x2F;(Precision+Recall)</p>
<p>第一种计算出所有类别总的Precision和Recall，然后计算F1</p>
<p>第二种方式是计算出每一个类的Precison和Recall后计算F1，最后将F1平均</p>
]]></content>
  </entry>
  <entry>
    <title>以太坊中的Merkle树 (Merkling in Ethereum)</title>
    <url>/post/merkling-in-ethereum/</url>
    <content><![CDATA[<p>Merkle树是使区块链运作的基础部分。尽管从理论上讲绝对可以制造没有Merkle树的区块链，但仅通过创建直接包含每个交易的巨型区块头就可以了，这样做带来了巨大的可扩展性挑战，可以说使得除了最大多数以外的所有人都无法信任地使用区块链的能力。从长远来看功能强大的计算机。多亏了Merkle树，才有可能构建以太坊节点，该节点可以在所有大小型笔记本电脑，智能手机甚至物联网设备（如Slock.it生产的设备）上运行。那么，无论现在还是将来，这些Merkle树如何精确发挥作用，并提供什么价值？</p>
<span id="more"></span>

<p>首先是基础知识。从最一般的意义上来说，Merkle树是一种将大量“块状”数据hash在一起的方法，该方法依赖于将块拆分为多个存储桶，其中每个存储桶仅包含几个存储块，然后获取每个存储桶的hash并重复相同的过程，继续这样做，直到剩余的hash总数变为一个：根hash。</p>
<p>Merkle树最常见，最简单的形式是二叉Merkle树，其中一个存储桶始终由两个相邻的块或hash组成。它可以描述如下：</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/merkle.png" loading="lazy"></p>
<p>那么，这种奇怪的hash算法有什么好处呢？为什么不将所有块连接在一起成为一个大块，并在其上使用常规的hash算法呢？答案是，它允许使用称为Merkle证明的简洁机制：</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/merkle2.png" loading="lazy"></p>
<p>Merkle证明由块，树的根hash和“分支”组成，其中“分支”由沿从块到根的路径上的所有hash组成。读取证明的人可以验证，至少对于该分支而言，hash在整个树上一直是一致的，因此，给定的块实际上位于树中的该位置。该应用程序很简单：假设有一个大型数据库，并且数据库的全部内容存储在Merkle树中，该树的根是公开已知且受信任的（例如，它已由足够的受信方进行数字签名） ，或者有很多工作证明）。然后，想要在数据库上进行键值查找的用户（例如“告诉我位置85273中的对象”）可以请求Merkle证明，并在收到证明后验证它是正确的，因此实际接收到的值在数据库中具有该特定根的位置85273处。它允许对少量数据（例如hash）进行身份验证的机制得以扩展，以对可能无限制大小的大型数据库进行身份验证。</p>
<h2 id="比特币中的Merkle证明"><a href="#比特币中的Merkle证明" class="headerlink" title="比特币中的Merkle证明"></a>比特币中的Merkle证明</h2><p>Merkle证明的原始应用是在比特币中，正如中本聪（Satoshi Nakamoto）在2009年描述和创建的那样。比特币区块链使用Merkle证明来将交易存储在每个区块中：</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/mining.jpg" loading="lazy"></p>
<p>这提供的好处是Satoshi将其描述为“简化的付款验证”的概念：“轻量级客户端”只下载块头链，每个块80字节的数据块，而不是下载每个交易和每个块，只包含五件事：</p>
<ul>
<li>前一个区块头的hash</li>
<li>时间戳</li>
<li>挖掘难度值</li>
<li>工作证明随机数</li>
<li>Merkle树的根hash，包含该块的交易事务</li>
</ul>
<p>如果轻量级客户想要确定交易的状态，则可以简单地索要Merkle证明，以证明特定交易在Merkle树之一中，其根在主链的块头中。</p>
<p>这使我们走得很远，但是比特币风格的轻客户端确实有其局限性。一个特别的限制是，尽管它们可以证明包括交易，但它们不能证明有关当前状态的任何信息（例如，数字资产持有，名称注册，金融合同的状态等）。您现在有多少个比特币？比特币轻量级客户端可以使用一种协议，该协议涉及查询多个节点并相信至少其中一个会从您的地址通知您任何特定的交易支出，这将使您在该用例中走得更远，但对于其他更复杂的应用程序这还远远不够；交易影响的确切性质可能取决于几个先前交易的影响，而这些交易本身也取决于先前交易，因此最终您将必须对整个链中的每个交易进行身份验证。为了解决这个问题，以太坊将Merkle树概念更进一步。</p>
<h2 id="以太坊的Merkle证明"><a href="#以太坊的Merkle证明" class="headerlink" title="以太坊的Merkle证明"></a>以太坊的Merkle证明</h2><p>以太坊中的每个块头不仅包含一棵Merkle树，还包含用于三种对象的三棵树​​：</p>
<ul>
<li>交易次数</li>
<li>收据（基本上是显示每笔交易效果的数据）</li>
<li>状态</li>
</ul>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/ethblockchain_full.png" loading="lazy"></p>
<p>这允许高度高级的轻客户端协议，该协议允许轻客户端轻松地对多种查询做出并获得可验证的答案：</p>
<ul>
<li>该交易是否包含在特定的区块中？</li>
<li>告诉我该地址在过去30天内引发的所有X类型事件（例如达成目标的众筹合同）的所有实例</li>
<li>我帐户的当前余额是多少？</li>
<li>这个帐户存在吗？</li>
<li>假设在此合同上运行此事务。输出是什么？</li>
</ul>
<p>第一个由事务树处理；第二个由事务树处理。第三个和第四个由状态树处理，第二个由接收树处理。前四个很容易计算。服务器简单地找到对象，获取Merkle分支（从对象到树根的hash列表），然后使用该分支答复轻客户端。</p>
<p>第五个也由状态树处理，但是计算它的方式更加复杂。在这里，我们需要构造所谓的Merkle状态转换证明。本质上，这是一个证明：“如果在具有根S的状态上运行事务T，结果将是具有根S’的状态，且具有日志L和输出O”（“输出”作为概念存在于以太坊，因为每个事务都是一个函数调用；从理论上讲不是必需的）。</p>
<p>为了计算证明，服务器在本地创建一个假块，将状态设置为S，并在应用事务时假装为轻客户端。即，如果进行交易的过程要求客户确定账户余额，则轻客进行余额查询。如果轻客户端需要检查特定合同存储中的特定项目，则轻客户端对此进行查询，依此类推。服务器正确地“响应”其自己的所有查询，但跟踪其发送回的所有数据。然后，服务器将所有这些请求的组合数据发送给客户端，以作为证明。然后，客户端将执行完全相同的过程，但使用提供的证据作为其数据库；如果其结果与服务器要求的结果相同，则客户端接受该证明。</p>
<p><img src="https://blog.ethereum.org/wp-content/uploads/2015/11/lightproof.png" loading="lazy"></p>
<h2 id="Patricia树"><a href="#Patricia树" class="headerlink" title="Patricia树"></a>Patricia树</h2><p>上面提到过，最简单的Merkle树是二元Merkle树。但是，以太坊中使用的树更加复杂-这就是您在我们的文档中听到的”Merkle Patricia树”。本文将不涉及详细规范；尽管我将讨论基本推理，但这是本文和本文中最好的方法。</p>
<p>二进制Merkle树是用于验证“列表”格式信息的非常好的数据结构。本质上是一系列的块，一个接一个。对于事务树，它们也很好，因为创建树后编辑多少时间都没有关系，因为先创建树然后再将其永久冻结。</p>
<p>但是，对于状态树，情况更为复杂。以太坊中的状态基本上由一个键值映射组成，其中的键是地址，值是帐户声明，列出每个帐户的余额，现时，代码和存储空间（存储空间本身是一棵树）。例如，Morden测试网的生成状态如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000001&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000002&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000003&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;0000000000000000000000000000000000000004&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1606938044258990275541962092341162602522202993782792835301376&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是，与交易历史记录不同，状态需要经常更新：帐户的余额和现时经常更改，此外，经常插入新帐户，并且经常插入和删除存储密钥。因此，需要一种数据结构，在该数据结构中，我们可以在执行插入，更新编辑或删除操作后快速计算新的树根，而无需重新计算整个树。还有两个非常理想的辅助属性：</p>
<ul>
<li>即使攻击者故意设计事务以使树尽可能深，它的深度也是有界的。否则，攻击者可以通过将树处理得如此之深以至于每个单独的更新变得极其缓慢，从而执行拒绝服务攻击。</li>
<li>树的根仅取决于数据，而不取决于更新的顺序。以不同的顺序进行更新，甚至从头开始重新计算树都不应更改根。</li>
</ul>
<p>简单来说，Patricia树可能是我们可以同时实现所有这些特性的最接近的树。关于其工作原理的最简单解释是，将存储值的键编码为您必须取下该树的“路径”。每个节点有16个子节点，因此路径是通过十六进制编码确定的：例如，十六进制编码的密钥狗是6 4 6 15 6 7，因此您将从根开始，沿着第6个子节点向下，然后是第4个，依此类推，直到到达终点为止。 在实践中，当树稀疏时，我们可以进行一些额外的优化以使过程效率更高，但这是基本原理。 上面提到的两篇文章更详细地描述了所有功能。</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>blockchain</tag>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Multi-Address Wallet Design: 多地址钱包设计</title>
    <url>/post/multi-addr-wallet-design/</url>
    <content><![CDATA[<p>因为导出的hex比较ugly，因此是想要为ngwallet钱包定制一个助记词方案。本来构思的是直接通过密钥生成助记词，但是在寻找wordlist的时候仔细看了一下bitcoin的助记词方案，发现hd钱包（Hierachical Deterministic Wallets）这套密钥管理非常有趣且实用。既然在专心做钱包了那就顺带学习借鉴。</p>
<span id="more"></span>

<h2 id="BIP32"><a href="#BIP32" class="headerlink" title="BIP32"></a>BIP32</h2><h3 id="Key-derivation-派生密钥"><a href="#Key-derivation-派生密钥" class="headerlink" title="Key derivation: 派生密钥"></a>Key derivation: 派生密钥</h3><p>我们将使用比特币中公钥加密曲线，即<a href="http://www.secg.org/sec2-v2.pdf" target="_blank" rel="noopener">secp256k1</a>定义的字段和曲线参数的椭圆曲线密码术。有关secp256k1的细节这里不做展开。</p>
<h4 id="Extended-keys-拓展密钥"><a href="#Extended-keys-拓展密钥" class="headerlink" title="Extended keys: 拓展密钥"></a>Extended keys: 拓展密钥</h4><p>在下面的内容中，我们将定义一个由父密钥派生许多子密钥的函数。 为了防止它们仅依赖于密钥本身，我们首先使用额外的256位”熵”(entropy)来扩展私有密钥和公共密钥。此扩展称为链码chain code，对于相应的私钥和公钥是相同的，并且由32个字节组成。</p>
<p>我们将扩展私钥表示为(k, c)，其中k为普通私钥，而c为链码。 扩展的公钥表示为(K, c)，其中<code>K = point(k)</code>，c为链码。</p>
<p>每个扩展密钥都有$2^{31}$个普通子密钥和$2^{31}$个强化子密钥。 这些子密钥中的每一个都有一个索引index。普通子键使用从0到$2^{31}-1$的index。加固的子密钥使用索引$2^{31}$到$2^{32} -1 $。 为了简化强化子密钥index的表示，用$i_H$表示$i + 2^{31}$。</p>
<h4 id="Child-key-derivation-CKD-functions-子密钥派生函数"><a href="#Child-key-derivation-CKD-functions-子密钥派生函数" class="headerlink" title="Child key derivation (CKD) functions: 子密钥派生函数"></a>Child key derivation (CKD) functions: 子密钥派生函数</h4><p>给定父扩展密钥和index i，可以计算相应的子扩展密钥。 这样做的算法取决于子密钥是否是强化密钥（或，等效地，i是否大于等于$2^{31}$），以及我们是在谈论私钥还是公钥。</p>
<h5 id="父私钥-amp-rarr-子私钥"><a href="#父私钥-amp-rarr-子私钥" class="headerlink" title="父私钥 &amp;rarr; 子私钥"></a>父私钥 &amp;rarr; 子私钥</h5><p>函数CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i) &amp;rarr; (k<sub>i</sub>, c<sub>i</sub>)从父扩展私钥计算子扩展私钥</p>
<ul>
<li><p>Check whether i ≥ 2<sup>31</sup> (whether the child is a hardened key).</p>
<ul>
<li>If so (hardened child): let I &#x3D; HMAC-SHA512(Key &#x3D; c<sub>par</sub>, Data &#x3D; 0x00 || ser<sub>256</sub>(k<sub>par</sub>) || ser<sub>32</sub>(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.)</li>
<li>If not (normal child): let I &#x3D; HMAC-SHA512(Key &#x3D; c<sub>par</sub>, Data &#x3D; ser<sub>P</sub>(point(k<sub>par</sub>)) || ser<sub>32</sub>(i)).</li>
</ul>
</li>
<li><p>Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.</p>
</li>
<li><p>The returned child key k<sub>i</sub> is parse<sub>256</sub>(I<sub>L</sub>) + k<sub>par</sub> (mod n).</p>
</li>
<li><p>The returned chain code c<sub>i</sub> is I<sub>R</sub>.</p>
</li>
<li><p>In case parse<sub>256</sub>(I<sub>L</sub>) ≥ n or k<sub>i</sub> &#x3D; 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2<sup>127</sup>.)</p>
</li>
</ul>
<h5 id="父私钥-amp-rarr-子公钥"><a href="#父私钥-amp-rarr-子公钥" class="headerlink" title="父私钥 &amp;rarr; 子公钥"></a>父私钥 &amp;rarr; 子公钥</h5><p>函数N((k, c)) &amp;rarr; (K, c) 从父扩展公钥计算子扩展公钥。 仅针对未加固的子键定义</p>
<ul>
<li>返回的密钥K为point(k)。</li>
<li>返回的链码c只是传递的链码。</li>
</ul>
<p>要计算父私钥的子公钥:</p>
<ul>
<li>N(CKDpriv((k<sub>par</sub>, c <sub>par</sub>), i))（始终有效）。</li>
<li>CKDpub(N(k<sub>par</sub>, c <sub>par</sub>), i)（仅适用于非强化的子密钥）。</li>
</ul>
<p>两者等效，使得非强化的密钥变得有用（一个人可以在不知道任何私钥的情况下派生出给定父密钥的子公钥），也使它们与强化密钥有所区别。 不一直使用非强化密钥（尽管更有用）的原因是安全性考量。</p>
<h5 id="父公钥-amp-rarr-子公钥"><a href="#父公钥-amp-rarr-子公钥" class="headerlink" title="父公钥 &amp;rarr; 子公钥"></a>父公钥 &amp;rarr; 子公钥</h5><p>函数 CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) &amp;rarr; (K<sub>i</sub>, c<sub>i</sub>) 从父扩展公钥计算子扩展公钥。它仅针对未强化的子密钥。</p>
<ul>
<li>检查是否 i ≥ 2<sup>31</sup> (即，是否子密钥为强化密钥).</li>
<li>如果是强化密钥，返回失败</li>
<li>如果是普通密钥: 设置 I &#x3D; HMAC-SHA512(Key &#x3D; c<sub>par</sub>, Data &#x3D; ser<sub>P</sub>(K<sub>par</sub>) || ser<sub>32</sub>(i)).</li>
<li>把I 分割成两个32-byte 序列, I<sub>L</sub> 和 I<sub>R</sub>.</li>
<li>返回的子密钥 K<sub>i</sub> 即为point(parse<sub>256</sub>(I<sub>L</sub>)) + K<sub>par</sub>.</li>
<li>返回的链码 c<sub>i</sub> 为 I<sub>R</sub>.</li>
<li>如果 parse<sub>256</sub>(I<sub>L</sub>) ≥ n 或 K<sub>i</sub> 是在无限上的点, 那么得到的密钥无效, 且需要继续处理i的下一个值.</li>
</ul>
<h5 id="父公钥-amp-rarr-子私钥"><a href="#父公钥-amp-rarr-子私钥" class="headerlink" title="父公钥 &amp;rarr; 子私钥"></a>父公钥 &amp;rarr; 子私钥</h5><p>不可能</p>
<h3 id="The-key-tree-密钥树"><a href="#The-key-tree-密钥树" class="headerlink" title="The key tree: 密钥树"></a>The key tree: 密钥树</h3><p>下一步则是串联数个CKD 结构来构造一个树形结构。我们从一个根节点，即主拓展密钥m开始。通过执行多个i值对应的CKDpriv(m,i) , 我们得到一系列level-1的派生节点。由于它们每个都是扩展密钥，因此CKDpriv也可以应用于这些扩展密钥。</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
        <tag>wallet</tag>
      </tags>
  </entry>
  <entry>
    <title>New Env in msys2: msys2引入的新环境</title>
    <url>/post/new-env-in-msys2/</url>
    <content><![CDATA[<p>今天为小平板配置精简版开发环境来着，因为vscode在ngcore上一直报</p>
<blockquote>
<p>go list failed to return CompiledGoFiles. This may indicate failure to perform cgo processing; try building at the command line.</p>
</blockquote>
<p>这样的错误，所以认为是因为没有gcc的问题。那就装msys2.</p>
<span id="more"></span>

<p>相比我上次装（应该是至少有半年了），这次msys2的installer换了个更精致的皮。不过在最后一步应该是开terminal初始化的时候还是会有各种乱码，而且内容格式也很混乱。</p>
<p>熟悉地pacman -Syu一阵之后根据提示自动关闭了installer弹出的msys2界面。然后进安装目录找exe打算再起一个terminal，结果发现多了个clang64.exe（没看到ucrt64，因为在后面平板屏幕小没拉下去继续看）。一开始觉得只是多了个clang定制入口没太当回事，打开mingw64并pacman -Ss gcc查找toolchain全名（安装这么多次从没记住过）。结果跳出来的相比以前有一堆ucrt64&#x2F;开头的，让人一脸懵逼。</p>
<p>这里就简单说一下当前的msys2内部支持的环境&#x2F;架构：</p>
<table>
<thead>
<tr>
<th>环境</th>
<th>路径前缀</th>
<th>toolchain</th>
<th>架构</th>
<th>C库</th>
<th>C++库</th>
</tr>
</thead>
<tbody><tr>
<td>msys2</td>
<td><code>/usr</code></td>
<td>gcc</td>
<td>x86_64</td>
<td>cygwin</td>
<td>libstdc++</td>
</tr>
<tr>
<td>mingw64</td>
<td><code>/mingw64</code></td>
<td>gcc</td>
<td>x86_64</td>
<td>msvcrt</td>
<td>libstdc++</td>
</tr>
<tr>
<td>ucrt64</td>
<td><code>/ucrt64</code></td>
<td>gcc</td>
<td>x86_64</td>
<td>ucrt</td>
<td>libstdc++</td>
</tr>
<tr>
<td>clang64</td>
<td><code>/clang64</code></td>
<td>llvm</td>
<td>x86_64</td>
<td>ucrt</td>
<td>libc++</td>
</tr>
<tr>
<td>mingw32</td>
<td><code>/mingw32</code></td>
<td>gcc</td>
<td>x86_64</td>
<td>msvcrt</td>
<td>libstdc++</td>
</tr>
</tbody></table>
<p>先从列内容说起。</p>
<ul>
<li>路径前缀：因为msys2是多环境混合的，所以就可能同时存在多个gcc这样的程序，因此使用路径前缀区分</li>
<li>Toolchain：就是一套默认的编译链，像arch上的base-devel和ubuntu上build-essential</li>
<li>架构：64和32位</li>
<li>C库：C语言的标准库，环境决定</li>
<li>C++库：C++标准库，编译器决定</li>
</ul>
<p>然后逐行介绍</p>
<ul>
<li>msys2：这个是msys2的支持环境，所有在msys2里直接跑的命令（比如最常用的pacman）都是这个环境支持的，环境基于cygwin也导致了它带的gcc编译出来的东西不好跑……真的不建议用它干任何除了pacman包管理以外的任何事。</li>
<li>mingw64 &amp; mingw32：这里把w32也一起说了。根据我的记忆，一开始是只有mingw32没有msys2，其基于msvcrt（Microsoft Visual C++ Runtime）因此相比cygwin（需要一堆支持库）更好用，可以直接在Windows下跑起来。那时候还是全32位的时代。后来64位成为了主流，也有人开始基于mingw32做了mingw64，但是包更新巨慢，而且w32和w64的更新器也非常难用（就vb程序显示一堆多选列表，每次都得取整个列表）。于是msys2出来带着pacman来管理各个包。</li>
<li>ucrt64：Visual Studio的新宠，全名是Universal C Runtime，用来替代前面mingw64&amp;w32里的msvcrt。ucrt不支持加载msvcrt的产物，因此老版本Windows（&lt;10）不能直接兼容基于它的软件。但是这不是无理由的激进，要知道msvcrt在当前开发环境里真的是让开发打哑谜，（原生）不支持C99，不支持UTF8</li>
<li>clang64：就是大家熟悉的llvm前端，其实mingw64&#x2F;w32里也有它的toolchain不过不是默认，这里它被拆出来作为默认且基于ucrt了。</li>
</ul>
<p>我现在的选择是开始尝试使用ucrt一阵子，后面再根据体验来反馈一下。<br>emmmmm…算是出师未捷身先死了，直接golang这关就过不了。首先我用的golang是官方预编译的安装版，肯定就是带msvcrt编译的，用cgo就出现了下面的报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Go\pkg\tool\windows_amd64\link.exe: running gcc failed: exit status 1</span><br><span class="line">C:/msys64/ucrt64/bin/../lib/gcc/x86_64-w64-mingw32/10.3.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\Users\c\AppData\Local\Temp\go-link-397521815\000007.o: in function `_cgo_preinit_init&#x27;:</span><br><span class="line">c:\go\src\runtime\cgo/gcc_libinit_windows.c:30: undefined reference to `__imp___iob_func&#x27;</span><br><span class="line">C:/msys64/ucrt64/bin/../lib/gcc/x86_64-w64-mingw32/10.3.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\Users\c\AppData\Local\Temp\go-link-397521815\000007.o: in function `x_cgo_sys_thread_create&#x27;:</span><br><span class="line">c:\go\src\runtime\cgo/gcc_libinit_windows.c:60: undefined reference to `__imp___iob_func&#x27;</span><br><span class="line">C:/msys64/ucrt64/bin/../lib/gcc/x86_64-w64-mingw32/10.3.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\Users\c\AppData\Local\Temp\go-link-397521815\000007.o: in function `x_cgo_notify_runtime_init_done&#x27;:</span><br><span class="line">c:\go\src\runtime\cgo/gcc_libinit_windows.c:101: undefined reference to `__imp___iob_func&#x27;</span><br><span class="line">C:/msys64/ucrt64/bin/../lib/gcc/x86_64-w64-mingw32/10.3.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\Users\c\AppData\Local\Temp\go-link-397521815\000008.o: in function `x_cgo_thread_start&#x27;:</span><br><span class="line">c:\go\src\runtime\cgo/gcc_util.c:18: undefined reference to `__imp___iob_func&#x27;</span><br><span class="line">C:/msys64/ucrt64/bin/../lib/gcc/x86_64-w64-mingw32/10.3.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\Users\c\AppData\Local\Temp\go-link-397521815\000009.o: in function `_cgo_sys_thread_start&#x27;:</span><br><span class="line">c:\go\src\runtime\cgo/gcc_windows_amd64.c:29: undefined reference to `__imp___iob_func&#x27;</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>为了继续体验就只能先把预编译的卸载了，在msys2里装<code>mingw-w64-ucrt-x86_64-go</code>。换完golang就能编译了。说明编译期间也支持装载msvcrt编译的.a文件</p>
<p>根据运行来看，对msvcrt下编译好的静态库.a的支持也是没有问题。</p>
<p>golang的动态库导入实现即plugin库还是不支持Windows。大概得靠rust来测试了。</p>
<hr>
<p>在小平板上用vscode+gopls配合完全没有问题，但是在PC上使用goland就出现问题了（虽然并不是ucrt的问题）——goland不支持msys2下的go……</p>
<p><del>goland在Windows上会直接找整个go的安装（linux下为tar解压后的）文件夹，在msys2这里并没有这样的一个单独文件夹给go，所以goland根本就不认。</del></p>
<p><del>唯一办法就是自己编译一个文件夹出来覆盖掉，但是以后升级什么的都得自己编译了。</del></p>
<hr>
<p>仔细搜了一下msys2里GOROOT的定义，发现了<code>/&lt;Env&gt;/lib/go</code>这个路径，即<code>C:\msys64\&lt;Env&gt;\lib\go</code>这个文件夹保留着GOROOT的全部内容</p>
<p>（默默把刚装回去的官方golang给卸载</p>
<p>试了下goland的确能识别这个目录作为SDK的。<br>但是有个小问题，就是GOROOT在msys2里写死了路径（即<code>C:\msys64\&lt;Env&gt;\lib\go</code>）意味着如果要用这个默认值你就不能把msys2装到其他盘或者其他目录（比如choco会把msys2放进<code>C:\tools\msys2</code>目录，直接导致了goland上的golangci-lint插件挂掉）。</p>
]]></content>
  </entry>
  <entry>
    <title>ngchain Serialization Selection: ngchain的序列化方案选择</title>
    <url>/post/ngchain-serialization-selection/</url>
    <content><![CDATA[<p>实在是苦于protobuf，不论是g家的老版本还是新版本，还是gogo，都逃离不了protobuf是非常面向对象的事实。<br>而我们需要的仅仅只是一个简单的blob存储&#x2F;传输方案。</p>
<span id="more"></span>

<p><a href="https://ethresear.ch/t/blob-serialisation/1705" target="_blank" rel="noopener">https://ethresear.ch/t/blob-serialisation/1705</a></p>
<h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><p>至于为什么会走向protobuf这个歪路，是因为真的在benchmark里它的速度太诱人了。<br>golang那个benchmark对比里它也是被推荐的。<br>那时候新版还没出，gogo的速度在一众序列化方案里简直快到爆。<br>而且protobuf序列化之后的字节也非常小。<br>所以当时就觉得这个可以有。</p>
<p>但是随着项目一点点成型，protobuf的定位和项目需求的矛盾也越来越明显。<br>对于一个到处都是serde，到处在不顾兼容性地通过修改数据原型优化系统的一个底层应用，<br>protobuf的操作实在是过于繁琐且束缚过大</p>
<ul>
<li><p>protobuf没有继承关系。<br>protobuf的各种feature在和golang结合的时候会让人很难受。<br>不止是单纯的用户定义的message之间继承不了，比如说这里希望<code>message A</code>继承<code>bytes</code>，<code>message B</code>继承<code>map&lt;string, string&gt;</code>这种就都做不到。<br>而且本身protobuf的（优化）集成也很麻烦（尤其在bazel里）。其对特殊类型（any啥的）的支持在golang下让人不太敢用，尤其是apiv2之后。</p>
</li>
<li><p>我想要的大部分情况下只是简单的把一个list序列化，但是protobuf只处理generated code里的那些message<br>例如raw, err :&#x3D; proto.Marshal([][]byte{[]byte{“wasd”}})<br>就会提示cannot use ([][]byte literal) (value of type [][]byte) as protoreflect.ProtoMessage value in argument to proto.Marshal: missing method ProtoReflect。<br>正确的serde做法就是建立一个新的message，然后这个message里带一个这个bytes list类型的字段。</p>
</li>
<li><p>我想要序列化过程可定制，但是官方新版本不可以<br>为什么需要可定制？因为一个struct中并非全部字段需要serde。<br>一般的解决方法是将要序列化的字段public，而不需要的private，通过func来调用private内容。<br>但是这里还有个痛点：生成的代码不应该修改，我根本没法把我的私有字段加到struct里。<br>v0.0.19之前，我们是通过func直接生成值，例如GetHash()相当于每次调用都进行hash。<br>即便是sha3.256这样的简单hash，都消耗了大量资源。<br>后面v0.0.20的实践是加上对应的public字段。<br>但是hash值这样的内容导致了值和其他内容填充的步调不一：需要先有内容且确定才能得到hash，修改内容后也得重新hash。<br>v0.0.21带来了更优实践：使用自定义struct继承生成的struct。<br>这样既可以保存自定义的辅助性字段（比如hash）（在自定义struct之中），<br>又可以serde（通过父struct，即生成的）。<br>但是实际体验并没有那么美好，自定义struct即便是继承了，也不是protoreflect.ProtoMessage，没法直接serde。<br>注意这里是protoreflect.ProtoMessage，不是proto.Message，这是新版和旧版（or gogo）的区别所在。<br>然而更坑的是goland会告诉你自定义的子类可以serde……因此需要一个个排查。<br>最后来到我们的最后一个方案，为了快速排查，我们放弃了直接继承，选择了将原型作为自定义struct字段，通过GetProto()来获取原型以及LoadProto()进行serde。<br>这样改掉一堆错误之后看似安静和谐了很多，但是，我们被框架限制住了。<br>这样妥协的方式，让我们很难在types.proto之外继续利用serde来扩展。<br>很明显，protobuf是给那些有准备的人的，而我们只是到处碰运气的赌徒罢了。</p>
</li>
</ul>
<h2 id="rlp"><a href="#rlp" class="headerlink" title="rlp"></a>rlp</h2><p>作为一个有在geth上debug经验的开发，我也不是第一次使用rlp。在过去golang使用还不熟练的经历里，rlp真的是不好用。<br>首先从直观来看rlp不像别的那样有Marshal和Unmarshal。<br>其次IDE上的提示（lint）也不尽如人意，经常会出现看起来啥问题都没有跑起来到处不能encode的问题。<br>同样Decode也有问题，见这里<a href="https://ethresear.ch/t/blob-serialisation/1705/5" target="_blank" rel="noopener">vb说的例子</a>。这个帖子说的序列化还在优化更新中，而prysm用的是protobuf，所以现在不适合跟上ethereum的设计。<br>再者，缺少对map的支持，不过这个很好理解，有map之后就很难deterministic，像protobuf一样可能不同的实现有着不同的deterministic规则，仅在同一语言上统一。<br>此外如果直接<code>type Uint uint</code>这样建立type（很常见，比如NetworkType，TxType等等），那么rlp是不支持把他当uint这样的原始类型看的，就需要自己实现一个Encoder+Decoder。</p>
<p>但是首先这个数据大小很香，真的很小。根据github上benchmark来看是比protobuf要小。</p>
<p>其次原理简洁易懂。说白了就是万物list or str。这部分根据rlp的En&#x2F;Decoder来讲。</p>
<h3 id="En-x2F-Decoder"><a href="#En-x2F-Decoder" class="headerlink" title="En&#x2F;Decoder"></a>En&#x2F;Decoder</h3><p>和json的返回值不同，rlp的内容是直接写入io.Writter。<br>一般我们就直接使用rlp.Encode(writter, 【自定义好的结构】)就可以</p>
<p>前面也说到了rlp原理简单，这里就举点案例：</p>
<p>比如说一个Nonce是个8字节的定长[]byte，需要把它encode to rlp只需要在这个8字节前面写一个prefix来描述它就可以用136（&#x3D;0x80+8）来表示8这个长度。</p>
<p>具体的rlp的规则：</p>
<ul>
<li>对于单个byte（char），如果值是在0x00-0x7f（127，也就是常用ascii），那么就直接放着就行</li>
<li>此外，对于0-55长度的bytes，rlp就用<code>0x80（128）+长度</code>作为其前缀来描述后面的列表（or单byte&gt;127）。这个前缀byte值在0x80（128）-0xb7（183）</li>
<li>如果是比55还长，那么肯定就需要不止一个byte来修饰。为了支持巨长的内容，前缀的第一个字符来描述后面&gt;55的长度。例如一个1024字节的bytes&#x2F;str，会被encode成<code>[0xb9, 0x04, 0x00, byte_1, ... , byte_1024]</code>，这里0xb9&#x3D;0xb7+2，这个2就表示后面有俩字节（0x04，0x00）是拿来描述长度的。而长度0x04，0x00则是1024的big-endian encode。这部分的首字节被限制在0xb8-0xbf，即最大支持8字节的长度描述，最大支持2^(8*4)字节长度的bytes</li>
<li>另外还有个概念就是list，就相当于bytes或者其他list的一个容器，例如[[‘h’, ‘e’], [‘l’, ‘p’]]。如果这个list的总payload（子元素，包括了前缀，的长度加起来）是0-55bytes，那么就单用一个0xc0（192）来表述。</li>
<li>和前面一样，如果超过55，那就用0xf7+长度。首字节范围在0xf8-0xff，也是最大支持2^(8*4)字节长度的bytes。</li>
</ul>
<h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>在翻rlp资料时候看到了eth社区提出的<a href="https://ethresear.ch/t/blob-serialisation/1705" target="_blank" rel="noopener">blob serialisation</a>。这里说下至今<br><a href="https://github.com/prysmaticlabs/prysm/pull/92" target="_blank" rel="noopener">https://github.com/prysmaticlabs/prysm/pull/92</a><br><a href="https://github.com/prysmaticlabs/prysm/pull/147" target="_blank" rel="noopener">https://github.com/prysmaticlabs/prysm/pull/147</a><br>现在状况就是人家折腾半天然后跑去拥抱protobuf了。</p>
<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>serde&#x3D;SERializing &amp; DEserializing, rust里的framework就叫这个</p>
]]></content>
  </entry>
  <entry>
    <title>NGIN的新架構</title>
    <url>/post/new-structure-of-ngin/</url>
    <content><![CDATA[<p>重構一時爽……</p>
<span id="more"></span>

<h2 id="權限更大的Consensus"><a href="#權限更大的Consensus" class="headerlink" title="權限更大的Consensus"></a>權限更大的Consensus</h2><p>之前的Consensus是管不到p2p的，因此初始化，同步，廣播這些都是由p2p模塊根據網絡場景來觸發，然後調用内置的Consensus來對區塊和狀態進行修改。</p>
<p>根據新的架構，Consensus將接管P2P的所有功能的主動觸發。</p>
<p>針對Wired協議中response的處理，原本是通過handler處理，現在改爲直接caller func中直接對stream進行後續讀取再關閉</p>
<h2 id="更强大的Tx"><a href="#更强大的Tx" class="headerlink" title="更强大的Tx"></a>更强大的Tx</h2><p>Tx，作为事务，除了处理交易以外最重要的功能就是处理智能合约，也就是第二层架构(layer-2)。</p>
<p>和虽然同样使用账户模型，NGIN的Tx和Ethereum的Transaction有很大不同：Tx的目标不唯一。</p>
<p>这就意味着，一个账户想在同一时间（同一区块）内发送多个ethereum交易，只需要将这些的内容进行合并。</p>
<p>这有什么好处？首先这可以保证在“一账户一区块一事务”的原则下尽可能地拓展有效交易吞吐量。其次，减少Multi-Tx时不必要的参数，达到减小Block体积，提高TPS。再者，这对于WASM的模块化至关重要。</p>
<p>前面两个应该很好理解，要是没这个那么“一账户一区块一事务”只能发一个交易也太难受了，要是一个账户发一堆Transaction的话累赘的sign和address也太多了。</p>
<p>WASM这个就值得介绍了。</p>
<p>首先WASM的设计是模块化的，所有功能或者值都可以被Module包裹形成一个模块，然后AsExtern就能被其他模块import。</p>
<p>那么如果热心群众A开发了个算法库，我B想拿来用在我的应用上，按照ethereum的操作就是拿来sol再import。这样会有俩问题，首先是网络上这个库相当于就装了两回，而且B的应用（binary）内部相当于包裹了这个算法的binary，只装一个还好，装多了就大的一批。</p>
<p>在WASM里，部署的是Module形式的WASM，只需要import就可以直接使用。这时候就是Tx出场的时候了，想要在Transaction里导入其他账户contract里的module，只需要把他们的owner写到participants里就可以。当然你要是觉得他们的库很赞，你可以写点value在vaules里给他们点赞助:-)</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>NGIN</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>PoW Algorithm Design</title>
    <url>/post/pow-algo-design/</url>
    <content><![CDATA[<p>首先</p>
<p>为了减少专用硬件的性能优势，工作量证明 (PoW) 算法必须通过针对现有通用硬件的特定功能来实现设备绑定。<br>这是一项复杂的任务，因为我们必须针对来自不同制造商的具有不同架构的一大类设备。</p>
<p>有两类不同的通用计算设备：中央处理单元 (CPU) 和图形处理单元 (GPU)。RandomX 针对 CPU 的原因如下：</p>
]]></content>
  </entry>
  <entry>
    <title>Profiling ngcore in go</title>
    <url>/post/profiling-ngcore-in-go/</url>
    <content><![CDATA[<p>因为新版本的ngcore已经把mining模块删除了，因此在空闲状态从理论上看应该是非常低调的一个p2p“哑巴”。但是实际在PC这个3600x相对高级u的环境下都能占据&gt;10%的cpu且高耗电。因此这里就开始对程序尝试调优。</p>
<p>暂时就只关注cpu利用率的问题（高耗电在客户端上太致命了</p>
<span id="more"></span>

<p>首先通过注释掉<code>import _ &quot;net/http/pprof&quot;</code>确认了高电量不是由于引入profile导致的。</p>
<p>然后根据profile给出的结果对几个loop都加了runtime.Goshced，并没有太大起色。</p>
<p>profile结果全是runtime.xxx这种内部的方法。</p>
<h2 id="go的profile"><a href="#go的profile" class="headerlink" title="go的profile"></a>go的profile</h2><p>首先肯定是需要熟练一下go自带的pprof工具。</p>
<p>为了方便profiling，ngcore会在一个随机可用端口上建立一个http server来为pprof提供当前运行数据。<br>一般可以使用<code>go tool pprof http://localhost:[port]</code>来开启命令行模式，如果带<code>-http=:[another_port]</code>参数就可以在another_port上建一个网页来展示diagrams</p>
<p>下面说一下在命令行模式下的一些命令</p>
<h3 id="topNN"><a href="#topNN" class="headerlink" title="topNN"></a>topNN</h3><p>NN可以换成任何数字，比如top10就profile（CPU）前十的func。</p>
<p>go的blog上示例明显老旧了，这里我拿go1.16下的结果讲解一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pprof) top10</span><br><span class="line">Showing nodes accounting for 15330ms, 54.15% of 28310ms total</span><br><span class="line">Dropped 151 nodes (cum &lt;= 141.55ms)</span><br><span class="line">Showing top 10 nodes out of 86</span><br><span class="line">显示节点占15330ms，占28310ms总数的54.15% （pprof标识的有效样本时间，和总样本时间）</span><br><span class="line">删除了 151 个节点（cum &lt;= 141.55ms，意思就是这151个剩余的加起来不超过141ms）</span><br><span class="line">显示 86 个节点中的前 10 个节点（即top10）</span><br><span class="line"></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    3530ms 12.47% 12.47%     8150ms 28.79%  runtime.selectgo</span><br><span class="line">    2920ms 10.31% 22.78%     2930ms 10.35%  runtime.stdcall1</span><br><span class="line">    1660ms  5.86% 28.65%     1700ms  6.00%  runtime.unlock2</span><br><span class="line">    1320ms  4.66% 33.31%    11930ms 42.14%  runtime.schedule</span><br><span class="line">    1310ms  4.63% 37.94%     1310ms  4.63%  runtime.stdcall2</span><br><span class="line">    1270ms  4.49% 42.42%     3300ms 11.66%  runtime.lock2</span><br><span class="line">     960ms  3.39% 45.81%     9160ms 32.36%  github.com/ngchain/ngcore/consensus.(*PoWork).eventLoop</span><br><span class="line">     920ms  3.25% 49.06%     6950ms 24.55%  runtime.findrunnable</span><br><span class="line">     850ms  3.00% 52.07%     3230ms 11.41%  runtime.checkTimers</span><br><span class="line">     590ms  2.08% 54.15%     1630ms  5.76%  runtime.sellock</span><br></pre></td></tr></table></figure>
<ul>
<li>flat：样本中running时间（不包含waiting for a called function to return，默认按此排序）</li>
<li>flat%：占总样本时间百分比</li>
<li>sum：即从上往下sum(flat%)</li>
<li>cum：func出现（包括running<strong>或waiting for a called function to return</strong>）的样本时间（用-cum就用它排序）</li>
<li>cum%：占总百分比</li>
</ul>
<h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p><code>web</code>命令就是在网页显示stack trace。命令行打开的web不如直接host在http。</p>
<p>通过trace就可以看到是主要哪里call了这个在前面疯狂running的func。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>list Func</code>会给你打印Func这个func的源码，并且在每行的左边显示对应的flat和cum</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>从上面的可以看出来其实是eventLoop里的select导致了selectgo的大量调用。</p>
<p>在这个函数里我用了两个case的for-select结构，两个case都是从channel里接受内容。</p>
<p>尝试了下把for-select-<code>&lt;- ch</code>分解成了两个for-<code>&lt;- ch</code>（不影响业务），cpu占用瞬间变成1-2%（而且是平板上）可以说是相当显著。</p>
<p>有关这个for-select性能的讨论</p>
<p><a href="https://stackoverflow.com/questions/42059800/performance-of-golang-select-statement-in-a-for-loop/42062485" target="_blank" rel="noopener">https://stackoverflow.com/questions/42059800/performance-of-golang-select-statement-in-a-for-loop/42062485</a></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.golang.org/pprof" target="_blank" rel="noopener">https://blog.golang.org/pprof</a></p>
<p><a href="https://github.com/dgryski/go-perfbook/blob/master/performance.md" target="_blank" rel="noopener">https://github.com/dgryski/go-perfbook/blob/master/performance.md</a></p>
]]></content>
  </entry>
  <entry>
    <title>市场上新一代公链研究</title>
    <url>/post/public-blockchain-research-report/</url>
    <content><![CDATA[<p>原本应该是edX上BerkeleyX CS198.2x: Blockchain Technology的Homework3，这里干脆就对所有知名的链做点分析。</p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>为了准备最终作业，本周的任务是对您选择的特定区块链进行研究，并将其发到在论坛。<br>您可以将此作业作为最终作业的头脑风暴会议。<br>重点是综合在材料的最后几周中学到的概念，主要是关于可伸缩性，安全性和去中心化的主题，并将这种理解应用于我们可能在课堂上未曾详细介绍过的各种区块链（或完全没介绍过的）。</p>
<p>请在下面的论坛中进行协作。<br>如果其他人写了关于您选择的区块链平台的文章，请添加到他们的帖子中，而不是您自己再建立个。<br>我们正在为每位经过深思熟虑的讨论贡献的人寻找大约1-2个段落。<br>请在您的帖子中引用您的消息来源。<br>也请在下面的文本框中粘贴您贡献的内容。<br>我们将对您提交的文本以及您参与讨论的内容进行评分。</p>
<p>以下是一些您可以编写的详细子话题，然后是一些更详细的提交规范。</p>
<h3 id="动机和用例-x2F-市场"><a href="#动机和用例-x2F-市场" class="headerlink" title="动机和用例&#x2F;市场"></a>动机和用例&#x2F;市场</h3><p>如果您的平台是面向用例的：它解决什么现实问题？您是否正在建立供应链平台？您的货币适合物联网等特定细分市场吗？</p>
<p>如果您的平台是基础架构：（例如，以太坊允许开发人员在公共系统中轻松编写和部署智能合约）这可以解决加密&#x2F;区块链行业中的哪些常见问题？其他人如何利用您的平台做更大的事情？</p>
<h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p>为什么采用这种共识算法？它的优点和缺点是什么？</p>
<p>例如，在许可的分类帐中使用PBFT效率更高，因为它不需要挖掘，并且在半信任的环境中效果很好。</p>
<h3 id="独特的功能"><a href="#独特的功能" class="headerlink" title="独特的功能"></a>独特的功能</h3><p>谈论您的加密货币或平台的一些很酷的方面。它具有增强的隐私性吗？它是否支持阈值签名？它是模块化的，因此特别适合企业集成吗？它使用zk-SNARK还是zk-STARK？是侧链吗？</p>
<h3 id="潜在漏洞和博弈论攻击"><a href="#潜在漏洞和博弈论攻击" class="headerlink" title="潜在漏洞和博弈论攻击"></a>潜在漏洞和博弈论攻击</h3><p>例如，如果您的区块链使用权益证明，您可能会遇到什么问题？您的系统是否完全不信任？如果不是，请详细说明一些担忧和权衡。您的平台有游戏理论问题吗？<br>可伸缩性注意事项</p>
<p>例如，如果它是由几家银行共享的私有链，那么在区块链上存储大量数据就不是那么重要了。您的区块链是否允许状态通道？它实现分片吗？它允许侧链吗？可以被群众合理使用吗？<br>规</p>
<p>是否存在KYC &#x2F; AML问题？对像您这样的区块链当前的监管观点是什么？</p>
<h3 id="规格："><a href="#规格：" class="headerlink" title="规格："></a>规格：</h3><ul>
<li>它不能使用工作量证明。在课程中，我们对PoW进行了很多分析，您应该尝试将类似的分析应用于其他平台和加密货币。</li>
<li>同上，它不能是比特币或以太坊。</li>
<li>确保引用您的消息来源。</li>
<li>在讨论区中应该大致为1-2个段落。您可以自由编写更多内容，但主要内容应为1-2个段落。</li>
</ul>
<p>卡住？这里有一些建议：</p>
<ul>
<li>Hyperledger</li>
<li>Rootstock（ps: 中文意思是砧木）（这是工作量证明里的例外，因为它使用合并挖掘）</li>
<li>Interledger</li>
<li>Stellar</li>
<li>Cosmos</li>
<li>Polkadot（ps: 中文意思是波尔卡圆点）</li>
<li>Monax</li>
<li>Tezos</li>
</ul>
<h2 id="Hyperledger"><a href="#Hyperledger" class="headerlink" title="Hyperledger"></a>Hyperledger</h2><h3 id="什么是Hyperledger？"><a href="#什么是Hyperledger？" class="headerlink" title="什么是Hyperledger？"></a>什么是Hyperledger？</h3><p>Hyperledger是一个开源<strong>社区</strong>，致力于为企业级区块链部署开发一套稳定的框架，工具和库。</p>
<p>它是各种分布式分类帐框架（包括Hyperledger Fabric，Sawtooth，Indy）以及Hyperledger Caliper之类的工具以及Hyperledger Ursa之类的库的中立场所。[1]</p>
<p>换句话说，Hyperledger（或Hyperledger项目）是开放源代码区块链及相关工具的总体项目，由Linux基金会于2015年12月启动，已获得IBM，Intel和SAP Ariba的捐款，以支持协作开发基于区块链的分布式账簿。[2]</p>
<p>去掉孵化中和停止维护的项目，由Hyperledger直接负责的项目有如下几个[3]：</p>
<ul>
<li>Hyperledger Besu：以太坊客户端，在以太坊公共网络、专用网络和测试网络（如Rinkeby，Ropsten和Görli）上运行。</li>
<li>Hyperledger Fabric：Go写的分布式账簿。（基本上说Hyperledger就是在指它）</li>
<li>Hyperledger Indy：专为去中心化身份而构建的分布式账簿</li>
<li>Hyperledger Iroha：C++写的分布式账簿</li>
<li>Hyperledger Sawtooth：具有多语言支持的分布式账簿</li>
</ul>
<p>[1]来源：<a href="https://www.hyperledger.org/" target="_blank" rel="noopener">https://www.hyperledger.org/</a><br>[2]来源：<a href="https://en.wikipedia.org/wiki/Hyperledger" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hyperledger</a><br>[3]来源：<a href="https://wiki.hyperledger.org/" target="_blank" rel="noopener">https://wiki.hyperledger.org/</a></p>
<h3 id="动机和用例-x2F-市场-1"><a href="#动机和用例-x2F-市场-1" class="headerlink" title="动机和用例&#x2F;市场"></a>动机和用例&#x2F;市场</h3><p>Hyperledger项目的目的是通过开发区块链和分布式账本来促进跨行业的协作，特别着重于提高这些系统的性能和可靠性（与可比的加密货币设计相比），以便它们能够支持全球业务交易 由主要的技术，金融和供应链公司提供。</p>
<p>项目将通过针对特定用途模块的框架集成独立的开放协议和标准，包括具有自己的共识和存储例程的区块链，以及用于身份，访问控制和智能合约的服务。<br>早期有人对Hyperledger会开发自己的比特币类型的加密货币感到困惑，但Behlendorf毫无保留地表示Hyperledger Project本身将永远不会构建自己的加密货币。[1]</p>
<p>[1]来源：<a href="https://en.wikipedia.org/wiki/Hyperledger" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hyperledger</a></p>
<h3 id="共识机制-1"><a href="#共识机制-1" class="headerlink" title="共识机制"></a>共识机制</h3><p>因为项目涉及多个区块链子项目，所以用表格讨论</p>
<table>
<thead>
<tr>
<th>子项目</th>
<th>共识</th>
</tr>
</thead>
<tbody><tr>
<td>Besu</td>
<td>PoW or PoAuthority [1]</td>
</tr>
<tr>
<td>Fabric</td>
<td>CFT（基于raft）[2]</td>
</tr>
<tr>
<td>Indy</td>
<td>RBFT[3]</td>
</tr>
<tr>
<td>Iroha</td>
<td>YAC（另一种CFT）[4]</td>
</tr>
<tr>
<td>Sawtooth</td>
<td>Dynamic Consensus（包括PBFT，Proof of Elapsed Time，Raft，Devmode） [5]</td>
</tr>
</tbody></table>
<p>[1]<a href="https://besu.hyperledger.org/en/stable/Concepts/Consensus-Protocols/Overview-Consensus/" target="_blank" rel="noopener">https://besu.hyperledger.org/en/stable/Concepts/Consensus-Protocols/Overview-Consensus/</a><br>[2]<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatis.html#pluggable-consensus" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatis.html#pluggable-consensus</a><br>[3]<a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiYgs_vzYTsAhX4yIsBHbPyBz4QFjACegQIAhAB&amp;url=https://wiki.hyperledger.org/download/attachments/20024919/Understanding%2520Hyperledger%2520Indy%2520Ledger.pdf?version=1&modificationDate=1571126012000&api=v2&amp;usg=AOvVaw3qDagJGg5Xapx9Dh5ANQxD" target="_blank" rel="noopener">https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiYgs_vzYTsAhX4yIsBHbPyBz4QFjACegQIAhAB&amp;url=https%3A%2F%2Fwiki.hyperledger.org%2Fdownload%2Fattachments%2F20024919%2FUnderstanding%2520Hyperledger%2520Indy%2520Ledger.pdf%3Fversion%3D1%26modificationDate%3D1571126012000%26api%3Dv2&amp;usg=AOvVaw3qDagJGg5Xapx9Dh5ANQxD</a><br>[4]<a href="https://iroha.readthedocs.io/en/master/overview.html" target="_blank" rel="noopener">https://iroha.readthedocs.io/en/master/overview.html</a><br>[5]<a href="https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html" target="_blank" rel="noopener">https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html</a></p>
<p>优点与缺点</p>
<h3 id="规格（技术细节）"><a href="#规格（技术细节）" class="headerlink" title="规格（技术细节）"></a>规格（技术细节）</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>todo</tag>
        <tag>blockchain</tag>
        <tag>edx</tag>
      </tags>
  </entry>
  <entry>
    <title>RandomX Design</title>
    <url>/post/randomx-design/</url>
    <content><![CDATA[<p>原文<a href="https://github.com/tevador/RandomX/blob/master/doc/design.md" target="_blank" rel="noopener">https://github.com/tevador/RandomX/blob/master/doc/design.md</a></p>
<p>为了最大限度地减少专用硬件的性能优势，工作量证明 (PoW) 算法必须通过针对现有通用硬件的特定功能来实现<em>设备绑定</em>。<br>这是一项复杂的任务，因为我们必须针对来自不同制造商的具有不同架构的一大类设备。</p>
<p>有两类不同的通用处理设备：中央处理单元 (CPU) 和图形处理单元 (GPU)。RandomX 针对 CPU 的原因如下：</p>
<ul>
<li>CPU非专业挖矿设备，对于正常用户来说更普遍且更容易访问。受 CPU 限制的算法更加平等，并允许更多参与者加入网络。这是[原始CryptoNote白皮书][cn_paper]中所述的目标之一。</li>
<li>在不同的 CPU 体系结构中存在大量通用的本地硬件指令子集。GPU 则不能这样说。例如，NVIDIA 和 AMD GPU <a href="https://github.com/ifdefelse/ProgPOW/issues/16" target="_blank" rel="noopener">没有通用的整数乘法指​​令</a>。</li>
<li>所有主要的CPU 指令集都有详细的文档记录，有多个可用的开源编译器。相比之下，GPU 指令集通常是专有的，可能需要供应商特定的闭源驱动程序才能获得最大性能。</li>
</ul>
<h2 id="1-设计考量"><a href="#1-设计考量" class="headerlink" title="1. 设计考量"></a>1. 设计考量</h2><p>CPU 绑定工作量证明的最基本思想是“工作”必须是动态的。这利用了 CPU 接受两种输入的事实：数据（主要输入）和代码（指定对数据执行什么操作）。</p>
<p>相反，经典的加密散列hash函数 [ 3 ] 并不适合 CPU 的工作，因为它们的唯一输入是<em>数据</em>，而<strong>操作序列是固定</strong>的，可以通过专用集成电路ASIC更有效地执行。</p>
<h3 id="1-1-动态工作量证明"><a href="#1-1-动态工作量证明" class="headerlink" title="1.1 动态工作量证明"></a>1.1 动态工作量证明</h3><p>一个动态PoW算法通常可以包括以下4个步骤：</p>
<ol>
<li>生成随机程序。</li>
<li>将其翻译成CPU的本地机器代码（机器码）。</li>
<li>执行程序。</li>
<li>将程序的输出转换为加密安全值。</li>
</ol>
<p>实际“有用”的 CPU 密集型工作在步骤 3 中执行，因此必须调整算法以最小化剩余步骤的开销。</p>
<h4 id="1-1-1-生成随机程序"><a href="#1-1-1-生成随机程序" class="headerlink" title="1.1.1 生成随机程序"></a>1.1.1 生成随机程序</h4><p>在动态PoW设计早期的尝试是基于在高级语言，如C或Javascript [4，5]。但是，由于两个主要原因，导致非常低效：</p>
<ul>
<li>高级语言具有复杂的语法，因此生成有效程序的速度相对较慢，因为它需要创建抽象语法树 (ASL)。</li>
<li>一旦生成了程序的源代码，编译器一般会将文本表示解析回ASL，这使得生成源代码的整个过程变得多余。</li>
</ul>
<p>生成随机程序的最快方法是使用无逻辑生成器：简单地用随机数据填充缓冲区。<br>这当然需要设计一种无语法的编程语言（或指令集），其中所有随机位串都代表有效程序。</p>
<h4 id="1-1-2-将程序翻译成机器码"><a href="#1-1-2-将程序翻译成机器码" class="headerlink" title="1.1.2 将程序翻译成机器码"></a>1.1.2 将程序翻译成机器码</h4><p>这一步是不可避免的，因为我们不想将算法限制在特定的 CPU 架构上。<br>为了尽可能快地生成机器代码，我们需要我们的指令集尽可能接近原生硬件，同时仍然足够通用以支持不同的架构。<br>在代码编译期间没有足够的时间进行昂贵的优化。</p>
<h4 id="1-1-3-执行程序"><a href="#1-1-3-执行程序" class="headerlink" title="1.1.3 执行程序"></a>1.1.3 执行程序</h4><p>实际的程序执行应该使用尽可能多的CPU组件。应该在程序中使用的一些功能是：</p>
<ul>
<li>多级缓存（L1、L2、L3）</li>
<li>μop 缓存 [ 6 ]</li>
<li>算术逻辑单元 (ALU)</li>
<li>浮点单元 (FPU)</li>
<li>内存控制器</li>
<li>指令级并行[ 7 ]<ul>
<li>超标量执行 [ 8 ]</li>
<li>乱序执行 [ 9 ]</li>
<li>投机性执行 [ 10 ]</li>
<li>寄存器重命名 [ 11 ]</li>
</ul>
</li>
</ul>
<p>第2章描述了 RandomX VM 如何利用这些功能。</p>
<h4 id="1-1-4-计算最终结果"><a href="#1-1-4-计算最终结果" class="headerlink" title="1.1.4 计算最终结果"></a>1.1.4 计算最终结果</h4><p>Blake2b是一种加密安全的散列函数，专门设计用于在软件中快速运行，尤其是在现代 64 位处理器上，它比 SHA-3 快三倍左右，并且可以以每 3 个时钟周期的速度运行输入字节。此函数是用于 CPU 友好的工作证明的理想候选者。</p>
<p>为了以加密安全的方式处理大量数据，高级加密标准 (AES) 可以提供最快的处理速度，因为许多现代 CPU 支持这些操作的硬件加速。有关在 RandomX 中使用 AES 的更多详细信息，请参阅第 3 章。</p>
<h3 id="1-2-“简易程序问题”"><a href="#1-2-“简易程序问题”" class="headerlink" title="1.2 “简易程序问题”"></a>1.2 “简易程序问题”</h3><p>当一个随机程序产生时，人们可以选择只在它有利的时候执行它。这种策略之所以可行，主要有两个原因：</p>
<p>随机生成程序的运行时间通常遵循对数正态分布 [ 14 ]（另见附录 C）。</p>
<ol>
<li>生成的程序可能会被快速分析，如果它的运行时间可能高于平均水平，则可能会跳过程序执行并生成一个新程序。这可以显着提高性能，尤其是在运行时分布有重尾（许多长期运行的异常值）并且程序生成成本低的情况下。</li>
<li>实现可以选择优化程序执行所需的功能子集。例如，可能会放弃对某些操作（例如除法）的支持，或者可能会更有效地实现某些指令序列。生成的程序只有在符合优化实施的特定要求时才会被分析和执行。</li>
</ol>
<p>这些搜索特定属性程序的策略与此工作量证明的目标背道而驰，因此必须消除它们。这可以通过要求执行一系列N个随机程序来实现，这样每个程序都是从前一个程序的输出生成的。然后将最终程序的输出用作结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          +---------------+     +---------------+               +---------------+     +---------------+</span><br><span class="line">          |               |     |               |               |               |     |               |</span><br><span class="line">input --&gt; |   program 1   | --&gt; |   program 2   | --&gt;  ...  --&gt; | program (N-1) | --&gt; |   program N   | --&gt; result</span><br><span class="line">          |               |     |               |               |               |     |               |</span><br><span class="line">          +---------------+     +---------------+               +---------------+     +---------------+</span><br></pre></td></tr></table></figure>

<p>其原理是，在第一个程序执行后，矿工要么承诺完成整个链（可能包括不利的程序），要么重新开始并浪费在未完成的链上花费的精力。附录 A 中给出了这如何影响不同挖掘策略的哈希率的示例。</p>
<p>此外，这种链式程序执行具有均衡整个链的运行时间的好处，因为相同分布的运行时间总和的相对偏差减少了。</p>
<p>1.3 验证时间<br>由于工作量证明的目的是在去信任的点对点网络中使用，网络参与者必须能够快速验证证明是否有效。这为工作量证明算法的复杂性设置了上限。特别是，我们为 RandomX 设定了一个目标，使其验证速度至少与 CryptoNight 哈希函数 [ 15 ]一样快，它旨在取代它。</p>
<p>1.4 记忆强度<br>除了纯计算资源，如 ALU 和 FPU，CPU 通常可以以 DRAM [ 16 ]的形式访问大量内存。内存子系统的性能通常会根据计算能力进行调整，例如 [ 17 ]：</p>
<ul>
<li>用于嵌入式和低功耗 CPU 的单通道内存</li>
<li>用于台式机 CPU 的双通道内存</li>
<li>用于工作站 CPU 的三通道或四通道内存</li>
<li>用于高端服务器 CPU 的六或八通道内存</li>
</ul>
<p>为了利用外部存储器以及片上存储器控制器，工作量证明算法应该访问一个大的存储器缓冲区（称为“数据集”）。数据集必须是：</p>
<ol>
<li>大于可以存储在芯片上的内容（需要外部存储器）</li>
<li>动态（需要可写内存）</li>
</ol>
<p>对于 16 nm 工艺而言，单个芯片上可放置的最大 SRAM 量超过 512 MiB，而对于 7 nm 工艺而言，则超过 2 GiB [ 18 ]。理想情况下，数据集的大小应至少为 4 GiB。但是，由于验证时间的限制（见下文），RandomX 使用的大小选择为 2080 MiB。虽然理论上可以使用当前技术（2019 年为 7 nm）使用如此数量的 SRAM 制造单个芯片，但这种解决方案的可行性值得怀疑，至少在不久的将来如此。</p>
<p>1.4.1 轻客户端验证<br>虽然对于解决工作量证明的专用挖矿系统要求 &gt;2 GiB 是合理的，但必须为轻客户端提供一个选项，以使用更少的内存来验证证明。</p>
<p>必须谨慎选择“快速”和“轻”模式所需的内存比例，以免轻模式适合挖矿。特别是，光模式的面积时间（AT）乘积不应小于快速模式的AT乘积。减少 AT 乘积是衡量权衡攻击的常用方法 [ 19 ]。</p>
<p>考虑到前几章中描述的限制，根据经验确定快速和轻型验证模式之间的最大可能性能比为 8。这是因为：</p>
<ol>
<li>进一步增加光验证时间将违反第 1.3 章中规定的限制。</li>
<li>进一步减少快速模式运行时间会违反第 1.1 章中规定的约束，特别是程序生成和结果计算的开销时间会变得太高。</li>
</ol>
<p>此外，256 MiB 被选为轻客户端模式下可能需要的最大内存量。即使对于 Raspberry Pi 这样的小型单板计算机，这个数量也是可以接受的。</p>
<p>为了保持恒定的内存时间乘积，最大的快速模式内存要求是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 * 256 MiB = 2048 MiB</span><br></pre></td></tr></table></figure>

<p>这可以进一步增加，因为光照模式需要额外的芯片面积用于 SuperscalarHash 函数（参见规范的第 3.4 章和第 6 章）。假设保守估计每个 SuperscalarHash 核心0.2 mm 2和 DRAM 密度为 0.149 Gb&#x2F;mm 2 [ 20 ]，额外的内存为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 * 0.2 * 0.149 * 1024 / 8 = 30.5 MiB</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>虚拟机架构<br>本节介绍 RandomX 虚拟机 (VM) 的设计。</li>
</ol>
<p>2.1 指令集<br>RandomX 使用固定长度的指令编码，每条指令有 8 个字节。这允许在指令字中包含 32 位立即数。选择指令字位的解释，以便任何 8 字节字都是有效指令。这允许非常有效的随机程序生成（参见第 1.1.1 章）。</p>
<p>2.1.1 指令复杂度<br>VM 是一个复杂的指令集机器，允许寄存器和内存寻址操作数。然而，每条 RandomX 指令只能转换为 1-7 条 x86 指令（平均 1.8 条）。保持指令复杂度相对较低以最小化具有定制指令集的专用硬件的效率优势非常重要。</p>
<p>2.2 程序<br>VM 执行的程序具有循环的形式，由 256 条随机指令组成。</p>
<ul>
<li>256条指令足够长，可以提供大量可能的程序和足够的分支空间。可以生成的不同程序的数量限制为 2 512 &#x3D; 1.3e+154，这是随机生成器可能的种子值的数量。</li>
<li>256 条指令足够短，因此高性能 CPU 可以在与从 DRAM 中获取数据所需的时间相似的时间内执行一次迭代。这是有利的，因为它允许同步数据集访问并完全可预取（参见第 2.9 章）。</li>
<li>由于程序是一个循环，它可以利用一些 x86 CPU 中存在的 μop 缓存 [ 6 ]。从 μop 缓存运行循环允许 CPU 关闭 x86 指令解码器的电源，这应该有助于平衡 x86 和具有简单指令解码的体系结构之间的功率效率。</li>
</ul>
<p>2.3 寄存器<br>VM 使用 8 个整数寄存器和 12 个浮点寄存器。这是 x86-64 中可以分配为物理寄存器的最大值，这是常见的 64 位 CPU 架构中架构寄存器最少的。使用更多寄存器会使 x86 CPU 处于劣势，因为它们必须使用内存来存储 VM 寄存器内容。</p>
<p>2.4 整数运算<br>RandomX 使用所有具有高输出熵的原始整数运算：加法（IADD_RS、IADD_M）、减法（ISUB_R、ISUB_M、INEG_R）、乘法（IMUL_R、IMUL_M、IMULH_R、IMULH_M、ISMULH_R、ISMULH_M、IMULR_RIXOR） IXOR_M) 和旋转 (IROR_R, IROL_R)。</p>
<p>2.4.1 IADD_RS<br>IADD_RS 指令利用 CPU 的地址计算逻辑，大多数 CPU（x86 lea、arm add）都可以在单个硬件指令中执行。</p>
<p>2.4.2 IMUL_RCP<br>因为整数除法在 CPU 中没有完全流水线化，在 ASIC 中可以做得更快，所以 IMUL_RCP 指令每个程序只需要一个除法来计算倒数。这迫使 ASIC 包含硬件分频器，而不会在程序执行期间给它们带来性能优势。</p>
<p>2.4.3 IROR_R&#x2F;IROL_R<br>旋转指令分为右旋转和左旋转，比例为 4:1。向右旋转具有更高的频率，因为某些架构（如 ARM）本身不支持向左旋转（必须使用向右旋转来模拟）。</p>
<p>2.4.4 ISWAP_R<br>支持寄存器重命名&#x2F;移动消除的 CPU 可以有效地执行此指令。</p>
<p>2.5 浮点运算<br>RandomX 使用双精度浮点运算，大多数 CPU 都支持这种运算，并且需要比单精度更复杂的硬件。所有操作都作为 128 位向量操作执行，所有主要 CPU 架构也支持这种操作。</p>
<p>RandomX 使用 IEEE 754 标准保证的五种运算来提供正确的舍入结果：加法、减法、乘法、除法和平方根。使用标准定义的所有 4 种舍入模式。</p>
<p>2.5.1 浮点寄存器组<br>浮点运算的域分为使用寄存器组 F 的“加法”运算和使用寄存器组 E 的“乘法”运算。这样做是为了防止加法&#x2F;减法在添加少量数字时变为空操作到大量。由于 F 组寄存器的范围限制在 左右±3.0e+14，因此对绝对值大于 1 的浮点数进行加减运算总是至少改变 5 个小数位。</p>
<p>由于 F 组寄存器的有限范围将允许使用更有效的定点表示（80 位数字），因此 FSCAL 指令操纵浮点格式的二进制表示，使这种优化更加困难。</p>
<p>E 组寄存器限制为正值，以避免出现NaN结果（例如负数的平方根或0 * ∞）。除法仅使用内存源操作数，以避免被优化为常数倒数的乘法。E组内存操作数的指数设置为-255和0之间的值，以避免除以0和乘以0并增加可以获得的数字范围。可能基团E的寄存器值的近似范围为1.7E-77至infinity。</p>
<p>每个程序循环结束时浮点寄存器值的近似分布如下图所示（左 - F组，右 - E组）：</p>
<p><img src="https://i.imgur.com/64G4qE8.png" alt="Imgur" loading="lazy"></p>
<p>1e+14FSCAL 指令导致的 F 寄存器值较少，显着增加了寄存器值的范围。</p>
<p>E 组寄存器涵盖了非常大的值范围。大约 2% 的程序至少产生一个infinity值。</p>
<p>为了最大化熵并适应一个 64 字节的高速缓存线，浮点寄存器在每次迭代结束时使用 XOR 运算进行组合，然后存储到暂存器中。</p>
<p><em>（注意：bins 由区间的左侧值标记，例如标记为 <code>1e-40</code> 的 bin 包含从 <code>1e-40</code> 到 <code>1e-20</code> 的值。）</em></p>
<p><code>1e+14</code> 处的 F 寄存器值较少是由 FSCAL 指令引起的，该指令显着增加了寄存器值的范围。</p>
<p>E 组寄存器涵盖了非常大的值范围。 大约 2% 的程序产生至少一个“无穷大”值。</p>
<p>为了最大化熵并适应一个 64 字节的高速缓存线，浮点寄存器在每次迭代结束时使用 XOR 操作进行组合，然后存储到暂存器中。</p>
<h3 id="2-6-分支"><a href="#2-6-分支" class="headerlink" title="2.6 分支"></a>2.6 分支</h3><p>现代 CPU 投入大量芯片面积和精力来处理分支。这包括：</p>
<ul>
<li>分支预测器单元 <a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="noopener">Branch predictor</a></li>
<li>检查点&#x2F;回滚状态，允许 CPU 在分支预测错误的情况下恢复。</li>
</ul>
<p>为了利用推测设计，随机程序应该包含分支。但是，如果分支预测失败，则推测执行的指令将被丢弃，这导致每次错误预测都会浪费一定的能量。因此，我们的目标应该是尽量减少错误预测的数量。</p>
<p>此外，代码中的分支是必不可少的，因为它们显着减少了可以进行的静态优化的数量。例如，考虑以下 x86 指令序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ...</span><br><span class="line">branch_target_00:</span><br><span class="line">    ...</span><br><span class="line">    xor r8, r9</span><br><span class="line">    test r10, 2088960</span><br><span class="line">    je branch_target_00</span><br><span class="line">    xor r8, r9</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>XOR 操作通常会取消，但由于分支而无法优化掉，因为如果采用分支，结果会有所不同。类似地，如果不是用于分支，ISWAP_R 指令可以始终被静态优化。</p>
<p>一般来说，随机分支必须以这样的方式设计：</p>
<ol>
<li>无限循环是不可能的。</li>
<li>预测错误的分支数量少。</li>
<li>分支条件取决于运行时值以禁用静态分支优化。</li>
</ol>
<h4 id="2-6-1-分支预测"><a href="#2-6-1-分支预测" class="headerlink" title="2.6.1 分支预测"></a>2.6.1 分支预测</h4><p>不幸的是，我们还没有找到如何在 RandomX 中利用分支预测的方法。因为 RandomX 是一个共识协议，所以所有的规则都必须提前制定，包括分支规则。完全可预测的分支不能依赖于任何 VM 寄存器的运行时值（因为寄存器值是伪随机且不可预测的），因此它们必须是静态的，因此可以通过专用硬件轻松优化。</p>
<h4 id="2-6-2-CBRANCH-指令"><a href="#2-6-2-CBRANCH-指令" class="headerlink" title="2.6.2 CBRANCH 指令"></a>2.6.2 CBRANCH 指令</h4><p>因此，RandomX 使用跳跃概率为 1&#x2F;256 的随机分支和依赖于整数寄存器值的分支条件。这些分支将被 CPU 预测为“未采用”。这些分支在大多数 CPU 设计中是“免费的”，除非它们被采用。虽然这没有利用分支预测器，但与非推测分支处理相比，推测设计将显着提高性能 - 有关更多信息，请参阅附录 B。</p>
<p>分支条件和跳转目标的选择方式使得 RandomX 代码中的无限循环是不可能的，因为控制分支的寄存器永远不会在重复代码块中被修改。每条 CBRANCH 指令最多可以连续跳转两次。使用谓词执行 [<a href="https://en.wikipedia.org/wiki/Predication_(computer_architecture)" target="_blank" rel="noopener">22</a>] 处理 CBRANCH 是不切实际的，因为大部分时间都不采用分支。</p>
<h3 id="2-7-指令级并行"><a href="#2-7-指令级并行" class="headerlink" title="2.7 指令级并行"></a>2.7 指令级并行</h3><p>CPU 使用几种利用执行代码的指令级并行性的技术来提高其性能。这些技术包括：</p>
<ul>
<li>拥有多个可以并行执行操作的执行单元（<em>超标量执行</em>）。</li>
<li>执行指令不是按照程序顺序，而是按照操作数可用性的顺序（<em>乱序执行</em>）。</li>
<li>预测分支将采用哪种方式来增强超标量和无序执行的好处。</li>
</ul>
<p>RandomX 受益于所有这些优化。详细分析见附录 B。</p>
<h3 id="2-8-Scratchpad"><a href="#2-8-Scratchpad" class="headerlink" title="2.8 Scratchpad"></a>2.8 Scratchpad</h3><p>Scratchpad 用作读写存储器。它的大小被选择为完全适合 CPU 缓存。</p>
<h4 id="2-8-1-Scratchpad-级别"><a href="#2-8-1-Scratchpad-级别" class="headerlink" title="2.8.1 Scratchpad 级别"></a>2.8.1 Scratchpad 级别</h4><p>Scratchpad 分为 3 个级别以模仿典型的 CPU 缓存层次结构 <a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">CPU_cache</a>。大多数 VM 指令访问“L1”和“L2”暂存器，因为 L1 和 L2 CPU 缓存位于靠近 CPU 执行单元的位置，并提供最佳的随机访问延迟。从 L1 和 L2 读取的比率为 3:1，这与典型延迟的反比相匹配（见下表）。</p>
<table>
<thead>
<tr>
<th>CPU μ 架构</th>
<th>L1 延迟</th>
<th>L2 延迟</th>
<th>L3 延迟</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>ARM Cortex A55</td>
<td>2</td>
<td>6</td>
<td>-</td>
<td>[<a href="https://www.anandtech.com/show/11441/dynamiq-and-arms-new-cpus-cortex-a75-a55/4" target="_blank" rel="noopener">src</a>]</td>
</tr>
<tr>
<td>AMD Zen+</td>
<td>4</td>
<td>12</td>
<td>40</td>
<td>[<a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen%2B#Memory_Hierarchy" target="_blank" rel="noopener">src</a>]</td>
</tr>
<tr>
<td>Intel Skylake</td>
<td>4</td>
<td>12</td>
<td>42</td>
<td>[<a href="https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)#Memory_Hierarchy" target="_blank" rel="noopener">src</a>]</td>
</tr>
</tbody></table>
<p>L3 缓存要大得多，并且离 CPU 内核更远。因此，它的访问延迟要高得多，并可能导致程序执行停顿。</p>
<p>因此，RandomX 每次程序迭代仅对“L3”Scratchpad 执行 2 次随机访问（规范第 4.6.2 章中的第 2 步和第 3 步）。来自给定迭代的寄存器值被写入它们从中加载的相同位置，这保证了所需的缓存线已移动到更快的 L1 或 L2 缓存中。</p>
<p>此外，从固定地址读取的整数指令也使用整个“L3”暂存器（规范的表 5.1.4），因为重复访问将确保缓存线将放置在 CPU 的 L1 缓存中。这表明 Scratchpad 级别并不总是直接对应于相同的 CPU 缓存级别。</p>
<h3 id="2-9-数据集"><a href="#2-9-数据集" class="headerlink" title="2.9 数据集"></a>2.9 数据集</h3><p>由于 Scratchpad 通常存储在 CPU 缓存中，因此只有数据集访问使用内存控制器。</p>
<p>RandomX 每次程序迭代从数据集随机读取一次（每个哈希结果 16384 次）。由于数据集必须存储在 DRAM 中，因此它提供了一个自然的并行化限制，因为 DRAM 每个存储体组每秒不能进行超过约 2500 万次随机访问。每个可单独寻址的银行组允许大约 1500 H&#x2F;s 的吞吐量。</p>
<p>所有数据集访问读取一个 CPU 缓存行（64 字节）并完全预取。执行规范第 4.6.2 章中描述的一个程序迭代的时间与典型的 DRAM 访问延迟（50-100 ns）大致相同。</p>
<h4 id="2-9-1-缓存"><a href="#2-9-1-缓存" class="headerlink" title="2.9.1 缓存"></a>2.9.1 缓存</h4><p>用于光照验证和Dataset构建的Cache，比Dataset小8倍左右。为了保持恒定的区域时间乘积，每个数据集项都由 8 次随机缓存访问构成。</p>
<p>由于 256 MiB 足够小，可以包含在芯片上，RandomX 使用自定义的高延迟、高功率混合函数（“SuperscalarHash”），这抵消了使用低延迟内存的好处，并且计算 SuperscalarHash 所需的能量变得轻巧模式非常低效的挖矿（见第 3.4 章）。</p>
<p>由于使用了具有 3 次迭代的抗折衷 Argon2d，因此不可能使用少于 256 MiB 的内存。当使用 3 次迭代（passes）时，将内存使用量减半会使最佳权衡攻击的计算成本增加 3423 倍 <a href="https://eprint.iacr.org/2015/430.pdf" target="_blank" rel="noopener">Fast and Tradeoff-Resilient Memory-Hard Functions for Cryptocurrencies and Password Hashing</a></p>
<h4 id="2-8-2-Scratchpad-写入"><a href="#2-8-2-Scratchpad-写入" class="headerlink" title="2.8.2 Scratchpad 写入"></a>2.8.2 Scratchpad 写入</h4><p>在 VM 执行期间，有两种方式修改 Scratchpad：</p>
<ol>
<li>在每次程序迭代结束时，所有寄存器值都写入“L3”暂存器（参见规范章节 4.6.2，步骤 9 和 11）。这在两个 64 字节的块中每次迭代总共写入 128 字节。</li>
<li>ISTORE 指令执行显式存储。每个程序平均有 16 个商店，其中 2 个商店进入“L3”级别。每个 ISTORE 指令写入 8 个字节。</li>
</ol>
<p>下图显示了写入暂存器的分布示例。图像中的每个像素代表 Scratchpad 的 8 个字节。红色像素代表在散列计算期间至少被覆盖一次的便签本部分。 “L1”和“L2”级别位于左侧（几乎完全覆盖）。暂存器的右侧代表底部 1792 KiB。其中只有大约 66% 被覆盖，但写入是均匀随机分布的。</p>
<p><img src="https://i.imgur.com/pRz6aBG.png" alt="Imgur" loading="lazy"></p>
<p>有关 Scratchpad 熵的分析，请参见附录 D。</p>
<h4 id="2-8-3-读写比例"><a href="#2-8-3-读写比例" class="headerlink" title="2.8.3 读写比例"></a>2.8.3 读写比例</h4><p>程序每次程序迭代平均对便笺簿进行 39 次读取（指令 IADD_M、ISUB_M、IMUL_M、IMULH_M、ISMULH_M、IXOR_M、FADD_M、FSUB_M、FDIV_M）和 16 次写入（指令 ISTORE）。额外的 128 个字节被隐式读取和写入以初始化和存储寄存器值。每次迭代从 Dataset 中读取 64 字节的数据。总共：</p>
<ul>
<li>每次程序迭代从内存读取的平均数据量为：39 * 8 + 128 + 64 &#x3D; <strong>504 字节</strong>。</li>
<li>每次程序迭代写入内存的平均数据量为：16 * 8 + 128 &#x3D; <strong>256 字节</strong>。</li>
</ul>
<p>这接近于 2:1 的读&#x2F;写比，这是 CPU 优化的。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
  </entry>
  <entry>
    <title>regenerate cgo definitions: vscode里gopls对cgo的新支持</title>
    <url>/post/regenerate-cgo-definitions/</url>
    <content><![CDATA[<p>因为之前都是让IDE&#x2F;VScode(goreturns)自动处理的import，所以今天在用vscode重新format的时候才看到，在<code>import &quot;C&quot;</code>的上面有个可以点的<code>regenerate cgo definitions</code>按钮。</p>
<p>这里就根据这个<a href="https://github.com/golang/go/issues/35721" target="_blank" rel="noopener">github issue</a>来阐述一下这个按钮是干啥的，该怎么用。答案是根据<a href="https://www.reddit.com/r/vscode/comments/hjphbz/what_is_the_purpose_of_regenerate_cgo_definitions/" target="_blank" rel="noopener">reddit上这个帖子的回复</a>找到的</p>
<span id="more"></span>

<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>使用了<code>import &quot;C&quot;</code>的源代码文件不是真正有效的Go。它们在严重依赖于go tool在构建软件包时所产生的额外信息。尽管可以通过设置<a href="https://golang.org/pkg/go/types/#Config" target="_blank" rel="noopener">types.Config.FakeImportC flag</a>来解决这些问题，可以对它们进行解析，但不能进行类型检查。</p>
<p>许多人建议gopls使用包中的GoFiles而不是其CompiledGoFiles。<br>GoFiles是原始的（即无效的）文件。使用它们可能会给编辑包的人带来更好的体验，但是由于包将不再进行类型检查，因此它将完全破坏依赖于类型信息的所有内容。在当前架构中进行更改之前，我们必须非常仔细地评估效果。</p>
<p>我们可以考虑两次检查cgo软件包的类型，一次使用实际代码，一次使用用户的代码。那将会是一个重大的架构变化。</p>
<p>或者，我们可以在<code>.go</code>文件更改时运行cgo工具，以生成实际代码。这是一种更加可靠的方法，但是运行cgo处理的成本可能太高，尤其是在大型的包上。</p>
<p>无论如何，这是一个大项目，需要大量的测试和思考。我们不太可能很快在这里做出巨大的改进。</p>
<h2 id="Beta测试指令"><a href="#Beta测试指令" class="headerlink" title="Beta测试指令"></a>Beta测试指令</h2><p>这是当前的状态：如果您使用tip Go（即gotip安装的golang, gotip是从开发分支上编译并运行go的命令）在master分支上构建gopls，那么您应该具有很好的cgo创作经验。<br>据我所知有一个bug在自动代码补全上，它会提供_cgo_foo之类的符号，而不是正确的C.foo。</p>
<p>不过，有一个障碍是，除非您告知，否则它不会重新生成cgo绑定。<br>为此，在使用cgo的文件中，在<code>import &quot;C&quot;</code>行的顶部应该有一个<code>regenerate cgo</code>的按钮。<br>当您引用C中的新标识符时，或使用影响Go可以看到的符号的方式更改魔术注释时，将需要使用它。</p>
<p>要进行设置，请按照以下说明进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go get golang.org/dl/gotip</span><br><span class="line">$ gotip download # 安装开发版golang</span><br><span class="line">[...]</span><br><span class="line">Success. You may now run &#x27;gotip&#x27;!</span><br><span class="line">$ cd /</span><br><span class="line">$ GO111MODULE=on gotip get golang.org/x/tools/gopls@master</span><br><span class="line">$ gotip version</span><br><span class="line">... devel +f7f9c8f ...</span><br><span class="line">$ gotip version $(which gopls)</span><br><span class="line">... devel +f7f9c8f ...</span><br></pre></td></tr></table></figure>

<p>您无需使用tip Go即可在自己的项目上工作，仅需用其构建gopls。（这是2020.05.01的更新，现在2020.10.24估计是不用了）</p>
<h2 id="说人话"><a href="#说人话" class="headerlink" title="说人话"></a>说人话</h2><p>就是，go自己读不懂cgo，要靠别的工具。但是别的工具一直调用会很浪费资源，那就让大家通过按钮手动让go通过工具读cgo。</p>
<p>但是看起来bug还是挺多的，所以issue也没close</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>vscode</tag>
        <tag>cgo</tag>
        <tag>gopls</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>rfc6979: ECDSA和DSA的确定性用法</title>
    <url>/post/rfc6979/</url>
    <content><![CDATA[<p>本文档定义了确定性数字签名生成程序。<br>此类签名与标准数字签名算法 (DSA) 和椭圆曲线数字签名算法 (ECDSA) 数字签名兼容，并且可以使用未经修改的验证器进行处理，无需了解其中描述的过程。<br>确定性签名保留了与数字签名相关的加密安全功能，但可以更轻松地在各种环境中实现，因为它们不需要访问高质量的随机源。</p>
<p>DSA [FIPS-186-4] 和 ECDSA [X9.62] 是两种标准的数字签名方案。 它们在各种协议中提供数据完整性和可验证的真实性。</p>
<p>DSA 和 ECDSA 的一个特点是它们需要为每个签名生成生成一个新的随机值（以下称为 k）。 为了有效的安全性，必须使用加密安全过程从一组模整数中随机且一致地选择 k。 在这个过程中即使是轻微的偏斜也可能变成对签名方案的攻击。</p>
<p>对加密安全随机源的需求已被公认是在某些架构中部署 DSA 和 ECDSA 签名方案的障碍，其中安全随机数生成具有挑战性，特别是嵌入式系统，如智能卡。 在这些系统中，RSA 签名算法，如公钥密码标准 (PKCS) #1 [RFC3447]（使用“类型 1”填充，而不是概率签名方案 (PSS)）和 ISO 9796-2 [ISO-9796-2]，通常是首选，即使它在计算上更昂贵，因为 RSA（具有此类填充方案）是确定性的，因此不需要随机源。</p>
<p>DSA 和 ECDSA 的随机特性也使得实现更难测试。自动化测试无法可靠地检测实现是否使用了足够高质量的随机源。 这使得实施过程更容易受到灾难性故障的影响，通常在系统部署并成功攻击后发现。</p>
<p>通过使用确定性过程生成“随机”值 k，可以将 DSA 和 ECDSA 转化为确定性方案。 该过程必须满足一些密码学特征，以保持签名方案所期望的可验证性和不可伪造性； 即，对于不知道签名私钥的人，从输入消息到相应 k 值的映射必须在计算上与随机且统一选择的函数（从消息集到可能的 k 值集）将返回的内容没有区别。</p>
<p>本文档描述了这样一个过程。 它具有以下特点：</p>
<ul>
<li>生成的签名与普通 DSA 和 ECDSA 保持完全兼容。 验证签名的实体不需要更改，甚至不需要知道用于生成 k 的过程。</li>
<li>密钥对生成没有改变。 现有的私钥可以与确定性 DSA 和 ECDSA 一起使用。</li>
<li>使用确定性 DSA 和 ECDSA 意味着没有任何秘密或公共价值的额外存储要求。</li>
<li>确定性 DSA 和 ECDSA 可以应用于与普通 DSA 和 ECDSA 相同的输入，即对要签名的消息计算的哈希值，具有加密安全的哈希函数。</li>
</ul>
<p>在本文档中指定的确定性 (EC)DSA 的定义中采取了一些相对随意的选择。<br>这样做是为了使其尽可能普遍适用，从而最大限度地提高包含的测试向量的有用性。 有关一些可能的变体的讨论，请参见第 3.6 节。</p>
<p>需要注意的是，密钥对的生成仍然需要一个随机源。<br>在随机性存在问题的嵌入式系统中，通常可以安排在更可控的条件下生成密钥对（例如，在特殊的智能卡初始化过程中或在宣誓代理的物理控制下）；<br>或者甚至可以在其他地方生成密钥并导入到设备中。<br>确定性 DSA 和 ECDSA 仅处理签名生成时对随机性的需求。</p>
<p>1.1. 需求语言</p>
<p>本文档中的关键词“必须”、“不得”、“需要”、“应该”、“不应”、“应该”、“不应该”、“推荐”、“可以”和“可选”是 按照 RFC 2119 [RFC2119] 中的描述进行解释。</p>
<ol start="2">
<li>DSA 和 ECDSA 符号</li>
</ol>
<p>在本节中，我们将简要描述 DSA 和 ECDSA 并定义我们的符号。 DSA 和 ECDSA 的完整规范可以分别在 [FIPS-186-4] 和 [X9.62] 中找到。</p>
<p>2.1. 关键参数</p>
<p>DSA 和 ECDSA 工作在一个大的素数范围上，其中群运算很容易计算，但是离散对数在现有和可预见的技术下在计算上是不可行的。 组的定义称为“关键参数”。 密钥参数可以在不同的密钥对之间共享，不会对安全产生不良影响； 这尤其是 ECDSA 的常见情况。</p>
<p>DSA 使用以下关键参数：</p>
<ul>
<li><strong>p</strong>：一个大素数（至少 1024 位）</li>
<li><strong>q</strong>：一个足够大的质数（至少 160 位），它也是 p-1 的除数</li>
<li><strong>g</strong>： 整数模 p 的 q 阶乘法子群的生成器</li>
</ul>
<p>计算 DSA 的组由值 ‘g^j mod p’ 组成，其中 ‘^’ 表示求幂，j 的范围从 0 到 q-1（含）。组的大小是 q。</p>
<p>ECDSA 使用以下关键参数：</p>
<ul>
<li><strong>E</strong> 椭圆曲线，定义在给定的有限域上</li>
<li><strong>q</strong> 一个足够大的素数（至少 160 位），它是曲线阶数的除数</li>
<li><strong>G</strong>：点 E的 q 阶乘</li>
</ul>
<p>将计算 ECDSA 的组由曲线点 jG（点 G 乘以整数 j）组成，其中 j 的范围从 0 到 q-1。 G 使得 qG &#x3D; 0（曲线 E 上的“无穷远点”）。<br>组的大小是 q。请注意，这些符号与 [X9.62] 中描述的符号略有不同；<br>我们使用它们是为了匹配用于 DSA 的那些。</p>
<p>2.2. 密钥对</p>
<p>DSA 或 ECDSA 私钥是一个整数 x 取模 q。 相关标准规定x不得为0； 因此，x 是 [1, q-1] 范围内的整数。</p>
<p>DSA 或 ECDSA 公钥由私钥 x 和密钥参数计算得出：</p>
<ul>
<li>对于 DSA，公钥是整数：y &#x3D; g^x mod p</li>
<li>对于 ECDSA，公钥是曲线点：U &#x3D; xG</li>
</ul>
<p>2.3. 整数转换</p>
<p>设 qlen 为 q 的二进制长度。 qlen 是使 q 小于 2^qlen 的最小整数。 这是没有符号位的 q 的二进制表示的大小（请注意，q 是一个大素数，是奇数，因此避免了关于任何等于 2 的幂的整数的长度的任何歧义）。 我们定义了五个转换函数，它们处理位串、八位组和整数模 q。 qlen 是这些转换的主要参数。</p>
<p>在以下小节中，我们使用另外两个长度，称为 blen 和 rlen。 rlen 等于 qlen，四舍五入到下一个 8 的倍数（如果 qlen 已经是 8 的倍数，则 rlen 等于 qlen；否则，rlen 稍大，最多为 qlen+7）。 请注意，rlen 与值 r（生成的签名的前半部分）无关。 blen 是输入位序列的长度（以位为单位），可能因调用而异。 blen 可能小于、等于或大于 qlen。</p>
<p>2.3.1. 二进制位和八进制位</p>
<p>形式上，所有操作都定义在位序列上。 一个序列是有序的； 第一位是最左边的，而最后一位是最右边的。</p>
<p>在大多数软件系统上，（每8个）位被编排分组为八进制位（八位序列）。<br>二进制数据，例如散列函数的输出，可用作八位字节序列。 在适用的情况下，我们认为八位字节中的位按从最重要到最不重要的顺序排列：八位字节中的第一个（最左侧）位的数值为 128，而最后一个（最右侧）的数值为 1。</p>
]]></content>
  </entry>
  <entry>
    <title>消息的签名与验证 —— 证明BTC地址的所有权</title>
    <url>/post/sign-and-verify-messages/</url>
    <content><![CDATA[<p>译：众所周知，本人现在正在开发一个新型的区块链架构NGIN。最近看到Schnorr签名算法很热门就在NG上部署了。但是部署完之后就陷入了更深层的思考——如何更好的利用Schnorr的MultiSig（多重签名）机制？现在我构思将Account也转为利用Schnorr来判定所有权。但是发现如此设计的话Account结构中不包含PublicKey，将很难通过anonymous表来搜索账户余额。故希望从本文中获得启发。</p>
<p><a href="https://bitcointalk.org/index.php?topic=4382780.0" target="_blank" rel="noopener">原文地址</a></p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>许多人在问，如何证明或声明属于某个公共地址的比特币的所有权？</p>
<p>假设，您叫A，并且想与B做生意。B告诉你，他的公开地址是19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC，而他在2015年10月15日余额恰好是2.04531538BTC。通过怎样，B可以毫无疑问地证明他确实拥有这个地址，让A能绝对信任？</p>
<p>在这个简短的教程中，我们将向您展示如何使用我们最喜欢的钱包Electrum完成所有这些工作。您根本不需要任何编程技能，但是您应该熟悉私钥和公钥的概念，并且至少应牢记不要与任何人共享私钥或以任何形式在线发送私钥的重要性。</p>
<p>其中的所有私钥和公钥都是出于教育目的，切勿使用——否则余额将立马被抢走。</p>
<h2 id="区块链还不够-——-屏幕截图还不够"><a href="#区块链还不够-——-屏幕截图还不够" class="headerlink" title="区块链还不够 —— 屏幕截图还不够"></a>区块链还不够 —— 屏幕截图还不够</h2><p>B向A发送了<a href="https://blockchain.info/address/19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC" target="_blank" rel="noopener">这个交易</a>到区块链。</p>
<p>当然，那里有公共地址，金额和日期。但是不久，A意识到A可以选择区块链上的任何随机地址，并将其作为“证明”发送给她。</p>
<p>A请B提供更好的证据，然后B用他的钱包的两个屏幕截图回复：</p>
<p>（图略，建议都用ascii图，不然图床真不靠谱）</p>
<p>好吧，所以看起来B好像在说实话。但是！图像很容易被操纵。B可以使用Photoshop来创建这些图像。</p>
<p>因此，A仍然没有被说服，A也不可能被这样说服。A需要确切的证据。最好的部分是A可以拥有的！</p>
<h2 id="消息的签名与验证-——-完美的证明"><a href="#消息的签名与验证-——-完美的证明" class="headerlink" title="消息的签名与验证 —— 完美的证明"></a>消息的签名与验证 —— 完美的证明</h2><p>比特币地址由一个私钥（您应该始终保持私有）和一个公钥组成，该公钥与您的公网地址相同。这是最重要的部分：密钥对可用于对消息进行签名。甚至不涉及区块链。</p>
<p>如果B真正拥有他声称的公共地址，那么他也拥有其私钥。它可以用来签名消息。</p>
<p>在这个例子中，B确实拥有他声称的比特币地址。具体来说，他的证据是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Private key: 5KSFWJRuCuTFFsPQgokmLuKbY84f8e9pcWaJX2C7r8jsLi2RuJF</span><br><span class="line">Public key: 19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC</span><br></pre></td></tr></table></figure>

<p>A现在意识到，如果B是诚实的，他可以访问他的密钥对，从而能够为珍妮签名消息。</p>
<p>现在，A要求B使用他的密钥对签署特定的消息。简希望约翰用他的公钥（即他的比特币地址）来签署“我拥有这个地址，A！”这个消息。</p>
<p>这可以在Electrum中快速完成。 John只是将他的私钥导入一个新的钱包，选择“工具&#x2F;签名&#x2F;验证”消息，然后…钱包吐出以下代码…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I own this address, Jane!</span><br><span class="line"></span><br><span class="line">19Ho6eA4hBtb7hkN1S6GdmHD611Egd7gtC</span><br><span class="line"></span><br><span class="line">GxHVqiSW+WxEA+IlNB5oqDpzLba7MJxYJl5Gr3ijm1SQYb9xEukrvnoXPbfi1k+wa54k0F/0tQ0hdsEjw1paa5w=</span><br></pre></td></tr></table></figure>

<p>…他寄给A。特别要注意的是，如果没有他的私钥，他将无法签署此消息。更重要的是，A从未将自己的私钥发送给简。</p>
<p>A现在可以在自己的计算机上使用Electrum。A完全不需要导入任何特定的钱包详细信息，现在可以使用相同的功能并粘贴自己的EXACT消息，B的比特币地址，签名的代码，然后按“验证”。 她得到…（图略，反正就是ok了）</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>任务完成！A现在可以100％确信B拥有他声称拥有的地址。B毫无疑问地证明了他控制着他所说的比特币地址。</p>
<p><strong>如果您正在考虑与不确定的人打交道，只需要求他们为您签名。这真的很容易，它使整个加密生态系统变得更加安全和可信。双赢！</strong></p>
<h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>妈的感觉白翻译了等于啥也没讲。都是超基础的……</p>
<p>也不知道哪里能找到，干脆就自己写吧。</p>
<p>就是说，BTC的地址是个公钥——这句话是不那么正确的，BTC地址是个hash后的公钥。换句话说，第三方没法通过你的地址得到你的公钥。</p>
<p>之前看到一个ETH的攻击，就是通过signature之后的R和S得到ETH的account地址，然后再结合别的R，S来降低爆破privateKey的难度（原文找不到了）。</p>
<p>恢复PublicKey的如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ECDSA public key recovery from signature</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Buffer</span>&#125; <span class="variable">msgHash</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">v</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Buffer</span>&#125; <span class="variable">r</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Buffer</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Buffer</span>&#125; <span class="variable">publicKey</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">ecrecover</span> = <span class="keyword">function</span> (<span class="params">msgHash, v, r, s</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> signature = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="built_in">exports</span>.<span class="title function_">setLength</span>(r, <span class="number">32</span>), <span class="built_in">exports</span>.<span class="title function_">setLength</span>(s, <span class="number">32</span>)], <span class="number">64</span>)</span><br><span class="line">  <span class="keyword">var</span> recovery = v - <span class="number">27</span></span><br><span class="line">  <span class="keyword">if</span> (recovery !== <span class="number">0</span> &amp;&amp; recovery !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid signature v value&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> senderPubKey = secp256k1.<span class="title function_">recover</span>(msgHash, signature, recovery)</span><br><span class="line">  <span class="keyword">return</span> secp256k1.<span class="title function_">publicKeyConvert</span>(senderPubKey, <span class="literal">false</span>).<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而BTC的<a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address" target="_blank" rel="noopener">PK-&gt;Addr转换方式</a>又是sha256又是ripemd160能recover个鬼……</p>
<p>这我就很好奇了，没PublicKey咋鉴权？</p>
<p>本来是打算btcd里看的，不过没立即找到。后来还是搜到<a href="https://github.com/nanotube/supybot-bitcoin-marketmonitor/blob/master/GPG/local/bitcoinsig.py" target="_blank" rel="noopener">别的实现</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_message</span>(<span class="params">address, signature, message</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; See http://www.secg.org/download/aid-780/sec1-v2.pdf for the math &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> ecdsa <span class="keyword">import</span> numbertheory, ellipticcurve, util</span><br><span class="line">    curve = curve_secp256k1</span><br><span class="line">    G = generator_secp256k1</span><br><span class="line">    order = G.order()</span><br><span class="line">    <span class="comment"># extract r,s from signature</span></span><br><span class="line">    sig = base64.b64decode(signature)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sig) != <span class="number">65</span>: <span class="keyword">raise</span> BaseException(<span class="string">&quot;Wrong encoding&quot;</span>)</span><br><span class="line">    r,s = util.sigdecode_string(sig[<span class="number">1</span>:], order)</span><br><span class="line">    nV = <span class="built_in">ord</span>(sig[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> nV &lt; <span class="number">27</span> <span class="keyword">or</span> nV &gt;= <span class="number">35</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> nV &gt;= <span class="number">31</span>:</span><br><span class="line">        compressed = <span class="literal">True</span></span><br><span class="line">        nV -= <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        compressed = <span class="literal">False</span></span><br><span class="line">    recid = nV - <span class="number">27</span></span><br><span class="line">    <span class="comment"># 1.1</span></span><br><span class="line">    x = r + (recid/<span class="number">2</span>) * order</span><br><span class="line">    <span class="comment"># 1.3</span></span><br><span class="line">    alpha = ( x * x * x  + curve.a() * x + curve.b() ) % curve.p()</span><br><span class="line">    beta = modular_sqrt(alpha, curve.p())</span><br><span class="line">    y = beta <span class="keyword">if</span> (beta - recid) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> curve.p() - beta</span><br><span class="line">    <span class="comment"># 1.4 the constructor checks that nR is at infinity</span></span><br><span class="line">    R = ellipticcurve.Point(curve, x, y, order)</span><br><span class="line">    <span class="comment"># 1.5 compute e from message:</span></span><br><span class="line">    h = Hash( msg_magic( message ) )</span><br><span class="line">    e = string_to_number(h)</span><br><span class="line">    minus_e = -e % order</span><br><span class="line">    <span class="comment"># 1.6 compute Q = r^-1 (sR - eG)</span></span><br><span class="line">    inv_r = numbertheory.inverse_mod(r,order)</span><br><span class="line">    Q = inv_r * ( s * R + minus_e * G )</span><br><span class="line">    public_key = ecdsa.VerifyingKey.from_public_point( Q, curve = SECP256k1 )</span><br><span class="line">    <span class="comment"># check that Q is the public key</span></span><br><span class="line">    public_key.verify_digest( sig[<span class="number">1</span>:], h, sigdecode = ecdsa.util.sigdecode_string)</span><br><span class="line">    <span class="comment"># check that we get the original signing address</span></span><br><span class="line">    addr = public_key_to_bc_address(encode_point(public_key, compressed))</span><br><span class="line">    <span class="keyword">if</span> address == addr:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#print addr</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这tm就很nb了，居然还真又是反推PublicKey的。</p>
<p>对应的是dcrd（一个btcd的fork）的<a href="https://github.com/decred/dcrd/blob/master/dcrec/secp256k1/ecdsa/signature.go#L746" target="_blank" rel="noopener">这部分</a></p>
<p>那么NGIN里的multi-own的设计就有点难了【本来还以为有什么黑科技</p>
<p>现在难点在于，用Account里增加Sign来实现了multi-own之后，怎么实现去publickey情况下的address?</p>
<p>一种办法是把balance写进Account里，这样的话anonymous表里的balance该怎么办？无Account的矿工或者买家该怎么办？</p>
<p>另一种办法是看看Schnorr能不能生成一个可以MultiSig的PublicKey。</p>
<p>还有种办法就是放弃这个特性。</p>
<p>看了下go-schnorr对聚合签名鉴权的确是用的一个新的PublicKey，索性就把这个拿来当address。也用不着放弃了。</p>
]]></content>
      <tags>
        <tag>bitcointalk</tag>
        <tag>done</tag>
        <tag>翻译</tag>
        <tag>ecdsa</tag>
        <tag>address</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程道德规范和专业实践 Software Engineering Code of Ethics and Professional Practice</title>
    <url>/post/software-engineering-code-of-ethics/</url>
    <content><![CDATA[<p><a href="https://ethics.acm.org/code-of-ethics/software-engineering-code/" target="_blank" rel="noopener">原文：Software Engineering Code of Ethics and Professional Practice (Version 5.2)</a>,<br><a href="https://ethics.acm.org/wp-content/uploads/2016/07/SEERI.chinese.code_.one_.column.pdf" target="_blank" rel="noopener">官方中文</a></p>
<p>FIT51365看起来很喜欢这个，实际考试里即便是已经出了同一Week里IP（知识版权&#x2F;专利）的考题也还是要再出一题考这个。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>计算机</strong>在商业，工业，政府，医学，教育，娱乐和整个社会中都发挥着中心作用，并且在不断增长。<strong>软件工程师</strong>是指通过直接参与或通过教学对软件系统的分析，规范，设计，开发，认证，维护和测试做出贡献的人员。由于软件工程师在开发软件系统中的作用，他们有很多机会去做善事或造成伤害，使他人能够做善事或造成伤害，或者影响他人做善事或造成伤害。为了尽可能地确保他们的努力会得到良好利用，软件工程师必须致力于使软件工程成为一个有益而受人尊敬的职业。根据该承诺，软件工程师应遵守以下《道德与专业准则》。</p>
<p>该规范包含与专业软件工程师的行为和决策有关的八项原则，包括从业人员，教育者，管理人员，主管和政策制定者以及该行业的学员和学生。本原则确定了个人，团体和组织参与的具有道德责任感的关系，以及这些关系中的主要义务。每个原则的条款都是这些关系中包含的某些义务的说明。这些义务建立在软件工程师的人性基础上，对受到软件工程师的工作影响的人们以及软件工程实践的独特要素应给予特别的照顾。 《准则》将这些规定为任何自称或希望成为软件工程师的人的义务。</p>
<p>并非有意将本规范的各个部分孤立使用，仅为疏忽或委托的错误辩护。原则和条款清单并不详尽。在所有实际情况下，本条款均不应理解为将专业行为中的可接受与不可接受分隔开来。 《准则》不是产生道德决策的简单道德算法。在某些情况下，标准之间可能会相互冲突，也可能与其他来源的标准存在冲突。这些情况要求软件工程师在特定情况下使用道德判断以最符合《道德与专业准则》精神的方式行事。</p>
<p>最好通过对基本原则的认真考虑来解决伦理紧张局势，而不是盲目地依赖详细的法规。这些原则应影响软件工程师，以广泛考虑谁受其工作影响；检查他们和他们的同事是否在适当尊重他人的情况下对待他们；考虑在合理了解情况的情况下，公众如何看待他们的决定；分析最无权的人将如何受到他们的决定的影响；并考虑是否认为他们的行为值得担任软件工程师的理想专业人员。在所有这些判断中，对公众健康，安全和福利的关注是首要的；也就是说，“公共利益”是本《准则》的核心。</p>
<p>动态而苛刻的软件工程环境需要一个适应新情况并与新情况相关的准则。但是，即使在这种普遍性下，本《准则》也为需要在特定情况下采取积极行动的软件工程师和软件工程师的经理提供了文件化的职业道德证明，从而为他们提供了支持。该准则为团队中的个人以及整个团队可以上诉的道德基础提供了基础。该准则有助于定义那些在道德上不符合软件工程师或软件工程师团队要求的操作。</p>
<p>《准则》不仅仅是为了裁定可疑行为的性质；它还具有重要的教育功能。由于本规范表达了专业人士在道德问题上的共识，因此它是一种教育公众和有抱负的专业人员有关所有软件工程师的道德义务的方法。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>原则1：Public 公共</p>
<p>软件工程师应采取符合公共利益的一致行动。特别是，软件工程师应酌情：</p>
<p>1.01 对自己的工作承担全部责任。</p>
<p>1.02 以公共利益来中和软件工程师，雇主，客户和用户的利益。</p>
<p>1.03 仅当有充分的根据认为安全，符合规格，通过适当的测试，并且不降低生活质量，降低隐私或损害环境时，才批准软件。这项工作的最终效果应该是为了公共利益。</p>
<p>1.04 向有关人员或当局披露他们合理地认为与软件或相关文档有关的对用户，公众或环境的任何实际或潜在危险。</p>
<p>1.05 合作解决由软件，其安装，维护，支持或文档引起的引起公众严重关注的问题。</p>
<p>1.06 保持公平，避免在所有有关软件或相关文档，方法和工具的声明（尤其是公开声明）中蒙骗他人。</p>
<p>1.07 考虑身体残疾，资源分配，经济劣势和其他因素的问题，即便这些因素可能会减少对软件收益的获取。</p>
<p>1.08 鼓励用专业技能提供志愿服务，并为有关该学科的公众教育做出贡献。</p>
<p>原则2：客户和雇主</p>
<p>软件工程师的行为应符合其客户和雇主的最大利益，并符合公共利益。特别是，软件工程师应酌情：</p>
<p>2.01 在自己的能力范围内提供服务，对自己的经验和教育的任何局限要诚实坦率。</p>
<p>2.02 不故意使用非法或不道德获得或保留的软件。</p>
<p>2.03 仅在获得客户或雇主的知情并同意的情况下，以适当的授权方式使用客户或雇主的财产。</p>
<p>2.04 在必要时，确保任何自己需要的文件已经获得相关人士批准授权。</p>
<p>2.05 将在其专业工作中获得的任何机密信息保密，这些机密性符合公共利益并且符合法律规定。</p>
<p>2.06 如果认为某个项目可能失败，证明过于昂贵，违反知识产权法或有其他问题，则应识别，记录，收集证据并立即向客户或雇主报告。</p>
<p>2.07 在软件或相关文档中向雇主或客户标识，记录并报告重要的社会关注问题。</p>
<p>2.08 不要接受任何不利于他们为主要雇主从事的工作的外部工作。</p>
<p>2.09 除非损害了更高的道德关注，否则不增加对雇主或客户不利的利益；在这种情况下，请将有关道德方面的问题告知雇主或其他有关部门。</p>
<p>原则3：产品</p>
<p>软件工程师应确保其产品和相关修改符合最高的专业标准。特别是，软件工程师应酌情：</p>
<p>3.01 力求高质量，可接受的成本和合理的时间表，确保重大的折衷方案已为雇主和客户所接受，并可供用户和公众考虑。</p>
<p>3.02 确保他们从事或提议进行的任何项目的正确和可实现的目标。</p>
<p>3.03 识别，定义和解决与工作项目有关的道德，经济，文化，法律和环境问题。</p>
<p>3.04 通过适当的教育和培训以及经验的组合，确保他们有资格从事他们正在从事或计划从事的任何项目。</p>
<p>3.05 确保将适当的方法用于正在进行或计划进行的任何项目。</p>
<p>3.06 努力遵循最适合手头任务的专业标准（如果有），只有在道德或技术上合理的情况下才偏离这些标准。</p>
<p>3.07 力求完全了解使用的软件的规范。</p>
<p>3.08 确保已正确编写了适用的软件的规格说明，并满足用户的要求并获得了适当的批准。</p>
<p>3.09 确保对从事或提议从事的任何项目的成本，进度，人员，质量和成果进行现实的定量估计，并对这些估计提供不确定性评估。</p>
<p>3.10 确保对其进行工作的软件和相关文档进行充分的测试，调试和审查。</p>
<p>3.11 确保从事的任何项目都有足够的文档，包括发现的重大问题和采用的解决方案。</p>
<p>3.12 致力于开发软件和相关文档，以尊重那些将受到该软件影响的人的隐私。</p>
<p>3.13 注意仅使用通过道德和合法手段获得的准确数据，并仅以经过适当授权的方式使用。</p>
<p>3.14 保持数据的完整性，对过时或有缺陷的事件敏感。</p>
<p>3.15 以与新<strong>开发</strong>相同的专业态度对待所有形式的软件<strong>维护</strong>。</p>
<p>原则4：审判</p>
<p>软件工程师应保持专业判断的完整性和独立性。特别是，软件工程师应酌情：</p>
<p>4.01。通过支持和维护人类价值观来调整所有技术判断。</p>
<p>4.02 仅批准在其监督下或在其权限范围内并与他们达成协议的文件。</p>
<p>4.03。对于要求他们评估的任何软件或相关文档，保持专业的客观性。</p>
<p>4.04。请勿进行欺诈性的财务行为，例如贿赂，重复开票或其他不当的财务行为。</p>
<p>4.05。向所有有关各方披露无法合理避免或避免的利益冲突。</p>
<p>4.06。拒绝以成员或顾问的身份参加与软件相关问题有关的私人，政府或专业机构，在这些机构中，他们，其雇主或客户存在未公开的潜在利益冲突。</p>
<p>原则5：管理</p>
<p>软件工程<strong>经理</strong>和<strong>领导者</strong>应当赞成和倡导以道德方式进行软件开发和维护管理。特别是那些<strong>管理</strong>或<strong>领导</strong>，应酌情：</p>
<p>5.01 确保对其所从事的任何项目进行良好的管理，包括提高质量和降低风险的有效程序。</p>
<p>5.02 在遵循标准之前，请确保将标准告知软件工程师。</p>
<p>5.03 确保软件工程师了解雇主的保护密码，文件和信息的政策和程序，这些密码，文件和信息对雇主是机密的或对他人是机密的。</p>
<p>5.04 只有在考虑了对教育和经验的适当贡献后，才进行工作分配，并希望进一步发展该教育和经验。</p>
<p>5.05 确保对他们从事或提议从事的任何项目的成本，进度，人员，质量和成果进行现实的定量估计，并对这些估计提供不确定性评估。</p>
<p>5.06。仅通过完整准确地描述雇用条件来吸引潜在的软件工程师。</p>
<p>5.07。提供公平公正的报酬。</p>
<p>5.08。不公正地阻止某人担任该人具有适当资格的职位。</p>
<p>5.09。确保就软件工程师所贡献的任何软件，过程，研究，写作或其他知识产权的所有权达成公平协议。</p>
<p>5.10。在违反雇主政策或本守则的指控中规定正当程序。</p>
<p>5.11。不要要求软件工程师做任何与本规范不一致的事情。</p>
<p>5.12。不要因为表达对项目的道德顾虑而惩罚任何人。</p>
<p>原则6：专业</p>
<p>软件工程师应提高与公共利益一致的专业的正直和声誉。特别是，<strong>软件工程师</strong>应酌情：</p>
<p>6.01。帮助建立有利于道德行为的组织环境。</p>
<p>6.02。促进公众对软件工程的了解。</p>
<p>6.03。通过适当参加专业组织，会议和出版物来扩展软件工程知识。</p>
<p>6.04。作为专业人士，应支持其他努力遵循本准则的软件工程师。</p>
<p>6.05。不以职业，客户或雇主为代价来提升自身利益。</p>
<p>6.06。遵守所有规范其工作的法律，除非在特殊情况下，这种遵守不符合公共利益。</p>
<p>6.07。准确说明其运行的软件的特征，不仅避免虚假声明，而且避免合理地被认为是投机性，虚假性，欺骗性，误导性或可疑性的声明。</p>
<p>6.08。负责检测，纠正和报告其工作所在的软件及相关文档中的错误。</p>
<p>6.09。确保客户，雇主和主管知道软件工程师对本《道德准则》的承诺以及此承诺的后续后果。</p>
<p>6.10。避免与与此准则冲突的企业和组织建立关联。</p>
<p>6.11。认识到违反本准则与成为专业软件工程师是不一致的。</p>
<p>6.12。当发现重大违反本《准则》的行为时，请引起有关人员的关注，除非这是不可能的，适得其反的或危险的。</p>
<p>6.13。如果很明显，与这些重大违反行为的人进行磋商是不可能，适得其反或危险的，请向有关当局报告重大违反本准则的行为。</p>
<p>原则7：同事</p>
<p>软件工程师应公平对待并支持其同事。特别是，软件工程师应酌情：</p>
<p>7.01。鼓励同事遵守本准则。</p>
<p>7.02。协助同事进行专业发展。</p>
<p>7.03。充分信任他人的工作，不要过度信任他人。</p>
<p>7.04。以客观，坦率且有据可查的方式审查他人的工作。</p>
<p>7.05。公正地听取同事的意见，疑虑或投诉。</p>
<p>7.06。协助同事充分了解当前的标准工作惯例，包括用于保护密码，文件和其他机密信息的策略和过程，以及一般的安全措施。</p>
<p>7.07。没有不公平地干预任何同事的职业；但是，出于雇主，客户或公共利益的考虑，可能迫使软件工程师真诚地质疑同事的能力。</p>
<p>7.08。在超出自己能力范围的情况下，请征询在该领域具有能力的其他专业人员的意见。</p>
<p>原则8：自我</p>
<p>软件工程师应参加有关其专业实践的终身学习，并应提倡以道德的方式进行专业实践。特别是，软件工程师应继续努力：</p>
<p>8.01。进一步了解软件，相关文档的分析，规范，设计，开发，维护和测试以及开发过程管理方面的开发知识。</p>
<p>8.02。提高以合理的成本在合理的时间内创建安全，可靠和有用的高质量软件的能力。</p>
<p>8.03。提高制作准确，信息丰富且编写得很好的文档的能力。</p>
<p>8.04。增进对他们工作所在的软件和相关文档以及使用它们的环境的了解。</p>
<p>8.05。提高对相关标准的知识，以及管理他们工作所在的软件和相关文档的法律。</p>
<p>8.06 提高对该守则，其解释及其在工作中的应用的了解。</p>
<p>8.07 不要因为任何不相关的偏见而对任何人给予不公平的待遇。</p>
<p>8.08。不影响他人采取任何涉及违反本准则的行为。</p>
<p>8.09。认识到个人违反本《准则》与成为专业软件工程师是不一致的。</p>
]]></content>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>标准化WASI: 一个网页外运行WebAssembly的系统接口</title>
    <url>/post/standardizing-wasi-a-webassembly-system-interface/</url>
    <content><![CDATA[<p>今天，我们宣布一项新标准化工作的开始——WASI，即WebAssembly系统接口。</p>
<span id="more"></span>

<p><strong>为何需要WASI</strong>：开发人员开始将WebAssembly(译：下称WASM)推向浏览器以外的世界，因为WASM提供了一种快速，可扩展，且安全的方式在所有计算机上运行相同的代码。</p>
<p>但是现在我们还没有坚实的基础可以构建WASI。浏览器外部的代码需要一种与系统对话的方式，即系统接口，这是当前WASM平台还没有的。</p>
<p><strong>WASI是什么</strong>：WebAssembly是用于概念中计算机的汇编语言，而不是用于物理计算机的汇编语言。这就是它可以在各种不同的机器架构上运行的原因。</p>
<p>就像WASM是概念中计算机的汇编语言一样，WebAssembly需要概念中的操作系统（而不是任何一个具体的操作系统）的系统接口。这样，它可以在所有不同的操作系统上运行。</p>
<p>这就是WASI – WASM平台的系统接口。</p>
<p>我们旨在创建一个系统接口，该接口将成为WebAssembly的真正伙伴，并经历时间考验。这意味着要坚持WASM的关键原则——“可移植性和安全性”。</p>
<p><strong>谁在制作WASI</strong>：我们正组织一个WebAssembly子项目组来专攻标准化WASI。我们已经召集了感兴趣的合作伙伴，并正在寻找更多加入的伙伴。</p>
<p>我们与合作伙伴，还有支持者，认为WASI重要的一些原因如下：</p>
<p>Mozilla首席研发官Sean White</p>
<p>“ WebAssembly正在为人们改变网络带来新的引人入胜的内容的方式，并使开发人员和创作者能够在网络上100%发挥实力。到目前为止，这是都是通过浏览器实现的。但是通过WASI，我们可以将WebAssembly和Web的优势交给更多的用户，更多的岗位，更多的设备，并作为更多体验的一部分。”</p>
<p>Fastly的首席技术官Tyler McMullen</p>
<p>“我们将WebAssembly扩展到浏览器之外，作为在边缘云中快速，安全地执行代码的平台。尽管我们的边缘和浏览器之间的环境存在差异，但WASI意味着WebAssembly开发人员无需将其代码移植到每个不同的平台上。”<br>Myles Borins，Node技术指导委员会主任</p>
<p>“ WebAssembly可以解决Node中最大的问题之一 —— 如何以接近本机的速度并像使用本机模块一样重用以C和C++等其他语言编写的代码，同时仍保持可移植性和安全性。标准化此系统接口是实现这一目标的第一步。”</p>
<p>npm的联合创始人Laurie Voss</p>
<p>“ npm对可能的WebAssembly能够扩展npm生态系统的功能感到非常兴奋，同时极大地简化了使本机代码在服务器端JavaScript应用程序中运行的过程。我们期待这一过程的结果。”</p>
<p>所以这是个大新闻！ 🎉</p>
<p>WASI当前有3种实现：</p>
<ul>
<li>wasmtime，Mozilla主导的WebAssembly运行时</li>
<li>Lucet，Fastly主导的WebAssembly运行时</li>
<li>浏览器上的polyfill</li>
</ul>
<p>如果您想了解有关该系统接口应如何工作的建议的更多信息，请继续阅读。</p>
<h2 id="什么是系统接口？"><a href="#什么是系统接口？" class="headerlink" title="什么是系统接口？"></a>什么是系统接口？</h2><p>许多人谈论像C这样可以使您直接访问系统资源的语言。但事实并不是这样的。</p>
<p>这些语言实际上无权直接在大多数系统上执行，打开或创建文件之类的操作。为什么不？</p>
<p>因为这些系统资源（例如文件，内存和网络连接）对于稳定性和安全性来说非常重要。</p>
<p>如果一个程序无意间弄乱了另一个程序的资源，则可能使该程序崩溃。更糟糕的是，如果某个程序（或用户）故意弄乱了另一个程序的资源，它可能会窃取敏感数据。(译：就是缓冲区溢出导致RCE)</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/01-01_crash-data-leak-1-500x220.png" class="" title="crash-data-leak">

<p>因此，我们需要一种方法来控制哪些程序和用户可以访问哪些资源。人们很早就意识到了这一点，并提出了一种提供这种控制的方法：保护环的安保。</p>
<p>借助保护环的安保，操作系统基本上可以在系统资源周围设置保护屏障。这也就是内核(Kernel)。内核是唯一一个需要做比如创建新文件，打开文件或打开网络连接之类的操作的东西。</p>
<p>用户程序在此内核之外以“用户模式”运行。如果程序想要执行任何操作，例如打开文件，则必须要求内核为其打开文件。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/01-02-protection-ring-sec-1-500x298.png" class="" title="protection-ring-sec">

<p>这就是系统调用(syscall)这个概念出现的地方。当程序需要让内核执行这些操作之一时，它会要求使用系统调用。这使内核有机会弄清楚是哪个用户在要求。然后，它可以在该用户在打开文件之前查看用户是否有权访问该文件。</p>
<p>在大多数设备上，这是代码可以通过系统调用访问系统资源的唯一方法。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/01-03-syscall-1-500x227.png" class="" title="syscall">

<p>操作系统使系统调用可用。但是，如果每个操作系统都有自己的系统调用，那么是否就需要为每个操作系统使用不同版本的代码？幸运的是，现在的您不需要。</p>
<p>那这个问题是如何被解决的？抽象化。</p>
<p>大多数语言都提供标准库。进行编码时，程序员无需知道他们针对的系统。他们只是使用接口。</p>
<p>然后，在编译时，您的工具链会根据您要定位的系统来选择要使用的接口实现。此实现使用操作系统API中的功能，因此特定于系统。</p>
<p>这就是系统接口的所在。例如，为Windows机器编译的printf可以使用Windows API与该机器进行交互。如果要针对Mac或Linux进行编译，它将改用POSIX。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/02-01-implementations-1-500x267.png" class="" title="implementations">

<p>但是，这也给WebAssembly带来了一个问题。</p>
<p>使用WebAssembly，即使在编译时，您也不知道要使用哪种操作系统。因此，您不能在标准库的WebAssembly实现中使用任何单个操作系统的系统接口。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/02-02-implementations-1-500x260.png" class="" title="implementations">

<p>我之前说过，为何WebAssembly是个<a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/" target="_blank" rel="noopener">用于概念计算机的汇编语言</a>而不是真实计算机的汇编语言。以同样的方式，WebAssembly需要用于概念性操作系统的系统接口，而不是真正的操作系统。</p>
<p>但是，即使没有适当的系统接口，也已经有运行时可以在浏览器外部运行WebAssembly。他们是怎么做到的呢？ 让我们来看看。</p>
<h2 id="当下，WebAssembly是如何在浏览器之外运行？"><a href="#当下，WebAssembly是如何在浏览器之外运行？" class="headerlink" title="当下，WebAssembly是如何在浏览器之外运行？"></a>当下，WebAssembly是如何在浏览器之外运行？</h2><p>生成WebAssembly的第一个工具是Emscripten。它在网页上模拟了特定的OS系统接口POSIX。这意味着程序员可以使用C标准库（libc）中的函数。</p>
<p>为此，Emscripten创建了自己的libc实现。 此实现分为两部分 —— 将一部分编译到WebAssembly模块中，另一部分用JS胶水代码实现；然后，此JS胶水将调用浏览器，此后浏览器将与OS通信。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/03-01-emscripten-1-500x329.png" class="" title="emscripten">

<p>早期的大多数WebAssembly代码都是使用Emscripten编译的。因此，当人们开始希望在没有浏览器的情况下运行WebAssembly时，他们首先通过运行Emscripten编译的代码开始。</p>
<p>所以，为JS胶水代码中的所有这些功能，这些运行时需要创建自己的实现。</p>
<p>不过这里有个问题。该JS胶水代码提供的接口并非标准设计，甚至不是面向外部的接口。因为这不是它当时需要解决的问题。</p>
<p>打个比方，对于一个类似于public接口API上<code>read</code>的函数的调用，JS胶水代码改用 <code>_system3(which, varargs)</code>。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/03-02-system3-1-500x179.png" class="" title="system3">

<p>第一个参数，<code>which</code>，是一个整数，该整数始终与名称中的数字相同（在这种情况下为3）。</p>
<p>第二个参数，<code>varargs</code>，是要使用的参数。之所以称为varargs，是因为您可以使用可变数量的变量。但是WebAssembly无法提供将可变数量的参数传递给函数的方法。因此，参数是通过线性内存传递的。这不是安全的类型，而且比使用寄存器传递参数的速度要慢。</p>
<p>这对于在浏览器中运行Emscripten来说很好。但是现在，运行时将其视为事实上的标准，实现了自己的JS胶水代码版本。他们正在仿真POSIX仿真层的内部细节。</p>
<p>这意味着他们正在重新实现基于Emscripten约束有意义的选择（例如将参数作为堆值传递），即使这些约束不适用于他们当前的环境。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/03-03-emulation-1-500x341.png" class="" title="emulation">

<p>如果我们要建立一个可持续数十年的WebAssembly生态系统，则需要坚实的基础。 这意味着我们的事实上的标准不能是模仿的模仿。</p>
<p>但是，我们应该采用什么原则？</p>
<h3 id="WASI需要遵循哪些原则？"><a href="#WASI需要遵循哪些原则？" class="headerlink" title="WASI需要遵循哪些原则？"></a>WASI需要遵循哪些原则？</h3><p>WebAssembly中包含两个重要的原则：</p>
<ul>
<li>可移植性</li>
<li>安全性</li>
</ul>
<p>在转向浏览器外的使用时，我们需要保证这些关键原则。</p>
<p>事实是，POSIX和Unix的安全性访问控制方法还不能完全解决问题。让我们看看它们的不足之处。</p>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>POSIX提供源代码可移植性。您可以使用不同版本的libc编译相同的源代码，以针对不同的计算机。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-01-portability-1-500x375.png" class="" title="portability">

<p>但是WebAssembly需要超越这一步骤。我们需要能够编译一次并跨一大堆不同的机器运行。我们需要可移植的二进制文件。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-02-portability-1-500x484.png" class="" title="portability">

<p>这种可移植性使向用户分发代码变得更加容易。</p>
<p>例如，如果Node的本机模块是用WebAssembly编写的，则用户在安装带有本机模块的应用程序时无需运行node-gyp，并且开发人员无需配置和分发数十个二进制文件。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>当一行代码要求操作系统进行某些输入或输出时，操作系统需要确定执行代码要求的操作是否安全。</p>
<p>操作系统通常使用基于所有权和组的访问控制来处理此问题。</p>
<p>例如，程序可能要求操作系统打开文件。用户具有他们有权访问的一组文件。</p>
<p>当用户启动程序时，该程序代表该用户运行。如果用户有权访问文件——（因为他们是所有者，或者因为他们在具有访问权限的组中），那么程序也具有相同的访问权限。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-03-access-control-1-500x224.png" class="" title="access-control">

<p>这样可以用户之间进行保护。在早期操作系统的开发中，这很有意义。系统通常是多用户的，并且管理员控制要安装的软件。因此，最主要的威胁是其他用户偷看您的文件。</p>
<p>但是，大人，时代变了。系统现在通常是单用户，但是它们正在运行的代码会引入许多其他可信度未知的第三方代码。现在最大的威胁是您自己正在运行的代码将对您不利。</p>
<p>例如，假设您在应用程序中使用的库获得了一个新的维护程序（在开放源代码中经常发生）。那个维护者可能会引起您的兴趣……或者他们可能是坏人之一。 而且，如果他们有权在您的系统上执行任何操作（例如打开任何文件并通过网络发送文件），那么他们的代码可能会造成很大的破坏。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-04-bitcoin-1-500x258.png" class="" title="bitcoin">

<p>这就是为什么使用可以直接与系统对话的第三方库很危险的原因。</p>
<p>WebAssembly的安全性方法不同。WebAssembly已沙盒化。</p>
<p>这意味着代码无法直接与操作系统对话。但是，它如何处理系统资源呢？主机（可能是浏览器，也可能是wasm运行时）将函数放入代码可以使用的沙箱中。</p>
<p>这意味着主机可以限制程序在逐个程序的基础上可以执行的操作。它不仅可以让程序代表用户执行操作，还可以在具有用户完全权限的情况下调用任何系统调用。</p>
<p>仅仅拥有一种沙箱机制并不能保证系统本身的安全性——因为主机仍然可以将所有功能都放到沙箱中，在这种情况下，我们的状况就不会更好了——但它至少使主机可以能够选择创建一个更安全的系统。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/04-05-sandbox-1-500x278.png" class="" title="sandbox">

<p>在我们设计的任何系统接口中，我们都需要坚持这两个原则。可移植性使开发和分发软件更加容易，并且绝对必须为主机提供工具以保护自己或他们的用户安全。</p>
<h3 id="WASI应该是什么样？"><a href="#WASI应该是什么样？" class="headerlink" title="WASI应该是什么样？"></a>WASI应该是什么样？</h3><p>给定这两个关键原则，WebAssembly系统接口的设计应该是什么？</p>
<p>这就是我们在标准化过程中要解决的问题。 不过，我们确实有一个建议：</p>
<ul>
<li>创建一组标准接口</li>
<li>从标准化最基本的模块wasi-core开始</li>
</ul>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-01-wasi-1-500x419.png" class="" title="wasi">

<p>wasi-core将会是个啥？</p>
<p>wasi-core将包含所有程序需要的基础。它将覆盖与POSIX相同的大部分内容，包括文件，网络连接，时钟和随机数。</p>
<p>对于许多这些事情，它将采用与POSIX非常相似的方法。例如，它将使用POSIX的面向文件的方式，在此基础上您可以进行诸如open，close，read和write之类的系统调用，而其他所有操作基本上都可以在顶部进行增强。</p>
<p>但是wasi-core无法涵盖POSIX的所有功能。例如，进程概念不能清楚地映射到WebAssembly上。除此之外，说每个WebAssembly引擎都需要支持进程操作（如fork）是没有意义的。 但是我们也想使标准化fork成为可能。</p>
<p>这就是模块化方法的用武之地。通过这种方式，我们可以获得良好的标准化覆盖率，同时仍然允许细分平台仅使用WASI在该平台上有意义的部分。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-02-wasi-1-500x251.png" class="" title="wasi">

<p>像Rust这样的语言将直接在其标准库中使用wasi-core。 例如，Rust的<code>open</code>是通过在编译为WebAssembly时调用<code>__wasi_path_open</code>来实现的。</p>
<p>对于C和C++，我们创建了一个<a href="https://github.com/CraneStation/wasi-sysroot" target="_blank" rel="noopener">wasi-sysroot</a>，它根据wasi-core函数实现了libc。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-03-open-imps-1-500x229.png" class="" title="open-imps">

<p>我们希望像clang这样的编译器准备好与WASI API交互，并且像Rust编译器和Emscripten这样的完整工具链也可以将WASI用作其系统实现的一部分</p>
<p>那么用户的代码需要如何调用这些WASI函数？</p>
<p>答案是，运行代码的运行时将wasi-core函数作为导入(imports)传递进WASM。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-04-imports-1-500x285.png" class="" title="imports">

<p>这给我们带来了可移植性，因为每个主机都可以有自己的wasi-core实现，该实现专门针对其平台编写——从Mozilla的wasmtime和Fastly的Lucet之类的WebAssembly运行时，到Node甚至是浏览器。</p>
<p>这也给我们提供了沙箱管理功能，因为主机可以逐个程序选择要传入的wasi-core函数，因此，可以允许哪个系统调用。 这样可以保持安全性。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-05-sec-port-2-500x705.png" class="" title="sec-port">

<p>WASI为我们提供了进一步扩展此安全性的方法。它从基于功能的安全性中引入了更多概念。</p>
<p>传统上，如果代码需要打开文件，则使用字符串（路径名）调用open。然后，操作系统会检查代码是否具有权限（基于启动程序的用户）。</p>
<p>使用WASI，如果要调用需要访问文件的函数，则必须传入文件描述符，该描述符具有附加的权限。这可以用于文件本身，也可以用于包含文件的目录。</p>
<p>这样，您就不会拥有随机要求打开&#x2F;etc&#x2F;passwd的代码。相反，代码只能在传递给它的目录上操作。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-06-openat-path-1-500x192.png" class="" title="openat-path">

<p>这使得可以安全地给沙盒代码更多地访问不同的系统调用的权限，因为这些系统调用的功能可能受到限制。</p>
<p>而且这是逐个模块进行的。默认情况下，模块无权访问文件描述符。但是，如果一个模块中的代码具有文件描述符，则可以选择将该文件描述符传递给它在其他模块中调用的函数。或者，它可以创建文件描述符的更多受限版本以传递给其他功能。</p>
<p>因此，运行时将应用程序可以使用的文件描述符传递给顶层代码，然后根据需要，将文件描述符传播到系统的其余部分。</p>
<img src="/post/standardizing-wasi-a-webassembly-system-interface/05-07-file-perms-1-500x423.png" class="" title="file-perms">

<p>这使WebAssembly更接近最小特权原则，在该原则下，模块只能访问执行其工作所需的确切资源。</p>
<p>这些概念来自面向功能的系统，例如CloudABI和Capsicum。面向功能的系统的一个问题是，通常很难向其移植代码。但是我们认为这个问题可以解决。</p>
<p>如果代码已经使用了带有相对文件路径的<code>openat</code>，那么编译代码就可以了。</p>
<p>如果代码使用<code>open</code>并且正迁移到<code>openat</code>风格是过度的前期投资，WASI可以提供一个增量解决方案。使用<img src="https://github.com/musec/libpreopen" alt="libpreopen" loading="lazy">，您可以创建应用程序需要合法访问的文件路径的列表。然后，您可以使用open，但只能使用这些路径。</p>
<h3 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h3><p>我们认为wasi-core是一个好的开始。它保留了WebAssembly的可移植性和安全性，为生态系统奠定了坚实的基础。</p>
<p>但是，在wasi-core完全标准化之后，我们仍然需要解决一些问题。这些问题包括：</p>
<ul>
<li>异步I&#x2F;O</li>
<li>文件监控</li>
<li>文件锁定</li>
</ul>
<p>这仅仅是开始，因此，如果您有解决这些问题的想法，请加入我们！</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>wasm</tag>
        <tag>wasi</tag>
      </tags>
  </entry>
  <entry>
    <title>近来半年工作的思考</title>
    <url>/post/start-job/</url>
    <content><![CDATA[<p>每个半年总得总结一下人生……</p>
<span id="more"></span>

<p>最近半年多着实忙碌，尤其是在踏出校门的过程中经历了不少坎坷的经历。</p>
<p>离开校园后的工作也并不令人满意，万幸也不幸的是家里对在银行工作万分肯定，处处都给予我帮助，让本打算当野草的我感觉有点不知所措。</p>
<p>大概人生就是这么戏谑，那些想留下的女生们开不出户，而想走的我却压着手里的户希望他们慢点来。</p>
<p>好吧那我把（工作时间的）闲暇时间拿来改良工作体验吧，于是做了个DamnCLPS系统，拿来优化一下内部数据提交流程，毕竟我最烦这种明明该电脑完成却让人手动录入的事，结果ok，刚好更新系统，IMB DB2搞ERROR，搞得我向Leader推广不出去，这样一来我也没了兴致，写到一半的批量工具也算腰斩了。</p>
<p>总之工作上不尽如人意。也对吧，银行本就该是一个传统守旧的行业，我却想革新它。感觉自己比朱雀还天真了。</p>
<p>索性的是，第一个月第一个领导跑了，上个月我的第二个领导被辞了。总的来说相比那些加班到10点的苦逼来说，我也算是下班早的了。下班健身是不可能的，约会也不存在的，B站等各大网站没买会员看番都看不舒服，玩黑客现在在社会了也不敢乱来了，只能继续完成在大四钻研的Proj Ridal。</p>
<p>啊哈没错Proj Ridal就是那个repo，啥都没，dev分支也就几个没卵用的go文件。当时这个Project的目标其实就是论文里的状态区块链的完整实现，Ridal即雷达，雷达那仪表盘玩意就是扫一圈周围出现几个点，再扫一圈出现几个点这样来表示信息的，和基于状态的区块链的思想上很接近。</p>
<p>想的的确还挺不错一个完整的区块链，但是实战要死了——要完成的东西真的有点多，我也没知道几个库能直接上手的，完成得不少时间吧，可我缺的不只是<strong>产品</strong>，还有<strong>时间</strong>。时间真的就是决定机缘的，17年那时候是个屎一样的白皮书ICO都能上千万。现在呢？ICO基本上凉凉，挖矿币倒是能吸引几个挖卖提或者初始投资者。毕业前我闲的蛋疼也做了几个新币的矿池，ok大部分都是跑路的，就剩一个webchain还坚挺。有人就建议我在矿池上熊市布局，牛市割肉。但是吧，我也知道，我有个缺点——在计算机上我什么都能做。你们说该现在布局，那为什么我就该把局布在矿池而不是直接在币上？<strong>我为什么就不能靠我自己赚钱？我不稀罕依附于别人，尤其是在这说散就散的币圈。</strong></p>
<p>然后我就自己做币了╮(╯_╰)╭</p>
<hr>
<p>然后就是新的更新了。2019-06-29</p>
<p>现在是2019年年中了。在年前因为项目代码实在无力维护暂时冻结了项目，年后主动提出了辞职，之后一边找工作一边重回Coding的状态。</p>
<p>当然了，混吃等死是不存在的，主要就靠挖矿、做挖矿软件、做矿池什么的稍微赚点伙食费，当然这些内容并不是无意义的，通过写这些子项目，对于golang和基于golang的PoW架构设计比以前得心应手多了。</p>
<p>因为之前的项目被frozen所以就没什么大顾虑了，干脆从0开始，现在全力以赴构造一个我所想要的区块链，一个我认为能够成功的项目。或者说，即便它不成功，我也要让它在学界在业界拥有技术的价值。</p>
<p>下面是这半年观察市场的收获。</p>
<ul>
<li><p>很明显，很多噱头公司bin没能撑下来，具体我说谁就不指明了。在去一个所谓“区块链公司”应聘的时候，了解到很多都已经跑路了，而这家把棋牌（赌博？）作为区块链游戏开发的小公司却活得像个业界明星。我：？？？</p>
</li>
<li><p>在大环境来看，发现具有传销性质的一些“半开源”币的社会影响比我想象中更大一点。币价和算力成正比，而算力和矿工收益成正比，矿工收益和币价升值成正比。</p>
</li>
<li><p>良心矿池不好混，基本上亏本。还不如提供挖矿软件0成本。</p>
</li>
</ul>
<hr>
<p>辛苦了，2019.</p>
<p>现在是2019的最后一天。昨晚为了给go-hwloc仓库debug只睡了三小时，今天又是加了爬crunchbase和计算300ETF实时理论价格的活，感觉脑子转的有点快。</p>
<p>除了索然无味的学英语以外，这半年又做了些什么？</p>
<p>首先肯定是秋季至今一直费心思的GxMiner，这家伙算是脱胎于之前的vns-stratum-miner，但是修改了很多也对它做了很多优化，甚至一段时间内比xmrig都快。但是哈毕竟xmrig群策群力，gxminer我独木难支233333。还想通过Ms.Jinx项目来实现多Miner管理，不过GUI和CLI的选择以及其他人对Miner的态度让我没那么多动力去做下去。我是个自私的人，这些项目都是为了我自己的技术成长而不是为了造福广大矿工这可真是抱歉。</p>
<p>然后就是各种算法在nodejs和go上的适配。小工作。换了个头像，这个风格我称之为illusion，是让观察者产生立体错觉的平面色块。</p>
<p>做的最最最多的还是NGIN，现在github上也划到我的maoxs2账号下了。这个项目除了初始的ethereum-fork-code以外我已经重构了四次了，每次都有新收获，上次的代码都已经可以直接PoW了，只不过我在回头来看的时候我还是觉得过于稚嫩。</p>
<p>另外，typescript重置nomp暂时难产，暂时改成了制作node-standalone-pool。</p>
<p>最近在小小的投资公司里实习（反正明年就得去澳洲懒得认真工作），也是做了很多东西，FR007和SHIBOR3M的IRS（带UI和傻瓜操作），基于interception的C#模拟键鼠操作实现无API自动交易，还有基于fsolve的回报值运算等等更琐碎的小运算。</p>
<p>2020年会继续做什么呢？</p>
<p>那肯定NGIN不会弃坑的，但是能不能产出来也不一定，毕竟是从底层重构区块链整个系统。然后预计node-standalone-pool会优先完成，因为pool的需求一直存在。</p>
<p>在技术上会找C艹或者rust再做晋升，另外在准备重写cpuminer。此外非编译型语言上，在nodejs+node-standalone-pool之后转置成ts+deno。</p>
<p>当然最后得强调不能丢下学习哈。去了Monash得去找Joseph Liu喝喝茶聊聊RingCT和他的hcash（哎没错就是那个坑害大妈的hsr）</p>
<hr>
<p>眨眼就2022了，被疫情偷走了整整两年了。</p>
<p>2020开头是艰难的，澳洲去不成了，没有了语言班，后面备战雅思又在报考和实际考试中继续受挫。再加上疫情伙食变好带来的急速增肥，导致健身时候情绪会崩溃。但是最后是幸运的，靠着网考的领思成绩通过了语言要求，在年末进入了Nov-Intake，开启了Zoom University的学习。学习内容其实从其他每个对应的课程笔记里看出，总体对我都不难，但是高分对于我还是艰难，毕竟粗心和英语底子摆在这里。</p>
<p>在学习过程之中对自己的开发必然是荒废了的，但是缝缝补补或者在假期里challenge还是在进行，向gayhub贡献了不少（dart的密码学库等）。2021年里继续靠剑三虚度了不少时光，也认识了不少有趣的人。最后的半年里开始了国内博士的申请，也很高兴被数个教授赏识。最主要的，申请的过程让我感觉到，这一路走下来并没有白费力气，所有的项目都是值得的。当然我也是在学术发表上依然有所欠缺，希望能在新的2022年改进。</p>
<p>NGIN，现在应该叫ngchain，我依然还在继续完善其代码。有教授问我，为什么会想着自己做这样的项目，我的答复是为了挑战自我，为了代码自由，ngchain会是我对于各类区块链技术的试验田，生命不息则<strong>n</strong>ext-<strong>g</strong>en不止。</p>
<p>看了下前面内容，好像说话都变得更官方了hhh</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Something on NGIN: 一些隨筆</title>
    <url>/post/sth-on-ngin/</url>
    <content><![CDATA[<p>隨意地記錄一些NGIN上的一些思考</p>
<span id="more"></span>

<h2 id="28-April-2020-爲什麽選擇不添加TD-Toatl-Difficulty"><a href="#28-April-2020-爲什麽選擇不添加TD-Toatl-Difficulty" class="headerlink" title="28 April 2020 爲什麽選擇不添加TD(Toatl Difficulty)?"></a>28 April 2020 爲什麽選擇不添加TD(Toatl Difficulty)?</h2><p>本來是打算加的，因爲有如下好處</p>
<ul>
<li>藉鑒ETH的sync</li>
<li>讓同一時間收到的Block之間有不同的rank， 方便node決定fork方向</li>
</ul>
<p>但是後來取消了，選擇了不添加TD，只使用Diff(target)</p>
<ul>
<li>無法排查Block的内部TD錯誤</li>
<li>需要修改難度算法。因爲當前Block難度是在一個checkround中不變的，TD決定rank的特性毫無意義。</li>
<li>Block的獨立性。這個是一直在爭取的東西，可以讓整個架構更可插拔，方便拓展。Diff的關聯已經和上一區塊過於緊密了。在不改變算法的情況下要使得rank不同就需要使用由nonce決定的ActualDiff，而每次ActualDiff實際上都是在re-hash，對PoW算法要求高。而NGIN本來就是CPU算法，不應當采取這樣的機制。</li>
<li>Sync還不完善。Sync機制還是殘廢狀態，不應該開始考慮調優</li>
<li>rank應該能有別的替代品: UnixNano, len(txs) …</li>
</ul>
<h2 id="28-April-2020-Sync機制"><a href="#28-April-2020-Sync機制" class="headerlink" title="28 April 2020 Sync機制?"></a>28 April 2020 Sync機制?</h2><p>P2P_protocol-v0.0.1下NGIN的Sync機制比較殘廢，是直接不停地pingpong來獲取Wired Node的狀態（最高高度）來確認自己是不是out of date.</p>
<p>這裏先簡單説一下其他區塊鏈網絡的Sync機制</p>
<ol>
<li>Bitcoin</li>
</ol>
<p>BTC的Sync機制是發一個hash_stop&#x3D;0（即取盡可能多）的getheaders&#x2F;getblocks，讓remoteNode傳回一份Inv也就是庫存清單，localNode就check了一眼這個清單，對自己沒的Block發getdata</p>
<ol start="2">
<li>Ethereum</li>
</ol>
<p>ETH有倆種Sync，一個是Block的，一個是State也就是合約狀態的</p>
<p>這裏就講下Block的。</p>
<p>ETH在連接建立之後就會優先交換一個Status message，裏面就包括了bestHash，前面說的TD，還有一些區別forknet的字段。</p>
<p>然後localNode一看我自家的TD不如別家啊，然後，就會發個GetBlockHeaders請求，認證了PoW信息之後再通過GetBlockBodies把内容也取來，之後就存（執行）起來。</p>
<hr>
<p>因爲Discovery是利用libp2p的kaddht實現，Broadcast機制也已經用libp2p的pubsub給實現了，所以NGIN天生就和上面的不一樣……</p>
<p>libp2p這裏有寫好的<a href="https://godoc.org/github.com/libp2p/go-libp2p-consensus" target="_blank" rel="noopener">共識</a>（<a href="https://godoc.org/github.com/libp2p/go-libp2p-raft" target="_blank" rel="noopener">raft</a>）</p>
<p>當然還有<a href="https://godoc.org/github.com/ipfs/ipfs-cluster/consensus/raft" target="_blank" rel="noopener">ipfs自己在用的raft</a></p>
<p>雖然這個raft庫不能用，也不能從ipfs的改，但是一些架構可以參考</p>
<p>比如，這個consensus是建立在p2p的上層</p>
<p>這就很顛覆了……</p>
<p>&#x3D; &#x3D;這樣咋收response</p>
<p>！！！<br>哦對哦</p>
<p>這個Wired又不是broadcast要register！我返回stream然後做個阻塞讀不就好了！</p>
<p>參考<a href="https://github.com/prysmaticlabs/prysm/blob/master/beacon-chain/p2p/sender.go" target="_blank" rel="noopener">prysm</a></p>
<p>媽的，被libp2p的example帶跑了……</p>
<p>看了下prysm的<a href="https://github.com/prysmaticlabs/prysm/tree/9d173dcad2146f34bf5583f359f6227951bf3efc/beacon-chain/sync" target="_blank" rel="noopener">sync</a>，看來他們對initial sync也花了不少心思……居然還有個old……</p>
<h2 id="orphan"><a href="#orphan" class="headerlink" title="orphan"></a>orphan</h2><p>因爲上綫了測試網，因此p2p上很多問題就暴露出來了，其中最嚴重的是由於BlockTime過短導致的分叉。</p>
<p>查了很多遍”prevent&#x2F;avoid fork”都沒結果，現在在看DAG方案時候才發現人家管這個問題叫orphan block…</p>
<p>大概是手上沒有算力的情況分叉的確就孤兒了……</p>
<p>eth的思路是uncle block，形象一点就是把敌人化为己用，就把uncle的header和hash保存进Block的uncle字段里。</p>
<p>如果分叉节点收到这个带uncle的Block广播就知道了自己手里拿着的这个Block是没用的，它就会“从良”回到这个主线上。</p>
<p>NGIN没有这个设计，因为我觉得uncle信息是冗余的，而且真的作为10s的blockTime要叉出去也很难直接救回来</p>
<p>所以在NGIN裏只有强制fork的情況，儅遠程節點比本機高出數個blockCheckRound的時候就會觸發</p>
<p>爲了防止惡意擡高區塊高度來强制fork，我們需要給這個機制加一個cap。換句話説就是對於離綫過久切分叉太遠的直接孤立隔離，避免其污染網絡</p>
<h2 id="quill"><a href="#quill" class="headerlink" title="quill"></a>quill</h2><p>在对错误处理升级的时候突然萌生了使用子协议来对tx进行操作的想法。暂时把这个协议称为quill（羽毛笔）。</p>
<p>现在tx的种类众多，却只是通过switch来将他们发到各个handler上进行验证或是处理。</p>
<p>现在我们希望能把contract相关的tx（append,delete,以及未来的lock,unlock）通过quill来进行整合，<br>即，使用quill来解析extra内容。看起来就应该像是在用tx操作一个quill（羽毛笔）在contract上写内容。</p>
<p>除了负责这些基本操作以外，quill也应当负责保证accounts的一致性。<br>和raft，paxos这些算法不同，quill是一个针对PoW环境的一致性算法，即记账人已经确定。</p>
]]></content>
      <tags>
        <tag>todo</tag>
        <tag>NGIN</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>工程项目管理应用的低存储量区块链实现</title>
    <url>/post/state-chain-on-pm-paper/</url>
    <content><![CDATA[<p>区块链不仅仅构造了数字货币，作为可信底层架构，区块链通过保存历史信息提供了可追溯的功能。该功能在获得用户信任基础上，保证了产品可信度，降低业务审查、清算等会计成本。状态区块链是一种比传统区块链更加激进的区块链底层架构，它选择了不保存所有历史，而是选择通过总结来归纳出每个可信区段中所有账户的状态，从而实现在现有可信基础上更加灵活的应用部署，彻底摆脱了原本对每个节点存储空间的苛刻要求。工程建设过程中随着工程的推进，尤其是大工程，工程管理对于可信基础上的账簿、设备以及合同等元素管理的需求越加强烈。但由于工程环境及项目成本的限制，相比传统区块链，状态区块链应更具优势。</p>
<p>本文中，在对区块链相关技术进行综述的基础上，对市场上的低存储量区块链技术进行了比较分析，提出了基于状态的低存储量区块链的实现方案和部署思路。然后，在工程项目管理领域中，对提出的低存储量区块链进行了实现和场景分析，表明本文所提方案在保障区块链安全性的基础上，具有项目成本优势。</p>
<span id="more"></span>

<p><strong>论文<a href="/state-chain-on-pm-paper.pdf">PDF标准版下载</a></strong></p>
<h2 id="区块链中存储的成本"><a href="#区块链中存储的成本" class="headerlink" title="区块链中存储的成本"></a>区块链中存储的成本</h2><p>首先，随着技术的提高，假定存储数据的成本呈指数级下降。我们则可得到一个这样的模型</p>
<p>$$c(t)&#x3D;Ae^{-kt}$$</p>
<p>c(t)是在任何给定年份t中存储1GB数据的成本。</p>
<p>A是当前按存储1GB1年的成本。通过Amazon Elastic File System进行定价。使用EFS，全年存储1GB数据的6个副本的成本为每年21.60美元。即A&#x3D;21.60美元。</p>
<p>k是存储成本随着时间推移下降的速度。k越大，价格越快降低。根据过去35年的历史数据，k约为0.2502，但对未来存储成本的预测表明未来这种变化率会下降。</p>
<p>这可以得出我们在任何一年内将要花费的存储容量。现在我们可以计算我们的存储总成本。</p>
<p>每年我们必须为当年收到的新数据支付费用，并继续存储前几年的所有数据。所以每年的存储成本为：</p>
<p>$$S(t)&#x3D;c(t)\sum_{T&#x3D;0}^nPredictedGB(t)$$</p>
<p>由于众所周知的区块链扩容，比如比特币从1MB过渡到2MB，模型中的Predicted_GB本质也是在逐年增加的值。随着数字货币与区块链逐步被越来越多的人所认可，区块容量(BuiltinSize)增加的步伐也越来越快。作为激进的比特币分叉，比特币现金，已经分叉至32MB。从市场来看，越是热门的区块链产品的信息存储量增速越快。而热门程度我们可以根据其代币的交易量来判断。</p>
<p>$$PredictedGB(t)&#x3D;\sum_{d&#x3D;0}^{365}BuiltinSize \times Volume(t,d)$$</p>
<p>那么最终的每年存储成本即为：</p>
<p>$$S(t)&#x3D;Ae^{-kt}\sum_{T&#x3D;0}^n\sum_{d&#x3D;0}^{365}BuiltinSize \times Volume(t,d)$$</p>
<p>总而言之，通过该模型，我们可以清晰地看出，这通过优化后的区块链存储成本模型，最终其是递增膨胀，还是逼近指数下降，取决于科技发展的k值（&lt;1）与年存储量，也可以说是k值与产品热度之间的博弈。作为跑赢市场的明星产品，例如Ethereum，必面临存储量爆炸的问题。当然从一般角度来看，<strong>服务器</strong>硬盘的发展是完全超越一般的区块链增长的。</p>
<p>但是在特定环境，尤其是分布式的物联网环境，区块链上为了实现分布式与数据可信，设备往往分散且数量可观。因此，实际在物联网或多节点等正常区块链环境下，当区块链应用全网设备数为DeviceNum时，存储成本为：</p>
<p>$$S(t)&#x3D;DeviceNum \times Ae^{-kt}\sum_{T&#x3D;0}^n\sum_{d&#x3D;0}^{365}BuiltinSize \times Volume(t,d)$$</p>
<p>也因此，为了节约成本，项目往往选择具有较少的存储空间的设备，这就更进一步限制了区块链存储不能无限制地膨胀。因此，换句话来说，在存储成本较低基础之上，倘若能够限制住区块链数据存储的膨胀，区块链产品则能够部署于更广泛的领域。</p>
<h3 id="区块链在工程管理中的应用"><a href="#区块链在工程管理中的应用" class="headerlink" title="区块链在工程管理中的应用"></a>区块链在工程管理中的应用</h3><p>到目前为止，区块链在建造行业中的实际使用并不常见。有些人正在使用它结合物联网来存储建筑物的传感器数据。还有人认为类似以太坊的分布式平台可以托管BIM应用程序。也有人提到区块链在合建项目中的应用，因为它可以提供一个有用的工具，通过使用智能合约，监控各方在整个设计和施工阶段管理和记录上对BIM模型的更改，即通过编辑和存储建筑模型的所有修改记录到不可变的公共记录中（区块）。</p>
<p>首先，众所周知的是，区块链可以作为数字账簿的存在，如hyperledger，中文名超级账簿。</p>
<p>当前，企业间的战略联盟（partnering模式）中，由于各个企业仍然是独立法人，战略联盟中经常会发生由于道德风险、逆向选择等问题造成的联盟合作关系不稳定。因此，目前急需一种合理的激励机制，保障供应链联盟之间的信息开放共享来防止问题发生。因此，需要一种受到各方信任的信息技术手段，来支持分布式的信息记录储存，联盟中的企业从不同途径来分享多样化的信息。区块链技术的应用，在对企业共识数字化的基础上，受所有人信任，不仅能实现价值共创共享的目标，而且构建了利益相关者之间的共生关系，实现了多元资本共生和利益相关者的共同治理。万达、百度、空客、美国运通、思科、富士通、日立等国内外各个行业的大公司在战略上往往拥有更加错综复杂的联盟关系，因此其对hyperledger的需求更为强烈。除他们以外，hyperledger还有约200余个企业合作伙伴，可见世界领先的企业对区块链在账簿上应用的普遍认可。</p>
<p>虽然区块链技术为项目相关的会计更多样化的工作与管理模式提供了可能。但与金融领域相比，项目管理会计领域拥有复杂性和独特性，区块链技术在该方面应用中依然面临数据存储空间有限、业务数据处理难度高、对现有中心化记录的管理会计基础业务架构和业务规则挑战等问题。</p>
<p>更贴近工程内容的，区块链往往依托着物联网或BIM这类将传统产品信息化的载体，以此方式在工程项目之中得到运用。</p>
<p>以前的方案可用于管理存储在文件中的任何建筑物信息，包括BIM文件。然而，在BIM设置中实施区块链的正确方法是将其与BIM服务器集成。架构如图所示。</p>
<img src="/post/state-chain-on-pm-paper/BIM&BC.jpg" class="" title="BIM">

<p>Barnett正在确定建筑行业中区块链的一些用途，例如维护记录数字财产，基于时间戳记录行为或交易，多重签名交易，智能监控情况并执行自己的计算机程序以及与真实世界结合的智能合约信息存储库。还有争议中能够使用自动化区块链解决方案，基于智能合约的智慧城市，以及区块链房地产投资等也被设想出来。</p>
<!--抄论文-->
<p>Security Ledger指出，“在保卫物联网安全方面最大的挑战之一就是身份问题。更明确一点就是：我们如何确保数十亿或者百亿的智能设备相互之间的连接与交流安全。看起来区块链能够提供答案。”</p>
<p>在与区块链结合之前，物联网一直是个“矛盾的存在”，物联网的发展前景已被所有人认可，但是症结问题一直得不到解决。中心化的管理架构存在无法自证清白的问题，也即不管你是否窃取了参与方的隐私，都容易被怀疑，没有理性的方式可以证明你的清白，完全靠相互的自觉与信任。况且，个人隐私数据被泄露的相关时间时有发生，例如，摄像头被网络直播的事屡见不鲜。物联网的参与者，尤其是工程项目中物联网的参与者，通常不完全被发起方所单独掌控（例如普通私人用户、企业用户），如何让其他的合作方能够更好地参与到项目之中，面临极为复杂的协同成本。</p>
<p>但是如此看待区块链，大多是由于当今区块链产品多基于以太坊等平台，制作思维也跳脱不出数字货币的范畴。以太坊中除了CAP冲突以外，对于合约本身的进行也存在着合约不可修改、合约太过依赖主网等缺陷。这未免太过局限了其区块链应用的发展。本质上来说，区块链的应用重点在于其共识的形成，共识才是一个分布式应用与区块链应用的最大差别，最重要的，包括区块形成条件（挖矿条件）、出块时间、区块存储方式设计等各种被平台所简化的内容本应也是应用的重要内容。</p>
<p>因此除了传统的和物联网、BIM等信息元素结合以外，工程项目之中可以将生产过程、交付过程等一系列费时费力的过程量化编译成数个共识，将这些共识合并起来数字化形成针对项目的合约。</p>
<h3 id="市场上的低存储区块链方案"><a href="#市场上的低存储区块链方案" class="headerlink" title="市场上的低存储区块链方案"></a>市场上的低存储区块链方案</h3><!-- 首先是将状态作为更重要的保存内容。 -->

<p>在UTXO中，比如比特币，抛去了状态的概念，其中账户（即地址）的余额通过与它相关的事务来进行判断，例如某个地址在区块链中的出现是先通过工作证明获得了100货币单位，然后在其之后8个区块时间后它将88个货币单位转移到另一个地址中，其后没有任何相关交易。这样在当一个节点遍历完所有区块之后就可以计算出该地址余额为12个货币单位。</p>
<p>这样的产品设计，虽说要求了节点必须下载并遍历整个区块才能分析出地址余额这样累赘的工作，但是也的确非常成功地解除了他人尤其是非技术人员对区块链的怀疑——至少让区块链概念更加通俗易懂。</p>
<p>可是区块链的不断增长使得这个下载与遍历操作越来越困难。比特币核心开发者团队意识到了这个问题的严肃性。在2016年初bitcoin的区块就已经超过60G，开发者团队在新核心钱包中针对节点新加了区块链存储的修剪模式（prune）。全节点钱包，即核心钱包的使用者通过在个人目录中bitcoin.conf配置文件中，输入“prune&#x3D;1024”并保存，重启钱包后即可打开节点的修剪模式。通过该模式，节点可以将60多G的存储不断删减直至你设定的值（1024mb），且相比以前能更加快速地打开钱包。但是这个模式仍有局限性——及其耗时且耗计算的同步过程：它需要先从p2p网络上下载这所有的区块，再对已下载的区块逐个进行散列计算生成散列值，并校对散列值的树结构，以此保证所下载区块的完整与安全——这样的下载过程中耗费数G的带宽流量以及堪比数字货币挖矿的计算任务依旧非个人电脑，或者非一般的服务器所能承受。尤其是在用户重新导入一个新私钥后，为了获取这个私钥对应地址的余额信息，节点必须再重复一遍上述所有操作。</p>
<p>随着时代的发展，在2016年开始行业进入了基于区块链的链上应用，即分布式应用（decentralized application，简称DApp）的时代。简单来说，DApp和普通的App原理一样，除了他们是完全去中心化的。由底层区块链网络自己的节点来运作的DApp，不依赖于任何中心化的服务器。虽然DApp是去中心化的，可以完全自动地运行，但是依然也有可能性会被入侵。为了要能够很好地使用这些DApp，就需要定制的入口。例如其中较为著名的就是Augur，一个基于以太坊的去中心化市场预测平台，完全不需要通过任何第三方服务器。目前来看，由于以太坊EVM的健壮，大部分分布式应用都是基于以太坊。</p>
<p>但是，从现状来看，如今很多区块链产品中的“永久存储”特性却仅仅只是一个吸引投资人和购买者的华丽噱头，或者说是一个非常普遍的对当下区块链模式的一种妥协现象：想要让人可信就必须永久存储所有事务。毕竟，在以太坊平台上就已经拥有了在链上存储的功能，无需再多费手脚即可拥有。</p>
<p>但是从产品设计的角度来看，在许多的特定环境下，区块链产品本质上其实并不需求永久的存储——例如游戏、匿名货币以及数据存储等。拿游戏作为例子来看，基于区块链的互联网游戏本身就是在飞速信息交换，在存储和带宽以及共识的限制下，这个交换的成本被无限放大。</p>
<p>如CryptoKitties这个在中心化时代看起来非常简单的养猫游戏。</p>
<p>CryptoKitties(加密猫)是因为一款基于以太坊的DAPP，它由设计工作室AxiomZen打造，它是一个围绕着可育，可收集和可爱生物的游戏，每只猫都是独一无二的，100％归您所有，而且它不能被复制，带走或毁坏。</p>
<p>CryptoKitties是世界上第一款基于区块链技术的游戏，这一突破使得一些像比特币和以太坊的虚拟物品成为可能。比特币和以太币是加密货币，但CryptoKitties是加密的收藏品。就像传统的收藏品一样，你可以购买，出售或交易你的CryptoKitty，在知识产权保护上，区块链会监测保障您的所有权。简单来说，就是利用链来存储了信息。</p>
<p>但是在以太坊网络中部署后，由于销量火爆，直接压垮了以太坊平台的交易传输。据悉以太坊网络在该期间平均堵了近2万笔交易。众所周知，无论是以太坊还是比特币都对每个区块限定了大小，这就决定了每次的区块打包交易中交易总数据量都有上限。对于超出上限的交易，就被拖至下个区块中打包。“近2万笔交易”，可见该应用在链上究竟写入了多少庞大的数据。</p>
<p>因此“永久存储”这个功能对于区块链应用底层来说非常容易成为网络的累赘。纵观当今部署的互联网应用，应用都是以一个“状态”实现的部署——持续集成（CI）就是这种理念的实现，通过不停的覆盖“状态”来达到工程合作的统一；同样的还有应用的持续发布，都是以最终的“状态”作为最终的目的。</p>
<p>对于此问题，以太坊选择的是利用分片技术对其网络进行扩容。</p>
<p>“分片”的大致设计思路是：将区块链网络中的每个区块变为一个子区块链，子区块链中可以容纳若干（目前为100个）打包了交易数据的Collation（大概可以称为“校验块”，为了在分片的情景中将其与区块的概念区分开），这些Collation最终组成一个在主链上区块；因为这些Collation是整体作为区块存在的，所以其数据必定是全部由某个特定的矿工所打包生成，本质上和现有协议中的区块没有区别，所以不再需要增加额外的网络确认。这样，每个区块的交易容量就大概扩大了100倍；而且这种设计还有利于未来的继续扩展，整个扩展计划目前也被大致分为4个阶段；本文所介绍的仅仅是第一阶段的相关实现细节。本质来说就是通过层叠的状态和少量的过程区块来保证性能与可信的双重获利。除此之外，以太坊在新节点部署上通过引入账户（Account）与状态（State）的概念来实现区块更加迅速的同步。其中账户即为已经出现在链上的地址，而状态即为一个时间点上账户及其相关信息的列表。</p>
<p>其实在以太坊启用分片之前，在市场上早已经出现了成型的利用类似技术的数字货币，PascalCoin，它通过pascal编程语言重写了比特币奠定的数字货币的架构，并且引入了账户和状态的概念，实现了其数字货币后台区块链的秒同步。但是，由于高度去中心化的办公模式带来的低效更新以及pascal编程语言死气沉沉的社区，目前情况来看，其在链上应用等方面的发展非常局限。</p>
<!-- pascalcoin的工作模式如图所示balabala -->
<p>简单来说，PascalCoin中的块将超过100的检查点高度新的块将附加到链的顶部，旧的块从底部删除，只有一个任何时候都将需要不断的块数。检查点在每100个区块中发生一次，并简单地压缩成SafeBox。当新节点加入网络时，它只会下载最新的检查点和几十个块。此外，SafeBox现在包含在每一个账户段子结构块头信息中。这使得节点成为能独立地计算、验证和构建SafeBox结构所需的累积工作。</p>
<p>它通过以下方式实现:</p>
<ul>
<li>检查是否所有区块头通过SafeBox以类区块链接方式连接</li>
<li>使用工作证明方式重新计算SafeBox的累积工作</li>
<li>验证是否SafeBox的累积工作是网络中最大的已知工作。</li>
</ul>
<p>因此，相比其他加密货币，PascalCoin会以指数方式达到更高的每单位存储吞吐量，因为节点只需要存储网络吞吐而不是累积的网络吞吐量。 换句话说，PascalCoin存储的是交易流，而不是交易历史 。如果流量不变，存储也是恒定的。这里要提醒的是SafeBox确实在每个区块都变得可以忽略不计，但总是在固定数量中且无论交易数量如何变化。</p>
<p>且由于节点在任何时间只需要保持100个块，所以相比其他加密数字货币，PascalCoin考虑到了以指数方式增长的更大的区块规模。例如，对于相同数量的存储，即一个Bitcoin节点在现在消耗的存储，PascalCoin理论上可以支持吞吐量为每秒72,000个交易，本地只需5.4GB区块大小。</p>
<p>从模型角度来说，传统区块链，例如比特币，区块大小起初线性增长，在触及区块上限后开启扩容分叉。</p>
<p>而状态链限制其账户增长。PascalCoin的主要新功能之一是帐户可以有唯一的公开可见的名称，与域名系统的方式大致相同。这允许用户接收资金到他们的电子邮件地址或聊天昵称。它允许商店用他们的域名或品牌名称收款。支付本质上仍然是通过数字号码来引用帐户，但是名称用于查找背后的帐号，就像是域名是用于查找背后的IP地址。</p>
<h2 id="低存储方案"><a href="#低存储方案" class="headerlink" title="低存储方案"></a>低存储方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然区块链总是存在着在新块生成同时有分叉的风险，但是在旧的区块链中，各节点总是形成相同的一条无任何分叉的链</p>
<p>传统的区块链存储结构与内容如下图所示：</p>
<img src="/post/state-chain-on-pm-paper/OriginBlockchainStructure.jpg" class="" title="OriginBlockchainStructure.jpg">

<p>可见大部分数据（难度、随机数、版本号等）都存在非常严重的冗余。而交易数据根据UTXO形式，分为交易发送者、交易接受者、交易货币数量、以及交易签名。其中交易签名占空间最大且基本上是一次性数据，对区块链后续发展并无推动作用。</p>
<p>因此我们需要从区块链结构入手设计低存储区块链的设计。</p>
<img src="/post/state-chain-on-pm-paper/4NodesNetwork.png" class="" title="4NodesNetwork.png">

<p>如图中四个区块链节点形成了一个区块链网络。我们可以看到每个节点都保存了从创世区块（GenesisBlock）到N号区块（BlockN），因此从创世区块到N号区块之间的链，根据共识来说，它们就是经过了所有节点的审计且已经可以被我们认为是可信的——那么对于可信的内容，我们则无需再进行验算（尤其是私钥导入新节点接入等流程中），因而我们可以将其删除。但是为了下方（N+1）号区块以及更新的节点的安全保证，我们仍然需要k个区块来形成最长链以防止分叉。同时为了防止数据的丢失，我们也应当将从创世区块到N号区块之间的链中的数据以其他格式存储起来。</p>
<p>因此我们将创世区块到（N-k）号区块的内容整合为“状态区块”来保存内容。</p>
<img src="/post/state-chain-on-pm-paper/IntroStateBlock.png" class="" title="IntroStateBlock.png">

<p>在每过一定阶段，根据全网节点状态进行区块删减，形成由数个“状态区块”形成的“状态区块链”。但是由于状态内容的冗余与过时我们仅仅保留数个最新块。最终则形成了我们的新方案。</p>
<img src="/post/state-chain-on-pm-paper/WithBIM.png" class="" title="WithBIM.png">

<p>用公式表示原始方案与改进方案的存储量如下</p>
<p>原始方案即为直接对区块的存储。StorageSize为总存储规模，blockHeight为区块高度（个数），BlockSize为内置的区块大小，例如Bitcoin初始为1M。<br>$$ StorageSize(blockHeight) &#x3D; BlockSize \times blockHeight $$</p>
<p>而在针对存储内容优化的新方案中，去除了极大部分的区块，引入了新的”状态区块”Generation来存储每个时间段账户信息。其中，StorageSize为总存储规模，blockHeight为区块高度（个数），GenerationSize为单个“状态区块”的大小，为了安全我们本地需要两个状态区块来保证安全性。CredibleHeight为可信高度，在PascalCoin中该高度被固定设定为100个区块。BuiltinTxNum为单个区块中的事务（交易）个数。<br>$$ StorageSize(blockHeight) &#x3D; BlockSize \times (blockHeight \bmod CredibleHeight) + GenerationSize(blockHeight) + GenerationSize(\lfloor \frac{blockHeight}{CredibleHeight} \rfloor ) $$</p>
<p>$$ GenerationSize(blockHeight) \approx \frac{BlockSize \times blockHeight}{BuiltinTxNum} $$</p>
<p>从数学模型可见，该方案除了删除了大部分冗余数据以外，还限制住了数据量体积，可以有效防止数据量的无限扩张。</p>
<h3 id="为什么该方案依旧安全可信"><a href="#为什么该方案依旧安全可信" class="headerlink" title="为什么该方案依旧安全可信"></a>为什么该方案依旧安全可信</h3><p>Bitcoin从Merkle树，即默克尔树出发来保证区块安全。如上所述，在进行区块“压缩”、“删减”过程之中链的默克尔树实际上是被破坏了——无法从创世区块重新递推至最新块。</p>
<p>但这并不意味着方案的安全性被打破。我们的关注点在于共识之上——在共识中，所有达到了N的节点在确认全网都已经达到N（通常实践上由8个“确认”消息来判断，与Bitcoin交易的广播类似）之后都会将（N-k）号区块之前的区块进行“删减”——这就如同一次简易的硬分叉（hard fork），在共识之中，虽然树被打破，但是所有交易信息所有事务的结果不会丢失。</p>
<p>而且，新方案中依然存在着默克尔树。首先是“状态区块”能够形成简短的默克尔树，防止恶意用户上线多个恶意节点利用共识篡改历史数据。其次，区块的默克尔树依然存在，但仅仅服务于现在与未来，关注于新区块是否安全可信。</p>
<!-- 3. 为什么该方案在低存储基础上还能低膨胀？ -->

<h3 id="低存储的应用部署思路"><a href="#低存储的应用部署思路" class="headerlink" title="低存储的应用部署思路"></a>低存储的应用部署思路</h3><!--非工程环境，通用思路-->
<p>本质来说，低存储方案中应用部署相比正常方案中并不具有相对更多的限制。但是若是需要最大程度地发挥其中优势，则需要更好地对应用进行筛选。</p>
<p>首先，最佳效果之下，信息应当存储于各个账户的状态之中。如此便可直接摆脱UTXO货币在导入新私钥时，或是创建账号地址时，不得不通过P2P网络将所有区块同步之后才能安全进行其余例如交易等操作的这一困境。这对于数字货币钱包来说，是加强了其易用性，几乎能够直接在打开瞬间开始进行操作。且摆脱了SPV协议轻钱包。由于SPV钱包不能检查区块上任意其他的交易，理论上讲，区块就有可能是无效的。而且spv协议往往指向一个中心服务器，这可能被重定向到一个恶意地址，给用户带来财产损失的风险。这对于如以太坊这类的应用入口来说，更可以大大加快应用开发速度，加快应用加载速度。</p>
<p>其次，尽可能地删除不必要的旧区块。在过了可信高度，即几乎所有节点的区块链存储都高于某一高度一定高度之后，区块链系统完全可以将某一高度前的区块进行删除来达到节省存储空间的目的。因为首先数据我们是选择存储在各个账户状态之中，换句话说就是即便删除了历史的区块也不会造成信息的损失。其次我们所有节点都在这“某一高度”上方，我们在这“某一高度”上达成了共识，即每个节点在“某一高度”之前的区块都是完全相同的，之后的区块的merkle树或trie树都可以在这“某一高度”开始进行，不必强制从创世区块开始。对于这之前的区块，已经无特别重要的作用，当然对于存储空间足够的设备来说依然可以保留这些区块，但是对于空间较小或者更加集约的环境下，将这之前的区块删除应当是最为正确的操作。</p>
<p>再者，必须限制账户、事务的膨胀。首先，区块的大小和事务数量有直接关系，因此中本聪利用了fee也就是手续费概念，fee的竞争以及区块打包交易上限增加了事务进入系统的成本，以此来防止事务的过度或恶意的膨胀。</p>
<p>其次由于新的区块链中选择将信息存储于账户之中，因此在打包账户时账户数量和使用存储量有直接的正比关系</p>
<p>$$ StorageSize &#x3D; kAccountNum $$</p>
<p>倘若不限制账户数量，依旧和比特币一样提供无限的基于私钥与ECDSA椭圆曲线数字签名算法生成的账户地址，那么存储量很容易脱离监管。例如可能有人恶意地通过给许多未在网络出现的地址发送事务，强制增加了许多新的账户，那么在该网络下：</p>
<p>$$ NewAccountNum &#x3D; TransactionNum $$</p>
<p>而为了交易的速度，我们往往在一个区块中打包许多事务。如比特币中，一般一个交易（事务）在250字节左右，扩容前1M大概就能容纳4000多笔。</p>
<p>$$ NewAccuntNum &#x3D;  TransactionNum &#x3D; 4000 $$<br>$$ AccountNum &#x3D; OriginalAccountNum + NewAccuntNum $$<br>$$ StorageSize &#x3D; kOriginalAccountNum + 4000k &#x3D; OriginalStorage + 4000k $$</p>
<p>即每次都需要增加整整4000k大小存储空间，而由于在攻击下，大部分账户不具有真实性，并不真正被他人使用，即很可能这4000k大小将是无用的。随着时间推移以及区块高度增加，在攻击之下的真实账户所占空间增长缓慢，无用账户所占空间却越来越多，最终和改良前无用区块冗余的状态一致。即无法达到限制膨胀，无法将其应用于多设备尤其是类似物联网的场景之中。可见限制账户与事务非常有必要。</p>
<!-- 另外，更切实的智能合约。结合工程详情 -->

<h2 id="项目案例"><a href="#项目案例" class="headerlink" title="项目案例"></a>项目案例</h2><p>实际工程项目中可能涉及工地环境，计算机环境以及经济环境等等具有非常鲜明特点且各不相同的方面。</p>
<p>因此，区块链在工程的每个部分中的应用都有所不同。但是在大多数场景中，我们都可以将其功能与需求部署在区块链中，从最基本的可信数据存储的基础之上开始向上增加特性。</p>
<h3 id="应用概述"><a href="#应用概述" class="headerlink" title="应用概述"></a>应用概述</h3><p>本案例从事务存储角度进行，假设进行的是一个混合了高频率的物联网监管信息监管以及企业间合约的共识化</p>
<p>首先，我们通过定义一系列参数为常见数字货币公有链中内置参数，来模拟通用状态下，基于状态的理论低存储非膨胀方案相比原始中本聪论文内方案在存储上的差异。</p>
<!--多扯点-->
<p>其次针对工程设计与安全责任的监控项目的低存储区块链化的目标设定相关内容，进行实验</p>
<p>最后根据工程合同的低存储区块链化来制定另一实验。</p>
<h3 id="不同的区块链底层设计"><a href="#不同的区块链底层设计" class="headerlink" title="不同的区块链底层设计"></a>不同的区块链底层设计</h3><!--代码细节-->
<p>首先，基于Python，我们可以从中本聪（Satoshi）论文中轻易地制作一个基本的区块链模型。</p>
<p>为了快速地实现多层的区块，我们可以将其中繁杂的工作证明、密钥交换、交易签名等安全细节删去。最终我们生成一个较为简易但具有完整的在挖矿成功后建立新区块并对数据进行存储的功能。</p>
<p>然后我们再建立一个基于状态的区块链系统。除了Block区块以外，我们还需要一个新的对象——该对象需要保存一个时间点上的账户状态信息以及之前历史区块信息，同时它也和传统的区块一样能够通过散列值来形成一个链。如前文介绍中简写，该“状态区块”也可以叫做Generation（代）。同样地为了测试我们将其中繁杂的工作证明、密钥交换、交易签名等安全细节删去，将判断可信高度的方法简便化。但是依然保留状态区块链之中删除历史区块的功能。</p>
<!--介绍！！！-->

<p>最终我们再写一个程序，通过该程序我们能对两个系统进行“挖矿”操作。简单来说，该程序能够在两个系统之中分别注入相对相同的事务信息，并不断激活两者新区块打包存储功能。在这个过程之中，两个不同的区块链系统会用两者不同的方式打包交易。但是，状态区块链除了单纯的打包储存以外，也会将交易信息在生成状态区块的过程中归纳进账户信息之中，在每个可信高度之后追加一个包含当前时间点链上所有账户的“状态区块”，并删除可信高度个“状态区块”之前的过久的区块。</p>
<p>公平起见，所有写入区块的交易本质相同，唯一不同在于低存储区块链中为数字（账户编号），传统区块链之中为对该数字进行类比特币地址生成方式处理（即sha256计算散列后将该值进行base58加密）后得到的地址。</p>
<p>此外，我们还可以通过修改模拟生成的交易内容来控制对实验内容的模拟。</p>
<p>在工程设计与安全责任的监控项目的低存储区块链化中，大部分事务是由物联网设备的工作证明与工作状态构成。这里的工作证明和传统的数字货币的工作证明挖矿是有些许区别的，工作内容不再是通过计算无意义的散列值，而是根据工程环境进行定制。例如在我们假设的传感器监控环境之中，所有进行正常工作（搜集数据，打包数据，分析数据等等）的时间都可以被视为其工作，而其对于每个时间段进行的工作总结即为工作证明。换句话说，我们是摆脱了账户间交易，或者说是只考虑工作证明并没有其他账户之间的交易，即我们可以选择将事务发送目标与发送货币数量字段都设置为空且增加可能的账户数（通用场景中设为100，在多设备的监控环境之中设置为10万，即100000）。对应的，又由于高速出块，我们将可信高度也拔高数倍（10000）。</p>
<p>在工程合同的低存储区块链化项目之中，往往参与账户相对较少（100），企业之间即合约内的总代币量不变。公司（账号0）为总发包方，即最终的代币兑现方，在初始即创世区块中账户就具备该代币量。其他各个承包方与“0”公司，或承包方之间，进行代币交易并在交易内签署合同落实细则来实现现实中项目转接或合同内外事件的发生。该场景下对于共识中区块生成条件没有额外要求，但是在最优情况下，应当结合底层设施，或者底层人员，对于项目工作落实的监测与管理汇报，在与实际工作相有机结合之后来实现上层管理（合约）与下层劳动的联动。在保证工作基础上，透明化联盟内合作企业之间关系，真正实现付出换来收获，也最大幅度地扩大各企业效益。</p>
<h3 id="模拟数据"><a href="#模拟数据" class="headerlink" title="模拟数据"></a>模拟数据</h3><!--图表-->
<p>通过Python制作的相关应用，我们可以得到各方案在区块存储方面随着区块高度逐步增加而变化的状况。我们将数据再次用Python清洗整理后，通过JavaScript配合Echarts进行渲染，我们即可得到可视化的数据图。</p>
<p>最终我们能够得到对比结果</p>
<img src="/post/state-chain-on-pm-paper/image0001.png" class="" title="image0001">

<p>具体的，对于传统区块链的存储使用情况如下：</p>
<img src="/post/state-chain-on-pm-paper/image0002.png" class="" title="image0002">

<p>对于状态的低存储区块链模型在使用中存储情况如下：</p>
<img src="/post/state-chain-on-pm-paper/image0003.png" class="" title="image0003">

<p>首先我们录入的数据分为两种。</p>
<p>第一种工程设计与安全责任的监控项目的低存储区块链化中，与第二种在工程合同的低存储区块链化项目之中，我们得到的结果都和通用情况下结果相近。</p>
<p>更详细<strong>实验与后续分析</strong>请见最上面PDF</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>blockchain</tag>
        <tag>paper</tag>
        <tag>project mManegement</tag>
      </tags>
  </entry>
  <entry>
    <title>WASM 2Master</title>
    <url>/post/wasm-2-master/</url>
    <content><![CDATA[<p>因为NGIN的缘故，所以相当于是加入了wasmtime这个坑里。</p>
<p>虽然名义上bytecodealliance算是正规军但是有一说一至少这个wasmtime-go做的稀烂啊……</p>
<p>这里就拿rust(写&amp;编译wasm)+wasmtime-go(调用)来介绍。</p>
<span id="more"></span>

<h2 id="Beginning"><a href="#Beginning" class="headerlink" title="Beginning"></a>Beginning</h2><p>首先得推荐一个工具<a href="https://webassembly.github.io/wabt/demo/wasm2wat/" target="_blank" rel="noopener">wasm2wat</a>。既然是想耍wasm那肯定听说过wat，因为现在各个语言对wasm的支持都一言难尽，所以个人经验来说是有事没事转成wat看看挺好的。</p>
<p>然后就是一些基本概念</p>
<p>基本上都在<a href="https://webassembly.github.io/spec/core/" target="_blank" rel="noopener">官方文档</a>里</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>WASM底层内部就四种值：字节(Bytes),整数(Integers),浮点数(Floating-Point),还有命名(Names，基本上可以理解为string)</p>
<p>这里的值和后面类型里的值是不一样的，这里是底层实现上的，类型的偏应用上。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>值做开发时候一般没啥感知，但是类型就不一样了，处处受它制约。</p>
<p>WASM有这样几个类型：值，结果，函数，约束，内存，表，全局，导出。</p>
<p>好像约束是最近多出来的以前好像没见过(</p>
<h4 id="值-1"><a href="#值-1" class="headerlink" title="值"></a>值</h4><p>就四种值：i32，i64，f32，f64。其中i表示整型，f表示浮点，32，64就是位，比如f64就是等价于其他语言类型的float64。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>表示一系列指令或者函数执行后的结果</p>
<p>结果本质上是一个值(上面那个i32这样的)的队列</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数类型对函数的签名进行分类，将参数映射到结果。</p>
<p>还用于对指令的输入和输出进行分类。</p>
<p>就类似C语言头文件里那个对函数的预定义，就写个名字，参数(类型)和结果(类型)</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束对与内存和表关联的可调整大小的存储的大小范围进行分类。</p>
<p>如果没有给出最大值，则相应的存储可以增长到任何大小。</p>
<p>换句话说就是把WASM沙箱当虚拟机client，约束就控制它的内存存储防止它把host资源用了</p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>内存是个线性的存储器，可以用约束对它进行限制，以页面大小为单位。</p>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表就相当于一些语言里的hashMap或者Array。</p>
<p>像内存一样，表格的最小和最大大小也受到约束，单位是条目数。</p>
<p>其中元素类型funcref是所有函数的无限并集。因此，有这个类型的表就相当于包含对函数的引用。</p>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><p>就修饰其他值说明其为全局变量，可变也行不可变也ok。</p>
<h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>导出是修饰其他值来说明其可外部访问&#x2F;调用。</p>
<h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>也很可能加别的类型，请告知我更新</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>WebAssembly代码由指令序列组成。它的计算模型基于堆栈计算机，其中指令在隐式操作数堆栈上操纵值，消耗（pop）参数值并生成或返回（push）结果值。</p>
<p>除了来自堆栈的动态操作数外，某些指令还具有静态直接变量，通常是索引或类型注释，它们是指令本身的一部分。</p>
<p>一些指令的结构形式是，它们将嵌套的指令序列括起来。</p>
<p>指令里包括： 数值，参数，变量，内存，控制，表达式</p>
<p>简单点讲就是对不同的类型的不同使用方式罢了</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>个人觉得这个很重点，经常考。</p>
<p>WebAssembly中的代码的可分发，可加载和可执行单元称为模块。 </p>
<p>在运行时，可以使用一组导入值实例化一个模块以生成一个实例，该实例是一个不可变的元组，引用了正在运行的模块可访问的所有状态。 </p>
<p>多个模块实例可以访问相同的共享状态，这是WebAssembly中动态链接(dynamic linking)的基础。 WebAssembly模块还可以在将来与ES6模块集成</p>
<p>一个模块包含以下部分：</p>
<ul>
<li>导入</li>
<li>导出</li>
<li>程序开始函数</li>
<li>全局</li>
<li>内存</li>
<li>数据</li>
<li>表</li>
<li>元素</li>
<li>函数和代码</li>
</ul>
<p>一个模块还定义了几个索引空间，这些索引空间由模块中的各种运算符和section字段静态索引：</p>
<ul>
<li>函数索引空间</li>
<li>全局索引空间</li>
<li>线性内存索引空间</li>
<li>表索引空间</li>
</ul>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>一个模块可以声明一系列导入，这些导入在实例化时由宿主机环境提供。有这样几种：</p>
<ul>
<li>函数导入，可以由<code>call</code>函数在模块内部调用；</li>
<li>全局导入，可以由全局操作在模块内部访问；</li>
<li>线性内存导入，可以由内存操作在模块内部访问；和</li>
<li>表导入，将来可以通过call_indirect和其他表运算符在模块内部访问。</li>
</ul>
<p>将来可能会增加其他的导入。导入的目的是在允许模块共享代码和数据情况下，同时允许单独的编译和缓存。</p>
<p>所有导入都包括两个显性名称：模块名称和导入名称，必须是有效的UTF-8。这些名称的解释取决于宿主机环境，但旨在允许宿主机环境（如Web）支持两级命名空间。</p>
<p>每种特定的导入类型都定义了额外字段：</p>
<p>函数导入包括用于模块内部导入函数的签名。主机环境定义了针对模块外部导入功能的签名检查。但是，如果导入的函数是WebAssembly函数，则如果签名不匹配，则宿主机环境必须触发实例化时间错误。</p>
<p>全局变量导入包括全局变量的值类型和可变性。这些字段的含义与“全局”部分中的含义相同。在最简化实现中，全局变量导入必须是不可变的。</p>
<p>线性内存导入包括“线性存储器”部分中定义的相同字段集：初始长度和可选的最大长度。主机环境必须仅允许导入WebAssembly线性内存，这些内存的初始长度大于或等于导入中声明的初始长度，并且最大长度&lt;&#x3D;导入中声明的最大长度。这样可以确保可以进行单独的编译：在声明的初始长度以下的内存访问始终是入站的，在声明的最大长度以上的内存访问始终是越界的，如果初始等于最大值，则该长度是固定的。在最简实现中，每个内存都是默认内存，因此至多可以有一个线性内存导入或线性内存定义。</p>
<p>表导入包括“表”部分中定义的相同字段集：元素类型，初始长度和可选的最大长度。与线性内存部分一样，主机环境必须确保仅导入具有完全匹配的元素类型，初始长度等于或大于最大长度，或等于或小于等于最大长度的WebAssembly表。在MVP中，每个表都是默认表，因此最多可以有一个表导入或表定义。</p>
<p>由于WebAssembly规范未定义如何解释导入名称：</p>
<ul>
<li>Web环境将名称定义为UTF8编码的字符串；</li>
<li>宿主机环境可以将模块名称解释为文件路径，URL，一组固定的内置模块中的密钥，或者主机环境可以调用用户定义的挂钩将模块名称解析为其中之一；</li>
<li>模块名称不需要解析为WebAssembly模块；它可以解析为内置模块（由主机环境实现）或以其他兼容语言编写的模块；和</li>
<li>调用导入函数的含义是宿主机定义的。</li>
</ul>
<p>模块导入的开放性使得它们可以用于向WebAssembly代码公开任意宿主机环境里的函数，类似于本机syscall。例如，一个shell环境可以定义一个带有内置stdio模块<code>puts</code>的导出。</p>
<h4 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h4><p>模块可以声明一系列导出，这些导出在实例化时返回给主机环境。每个导出都有三个字段：一个名称（必须是有效的UTF-8），其名称由主机环境定义；一个类型（用于说明导出是函数，全局，内存还是表），以及指向类型对应索引空间的索引。</p>
<p>所有定义都是可导出的：函数，全局变量，线性内存和表。导出了的定义的实际含义由宿主机环境定义。但是，如果另一个WebAssembly实例导入该定义，则两个实例将共享相同的定义，并且共享了关联的状态（全局变量值，线性内存字节，表元素）。</p>
<p>导出名称必须唯一。</p>
<p>在最小实现中，只能导出不可变的全局变量。</p>
<h4 id="模块启动函数"><a href="#模块启动函数" class="headerlink" title="模块启动函数"></a>模块启动函数</h4><p>如果模块已定义起始节点，则在实例实例初始化之后，包括通过“数据”和“元素”部分的“内存”和“表”，以及可调用导出的函数之前，加载器应调用它引用的函数。</p>
<ul>
<li>start函数不能接受任何参数或返回任何内容</li>
<li>该功能由功能索引标识，可以是导入的，也可以导出的</li>
<li>每个模块最多只能有一个起始节点</li>
</ul>
<p>例如，模块中的起始节点将是：</p>
<p><code>(start $start_function)</code></p>
<p>要么</p>
<p><code>(start 42)</code></p>
<p>在这第一个示例中，预期环境在调用任何其他模块函数之前先调用函数$start_function。在第二种情况下，预期环​​境将调用索引为42的模块函数。该数字是从0开始的函数索引（与导出相同）。</p>
<p>一个模块可以：</p>
<ul>
<li>最多只有一个起始节点</li>
<li>如果模块包含起始节点，则必须在模块中定义功能</li>
<li>在加载模块之后且对模块函数的任何调用完成之前，将调用start函数</li>
</ul>
<h4 id="全局部分"><a href="#全局部分" class="headerlink" title="全局部分"></a>全局部分</h4><p>全局部分提供了零或数个全局变量的内部定义。</p>
<p>每个全局变量内部定义都声明其类型（值类型），可变性（布尔标志）和初始值设定项（初始值设定项表达式）。</p>
<h4 id="线性内存部分"><a href="#线性内存部分" class="headerlink" title="线性内存部分"></a>线性内存部分</h4><p>线性内存部分提供了一个线性内存的内部定义。在最小实现中，每个内存都是默认内存，并且最多可以有一个线性内存导入或线性内存定义。</p>
<p>每个线性内存部分都声明一个初始内存大小（随后可以通过grow_memory增加）和一个可选的最大内存大小。</p>
<p>如果尝试增长超过声明的最大值，grow_memory将确保失败。 声明后，实现应（非规范性的）尝试保留最大大小的虚拟内存。 分配初始内存大小失败是运行时错误，而保留最大内存失败则不是。 如果未声明最大内存大小，则在虚拟地址空间有限的体系结构上，引擎应仅分配初始大小并按需重新分配。</p>
<h4 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h4><p>线性存储器的初始内容为零。</p>
<p>数据节包含一个可能为空的数据段数组，这些数据段指定给定内存的固定（偏移，长度）范围的初始内容，该内容由其线性内存索引指定。</p>
<p>数据部分类似于原生可执行文件的<code>.data</code>部分。</p>
<p>长度是一个整数常数值（定义给定段的长度）。偏移量是一个初始化表达式。</p>
<h4 id="表部分"><a href="#表部分" class="headerlink" title="表部分"></a>表部分</h4><p>表格部分包含零或数个不同表格的定义。在最小实现中，每个表都是默认表，并且至多一个表导入或表定义。</p>
<p>每个表定义都声明一个元素类型，初始长度和可选的最大长度。</p>
<p>在最小实现中，唯一有效的元素类型是<code>anyfunc</code>，但将来，可能会添加更多元素类型。</p>
<p>在最小实现中，只能通过宿主机定义的API（例如JavaScript的<code>WebAssembly.Table.prototype.grow</code>）来调整表的大小。将来可能会添加一个grow_table。</p>
<p>在任何一种情况下，如果试图增长到声明的最大值以上，表增长都会失败。与线性内存一样，当声明最大值时，实现应（非规范）尝试将虚拟内存保留为最大大小。分配初始内存大小失败是运行时错误，而保留最大内存失败则不是。如果未声明最大内存大小，则在虚拟地址空间有限的体系结构上，引擎应仅分配初始大小并按需重新分配。</p>
<h4 id="元素部分"><a href="#元素部分" class="headerlink" title="元素部分"></a>元素部分</h4><p>表中元素的初始内容是个标记值（如果被调用，则会被捕获）。 </p>
<p>元素部分允许模块使用模块中的任何其他定义初始化（在实例化时）任何导入的或内部定义的表的元素。这与数据部分允许模块初始化任何已导入或已定义存储器的字节对称。</p>
<p>元素部分包含元素段的可能为空的数组，这些元素段指定给定表的固定（偏移，长度）范围的初始内容，该范围由表索引指定。</p>
<p>长度是一个整数常数值（定义给定段的长度）。偏移量是一个初始化表达式。元素由它们在相应索引空间中的索引指定。</p>
<h4 id="功能和代码部分"><a href="#功能和代码部分" class="headerlink" title="功能和代码部分"></a>功能和代码部分</h4><p>一个逻辑功能定义由以下两个部分决定</p>
<ul>
<li>函数部分声明模块中每个内部函数定义的签名</li>
<li>代码部分包含功能部分声明的每个函数的函数主体</li>
</ul>
<p>此拆分通过将构成模块大部分字节大小的函数主体放在结尾处来帮助进行流式编译，以便在编译开始之前可以使用递归模块加载和并行编译所需的所有元数据。</p>
<h4 id="功能索引空间"><a href="#功能索引空间" class="headerlink" title="功能索引空间"></a>功能索引空间</h4><p>函数索引空间对所有导入的和内部定义的函数定义建立索引，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，函数导入（如果有），然后是模块内定义的函数。</p>
<p>函数索引空间由以下部分使用：</p>
<ul>
<li>调用，以识别直接调用的被调用函数。</li>
<li>元素。</li>
<li>导出，以确定哪些功能公开给嵌入器。</li>
<li>启动函数，以确定实例完全初始化后调用哪个函数。</li>
</ul>
<h4 id="全局索引空间"><a href="#全局索引空间" class="headerlink" title="全局索引空间"></a>全局索引空间</h4><p>全局索引空间对所有导入的和内部定义的全局定义进行索引，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，首先是全局导入（如果有），然后是模块内定义的全局。</p>
<p>全局索引空间用于：</p>
<ul>
<li>全局变量访问运算符，标识要读取&#x2F;写入的全局变量</li>
<li>数据段，以将数据段的偏移量（在线性存储器中）定义为全局变量的值</li>
<li>线性内存索引空间</li>
<li>线性内存索引空间索引所有导入的和内部定义的线性内存定义，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，首先是内存导入（如果有），然后是模块内定义的内存。</li>
</ul>
<p>线性内存的索引空间仅由数据部分使用。在最小实现中，最多只有一个线性内存，因此该索引空间只是当可以有多个内存时使用的占位符。</p>
<h4 id="表索引空间"><a href="#表索引空间" class="headerlink" title="表索引空间"></a>表索引空间</h4><p>表索引空间为所有导入的和内部定义的表定义建立索引，并根据模块中定义的顺序（由二进制编码定义）分配单调递增的索引。因此，索引空间从零开始，首先是表导入（如果有），然后是模块中定义的表。</p>
<p>表索引空间仅由元素部分使用。在最小实现中，最多有一个表，因此该索引空间只是可以存在多个表时的占位符。</p>
<h3 id="初始化程序表达式"><a href="#初始化程序表达式" class="headerlink" title="初始化程序表达式"></a>初始化程序表达式</h3><p>初始化程序表达式在实例化时进行执行，现在用于：</p>
<ul>
<li>定义全局变量的初始值</li>
<li>定义数据段或元素段的偏移量</li>
</ul>
<p>一个初始化程序表达式是纯WebAssembly表达式，其编码与WebAssembly表达式相同。并不是所有的WebAssembly运算符都可以或不应该在初始化表达式中得到支持。初始化表达式表示WebAssembly表达式的最小纯子集。</p>
<p>在最小实现中，为了使事情简单，同时仍支持动态链接的基本需求，初始化器表达式仅限于以下空运算符：</p>
<ul>
<li>四个常量运算符</li>
<li><code>get_global</code>，其中全局索引必须引用不可变的导入。</li>
</ul>
<p>将来，可以添加诸如<code>i32.add</code>之类的运算符，以实现更具表现力的base + offset耗时计算。</p>
<h3 id="Tricks-基本操作"><a href="#Tricks-基本操作" class="headerlink" title="Tricks 基本操作"></a>Tricks 基本操作</h3><p>很明显哈，wasm半点都没提到string或者bytes，那么在使用嵌入式的WASM模块时候我们怎么输入string和bytes(Uint8Array)？</p>
<p>先从非语言相关角度看，由于没法传数组没法传不定参数，所以我们需要一个起点和一个长度来定位需要导入的string。因此就直接发送指针位置和长度两个值作为i32到WASM就充当了string。</p>
<p>就相当于，宿主机往内存写入数据，然后把位置和长度告诉WASM，WASM再从内存上取出来。</p>
<p>这里有个增强WASM的rust库，wasm-bindgen，基本上能帮忙把东西都给实现了</p>
<p>【吐槽一下基本上每个WASM相关rust库都能看到alexcrichton在回答issue……劳模啊……</p>
<p>做WASM开发的时候可以把<code>.wasm</code>看作是一个dll，so或者out，面向的是WASM这个系统，所以就可以意识到为啥内置没string这些高级的类型了【不让你写0101已经很不错了。</p>
<p>那么这么来看wat就是汇编语言了:-)</p>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// no_mangle表示不会为函数进行函数名混淆，保证FFI名字不变</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">string</span>() <span class="punctuation">-&gt;</span>  *<span class="keyword">const</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="string">b&quot;Hello, World!\0&quot;</span>.<span class="title function_ invoke__">as_ptr</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么我们可以通过<code>instance.GetExport(&quot;memory&quot;).Memory().UnsafeData()</code>获取<code>Hello, World!</code>?</p>
<p>因为编译的时候这个Hello world就被写进了wasm里面，是·个·常·量！初始化之后就理所当然进了线性内存(liner memory)里。call string的时候本质就是string乖乖把<strong>在WASM上的</strong>内存地址给返回了。</p>
<p>也就是说相当于</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="WASI"><a href="#WASI" class="headerlink" title="WASI"></a>WASI</h2><p>WASI 是个很有趣的东西，他就直接把WASM带到了系统上</p>
<p>在<a href="https://github.com/WebAssembly/WASI/issues/223%EF%BC%8C" target="_blank" rel="noopener">https://github.com/WebAssembly/WASI/issues/223，</a> 有个回答很精妙：At an application level though, the direction WASI is heading is away from “A passes B a string, then then B opens the resource”, and toward “A opens the resource and passes B a handle”. 这其实也就是WASM工作的原理。</p>
<h2 id="NGIN"><a href="#NGIN" class="headerlink" title="NGIN"></a>NGIN</h2><p>在链上应用我需要的是其对链上信息(block, tx etc)做出反应。</p>
<p>例如，子网币的发行针对主网矿工，那么其应当在WASM中维护一个account balances，然后对block的事件侦听来实现分发，对tx事件侦听实现交易。</p>
<p>那么换句话说，我们只需要把外部信息(结构体)传递到WASM沙箱中作为事件，然后再加点getter。</p>
<p>当然我们也要提供好存储。</p>
]]></content>
      <tags>
        <tag>wasm</tag>
        <tag>wasi</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么选择放弃在block中加入sheet</title>
    <url>/post/why-shouldnt-put-sheet-into-block/</url>
    <content><![CDATA[<p>先简单说下最开始的Vault，vault是一个从上个vault角度对一个范围内block的状态总结，包含一个叫sheet的map(s)来存放最终账户数据（公钥，数据，合约etc）。然后由于同步和验证等过程中因为将vault并入了block的chain中所以每次都要swich type相当别扭，所以删除了vault，将sheet放进了block里。然后就是出现如下弊端。</p>
<span id="more"></span>

<p>最开始独立的vault设计虽然在同步block时候会别扭，但是对于账户等的设计上完全可以做到“状态chain”。在Vault合并Block之后就出现了明显的问题：真的太大了。刚开始想的是放整个sheet，然后发现sheet太大了（相比其他），一个sheet就相当于N*Tx大小而且还每个块必出现。这<strong>恒定占据size对于VPS带宽压力非常大</strong>。VPS带宽的利用会极大地影响实际的TPS和使用体验。假设在未来正常情况下，我区块大小10M，区块时间10s，那么要求就是VPS的网速达到1M&#x2F;s才能广播<strong>1</strong>个区块。在追求低区块时间的同时，追求减小区块体积的目标也应该落实。这样就和“存入状态”的设计相悖。</p>
<p>后来尝试了sheetHash。从功能上和结构上看是没有什么问题。但是从设计上来看，sheet在仅“账户-余额”的简单应用中大概率可行，但是在涉及了虚拟机和DAPP业务之后就力不从心：因为<strong>需要考虑执行时间</strong>。这也是为啥ethereum不让玩for遍历的原因。当一个新块已经成熟，上个块Block对应的任务还没做完，那这时候的sheet内容就是不正确的。另外，接收者的验证sheet阶段也会消耗时间，当多个Block广播时就会出现疲于验证。</p>
<p>虽然初衷是为chain的deleteable，但是这样就有点得不偿失。</p>
<p>未来做coin了会考虑重拾状态链，但是现阶段主攻还是wasm，schnorr这些技术融合的区块链引擎。</p>
]]></content>
      <tags>
        <tag>done</tag>
        <tag>NGIN</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Why do I dislike big data, AI etc</title>
    <url>/post/why_do_I_dislike_big_data_AI_etc/</url>
    <content><![CDATA[<p>当时大二的时候，人工智能还不像现在这么火，big data也是个新玩意。作为一个尝鲜者我很早就开始对这些东西进行学习研究了。</p>
<p>但是我，出于自身的角度，不喜欢它们。并不是说他们的技术水平我达不到，让我对这些“企业级技术”感到不爽的他们在技术之外的门槛。</p>
<span id="more"></span>

<p>如果你做过AI，你肯定知道要训练一个合格的模型，需要大量的例子去验证准确度，需要将更大量的例子转化成矢量去喂给算法。这些例子还都得是经过清洗的具有代表性的。换句话说，这不是个小工程。</p>
<p>很多的企业级技术和这类似。这些所谓的成功技术路线其实就是把人往大公司的坑里带：我想要训练出好的产品，我就没办法脱离大公司的帮助，只有在大公司的数据支持下我才能向前进。</p>
<p>这结果是什么呢？当资本开始作恶我们无能为力，甚至被迫出卖自己劳动力。996至今愈演愈烈越喊越轻；字节招人却都大喊真香。</p>
<p>那么，什么样的是好技术？</p>
<p>首先我认为是数字货币和区块链。众所周知的财富革命。这里不展开多说。</p>
<p>其次我认为是vr ar还有mr。设备，体验，交互和认知上的革命。</p>
<p>还有物联网，这才是真正的赋予智能。<br>还有3d打印解放个人生产力。</p>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>BigData</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly核心标准：WebAssembly Core Specification</title>
    <url>/post/wasm-core-1/</url>
    <content><![CDATA[<p>细枝末节略，无关内容略。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文档介绍了WebAssembly核心标准的1.0版。WebAssembly是一种安全，可移植的低级代码格式，旨在有效执行和紧凑表达。</p>
<p>相关文档：核心WebAssembly规范，WebAssembly JS接口和WebAssembly Web API。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1. 引言"></a>1.1. 引言</h3><p>WebAssembly（缩写为Wasm）是一种安全，可移植的低级代码格式，旨在高效执行和紧凑表达。</p>
<p>它的主要目标是在Web上启用高性能应用程序，但是它没有做任何特定于Web的假设或提供特定于Web的功能，因此它也可以在其他环境中使用。</p>
<p>WebAssembly是W3C组织开发的开放标准。</p>
<p>本文档介绍了核心WebAssembly标准的1.0版。其未来将被替换为添加具有其他功能的新增量发行版。</p>
<h4 id="1-1-1-设计目标"><a href="#1-1-1-设计目标" class="headerlink" title="1.1.1. 设计目标"></a>1.1.1. 设计目标</h4><p>WebAssembly的设计目标如下：</p>
<ul>
<li>快速，安全和可移植的语义：</li>
</ul>
<p><strong>快速</strong>：利用几乎所有现代硬件共有的功能，以接近本机的代码性能执行。</p>
<p><strong>安全</strong>：代码经过验证并在内存安全的[2]沙盒环境中执行，可防止数据损坏或安全漏洞。</p>
<p><strong>定义明确</strong>：以易于非正式地和正式地进行推理的方式，全面而精确地定义有效的程序及其行为。</p>
<p><strong>与硬件无关</strong>：可以在所有现代体系结构，台式机或移动设备以及嵌入式系统上进行编译。</p>
<p><strong>与语言无关</strong>：不青睐任何特定的语言，编程模型或对象模型。</p>
<p><strong>与平台无关</strong>：可以嵌入在浏览器中，作为独立VM运行或集成在其他环境中。</p>
<p><strong>开放</strong>：程序可以通过简单通用的方式与其环境进行互操作。</p>
<ul>
<li>高效便携的表示形式：</li>
</ul>
<p><strong>紧凑</strong>：具有比典型文本或本机代码格式小的传输速度快的二进制格式。</p>
<p><strong>模块化</strong>：程序可以分成较小的部分，可以分别传输，缓存和使用。</p>
<p><strong>高效</strong>：可以通过一次快速遍历进行解码，验证和编译，等同于即时（JIT）或提前（AOT）编译。</p>
<p><strong>可流式传输</strong>：允许在看到所有数据之前尽快开始解码，验证和编译。</p>
<p><strong>可并行化</strong>：允许将解码，验证和编译分为许多独立的并行任务。</p>
<p><strong>可移植性</strong>：没有任何现代硬件无法广泛支持的架构假设。</p>
<p>WebAssembly代码还旨在易于检查和调试，尤其是在Web浏览器之类的环境中，但是此类功能超出了本规范的范围。</p>
<p>[1]“WebAssembly”的缩写，而不是首字母缩写，因此未使用大写字母。</p>
<p>[2]没有任何程序可以破坏WebAssembly的内存模型。当然，它不能保证编译为WebAssembly的不安全语言不会破坏其自身的内存布局，例如WebAssembly的线性内存中。</p>
<h4 id="1-1-2-作用域"><a href="#1-1-2-作用域" class="headerlink" title="1.1.2. 作用域"></a>1.1.2. 作用域</h4><p>WebAssembly的核心是一套<em>虚拟指令集体系结构（虚拟ISA）</em>。<br>因此，其具有许多用例，且可以嵌入许多不同的环境中。<br>为了涵盖它们的多样性并实现最大程度的重用，WebAssembly规范被拆分并分层为多个文档。</p>
<p>本文档与WebAssembly的核心ISA层有关。<br>它定义了指令集，二进制编码，验证和执行语义以及文本表示形式。<br>但是，它没有定义WebAssembly程序如何与它们在其中执行的特定环境交互，也没有定义如何从这样的环境中调用它们。</p>
<p>取而代之的是，此规范得到了其他文档的补充，这些文档定义了到特定嵌入环境（例如Web）的接口。<br>这些都将定义适合给定环境的WebAssembly<em>应用程序编程接口（API）</em>。</p>
<h3 id="1-2-安全性考量"><a href="#1-2-安全性考量" class="headerlink" title="1.2. 安全性考量"></a>1.2. 安全性考量</h3><p>WebAssembly不提供对执行代码的计算环境的环境访问。<br>与环境的任何交互（例如I&#x2F;O，对资源的访问或操作系统调用）只能通过调用嵌入器提供的功能并将其导入WebAssembly模块中来执行。<br>嵌入程序可以通过控制或限制其可用于导入的功能来建立适用于相应环境的安全策略。<br>这些注意事项是嵌入程序的责任，也是特定环境的API定义的内容。</p>
<p>由于WebAssembly旨在转换为直接在主机硬件上运行的机器代码，因此可能会在硬件级别受到旁通道攻击。<br>在这是一个潜在的脆弱的环境中，嵌入程序可能必须设置适当的缓解措施以隔离WebAssembly计算。</p>
<h4 id="1-2-1-依赖"><a href="#1-2-1-依赖" class="headerlink" title="1.2.1. 依赖"></a>1.2.1. 依赖</h4><p>WebAssembly依赖于两个现有标准：</p>
<ul>
<li>[IEEE-754-2019]，用于表示浮点数据和相应数字运算的语义。</li>
<li>[UNICODE]，用于表示导入&#x2F;导出名称和文本格式。</li>
</ul>
<p>但是，为了使本规范变得独立，将上述标准的相关方面定义并正式化为本规范的一部分，例如二进制表示和浮点值的取整，以及Unicode的值范围和UTF-8编码字符。</p>
<blockquote>
<p>注意!</p>
<p>前述标准是所有各个定义的权威来源。本规范中给出的形式化旨在与这些定义匹配。所描述的语法或语义上的任何差异均应视为错误。</p>
</blockquote>
<h3 id="1-3-概览"><a href="#1-3-概览" class="headerlink" title="1.3. 概览"></a>1.3. 概览</h3><h4 id="1-3-1-概念"><a href="#1-3-1-概念" class="headerlink" title="1.3.1 概念"></a>1.3.1 概念</h4><p>WebAssembly编码一种低级的，类似于程序集的编程语言。该语言围绕以下概念构建。</p>
<p><strong>值Values</strong></p>
<blockquote>
<p>WebAssembly仅提供四种基本值类型。这些是整数和<a href="https://www.w3.org/TR/wasm-core-1/#biblio-ieee-754-2019" target="_blank" rel="noopener">IEEE-754-2019</a>数字，分别为32位和64位宽度。32位整数还用作布尔值和内存地址。可以使用这些类型的常规操作，包括它们之间转换的完整矩阵。有符号和无符号整数类型之间没有区别。取而代之的是，整数会被相应的操作解释为无符号或有两个补码表示形式的符号。</p>
</blockquote>
<p><strong>指令Instructions</strong></p>
<blockquote>
<p>WebAssembly的计算模型基于<em>堆栈计算机</em> 。代码由按顺序执行的指令序列组成。指令在隐式操作数堆栈[1]上操作值，并分为两个主要类别。简单的指令对数据执行基本操作。它们从操作数堆栈中弹出参数，并将结果压回该操作数堆栈。控制指令会改变控制流程。控制流是结构化的，这意味着它可以用嵌套好的结构（例如块，循环和条件）来表示。分支只能针对此类构造。</p>
</blockquote>
<p><strong>陷阱Traps</strong></p>
<blockquote>
<p>w在某些情况下，某些指令可能会产生陷阱，该陷阱会立即中止执行。陷阱不能由WebAssembly代码处理，但是会报告给外部环境，通常可以在外部环境中捕获它们。</p>
</blockquote>
<p><strong>功能Functions</strong></p>
<blockquote>
<p>代码被组织成单独的功能。每个函数都将值序列作为参数，并返回值序列作为结果。 [2]函数可以互相调用，包括递归调用，从而导致无法直接访问的隐式调用堆栈。函数还可以声明可用作虚拟寄存器的可变局部变量。</p>
</blockquote>
<p><strong>表Tables</strong></p>
<blockquote>
<p>表是特定元素类型的不透明值的数组。它允许程序通过动态索引操作数间接选择这些值。当前，唯一可用的元素类型是无类型的函数引用。因此，程序可以通过向表中的动态索引间接调用函数。例如，这允许通过表索引模拟功能指针。</p>
</blockquote>
<p><strong>线性内存Linear Memory</strong></p>
<blockquote>
<p>线性内存是连续，可变的原始字节数组。这样的存储器以初始大小创建，但是可以动态增长。程序可以在任何字节地址（包括未对齐）将线性存储器中的值加载&#x2F;存储在线性存储器中或将其存储在其中。整数加载和存储可以指定小于各自值类型的大小的存储大小。如果访问不在当前内存大小的范围内，则会发生陷阱。</p>
</blockquote>
<p><strong>模块Modules</strong></p>
<blockquote>
<p>WebAssembly二进制文件采用模块的形式，该模块包含函数，表和线性内存的定义以及可变或不可变的全局变量。也可以导入定义，指定模块&#x2F;名称对和合适的类型。每个定义可以选择以一个或多个名称导出。除定义外，模块还可以为其内存或表定义初始化数据，该初始化数据采用复制到给定偏移量的段的形式。他们还可以定义自动执行的启动功能。</p>
</blockquote>
<p><strong>嵌入器Embedder</strong></p>
<blockquote>
<p>WebAssembly实现通常将嵌入到主机环境中。此环境定义了如何启动模块加载，如何提供导入（包括主机端定义）以及如何访问导出。但是，任何特定嵌入的细节都超出了本规范的范围，而是由互补的，特定于环境的API定义提供。</p>
</blockquote>
<p>[1]实际上，实现无需维护实际的操作数堆栈。取而代之的是，堆栈可以看作是一组由指令隐式引用的匿名寄存器。类型系统可确保始终静态地了解堆栈高度，从而确保所有引用的寄存器。<br>[2]在当前版本的WebAssembly中，最多只有一个结果值。</p>
<h4 id="1-3-2-语义解析"><a href="#1-3-2-语义解析" class="headerlink" title="1.3.2. 语义解析"></a>1.3.2. 语义解析</h4><p>从概念上讲，WebAssembly的语义分为三个阶段。对于语言的每个部分，规范都会对其进行指定。</p>
<p><strong>解码Decoding</strong></p>
<blockquote>
<p>WebAssembly模块以二进制格式分发。解码过程将格式化并将其转换为模块的内部表示形式。在本规范中，此表示是通过抽象语法建模的，但是实际的实现可以改为直接编译为机器代码。</p>
</blockquote>
<p><strong>验证Validation</strong></p>
<blockquote>
<p>被解码的模块必须<em>有效</em>。验证检查许多格式​​正确的条件，以确保模块有意义且安全。特别是，它对功能及其内部的指令序列进行类型检查，以确保例如一致地使用操作数堆栈。</p>
</blockquote>
<p><strong>执行Execution</strong></p>
<blockquote>
<p>最后，一个有效的模块可以被<em>执行</em>。执行可以进一步分为两个阶段：</p>
<p><strong>实例化Instantiation</strong>。模块实例是模块的动态表示，带有其自己的状态和执行堆栈。实例化将执行模块主体本身，并为其定义所有导入。它将初始化全局变量，内存和表，并调用模块的启动函数（如果已定义）。它返回模块导出的实例。</p>
<p><strong>调用Invocation</strong>。一旦实例化，就可以通过在模块实例上<em>调用</em>导出的函数来启动进一步的WebAssembly计算。给定必需的参数，该函数将执行相应的函数并返回其结果。</p>
<p>实例化和调用是在嵌入环境中的操作。</p>
</blockquote>
<h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h2><h3 id="2-1-规定"><a href="#2-1-规定" class="headerlink" title="2.1. 规定"></a>2.1. 规定</h3><p>WebAssembly是一种编程语言，具有多种具体表示形式（其二进制格式和文本格式）。 两者都映射到一个共同的结构。为简明起见，以抽象语法的形式描述了此结构。本规范的所有部分均根据此抽象语法定义。</p>
<h4 id="2-1-1-语法符号"><a href="#2-1-1-语法符号" class="headerlink" title="2.1.1. 语法符号"></a>2.1.1. 语法符号</h4><p>在定义抽象语法的语法规则时采用以下约定。</p>
<ul>
<li>结束符号（原子）以sans-serif字体编写$\mathrm{i32, end}$。</li>
<li>非结束符以斜体字体表示：$valtype，instr$。</li>
<li>$A^n$是A的$n\geq0$个迭代的序列。</li>
<li>$A^*$是A的可能是空的迭代序列。（这是n无关的$A^n$的简写。）</li>
<li>$A^+$是A的非空迭代序列。（这是$A^n$的简写，其中n≥1。）</li>
<li>$A^?$是A的可选出现。（这是$A^n$的简写，其中n≤1。）</li>
<li>产生式被写成$sym::&#x3D;A_1∣…∣A_n$。</li>
<li>大型产生式可能会分为多个定义，可以用第一个以显式椭圆$sym::&#x3D;A_1|…$结束，并以椭圆以$sym::&#x3D;…∣A_2$开头来表示。</li>
<li>一些产品在括号中加上附加条件“$(\mathrm{if} condition)$”，这为将产品组合扩展为许多单独的案例提供了捷径。</li>
</ul>
<h4 id="2-1-2-辅助符号"><a href="#2-1-2-辅助符号" class="headerlink" title="2.1.2. 辅助符号"></a>2.1.2. 辅助符号</h4><p>在处理语法结构时，还使用以下表示法：</p>
<ul>
<li>$\epsilon$表示空序列。</li>
<li>$|s|$表示序列s的长度。</li>
<li>$s[i]$表示序列s的第i个元素，从0开始。</li>
<li>$s[i:n]$表示序列s的子序列$s[i]…s [i+n-1]$。</li>
<li>$s\ with [i] &#x3D; A$表示与s相同的序列，除了第i个元素被A代替。</li>
<li>$s\ with [i:n] &#x3D; A^n$表示与s相同的序列，不同之处在于子序列$s[i:n]$被An取代。</li>
<li>$concat(s^*)$表示通过将$s^*$中的所有序列$s^i$串联而形成的平坦序列。</li>
</ul>
<p>此外，采用以下约定：</p>
<ul>
<li><p>符号$x^n$（其中x是非终结符号）被视为跨x的各个序列（类似于$x^*$，$x^+$，$x^?$）的元变量。</p>
</li>
<li><p>当给定一个序列$x^n$时，则假定在$(A1xA2)^n$中写入的序列中x的出现与xn呈逐点对应关系（对于$x^*$，$x^+$，$x^?$同样）。这隐式表达了在序列上映射语法结构的形式。</p>
</li>
</ul>
<p>以下形式的生产被解释为分别将一组固定的字段$field_i$映射到“值” Ai的记录：<br>$$r ::&#x3D; { field_1 A_1, field_2 A_2,… }$$</p>
<p>使用以下表示法来处理此类记录：</p>
<ul>
<li><p>$r.field$表示r的字段filed的内容。</p>
</li>
<li><p>$r\ with\ field &#x3D; A$表示与r相同的记录，除了字段组件的内容被A代替。</p>
</li>
<li><p>$r1 \oplus r2$通过逐点追加每个序列来表示具有相同序列字段的两个记录的组合：</p>
</li>
</ul>
<p>$${ field_1 A_1^*, field_2 A_2^*, … } {field_1 B_1^*, field_2 B_2^*, … } &#x3D; { field_1 A_1^* B_1^*, field_2 A_2^* B_2^*,… }$$</p>
<ul>
<li>$\oplus r^*$分别表示记录序列的组成；如果序列为空，则结果记录的所有字段均为空。</li>
</ul>
<p>序列和记​​录的更新符号递归地概括为“路径” $pth ::&#x3D;([…]|.field)^+$所访问的嵌套组件：</p>
<ul>
<li>$s\ with\ [i]\ pth &#x3D; A$是$s\ with [i] &#x3D;(s[i]\ with\ pth &#x3D; A)$的缩写。</li>
<li>$r\ with\ field\ pth &#x3D; A$是$r\ with\ field &#x3D;(r.field\ with\ pth &#x3D; A)$的缩写。</li>
</ul>
<p>其中$r\ with\ .field &#x3D; A$缩写为$r\ with\ field &#x3D; A$</p>
<h4 id="2-1-3-向量"><a href="#2-1-3-向量" class="headerlink" title="2.1.3. 向量"></a>2.1.3. 向量</h4><p>向量是形式为$A^n$（或$A^*$）的有界序列，其中A可以是值或复杂的构造。一个向量最多可包含$2^32-1$（即MaxUint256）个元素。</p>
<p>$$vec(A) ::&#x3D; A^n\ (if\ n&lt;2^{32})$$</p>
<h3 id="2-2-值"><a href="#2-2-值" class="headerlink" title="2.2. 值"></a>2.2. 值</h3><p>WebAssembly程序对原始数值进行操作。<br>此外，在程序的定义中，值的不可变序列出现以表示更复杂的数据，例如文本字符串或其他向量。</p>
<h4 id="2-2-1-Bytes"><a href="#2-2-1-Bytes" class="headerlink" title="2.2.1. Bytes"></a>2.2.1. Bytes</h4><p>值的最简单形式是未解释的原始字节。<br>在抽象语法中，它们表示为十六进制文字。</p>
<p>$$ byte​::&#x3D;​0x00 |…| 0xFF​ $$</p>
<h5 id="2-2-1-1-惯例"><a href="#2-2-1-1-惯例" class="headerlink" title="2.2.1.1. 惯例"></a>2.2.1.1. 惯例</h5><ul>
<li><p>元变量$b$的范围为字节。</p>
</li>
<li><p>字节有时被解释为自然数$n &lt; 256$。</p>
</li>
</ul>
<p>2.2.2. 整数</p>
<p>具有不同值范围的不同类别的整数通过其<em>位宽</em>$N$以及是<em>无符号</em>还是<em>有符号</em>来区分。</p>
<p>$$uN ::&#x3D; 0 | 1| … | 2^N-1$$<br>$$sN ::&#x3D; -2^N-1|…| -1 | 0 | 1 | … | 2^N-1$$<br>$$iN ::&#x3D; uN$$</p>
<p>后者定义了未解释的整数，其有符号性解释会根据上下文而变化。<br>在抽象语法中，它们表示为无符号值。<br>但是，某些运算会根据二进制补码解释将其转换为带符号。</p>
<blockquote>
<p>注意</p>
<p>在本规范中出现的主要整数类型是u32，u64，s32，s64，i8，i16，i32，i64。但是，例如在浮点数的定义中，其他大小也可以作为辅助结构。</p>
</blockquote>
<h5 id="2-2-2-1-惯例"><a href="#2-2-2-1-惯例" class="headerlink" title="2.2.2.1. 惯例"></a>2.2.2.1. 惯例</h5><ul>
<li>元变量$m，n，i$的范围是整数。</li>
<li>如上面的语法所示，数字可以用简单的算术表示。<br>为了区分$2^N$之类的算术与$(1)^N$之类的序列，用括号将后者区分。</li>
</ul>
<h4 id="2-2-3-浮点数"><a href="#2-2-3-浮点数" class="headerlink" title="2.2.3. 浮点数"></a>2.2.3. 浮点数</h4><p>浮点数据表示32或64位值，它们对应于[IEEE-754-2019]标准（第3.3节）的相应二进制格式。</p>
<p>每个值都有一个符号和大小。 幅值可以表示为形式为$m_0 m_1 m_2 \ldots m_M \cdot 2^e$的正态数，其中$e$是指数，m是其最高位$m_0$为1的有效数，或者以次正规数来表示 指数固定为最小可能值，且$m_0$为0; 在次法线中的是零正值和负值。 由于有效位数是二进制值，因此法线以$(1 +m\cdot 2^{-M})\cdot 2e$的形式表示，其中$M$是$m$的位宽； 对于次普通人也是如此。</p>
<p>可能的大小还包括特殊值$\infty$（无穷大）和nan（即NaN，非数字）。NaN值具有一个有效载荷，该载荷描述了基础二进制表示形式中的尾数位。 信号和安静的NaN之间没有区别。</p>
<p>$$fN ::&#x3D; +fNmag | -fNmag$$<br>$$\displaylines{fNmag ::&#x3D;(1+uM\cdot 2^{-M})\cdot 2^e ((if\ −2^{E−1} + 2 \leq e \leq 2^{E−1}−1))\<br>|\ (0+uM\cdot 2^{-M})\cdot 2^e (if\ e&#x3D;-2^{E-1}+2)\<br>\infty\<br>nan(n)\ (if 1\leq n\lt 2^M)}$$</p>
<p>当 M&#x3D;signif(N) 且 E&#x3D;expon(N) 则</p>
<p>$$\displaylines{signif(32) &#x3D; 23 \<br>expon(32) &#x3D;8 \<br>signif(64)&#x3D;52\<br>expon(64)&#x3D;11}$$</p>
<p>一个*规范的(canonical)*NaN是浮点数值$\pm nan(canon_N)$，其中$canon_N$是有效载荷，其最高有效位为1而所有其他均为0：</p>
<p>$$canon_N &#x3D; 2^{signif(N)-1}$$</p>
<p>一个*算术(arithmetic)*NaN是$n\geq canon_N$的浮点值$\pm nan(n)$，因此最高有效位为1，其他所有位均为任意。</p>
<blockquote>
<p>注意</p>
<p>在抽象语法中，子范数以有效数字的前导0区分。 次正态的指数与正态数的最小可能指数具有相同的值。 仅在二进制表示中，次正态的指数与任何正态数的指数的编码方式不同。</p>
</blockquote>
<h5 id="2-2-3-1-惯例"><a href="#2-2-3-1-惯例" class="headerlink" title="2.2.3.1. 惯例"></a>2.2.3.1. 惯例</h5><ul>
<li>元变量z取自从上下文清晰可辨的浮点值。</li>
</ul>
<h4 id="2-2-4-名称Names"><a href="#2-2-4-名称Names" class="headerlink" title="2.2.4. 名称Names"></a>2.2.4. 名称Names</h4><p>名称是字符序列，是[UNICODE]（第2.4节）定义的标量值。</p>
<p>$$\displaylines{name::&#x3D; char^* \ (if\ |utf8(char^*)|&lt;2^{32})\<br>char ::&#x3D; U+00|\ldots|U+D7FF|U+E000|…U+10FFFF}$$</p>
<p>由于二进制格式的限制，名称的长度受其UTF-8编码的长度限制。</p>
<h5 id="2-2-4-1-惯例"><a href="#2-2-4-1-惯例" class="headerlink" title="2.2.4.1. 惯例"></a>2.2.4.1. 惯例</h5><ul>
<li>字符（Unicode标量值）有时与n &lt;1114112的自然数互换使用。</li>
</ul>
<h3 id="2-3-类型Types"><a href="#2-3-类型Types" class="headerlink" title="2.3 类型Types"></a>2.3 类型Types</h3><p>WebAssembly中的各种实体按类型分类。<br>在验证，实例化以及可能的执行期间检查类型。</p>
<h4 id="2-3-1-值-Value-类型"><a href="#2-3-1-值-Value-类型" class="headerlink" title="2.3.1 值(Value)类型"></a>2.3.1 值(Value)类型</h4><p>值类型对WebAssembly代码可以计算的单个值以及变量接受的值进行分类。</p>
<p>$$valtype ::&#x3D; i32|i64|f32|f64$$</p>
<p>i32和i64类型分别将32位和64位整数分类。<br>整数不是固有地带符号或无符号的，它们的解释由单个操作确定。</p>
<p>f32和f64类型分别将32位和64位浮点数分类。<br>它们分别对应于[IEEE-754-2019]标准（第3.3节）定义的相应二进制浮点表示形式，也称为单精度和双精度。</p>
<h5 id="2-3-3-1-惯例"><a href="#2-3-3-1-惯例" class="headerlink" title="2.3.3.1. 惯例"></a>2.3.3.1. 惯例</h5><ul>
<li>元变量t可以从清晰的上下文中范围内的值类型。</li>
<li>符号$|t|$表示值类型的位宽。即，$|i32|&#x3D;|f32|&#x3D;32$和$|i64|&#x3D;|f64|＝64$。</li>
</ul>
<h4 id="2-3-2-结果-Result-类型"><a href="#2-3-2-结果-Result-类型" class="headerlink" title="2.3.2. 结果(Result)类型"></a>2.3.2. 结果(Result)类型</h4><p>结果类型对执行指令或块的结果进行分类，该指令或块是用括号写入的一系列值。</p>
<p>$$resulttyle ::&#x3D; [valtype^?]$$</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，结果最多允许一个值。但是，这可能会泛化为将来版本中的值序列。</p>
</blockquote>
<h4 id="2-3-3-函数-Function-类型"><a href="#2-3-3-函数-Function-类型" class="headerlink" title="2.3.3 函数(Function)类型"></a>2.3.3 函数(Function)类型</h4><p>函数类型对函数的签名进行分类，将参数向量映射到结果向量，如下所示。</p>
<p>$$ functype ::&#x3D; [vec(valtype)] -&gt; [vec(valtype)]$$</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，有效函数类型的结果类型向量的长度最多为1。此限制在将来的版本中可能会消除。</p>
</blockquote>
<h4 id="2-3-4-限制"><a href="#2-3-4-限制" class="headerlink" title="2.3.4. 限制"></a>2.3.4. 限制</h4><p>限制对与内存类型和表类型关联的可调整大小的存储的大小范围进行分类。</p>
<p>$$limits ::&#x3D; {min u32, max u32^?}$$</p>
<p>如果没有给出最大值，则相应的存储可以增长到任何大小。</p>
<h4 id="2-3-5-内存-Memories-类型"><a href="#2-3-5-内存-Memories-类型" class="headerlink" title="2.3.5. 内存(Memories)类型"></a>2.3.5. 内存(Memories)类型</h4><p>存储器类型将线性存储器及其大小范围分类。</p>
<p>$$memtype ::&#x3D; limits$$</p>
<p>这些限制限制了内存的最小和最大可选大小。 限制以页面大小为单位给出。</p>
<h4 id="2-3-6-表格类型"><a href="#2-3-6-表格类型" class="headerlink" title="2.3.6. 表格类型"></a>2.3.6. 表格类型</h4><p>表类型根据大小范围内的元素类型的元素对表进行分类。</p>
<p>$$\displaylines{tabletype ::&#x3D; limits elemtype\<br>elemtype::&#x3D;funcref}$$</p>
<p>像内存一样，表格的最小和最大大小限制也受到限制。<br>限制以条目数给出。</p>
<p>元素类型funcref是所有函数类型的无限并集。<br>因此，该类型的表包含对异构类型函数的引用。</p>
<blockquote>
<p>注意</p>
<p>在WebAssembly的未来版本中，可能会引入其他元素类型。</p>
</blockquote>
<h4 id="2-3-7-全局变量类型"><a href="#2-3-7-全局变量类型" class="headerlink" title="2.3.7. 全局变量类型"></a>2.3.7. 全局变量类型</h4><p>全局变量类型对全局变量进行分类，这些全局变量具有一个值，并且可以是可变的或不可变的。</p>
<p>$$\displaylines{globaltype ::&#x3D; mut valtype\mut ::&#x3D; const | var}</p>
<h4 id="2-3-8-外部类型"><a href="#2-3-8-外部类型" class="headerlink" title="2.3.8. 外部类型"></a>2.3.8. 外部类型</h4><p>外部类型使用各自的类型对导入和外部值进行分类。</p>
<p>$$ externtype :: &#x3D; func functype| table tabletype | mem memtype | global globaltype $$</p>
<h5 id="2-3-8-1-惯例"><a href="#2-3-8-1-惯例" class="headerlink" title="2.3.8.1 惯例"></a>2.3.8.1 惯例</h5><p>为外部类型的序列定义了以下辅助符号。<br>它以保留顺序的方式筛选出特定种类的条目：</p>
<p>$$\displaylines{funcs(externtype^*)&#x3D;[functype|(func functype) \in externtype^*] \<br>tables(externtype^*)&#x3D;[tabletype | (table tabletype)\in externtype^*] \<br>mems(externtype^*)&#x3D;[memtype | (mem memtype)\in externtype^*] \<br>globals(externtype^*)&#x3D;[globaltype | (global globaltype)\in externtype^*]}$$</p>
<h3 id="2-4-指令Instructions"><a href="#2-4-指令Instructions" class="headerlink" title="2.4. 指令Instructions"></a>2.4. 指令Instructions</h3><p>WebAssembly代码由指令序列组成。 它的计算模型基于堆栈机，其中指令在隐式操作数堆栈上操纵值，使用（弹出）自变量值并生成或返回（推入）结果值。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，单个指令最多可以推入一个结果值。在将来的版本中可能会取消此限制。</p>
</blockquote>
<p>除了来自堆栈的动态操作数之外，某些指令还具有静态中间参数，通常是索引或类型注释，它们是指令本身的一部分。</p>
<p>某些指令的结构在于将嵌套的指令序列括起来。</p>
<p>以下各节将指令分为许多不同的类别。</p>
<h4 id="2-4-1-数值指令"><a href="#2-4-1-数值指令" class="headerlink" title="2.4.1. 数值指令"></a>2.4.1. 数值指令</h4><p>数值指令提供对特定类型数值的基本操作。<br>这些操作与硬件中可用的各个操作紧密匹配。</p>
<p>$$nn,mm::&#x3D; 32| 64$$<br>$$sx ::&#x3D;  \rm{u} |  \rm{s}$$<br>$$\displaylines{instr ::&#x3D; \mathrm{i} nn.\mathrm{const}\ inn | \mathrm{i}nn.\mathrm{const}\ fnn \<br>| \mathrm{i}nn.iunop | \mathrm{f}nn.funop \<br>| \mathrm{i}nn.ibinop | \mathrm{f}nn.fbinop \<br>| \mathrm{i}nn.itestop \<br>| \mathrm{i}nn.irelop | \mathrm{f}nn.frelop \<br>| \mathrm{i32.wrap_i64} | \mathrm{i64.extend_i32_}sx | \mathrm{i}nn.\mathrm{trunc_f}mm_sx \<br>| \mathrm{f32.demote_f64} | \mathrm{f64.promote_f32} | \mathrm{f}nn.\mathrm{convert_i}mm_sx \<br>| \mathrm{i}nn.\mathrm{reinterpret_f}nn | \mathrm{i}nn.\mathrm{reinterpret_i}nn \<br>| \ldots}$$<br>$$ iunop ::&#x3D; \mathrm{clz | ctz | opocnt}$$<br>$$ \displaylines{ibinop ::&#x3D; \mathrm{add | sub | mul | div_}sx \mathrm{|rem_}sx \<br>| \mathrm{and | or | xor | shl | shr_}sx \mathrm{| rtol | rtor} }$$<br>$$ funop ::&#x3D; \mathrm{abs | neg | sqrt | ceil | floor | trunc | nearest}$$<br>$$ fbinop ::&#x3D; \mathrm{add | sub | mul | div | min | max | copysign}$$<br>$$ itestop ::&#x3D; \mathrm{eqz}$$<br>$$ irelop ::&#x3D; \mathrm{eq | ne | lt_}sx \mathrm{| gt_}sc \mathrm{| le_}sx \mathrm{| ge_}sx$$<br>$$ frelop ::&#x3D; \mathrm{eq | ne | lt | gt | le | ge }$$</p>
<p>数字指令按值类型划分。 对于每种类型，可以区分几个子类别：</p>
<ul>
<li>常量：返回静态常量。</li>
<li>一元运算符：使用一个操作数并产生相应类型的一个结果。</li>
<li>二进制运算符：使用两个操作数并产生一个相应类型的结果。</li>
<li>测试：消耗一个相应类型的操作数，并产生一个布尔整数结果。</li>
<li>比较：消耗两个各自类型的操作数，并产生一个布尔整数结果。</li>
<li>转换：使用一种类型的值并产生另一种类型的结果（转换的源类型是“_”之后的类型）。</li>
</ul>
<p>一些整数指令有两种形式，其中带符号注释sx区分是将操作数解释为无符号整数还是带符号整数。<br>对于其他整数指令，对有符号的解释使用二进制补码意味着无论有符号性如何，它们的行为都相同。</p>
<h5 id="2-4-1-1-惯例"><a href="#2-4-1-1-惯例" class="headerlink" title="2.4.1.1. 惯例"></a>2.4.1.1. 惯例</h5><p>有时，根据以下语法速记将操作分组在一起很方便：</p>
<p>$$unop ::&#x3D; iunop | funop$$<br>$$binop ::&#x3D; ibinop | fbinop$$<br>$$testop ::&#x3D; itestop$$<br>$$relop ::&#x3D; irelop | frelop$$<br>$$cutop ::&#x3D; \mathrm{wrap | entend | trunc | convert | demote | promote | reinterpret}$$</p>
<h4 id="2-4-2-参数指令"><a href="#2-4-2-参数指令" class="headerlink" title="2.4.2. 参数指令"></a>2.4.2. 参数指令</h4><p>该组中的指令可以对任何值类型的操作数进行运算。</p>
<p>$$ \displaylines{ instr ::&#x3D; \ldots \<br>| \mathrm{drop} \<br>| \mathrm{select} }$$ </p>
<p>drop运算符只是丢掉单个操作数。</p>
<p>select运算符根据其第三个操作数是否为零来选择执行其前两个操作数之一。</p>
<h4 id="2-4-3-变量指令"><a href="#2-4-3-变量指令" class="headerlink" title="2.4.3. 变量指令"></a>2.4.3. 变量指令</h4><p>变量指令涉及对局部或全局变量的访问。</p>
<p>$$ \displaylines{ instr ::&#x3D; \ldots \<br>| \mathrm{local.get}\ localidx \<br>| \mathrm{local.set}\  localidx \<br>| \mathrm{local.tee}\ localidx \<br>| \mathrm{global.get}\ globalidx \<br>| \mathrm{global.set}\ globalidx}$$</p>
<p>这些指令分别获取或设置变量的值。<br>local.tee指令类似于local.set，但会返回其参数。</p>
<h4 id="2-4-4-内存指令"><a href="#2-4-4-内存指令" class="headerlink" title="2.4.4. 内存指令"></a>2.4.4. 内存指令</h4><p>该组指令与线性内存有关。</p>
<p>$$ memarg ::&#x3D; { \mathrm{offset}\ u32, \mathrm{align}\ u32 }$$</p>
<p>内存可以通过使用不同<em>值类型</em>的加载（load）和存储（store）指令来访问。<br>它们都使用一个内存中间值memarg，该值包含一个地址<em>偏移量（offset）</em>和一个预期的<em>编排方式</em>（表示为2的幂的指数）。<br>整数的加载和存储可以选择指定小于各自值类型的位宽度的存储大小。<br>在一些加载情况下，则需要符号扩展模式$sx$来选择适当的行为。</p>
<p>静态地址偏移量被添加到动态地址操作数，从而产生33位长度的<em>有效地址</em>，该地址是从零开始的索引，可从该索引访问内存。<br>所有值以Little-Endian读取和写入。<br>如果任何已访问的内存字节超出了内存当前大小所隐含的地址范围，就会产生陷阱（Trap）。</p>
<blockquote>
<p>注意</p>
<p>WebAssembly的未来版本可能会提供具有64位地址范围的内存指令。</p>
<p>（这也是为啥现在叫wasm32）</p>
</blockquote>
<p>memory.size指令返回当前的内存大小。<br>memory.grow指令将内存增加给定的增量，并返回先前的大小；如果无法分配足够的内存，则返回-1。<br>两条指令均以页面大小为单位。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，所有内存指令都隐式地（默认）对内存索引0进行操作。此限制在将来的版本中可能会取消。</p>
</blockquote>
<h4 id="2-4-5-控制指令"><a href="#2-4-5-控制指令" class="headerlink" title="2.4.5. 控制指令"></a>2.4.5. 控制指令</h4><p>该组中的指令会影响控制流程。</p>
<p>$$ \displaylines{ instr ::&#x3D; \ldots \<br>| \mathrm{nop} \<br>| \mathrm{unreachable} \<br>| \mathrm{block}\ resulttype\ instr^<em>\ \mathrm{end} \<br>| \mathrm{loop }\ resulttype\ instr^</em>\ \mathrm{end} \<br>| \mathrm{if}\ resulttype\ instr^<em>\ \mathrm{else}\ instr^</em>\ \mathrm{end} \<br>| \mathrm{br}\ labelidx \<br>| \mathrm{br_if}\ labelidx \<br>| \mathrm{br_table}\ vec(labelidx)\ labelidx \<br>| \mathrm{return} \<br>| \mathrm{call}\ funcidx \<br>| \mathrm{call_indirect}\ typeidx}$$</p>
<p>nop指令不执行任何操作。</p>
<p>unreachable指令触发无条件的陷阱。</p>
<p>block,loop以及if指令是结构化指令。<br>它们将嵌套的指令序列（称为块）括起来，以指令末尾或伪指令终止或分隔。<br>正如语法规定的那样，必须将它们嵌套好。<br>结构化指令可以产生一个如注释结果类型描述的值。</p>
<p>每个结构化控制指令都会引入一个隐式标签。<br>标签（Label）是分支指令通过标签索引引用的目标。<br>与其他索引空间不同，标签的索引是相对于嵌套深度的，也就是说，标签0指的是包围引用分支指令的最内部结构化控制指令，而递增的索引则引用更远的索引。<br>因此，只能从关联的结构化控制指令中引用标签。<br>这也意味着分支只能指向外部，“脱离”它们所针对的控制构造的块。<br>具体效果取决于该控制结构：<br>在block或if情况下，向前跳转直到匹配到end后恢复执行。<br>在loop循环情况下，向后跳到loop开始。</p>
<blockquote>
<p>注意</p>
<p>这将强制执行结构化的控制流程。<br>直观地讲，在大多数类似于C的语言中，针对块的if分支的行为类似于break语句，而针对循环的分支的行为类似于continue语句。</p>
</blockquote>
<p>分支（Branch）指令有以下几种形式：<br>br：执行无条件分支<br>br_if：执行条件分支<br>br_table：通过操作数索引到标签向量的间接操作来执行该间接操作，该标签向量是指令的直接执行对象，如果操作数超出范围，则指向默认目标。<br>return：无条件分支到最外层代码块的快捷方式，该块隐式地是当前函数的主体。<br>采取分支将操作数堆栈展开到输入目标结构化控制指令的高度。<br>但是，以非空结果类型为目标的控制指令作为目标的前向分支首先消耗匹配的操作数，并在展开后将它们推回操作数堆栈中，以作为终止的结构化指令的结果。</p>
<p>call指令调用另一个函数，从堆栈中使用必要的参数并返回调用的结果值。<br>call_indirect指令通过将操作数索引到表中来间接调用函数。<br>由于表（table）可能包含异构类型funcref的函数元素，因此将根据指令的立即数对被调用方进行动态检查，以检查该函数类型（function type），如果调用不匹配，则调用将使用陷阱（trap）中止。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，call_indirect默认对表索引（tableidx）0操作。在将来的版本中可能会取消此限制。</p>
</blockquote>
<h4 id="2-4-6-表达式Expression"><a href="#2-4-6-表达式Expression" class="headerlink" title="2.4.6. 表达式Expression"></a>2.4.6. 表达式Expression</h4><p>函数（function）主体，全局变量（globals）的初始化值以及元素（element）或数据（data）段的偏移量都作为表达式给出。表达式是由结束（end）标记终止的指令（instruction）序列。</p>
<p>$$ expr ::&#x3D; instr* \mathrm{end}$$</p>
<p>在某些地方，验证器将表达式限制为常量，从而限制了被允许的指令集。</p>
<h3 id="2-5-模块-Modules"><a href="#2-5-模块-Modules" class="headerlink" title="2.5 模块 Modules"></a>2.5 模块 Modules</h3><p>WebAssembly程序被组织成模块，这些模块是部署，加载和编译的单元。<br>一个模块包含了类型（types），函数（functions），表（tables），内存（memories）和全局变量（globals）的定义。<br>此外，它可以声明导入（imports）和导出（exports），并以数据（data）和元素（element）段或启动函数的形式提供初始化逻辑。</p>
<p>$$ \displaylines{ module ::&#x3D; { types\ vec(functype),<br>funcs\ vec(func), \<br>tables\ vec(table), \<br>mems vec(mem), \<br>globals\ vec(elem), \<br>data\ vec(data), \<br>start\ start^?, \<br>imports\ vec(import),<br>exports\ vec(export) }}$$</p>
<p>每个向量，甚至整个模块，都可能是空的。</p>
<h4 id="2-5-1-索引"><a href="#2-5-1-索引" class="headerlink" title="2.5.1. 索引"></a>2.5.1. 索引</h4><p>定义被以从0开始的索引引用。<br>每个定义类都有其自己专属的索引空间，如以下类所示。</p>
<p>$$\displaylines{ typeidx ::&#x3D; u32\<br>funcidx ::&#x3D; u32\<br>tableidx ::&#x3D; u32\<br>memidx ::&#x3D; u32\<br>globalidx ::&#x3D; u32\<br>localidx ::&#x3D; u32\<br>labelidx ::&#x3D; u32}$$</p>
<p>函数（functions），表（tables），内存（memories）和全局变量（globals）的索引空间包括在同一模块中声明的相应导入（imports）中。<br>这些导入（imports）的索引在同一索引空间中优先于其他定义的索引。</p>
<p>局部变量（locals）的索引空间只能在函数内部访问，并且包括以此为参数的函数。这种函数位于局部变量之前。</p>
<p>标签（label）索引引用指令序列内的结构化控制指令。</p>
<h5 id="2-5-1-1-惯例"><a href="#2-5-1-1-惯例" class="headerlink" title="2.5.1.1. 惯例"></a>2.5.1.1. 惯例</h5><ul>
<li>元变量l覆盖标签索引。</li>
<li>元变量x，y覆盖其他任何索引空间中的索引。</li>
</ul>
<h4 id="2-5-2-类型"><a href="#2-5-2-类型" class="headerlink" title="2.5.2. 类型"></a>2.5.2. 类型</h4><p>模块的类型组件定义了一个功能类型（function types）的向量。</p>
<p>所有功能类型必须在此组件中定义模块中使用。<br>它们由类型索引引用。</p>
<blockquote>
<p>注意</p>
<p>WebAssembly的未来版本可能会添加类型定义的其他形式。</p>
</blockquote>
<h4 id="2-5-3-函数"><a href="#2-5-3-函数" class="headerlink" title="2.5.3. 函数"></a>2.5.3. 函数</h4><p>模块的funcs组件定义具有以下结构的函数向量：</p>
<p>$$ func ::&#x3D; {\mathrm{type}\ typeidx, \mathrm{locals}\ vec(valtype), \mathrm{body}\ expr}$$</p>
<p>函数（function）的类型通过引用模块中定义的类型来声明其签名。<br>该函数的参数通过函数主体中从0的局部索引进行引用； 他们是可变的。</p>
<p>局部变量（locals）声明一个可变局部变量及其类型的向量。<br>这些变量是通过函数体内的局部索引来引用的。<br>第一个局部变量的索引是最小索引，其不引用任何参数。</p>
<p>主体（body）是一个指令序列，在终止时必须产生一个与函数类型的结果类型（result type）匹配的堆栈。</p>
<p>函数通过函数索引被引用，由最小索引开始，不引用任何函数导入（function import）。</p>
<h4 id="2-5-4-表"><a href="#2-5-4-表" class="headerlink" title="2.5.4. 表"></a>2.5.4. 表</h4><p>模块的表组件定义了由表类型描述的一个表向量：</p>
<p>$$ table ::&#x3D; { \mathrm{type}\ tabletype }$$</p>
<p>表是特定表元素类型的不透明值的向量。<br>表类型的限制中的最小的大小指定了该表的初始大小。<br>而如果存在最大则其大小限制该表稍后可以增长至的大小。</p>
<p>可以通过元素段（element segment）初始化表。</p>
<p>通过表索引引用表，从最小索引开始，不需要引用一个表导入（table import）。<br>大多数构造都隐式引用表索引0。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，最多可以在一个模块中定义或导入一个表，并且所有构造都隐式引用表0。此限制在将来的版本中可能会取消。</p>
</blockquote>
<h4 id="2-5-5-内存"><a href="#2-5-5-内存" class="headerlink" title="2.5.5. 内存"></a>2.5.5. 内存</h4><p>模块的内存（mems）组件定义了一个线性存储器（或简称为存储器）的向量，如其存储器类型所述：</p>
<p>$$ mem :&#x3D; {\mathrm{type}\ memtype }$$</p>
<p>内存是未被解释的原始字节的向量。<br>内存类型的限制中的最小（Min）大小指定该内存的初始大小，而最大内存大小（Max，如果存在）则限制了以后可以增长的大小。<br>两者均以页面大小为单位。</p>
<p>可以通过数据段（data segment）初始化内存。</p>
<p>内存被内存索引引用，从最小索引开始，不引用内存导入（memory import）。<br>大多数构造都隐式引用内存索引0。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，最多可以在一个模块中定义或导入一个内存，并且所有构造都隐式引用此内存0。此限制在将来的版本中可能会取消。</p>
<p>（换句话说现在的mems根本就是个单元素数组，里面就一个memory）</p>
</blockquote>
<h4 id="2-5-6-全局变量Globals"><a href="#2-5-6-全局变量Globals" class="headerlink" title="2.5.6. 全局变量Globals"></a>2.5.6. 全局变量Globals</h4><p>模块的全局变量组件定义了一个全局变量的向量（或简称为globals）：</p>
<p>$$global ::&#x3D; { \mathrm{type}\ globaltype, \mathrm{init}\ expr}$$</p>
<p>每个全局变量都存储给定全局变量类型（global type）的单个值。<br>它的类型还指定了全局变量是不可变的还是可变的。<br>此外，每个全局变量都使用常量初始化表达式（expr）给出的初始化值进行初始化。</p>
<p>全局变量通过全局索引引用，从最小的索引开始，不引用全局导入。</p>
<h4 id="2-5-7-元素段-Element-Segments"><a href="#2-5-7-元素段-Element-Segments" class="headerlink" title="2.5.7. 元素段 Element Segments"></a>2.5.7. 元素段 Element Segments</h4><p>表的初始内容未初始化。<br>模块的elem组件定义元素段的向量，这些向量以给定的偏移量从元素的静态向量初始化表的子范围。</p>
<p>$$ elem ::&#x3D; { \mathrm{table}\ tableidx, \mathrm{offset}\ express, \mathrm{init} vec(funcidx)}$$</p>
<p>偏移量（offset）由一个常量表达式给出。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，模块中最多允许一个表。因此，唯一有效的tableidx为0。</p>
</blockquote>
<h4 id="2-5-8-数据段-Data-Segments"><a href="#2-5-8-数据段-Data-Segments" class="headerlink" title="2.5.8. 数据段 Data Segments"></a>2.5.8. 数据段 Data Segments</h4><p>内存的初始内容为一堆零值字节。<br>模块的数据组件定义数据段的向量，这些数据段以给定的偏移量和静态字节向量来初始化内存范围。</p>
<p>$$ data ::&#x3D; { \mathrm{data}\ memidx, \mathrm{offset}\ expr, \mathrm{init}\ vec(byte) }$$</p>
<p>偏移量（offset）由一个常量表达式给出。</p>
<blockquote>
<p>注意</p>
<p>在当前版本的WebAssembly中，一个模块中最多允许有一个内存。 因此，唯一有效的memidx为0。</p>
</blockquote>
<h4 id="2-5-9-启动函数-Start-Function"><a href="#2-5-9-启动函数-Start-Function" class="headerlink" title="2.5.9. 启动函数 Start Function"></a>2.5.9. 启动函数 Start Function</h4><p>模块的启动（start）组件声明一个启动函数的函数索引，该函数在初始化表和内存后在实例化模块时自动调用。</p>
<p>$$ start ::&#x3D; { \mathrm{func}\ funcidx }$$</p>
<blockquote>
<p>注意</p>
<p>启动功能用于初始化模块的状态。在初始化完成之前，无法访问模块及其导出（exports）。</p>
</blockquote>
<h4 id="2-5-10-导出-exports"><a href="#2-5-10-导出-exports" class="headerlink" title="2.5.10. 导出 exports"></a>2.5.10. 导出 exports</h4><p>模块的导出组件定义了一组导出。一旦实例化该模块，主机环境就可以访问它们。</p>
<p>$$ export ::&#x3D; { \mathrm{name}\ name, \mathrm{desc}\ exportdesc }$$<br>$$ \displaylines{ exportdesc ::&#x3D; \mathrm{func}\ funcidx\<br>| \mathrm{table}\ tableidx\<br>| \mathrm{mem}\ memidx\<br>| \mathrm{global}\ globalidx}$$</p>
<p>每个导出都用唯一的名称标记。<br>可导出的定义是函数，表，内存和全局变量，它们通过相应的描述符进行引用。</p>
<h5 id="2-5-10-1-惯例"><a href="#2-5-10-1-惯例" class="headerlink" title="2.5.10.1. 惯例"></a>2.5.10.1. 惯例</h5><p>为导出序列定义了以下辅助符号，以保留顺序的方式过滤出特定种类的索引：</p>
<ul>
<li>$func(export^*)&#x3D;[ funcidx | \mathrm(func)\ funcidx \in (export.\mathrm{desc}) ]$</li>
<li>$tables(export^*)&#x3D;[ tableidx | \mathrm(table)\ tableidx \in (export.\mathrm{desc}) ]$</li>
<li>$mems(export^*)&#x3D;[ memidx | \mathrm(mem)\ memidx \in (export.\mathrm{desc}) ]$</li>
<li>$globals(export^*)&#x3D;[ globalidx | \mathrm(global)\ globalidx \in (export.\mathrm{desc}) ]$</li>
</ul>
<h4 id="2-5-11-导入-imports"><a href="#2-5-11-导入-imports" class="headerlink" title="2.5.11. 导入 imports"></a>2.5.11. 导入 imports</h4><p>模块的导入组件定义了实例化所需的一组导入。</p>
<p>$$ import ::&#x3D; { \mathrm{module}\ name, \mathrm{name}\ name, \mathrm{desc}\ importdesc}$$<br>$$ \displaylines{ importdesc ::&#x3D; \mathrm{func}\ typeidx\<br>| \mathrm{table}\ tabletype\<br>| \mathrm{mem}\ memtype\<br>| \mathrm{global}\ globaltype}$$</p>
<p>每个导入都由两级名称空间标记，该名称空间由<em>模块名称</em>和该模块内<em>实体的名称</em>组成。<br>可导入的定义为函数，表，内存和全局变量。<br>每个导入都由一个描述符指定，该描述符的类型与实例化期间提供的定义必须匹配。</p>
<p>每次导入都会在相应的索引空间（index space）中定义一个索引。<br>在每个索引空间中，导入索引都位于模块本身包含的任何定义的第一个索引之前。</p>
<blockquote>
<p>注意</p>
<p>与导出名称不同，导入名称不一定是唯一的。<br>可以多次导入同一“模块名::名称”。<br>这样的导入甚至可能具有不同的类型描述，包括不同种类的实体。<br>仍然可以实例化具有此类导入的模块，具体取决于<em>嵌入程序</em>如何允许解析和提供导入的细节。<br>但是，不需要嵌入程序来支持此类重载，并且WebAssembly模块本身无法实现重载名称。</p>
</blockquote>
<h2 id="3-验证"><a href="#3-验证" class="headerlink" title="3. 验证"></a>3. 验证</h2><h3 id="3-1-惯例"><a href="#3-1-惯例" class="headerlink" title="3.1. 惯例"></a>3.1. 惯例</h3><p>验证将检查WebAssembly模块的格式是否正确，因为只能有效的模块能够被实例化。</p>
<p>有效性是由类型系统根据模块及其内容的抽象语法定义的。<br>对于每个抽象语法，都有一个键入规则，用于指定适用于它的约束。<br>所有规则均以两种等效形式给出：</p>
<ul>
<li>用行文，以直观的形式描述含义。</li>
<li>用公式表示法，以数学形式描述规则。[1]</li>
</ul>
<blockquote>
<p>注意</p>
<p>行文和公式规则是等效的，因此阅读本规范不需要理解公式符号。<br>公式提供了更简洁的符号描述，该符号广泛用于编程语言的语义中，并易于进行数学证明。</p>
</blockquote>
<p>在这两种情况下，规则都是以声明方式制定的。也就是说，它们仅制定约束条件，而没有定义算法。<br>附录中提供了根据本规范的用于类型检查指令序列的健全完整算法的框架。</p>
<h4 id="3-1-1-上下文"><a href="#3-1-1-上下文" class="headerlink" title="3.1.1. 上下文"></a>3.1.1. 上下文</h4><p>单个定义的有效性被制定为与上下文相关，该上下文收集有关周围模块和范围内定义的相关信息：</p>
<ul>
<li>类型：当前模块中定义的类型列表。</li>
<li>函数：在当前模块中声明的功能列表，以其功能类型表示。</li>
<li>表：在当前模块中声明的表格列表，以表格类型表示。</li>
<li>内存：在当前模块中声明的内存列表，以其内存类型表示。</li>
<li>全局变量：在当前模块中声明的全局变量列表，以其全局类型表示。</li>
<li>局部变量：在当前函数中声明的本地列表（包括参数），以其值类型表示。</li>
<li>标签：从当前位置可访问的标签堆栈，以其结果类型表示。</li>
<li>返回值：当前函数的返回类型，表示为可选结果类型，当不允许返回时（如独立表达式），该结果类型不存在。</li>
</ul>
<p>换句话说，上下文包含每个索引空间的一系列适当类型，描述该空间中的每个定义条目。<br>局部变量，标签和返回类型仅用于验证函数体中的指令，而在其他地方保留为空。<br>标签栈是上下文中随指令序列的验证而变化的唯一部分。</p>
<p>更具体地说，上下文被定义为具有抽象语法的记录（records），$C$：</p>
<p>$$ \displaylines{C::&#x3D;\mathrm{types}\ functype^*,\<br>\mathrm{funcs}\ functype^*,\<br>\mathrm{tables}\ tabletype^*,\<br>\mathrm{mems}\ memtype^*,\<br>\mathrm{globals}\ globaltype^*,\<br>\mathrm{locals}\ valtype^*,\<br>\mathrm{labels}\ resulttype^*,\<br>\mathrm{return}\ resulttype^?}$$</p>
<p>除了使用$C.\mathrm{field}$编写的现场访问外，还采用以下表示法来处理上下文：</p>
<ul>
<li>拼写上下文时，将省略空白字段。</li>
<li>$C, \mathrm{field}\ A^*$表示与$C$相同的上下文，但元素$A^*$附加在其$\mathrm{field}$组件序列之前。</li>
</ul>
<blockquote>
<p>注意</p>
<p>我们使用诸如$C.labels[i]$之类的索引符号在上下文中的相应索引空间中查找索引。<br>上下文扩展符号$C，\mathrm{field}\ A$主要用于局部扩展相对索引空间，例如标签索引。<br>因此，将符号定义为附加在各个序列的前面，引入新的相对索引0并移动现有的相对索引。</p>
</blockquote>
<h4 id="3-1-2-行文符号"><a href="#3-1-2-行文符号" class="headerlink" title="3.1.2. 行文符号"></a>3.1.2. 行文符号</h4><p>验证由程式化规则为抽象语法的每个相关部分指定。 这些规则不仅说明定义短语何时有效的约束，而且还使用类型对短语进行分类。 在说明这些规则时采用了以下约定。</p>
<ul>
<li>当且仅当满足相应规则表示的所有约束时，短语A才被称为“对于T型有效”。 T的形式取决于A是什么。</li>
</ul>
<blockquote>
<p>注意</p>
<p>例如，如果$A$是一个函数，则$T$也是一个函数类型。<br>如果$A$是全局类型，则$T$也是全局类型； 如此类推。</p>
</blockquote>
<ul>
<li><p>规则隐式假定给定上下文$C$。</p>
</li>
<li><p>在某些地方，此上下文在本地扩展到带有其他条目的上下文$C’$。措词“*在上下文中$C’$，…声明…*”用于表示以下声明必须在扩展上下文中包含的假设下适用。</p>
</li>
</ul>
<h4 id="3-1-3-正式符号"><a href="#3-1-3-正式符号" class="headerlink" title="3.1.3. 正式符号"></a>3.1.3. 正式符号</h4><blockquote>
<p>注意</p>
<p>本节简要说明了正式指定键入规则的表示法。<br>对于感兴趣的读者，可以在相应的书中找到更全面的介绍。 [2]</p>
</blockquote>
<p>短语$A$具有各自类型$T$的命题被写为$A:T$。<br>但是，总的来说，键入取决于上下文$C$。<br>为明确表示这一点，完整的形式为判断$C\vdash A:T$，它表示$A:T$在C的假设下成立。</p>
<p>正式的符号规则使用一种标准的方法来指定类型系统，将它们呈现为<em>推理规则</em>。<br>每个规则具有以下一般形式：</p>
<p>$$\frac{<br>     {premise}_1 \qquad {premise}_2 \qquad \dots \qquad {premise}_n<br>   }{<br>     {conclusion}<br>   }$$</p>
<p>这样的规则被认为是一个大含义：如果所有前提都成立，那么结论成立。<br>有些规则没有前提；它们是其结论无条件成立的<em>公理</em>。<br>结论始终是判断$C \vdash A : T$，并且抽象语法的每个相关构造A都有一个相应的规则。</p>
<blockquote>
<p>注意</p>
<p>例如，可以将i32.add指令的输入规则作为一个公理给出：<br>$$\frac{<br>      }{<br>        C \vdash i32.add : [i32, i32] \to [i32]<br>      }$$</p>
<p>该指令对于[i32, i32]→[i32]类型始终有效（假设它使用两个i32值并产生一个i32），而与任何其他条件无关。<br>像local.get这样的指令可以按如下方式键入：<br>$$\frac{<br>        C.locals[x] &#x3D; t<br>      }{<br>        C \vdash \mathrm{local.get}\ x : [] \to [t]<br>      }$$<br>在此，前提要求上下文中存在直接本地索引x。<br>该指令产生其各自类型t的值（并且不消耗任何值）。<br>如果C.locals[x]不存在，则前提不成立，并且指令类型错误。</p>
<p>最后，结构化指令需要一个递归规则，其中前提本身就是键入判断：<br>$$\frac{<br>        C,\ \mathrm{label}[t^?] \vdash instr^\ast : [] \to [t^?]<br>      }{<br>        C \vdash \mathrm{block}[t^?]\ instr^\ast \ \mathrm{end}: [] \to [t^?]<br>      }$$<br>一个block指令仅在其主体中的指令序列有效时才有效。<br>此外，结果类型必须与区块的注解$[t^?]$匹配。<br>如果是这样，则块指令与主体具有相同的类型。<br>在内部，可以使用相同类型的其他标签，这可以通过使用前提的其他标签信息扩展上下文C来表示。</p>
</blockquote>
<p>[1]语义来自以下文章：Andreas Haas，Andreas Rossberg，Derek Schuff，Ben Titzer，Dan Gohman，Luke Wagner，Alon Zakai，JF Bastien，Michael Holman。 《通过WebAssembly加速Web》。 第38届ACM SIGPLAN编程语言设计和实现会议（PLDI 2017）的会议记录。 ACM 2017年。</p>
<p>[2]例如：Benjamin Pierce。 《类型和编程语言》。 麻省理工学院出版社2002</p>
<h3 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2. 类型"></a>3.2. 类型</h3><p>大多数类型都是普遍有效的。<br>但是，限制适用于函数类型以及表类型和内存类型的限制，必须在验证期间进行检查。</p>
<h4 id="3-2-1-限制Limits"><a href="#3-2-1-限制Limits" class="headerlink" title="3.2.1. 限制Limits"></a>3.2.1. 限制Limits</h4><p>界限必须具有在给定范围内的有意义的界限。</p>
<h5 id="3-2-1-1-min-n-max-m"><a href="#3-2-1-1-min-n-max-m" class="headerlink" title="3.2.1.1. ${min\ n, max\ m^?}$"></a>3.2.1.1. ${min\ n, max\ m^?}$</h5><ul>
<li>n的值不能大于k。</li>
<li>如果最大值$m^?$不为空，则：<ul>
<li>它的值不能大于k。</li>
<li>它的值不能小于n。</li>
</ul>
</li>
<li>然后该限制在范围k内有效。</li>
</ul>
<p>$$\frac{<br>     n \leq k<br>     \qquad<br>     (m \leq k)^?<br>     \qquad<br>     (n \leq m)^?<br>   }{<br>     \vdash limits { min<del>n, max</del>m^? } : k<br>   }$$</p>
<h4 id="3-2-2-函数类型"><a href="#3-2-2-函数类型" class="headerlink" title="3.2.2. 函数类型"></a>3.2.2. 函数类型</h4><p>函数类型不能指定一个以上的结果。</p>
<h5 id="3-2-2-1-t-1-n-to-t-2-m"><a href="#3-2-2-1-t-1-n-to-t-2-m" class="headerlink" title="3.2.2.1. $[t_1^n] \to [t_2^m]$"></a>3.2.2.1. $[t_1^n] \to [t_2^m]$</h5><ul>
<li>参数m不得大于1。</li>
<li>则函数类型有效。</li>
</ul>
<p>$$\frac{<br>   }{<br>     \vdash [t_1^\ast] \to [t_2^?] ~ok<br>   }$$</p>
<blockquote>
<p>注意</p>
<p>在将来的WebAssembly版本中，可能消除对返回值至多一个的限制。</p>
</blockquote>
<h4 id="3-2-3-表类型"><a href="#3-2-3-表类型" class="headerlink" title="3.2.3. 表类型"></a>3.2.3. 表类型</h4><h5 id="3-2-3-1-元素类型：限制"><a href="#3-2-3-1-元素类型：限制" class="headerlink" title="3.2.3.1. 元素类型：限制"></a>3.2.3.1. 元素类型：限制</h5><ul>
<li>限制limits必须在$2^32$范围内有效</li>
<li>则表类型有效。</li>
</ul>
<p>$$   \frac{<br>     \vdash limits: 2^{32}<br>   }{<br>     \vdash limits<del>elemtype</del>\mathrm{ok}<br>   }$$</p>
<h4 id="3-2-4-内存类型"><a href="#3-2-4-内存类型" class="headerlink" title="3.2.4. 内存类型"></a>3.2.4. 内存类型</h4><h5 id="3-2-4-1-限制"><a href="#3-2-4-1-限制" class="headerlink" title="3.2.4.1. 限制"></a>3.2.4.1. 限制</h5><ul>
<li>限制limits必须在$2^16$范围内有效</li>
<li>则内存类型有效。</li>
</ul>
<p>$$   \frac{<br>     \vdash limits: 2^{16}<br>   }{<br>     \vdash limits~\mathrm{ok}<br>   }$$</p>
<h4 id="3-2-5-全局类型"><a href="#3-2-5-全局类型" class="headerlink" title="3.2.5. 全局类型"></a>3.2.5. 全局类型</h4><h5 id="3-2-5-1-可变值类型"><a href="#3-2-5-1-可变值类型" class="headerlink" title="3.2.5.1. 可变值类型"></a>3.2.5.1. 可变值类型</h5><ul>
<li>全局类型有效</li>
</ul>
<p>$$   \frac{<br>   }{<br>     \vdash globaltype\ mut<del>valtype</del>\mathrm{ok}<br>   }$$</p>
<h4 id="3-2-6-外部类型"><a href="#3-2-6-外部类型" class="headerlink" title="3.2.6. 外部类型"></a>3.2.6. 外部类型</h4><h5 id="3-2-6-1-函数类型-func"><a href="#3-2-6-1-函数类型-func" class="headerlink" title="3.2.6.1. 函数类型 func"></a>3.2.6.1. 函数类型 func</h5><ul>
<li>func的函数类型functype必须有效。</li>
<li>则外部类型有效。</li>
</ul>
<p>$$   \frac{<br>     \vdash functype<del>ok<br>   }{<br>     \vdash func</del>functype~ok<br>   }$$</p>
<h5 id="3-2-6-2-表类型-table"><a href="#3-2-6-2-表类型-table" class="headerlink" title="3.2.6.2. 表类型 table"></a>3.2.6.2. 表类型 table</h5><ul>
<li>差不多同上，仅类型区别，类型有效则有效</li>
</ul>
<h5 id="3-2-6-3-内存类型-mem"><a href="#3-2-6-3-内存类型-mem" class="headerlink" title="3.2.6.3. 内存类型 mem"></a>3.2.6.3. 内存类型 mem</h5><ul>
<li>差不多同上，仅类型区别，类型有效则有效</li>
</ul>
<h5 id="3-2-6-4-全局类型-global"><a href="#3-2-6-4-全局类型-global" class="headerlink" title="3.2.6.4. 全局类型 global"></a>3.2.6.4. 全局类型 global</h5><ul>
<li>差不多同上，仅类型区别，类型有效则有效</li>
</ul>
<h3 id="3-3-指令"><a href="#3-3-指令" class="headerlink" title="3.3. 指令"></a>3.3. 指令</h3><p>指令按函数类型[t]→[t]进行分类，这些函数类型描述了指令如何操纵操作数堆栈。 这些类型描述了必需的输入堆栈，其中弹出了一条指令的类型为t的参数值，以及提供的输出堆栈，其返回的结果为类型t的结果。</p>
<h2 id="4-执行"><a href="#4-执行" class="headerlink" title="4. 执行"></a>4. 执行</h2><h2 id="5-二进制格式"><a href="#5-二进制格式" class="headerlink" title="5. 二进制格式"></a>5. 二进制格式</h2><h2 id="6-文本格式"><a href="#6-文本格式" class="headerlink" title="6. 文本格式"></a>6. 文本格式</h2><h2 id="A-附录"><a href="#A-附录" class="headerlink" title="A. 附录"></a>A. 附录</h2>]]></content>
      <tags>
        <tag>wasm</tag>
        <tag>todo</tag>
        <tag>specification</tag>
      </tags>
  </entry>
</search>
