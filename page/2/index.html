<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"c0mm4nd.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Talkless">
<meta property="og:url" content="https://c0mm4nd.com/page/2/index.html">
<meta property="og:site_name" content="Talkless">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Command M (C0MM4ND&#x2F;K0MM4ND)">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://c0mm4nd.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Talkless</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Talkless</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">55</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">65</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/fit5046-a2-paper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/fit5046-a2-paper/" class="post-title-link" itemprop="url">使用现有基础架构进行服务器端WiFi室内定位的经验与挑战 Experiences & Challenges with Server-Side WiFi Indoor Localization Using Existing Infrastructure</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-11 17:21:35" itemprop="dateCreated datePublished" datetime="2021-10-11T17:21:35+08:00">2021-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>FIT5046 要求做PPT演讲的paper</p>
<p>Authors:</p>
<img src="/post/fit5046-a2-paper/image-20210412225148141.png" class="" title="image-20210412225148141">

<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>在大型公共场所中，基于WiFi的室内定位的实际部署很少，而且相差甚远，因为大多数最新解决方案都需要客户端或基础架构方面的更改。因此，即使这些解决方案可以实现较高的定位精度，但由于成本和/或客户采用原因，它们并不实用。大多数公共场所都使用商业控制器管理的WLAN解决方案，该解决方案既不允许客户更改，也不允许基础架构更改。实际上，对于这样的场所，我们已经观察到高度异构的设备，客户端应用的采用率非常低。</p>
<p>在本文中，我们介绍了在此类场所部署可扩展位置系统的经验。我们证明服务器端定位并非易事，并且提出了与此方法相关的两个独特挑战，即基数不匹配和高客户端扫描延迟。 “不匹配”挑战导致在离线阶段和在线阶段报告客户端的一组接入点（AP）之间严重不匹配，而“延迟”挑战导致报告任何特定客户端的AP报告数据的数量较少。我们从已经部署了四年以上的WiFi设置中收集了三周的详细地面真相数据（≈200个地标），以提供证据证明这些问题的严重程度并了解这些问题的影响。我们提出启发式方法来减轻它们。我们还总结了实际部署面临的挑战和陷阱，这些挑战和陷阱会影响定位的准确性。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/fit5046-a2-paper/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/design-of-contracts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/design-of-contracts/" class="post-title-link" itemprop="url">Design of Contracts</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-11 17:21:35" itemprop="dateCreated datePublished" datetime="2021-10-11T17:21:35+08:00">2021-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>说实话其实一开始压根没想做合约，就只是想做个chain。</p>
<p>但是后来发现你不做DAPP你的chain都没人看，那些做coin的也都在往DAPP靠。就有种被逼上梁山的感觉。不过还好现在有个去华山的路（WASM），可以考虑上了华山再往梁山飞。</p>
<p>其实我也不算是第一个选择华山飞梁山的，cosmos和eth2.0也选，不过人家有现成地图，我只能凭感觉乱飘。而且我们不是一个山头起飞的，他们选了更早被人发现的山头（wasmer），我选了个看起来粗大(?)一点的新山头（wasmtime）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/design-of-contracts/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/ecdsa-sign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/ecdsa-sign/" class="post-title-link" itemprop="url">ECDSA签名及验证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-11 17:21:35" itemprop="dateCreated datePublished" datetime="2021-10-11T17:21:35+08:00">2021-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ECDSA私钥是取q为模后得到的整数x。相关标准规定x不得为0。 因此，x是在[1，q-1]范围内的整数。qlen为q的二进制长度。</p>
<p>签名的生成使用了密码学哈希函数H和输入的消息m。消息首先由H处理，产生值H(m)即消息m的hash，它是长度为hlen的二进制序列。通常，选择H使其输出长度hlen大致等于qlen，因为签名方案的总体安全性取决于hlen和qlen之间的最小值；但是，相关标准支持hlen和qlen的所有组合。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/ecdsa-sign/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/bitcontracts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/bitcontracts/" class="post-title-link" itemprop="url">Bitcontracts: Supporting Smart Contracts in Legacy Blockchains</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-11 03:20:25" itemprop="dateCreated datePublished" datetime="2021-10-11T03:20:25+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-26 13:37:10" itemprop="dateModified" datetime="2021-10-26T13:37:10+08:00">2021-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bitcontracts：传统区块链上支持智能合约"><a href="#Bitcontracts：传统区块链上支持智能合约" class="headerlink" title="Bitcontracts：传统区块链上支持智能合约"></a>Bitcontracts：传统区块链上支持智能合约</h1><p><strong>摘要：</strong>在本文中，我们提出了 Bitcontracts，这是一种新颖的解决方案，可以在未修改的传统加密货币（如原生不支持合约的比特币）之上安全高效地执行通用智能合约。我们解决方案的出发点是一个链下执行模型，其中合约的发行者指定一组服务提供商来执行合约的代码。如果法定数量的服务提供商报告相同的结果，并且客户可以自由选择他们信任和使用哪些此类合约，则合约的执行结果被接受。本文的主要技术贡献是如何在不修改底层区块链的情况下安全高效地实现这样的信任模型。我们还确定了区块链系统必须支持的一组通用属性，以便可以安全地添加富有表现力的智能合约，并根据这些标准分析流行的现有区块链。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/bitcontracts/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/enabling-x-chain-txs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/enabling-x-chain-txs/" class="post-title-link" itemprop="url">Enabling Cross-Chain Transactions: A Decentralized Cryptocurrency Exchange Protocol</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-10 00:47:41" itemprop="dateCreated datePublished" datetime="2021-10-10T00:47:41+08:00">2021-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-26 13:38:21" itemprop="dateModified" datetime="2021-10-26T13:38:21+08:00">2021-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="赋能跨链交易：一项分布式的加密货币交易协议"><a href="#赋能跨链交易：一项分布式的加密货币交易协议" class="headerlink" title="赋能跨链交易：一项分布式的加密货币交易协议"></a>赋能跨链交易：一项分布式的加密货币交易协议</h1><img src="/post/enabling-x-chain-txs/image-20211011032455266.png" class="" title="image-20211011032455266">

<p><strong>摘要：</strong>受比特币的启发，市场上出现了多种基于区块链技术的加密货币。由于区块链的特殊结构，传统货币与加密货币之间或不同类型加密货币之间的直接交易被认为是不可能的。<br>通常，不同货币之间的交易是通过一个中心化的第三方平台进行的。但是，它存在单点故障的问题，容易受到攻击，从而影响交易的安全性。在本文中，我们提出了一种分布式加密货币交易方案来解决中心化交易所的问题，可以实现不同类型加密货币之间的安全交易。我们的方案是通过以太坊区块链上的智能合约实现的，并部署在以太坊测试网络上。除了实现单个用户之间的交易，我们的方案还允许多个用户之间的交易。实验结果证明我们方案的成本是可以接受的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/enabling-x-chain-txs/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/go-interesting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/go-interesting/" class="post-title-link" itemprop="url">Go Interesting</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-17 21:49:23" itemprop="dateCreated datePublished" datetime="2021-09-17T21:49:23+08:00">2021-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-11 17:21:35" itemprop="dateModified" datetime="2021-10-11T17:21:35+08:00">2021-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里记录一些golang使用中的小细节，每次都像cgo那样单独写一篇有点太水了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/go-interesting/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/fit5137-adv-db-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/fit5137-adv-db-notes/" class="post-title-link" itemprop="url">Notes for FIT5137: Advanced database technology</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-21 00:05:45" itemprop="dateCreated datePublished" datetime="2021-08-21T00:05:45+08:00">2021-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-31 22:31:10" itemprop="dateModified" datetime="2021-10-31T22:31:10+08:00">2021-10-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>所谓的“高级数据库技术”居然是NoSQL……</p>
<h2 id="W1-Intro"><a href="#W1-Intro" class="headerlink" title="W1 Intro"></a>W1 Intro</h2><p>关系型数据库<br>Structured Query Language (SQL)<br>ACID (Atomicity, Consistency, Isolation, Durability) 原子性，一致性，隔离性，持久性</p>
<p>非关系型数据库（=NoSQL）<br>BASE (Basically Available, Soft state, Eventual consistency)  基本可用性，软状态，最终一致性</p>
<p>Big Data特征（3V）</p>
<ul>
<li>Volume （数据）量 -&gt; Scaling up/out-&gt;up=升配; out=加机</li>
<li>Velocity （数据输入的）速 -&gt; stream / feedback-loop</li>
<li>Variety 多样化 -&gt; Structured/Unstructured/Semi-structured</li>
</ul>
<p>因此使用传统关系型数据库难以处理BigData</p>
<p>NoSQL的属性</p>
<ul>
<li>schema-free 不受结构限制</li>
<li>Support distributed database architectures 支持分布式数据库架构</li>
<li>high scalability, high availability, and fault tolerance 高拓展，高可用，错误容忍</li>
</ul>
<p>NoSQL的分类</p>
<ul>
<li>Key-value databases</li>
<li>Document-oriented databases</li>
<li>Column-oriented databases</li>
<li>Graph databases</li>
</ul>
<p>这个unit里不讲kv（讲kv估计要么讲太简单要么讲太难</p>
<p>后面三类的介绍略，在对应week会讲到</p>
<p>NoSQL</p>
<table>
<thead>
<tr>
<th>Adv</th>
<th>Disadv</th>
</tr>
</thead>
<tbody><tr>
<td>高拓展，可用，错误容忍</td>
<td>需要复杂的编程</td>
</tr>
<tr>
<td>使用低成本商品硬件</td>
<td>无关系——只有应用代码</td>
</tr>
<tr>
<td>支持BigData</td>
<td>没有事务完整性支持</td>
</tr>
<tr>
<td>k-v模型提高了存储效率</td>
<td>只提供了最终一致</td>
</tr>
</tbody></table>
<p>Relational Model</p>
<table>
<thead>
<tr>
<th>Adv</th>
<th>Disadv</th>
</tr>
</thead>
<tbody><tr>
<td>使用独立表使得结构独立。表结构变化不影响数据访问或应用程序</td>
<td>RMDBS需要大量硬件和系统软件开销</td>
</tr>
<tr>
<td>表视图提高了概念的简单些，促进数据库设计实现管理与使用</td>
<td>概念上的简单些为相对未受训练的人提供了良好的系统工具，但是如果不加以检查可能会产生与文件系统中数据发生异常</td>
</tr>
<tr>
<td>基于SQL的Ad-hoc查询能力</td>
<td>个人和部门开发各自的应用，产生信息孤岛（islands of info）问题</td>
</tr>
<tr>
<td>强大的RMDBS将最终用户和物理层面细节隔离开，提高实践和管理的简单性</td>
<td></td>
</tr>
</tbody></table>
<h2 id="W2-Intro-to-MongoDB"><a href="#W2-Intro-to-MongoDB" class="headerlink" title="W2: Intro to MongoDB"></a>W2: Intro to MongoDB</h2><p>Document-oriented databases, 本质上是K-V数据库的子类</p>
<p>面向文档的数据库是无模式scheme-free的。</p>
<ul>
<li>存储的数据没有预定义的结构</li>
<li>每个文档都可以有自己的结构</li>
</ul>
<p>文档：MongoDB 中数据的基本单位。<br>➢ 类似于关系数据库中的一行（但更具表现力）。<br>➢ 文档采用 BSON 结构——类似于 JSON（由字段和值对组成的数据结构）</p>
<p>集合：一组 MongoDB 文档。<br>➢ 类似于关系数据库中的表。<br>➢ 通常，集合中的所有文档都有相似或相关的目的。</p>
<p>数据库：集合的物理容器。</p>
<h3 id="易于使用"><a href="#易于使用" class="headerlink" title="易于使用"></a>易于使用</h3><p>用更灵活的模型文档替换了关系数据库中行的概念。</p>
<ul>
<li>复杂的层级关系可以用单个记录表示。</li>
<li>没有预定义的模式：文档的key和value不是固定的类型或大小 </li>
</ul>
<p>MongoDB结合了横向扩展(scale out)的能力和各种功能，如二级索引、范围查询、排序、聚合和地理空间索引。</p>
<h3 id="易于拓展"><a href="#易于拓展" class="headerlink" title="易于拓展"></a>易于拓展</h3><p>▪ MongoDB 旨在横向扩展。<br>▪ 面向文档的数据模型可以更轻松地跨多个服务器拆分数据。<br>▪ MongoDB 自动负责平衡集群中的数据和负载，自动重新分发文档并将用户请求路由到正确的机器。<br>➢ 允许开发人员专注于对应用程序进行编程，而不是对其进行扩展。 </p>
<h3 id="众多特性"><a href="#众多特性" class="headerlink" title="众多特性"></a>众多特性</h3><p>MongoDB 旨在成为通用数据库。</p>
<p>主要特点：</p>
<ul>
<li>创建、读取、更新、删除 (CRUD) 操作</li>
<li>索引index：MongoDB 支持通用二级索引，允许多种快速查询，并提供唯一、复合、地理空间和全文索引功能。</li>
<li>聚合aggregation：MongoDB 支持“聚合管道”，允许从简单的片段构建复杂的聚合并允许数据库对其进行优化</li>
<li>特殊集合类型：MongoDB 支持应在特定时间到期的数据的生存时间集合，例如会话。 它还支持固定大小的集合，这对于保存最近的数据（例如日志）很有用。</li>
<li>文件存储：MongoDB 支持易于使用的协议来存储大文件和文件元数据。</li>
</ul>
<p>与关系数据库不同，MongoDB 不支持join和复杂的多行事务，因为在分布式系统中很难有效地提供这两种功能。</p>
<h3 id="不牺牲速度"><a href="#不牺牲速度" class="headerlink" title="不牺牲速度"></a>不牺牲速度</h3><p>MongoDB 的几乎每个方面都旨在保持高性能。</p>
<ul>
<li>MongoDB 为文档添加动态填充并预分配数据文件以换取额外的空间使用以获得一致的性能。</li>
<li>它使用尽可能多的 RAM 作为其缓存，并尝试自动选择正确的索引进行查询。</li>
</ul>
<h2 id="W3-Mongo-Shell"><a href="#W3-Mongo-Shell" class="headerlink" title="W3: Mongo Shell"></a>W3: Mongo Shell</h2><p>一些MongoDB的CRUD操作。GUI上操作是在MongoDB Compass下，在w2最后讲了。w3主要是在shell里自己coding。</p>
<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p>Create（<code>createCollection</code>， <code>insert[One/Many](&lt;Array of Objects&gt;)</code>，）</p>
<p>Update(<code>update[One/Many](&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;</code>) )</p>
<p>Delete(<code>.drop()</code>, <code>.dropDatabase()</code>,<code>delete[One/Many]</code>)在GUI下很简单，这里省略。</p>
<p>主要需要关注R(ead)里即Query的编写：<br><code>find[One/Many](&lt;query&gt;, &lt;fields&gt;)</code></p>
<p>Projection: find的第二个字段表示输出（Project）的内容</p>
<p>Limit &amp; Skip: Skip（跳过数个record）优先于Limit</p>
<p>Sort: 1 ascending , -1 descending</p>
<p>update也可以用replaceOne()，参数相同</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MongoDB 必须进行<strong>集合扫描</strong>（<strong>COLLSCAN</strong>）（扫描集合中的<strong>每个</strong>文档）以检索与用户查询语句匹配的文档。</p>
<p>通过索引（<strong>IXSCAN</strong>），可以加速查询处理。索引支持高效的数据检索，因为 MongoDB 可以使用索引来限制它必须检查的文档数量。</p>
<p><code>db.&lt;collection name&gt;.createIndex( &#123; KEY1:1, KEY2:1 &#125; )</code></p>
<p>注意：要升序索引，请使用 1。要降序索引，请使用 -1。</p>
<h2 id="W4-MongoDB-Aggregation"><a href="#W4-MongoDB-Aggregation" class="headerlink" title="W4: MongoDB Aggregation"></a>W4: MongoDB Aggregation</h2><p>略难的部分，有点绕口</p>
<p>Aggregation聚合操作处理数据记录并返回计算结果。<br>聚合操作将来自多个文档的值组合在一起，并且可以对分组的数据进行各种操作，返回一个<br>单一结果。<br>MongoDB 提供三种聚合方式：</p>
<ul>
<li>Aggregation pipeline</li>
<li>Map-reduce 功能</li>
<li>单一目的Aggregation方法</li>
</ul>
<h3 id="Aggregation管道"><a href="#Aggregation管道" class="headerlink" title="Aggregation管道"></a>Aggregation管道</h3><p>MongoDB 的聚合框架以数据处理管道的概念为模型。文档进入多阶段管道，将文档转换为聚合结果。</p>
<p>特性：<br>➢ 每一阶段接收前一阶段的输出。<br>➢ 应该在一个数组中，因为要遵循某些步骤。</p>
<p>$match：等于find</p>
<p>$group，精髓在于_id的选择</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.persons.aggregate([</span><br><span class="line">    &#123; $match: &#123;gender: <span class="string">&quot;female&quot;</span>&#125; &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">        $group: &#123; <span class="comment">// 表示总人数</span></span><br><span class="line">            _id: &#123; state: <span class="string">&quot;$location.state&quot;</span> &#125;, <span class="comment">//匹配了上面所有</span></span><br><span class="line">            totalPersons: <span class="comment">// 新字段名字 </span></span><br><span class="line">                &#123; $sum: <span class="number">1</span> &#125; <span class="comment">// group需要配合$sum, $avg, $max, $min, $first, $last之类的操作分组</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">]).pretty()</span><br></pre></td></tr></table></figure>

<p>$sort</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $sort: &#123; totalPersons: <span class="number">-1</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>$project</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$project: &#123;</span><br><span class="line">    _id: 0, </span><br><span class="line">    name: 1, </span><br><span class="line">    email: 1, </span><br><span class="line">    birthdate: &#123; $convert: &#123; input: &#x27;$dob.date&#x27;, to: &#x27;date&#x27; &#125; &#125;, </span><br><span class="line">    age: &quot;$dob.age&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>$lookup(匹配文档之间关系)生成嵌入文档</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $lookup: &#123;</span><br><span class="line">        from: &lt;collection to join&gt;,</span><br><span class="line">        localField: &lt;field from the input documents&gt;,</span><br><span class="line">        foreignField: &lt;field from the documents of the <span class="string">&quot;from&quot;</span> collection&gt;,</span><br><span class="line">        as: &lt;output array field&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，我们现有文档含有_id这个字段，从address这个collection（含有patron_id）之中找到和_id相同（匹配）的patron_id，然后作为一个列表放在当前文档的addresses里</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.patron.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $lookup: &#123;</span><br><span class="line">            from: <span class="string">&quot;address&quot;</span>,</span><br><span class="line">            localField: <span class="string">&quot;_id&quot;</span>,</span><br><span class="line">            foreignField: <span class="string">&quot;patron_id&quot;</span>,</span><br><span class="line">            as: <span class="string">&quot;addresses&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3><p>检索每个含k的文档作为一个map，然后每个执行reduce</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.collection.mapReduce(</span><br><span class="line">                         &lt;map&gt;, // function() &#123; emit(this.cust_id, this.amount) &#125;</span><br><span class="line">                         &lt;reduce&gt;, // function(k, v) &#123; return Array.sum(v) &#125; </span><br><span class="line">                         &#123;</span><br><span class="line">                           out: &lt;collection&gt;,</span><br><span class="line">                           query: &lt;document&gt;,</span><br><span class="line">                           sort: &lt;document&gt;,</span><br><span class="line">                           limit: &lt;number&gt;,</span><br><span class="line">                           finalize: &lt;function&gt;,</span><br><span class="line">                           scope: &lt;document&gt;,</span><br><span class="line">                           jsMode: &lt;boolean&gt;,</span><br><span class="line">                           verbose: &lt;boolean&gt;,</span><br><span class="line">                           bypassDocumentValidation: &lt;boolean&gt;</span><br><span class="line">                         &#125;</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure>

<p>测验常客 $unwind</p>
<h3 id="单一目的Aggregation方法"><a href="#单一目的Aggregation方法" class="headerlink" title="单一目的Aggregation方法"></a>单一目的Aggregation方法</h3><p>.estimatedDocumentCount( )<br>.count( )<br>.distinct( )</p>
<h2 id="W5-Introduction-to-Column-Oriented-Database"><a href="#W5-Introduction-to-Column-Oriented-Database" class="headerlink" title="W5 Introduction to Column-Oriented Database"></a>W5 Introduction to Column-Oriented Database</h2><p>▪ 源自 Google 的 BigTable 产品、HBase 和 Cassandra。<br>▪ 也称为列族数据库。<br>▪ 以键值对的形式组织数据，键映射到值组件中的一组列。<br>➢ Column：类似于关系数据库中一个数据单元格的键值对<br>➢ Key：列名<br>➢ Value：列中存储的数据<br>▪ 一组逻辑相关的列称为超级列。 所有超级列组合在一起以创建列族。 列族在概念上类似于关系模型中的表。<br>▪ 列族中的每个行键可以有不同的列。</p>
<p>▪ 面向列的 DBMS 是一种 DBMS，它将数据表存储为数据列的部分，而不是大多数 DBMS 实现中的数据行。<br>▪ 具有许多空值的列（称为稀疏sparse 数据）可以更有效地处理，而不会浪费空单元格的存储容量。</p>
<p>▪ 关系数据库既可以面向行，也可以面向列。<br>▪ 基于行的系统旨在高效地返回整行的数据，这与用户希望检索有关特定对象或实体的信息的常见用例相匹配。<br>▪ 大多数数据库系统通过数据库索引来加速搜索操作。</p>
<p>▪ 在面向列的数据库中，一列的所有值都放在磁盘上</p>
<p>Column-Oriented Databases</p>
<table>
<thead>
<tr>
<th>Adv</th>
<th>Disadv</th>
</tr>
</thead>
<tbody><tr>
<td>加快查询处理和聚合操作。</td>
<td>检索与单个实体有关的所有属性变得效率低下</td>
</tr>
<tr>
<td>高效的存储空间消耗（非常适合处理稀疏数据）。</td>
<td>Join操作将大大减慢（必须扫描每一列才能找到属于某个外部记录标识符的值）。</td>
</tr>
</tbody></table>
<p>以下是 Google BigTable 的核心功能：<br>➢ 开发者可以动态控制列。<br>➢ 数据值由行标识符、列名和时间戳索引。<br>➢ 数据建模者和开发者可以控制数据的位置。<br>➢ 一行的读写是原子的。<br>➢ 行按排序顺序维护。</p>
<p>▪ 行由多个列族组成。 每个系列由一组相关的列组成。<br>▪ 数据值由行、列名和时间戳记索引</p>
<p>▪ 数据值按行标识符、列名和时间戳编制索引。<br>➢ 行标识符类似于关系数据库中的主键。<br>▪ 一个列值可以存在多个版本。 查询列值时默认返回最新版本。</p>
<p>Apache Cassandra Features</p>
<ul>
<li>Distributed</li>
<li>Decentralized</li>
<li>Elastically scalable</li>
<li>Highly available &amp; Fault-tolerant</li>
</ul>
<p>Monolithic Architecture-&gt; single point of failure</p>
<p>The Master-slave model (only master server performs writes)-&gt; a failure of the write master</p>
<p>sharding to scale writes -&gt; Requires manual shuffling of data &amp; Failure points of the master nodes</p>
<p>处理领导者的死亡<br>▪ 提高主从系统可用性的解决方案。<br>▪ 采用主故障转移协议。<br>▪ 协议因实现而异。<br>▪ 原则是当前一个master失败时指定一个新的master</p>
<p>领导选举的不良特征<br>▪ 应用程序必须了解数据库拓扑。<br>▪ 必须仔细规划数据分区。<br>▪ 写入难以扩展。<br>▪ 故障转移通常会显着增加系统的复杂性，对于多站点数据库尤其如此。<br>▪ 增加容量需要重新整理数据，这可能会导致停机。</p>
<p>Cassandra 是一个可弹性伸缩的数据库<br>▪ 可扩展性——可以在性能几乎没有下降的情况下继续处理更多的请求。<br>➢ 纵向扩展：增加更多的硬件容量和内存。<br>➢ 水平扩展：添加更多的机器，上面有全部或部分数据，这样没有一台机器必须承担服务请求的全部负担。<br>▪ 弹性可扩展性 – 指横向可扩展性的一个特殊属性，这意味着您的集群可以无缝扩展和缩减</p>
<p>Cassandra 的点对点方法<br>▪ Cassandra 集群中的所有节点都可以接受读取和写入，无论写入或请求的数据属于集群中的哪个位置。<br>▪ 节点间通信通过gossip 协议进行，该协议允许所有节点快速接收更新，而无需主协调器</p>
<p>P2P方法有几个优点：</p>
<ol>
<li>简单。</li>
<li>没有节点可以是单点故障。</li>
<li>扩展和缩减相当简单：在集群中添加或删除服务器。<br>➢ 点对点网络中的服务器相互通信，最终为新节点分配一组数据进行管理。<br>➢ 当一个节点被移除时，托管来自被移除节点的数据副本的服务器响应读写请求。</li>
</ol>
<p>▪ 由于P2P网络没有单一的主协调服务器，集群中的服务器负责管理主服务器将处理的许多操作，包括以下内容：<br>➢ 共享集群中服务器状态信息<br>➢ 确保节点拥有最新版本的数据<br>➢ 确保在应该接收写入的服务器不可用时存储写入数据<br>▪ Cassandra 拥有实现所有这些功能的协议。</p>
<p>节点间通信（Gossip）<br>▪ Gossip协议：<br>o 是对等通信协议。<br>o 定期交换关于它们自己和集群中其他节点的状态信息。<br>o 在计时器上每秒运行一次，并最多与其他三个节点交换状态消息。<br>o 用作分布式数据库中的自动复制机制<br>o 较旧的信息被特定节点的最新状态覆盖</p>
<p>▪ 每次将服务器添加到集群中时，以完整的服务器到服务器通信协议发送的消息数量增长得更快。</p>
<p>Gossiper 如何运作<br>▪ 每秒一次，Gossiper 将在集群中随机选择一个节点并与其初始化gossip 会话。<br>o 每轮gossip 需要三个消息。<br>▪ gossip 发起者向其选择的朋友发送 GossipDigestSynMessage。<br>▪ 当朋友收到这个消息时，它返回一个 GossipDigestAckMessage。<br>▪ 当发起者收到好友的 ack 消息时，它会向好友发送 GossipDigestAck2Message 以完成一轮gossip 。</p>
<p>Cassandra ——Read<br>▪ Cassandra 集群中的任何节点都可以处理客户端请求。<br>▪ 所有节点都有关于集群状态的信息，并且可以充当客户端的代理，将请求转发到集群中的适当节点。</p>
<p>Cassandra ——Write<br>▪ 如果一个节点不可用，则其他节点可以代表它接收写入请求，并在可用时将它们转发到预期节点。</p>
<p>什么时候使用面向列的数据库？<br>▪ 列族数据库是需要高水平写入性能、大量服务器或多数据中心可用性的大规模数据库部署的合适选择。<br>➢ Cassandra 支持多数据中心部署，包括多数据中心复制。<br>▪ 写密集型操作，例如社交网络应用程序中的操作，是使用列族数据库的良好候选者。<br>➢ Cassandra 的点对点架构支持暗示切换，这意味着只要至少有一个节点在运行且可达，数据库将始终能够接受写操作。<br>▪ 列族数据库也适用于需要大量服务器来满足预期工作负载的情况。</p>
<h2 id="W6-Apache-Cassandra-Architecture-amp-CQL"><a href="#W6-Apache-Cassandra-Architecture-amp-CQL" class="headerlink" title="W6 Apache Cassandra Architecture &amp; CQL"></a>W6 Apache Cassandra Architecture &amp; CQL</h2><h3 id="Cassandra-架构的特点"><a href="#Cassandra-架构的特点" class="headerlink" title="Cassandra 架构的特点"></a>Cassandra 架构的特点</h3><p>▪ Cassandra 没有主节点或从节点。<br>▪ 它具有环型/点对点架构。<br>▪ 数据自动分布在所有节点上。<br>▪ 跨节点复制数据以实现冗余。<br>▪ 数据保存在内存中并缓慢写入磁盘。<br>▪ 键的哈希值用于在集群中的节点之间分配数据。<br>▪ Cassandra 架构支持多个数据中心。<br>▪ 数据可以跨数据中心复制。</p>
<h3 id="环和令牌"><a href="#环和令牌" class="headerlink" title="环和令牌"></a>环和令牌</h3><p>▪ Cassandra 将集群管理的数据表示为环。<br>▪ 环中的每个节点都由一个令牌描述。<br>▪ 令牌是用于标识每个分区的 64 位 ID。<br>▪ 令牌范围从 -263 到 263-1。<br>▪ 通过使用散列函数计算分区键的令牌，将数据分配给节点。</p>
<h3 id="Cassandra-架构的影响"><a href="#Cassandra-架构的影响" class="headerlink" title="Cassandra 架构的影响"></a>Cassandra 架构的影响</h3><p>▪ Cassandra 架构支持将数据透明地分发到节点。<br>➢ 这意味着您可以根据数据确定您的数据在集群中的位置。</p>
<p>▪ 任何节点都可以接受任何请求，因为没有主节点或从节点。<br>➢ 如果一个节点有数据，它会返回数据。<br>➢ 否则，它将请求发送到有数据的节点</p>
<p>▪ 您可以指定数据的副本数以达到所需的冗余级别。<br>➢ 例如，如果数据非常关键，您可能希望指定复制因子为 4 或 5。<br>➢ 如果数据不重要，您可以只指定一两个。</p>
<p>▪ 它还提供可调整的一致性——一致性级别可以指定为与性能的权衡。<br>➢ 事务总是写入磁盘上的提交日志，以便它们是持久的。</p>
<h3 id="关键结构"><a href="#关键结构" class="headerlink" title="关键结构"></a>关键结构</h3><p>▪ 节点：您存储数据的地方。<br>▪ 数据中心：相关节点的集合。<br>▪ 集群：包含一个或多个数据中心。<br>▪ 提交日志：所有数据首先写入提交日志以保证持久性。<br>▪ Mem-table：内存常驻数据结构。<br>▪ SSTable：排序字符串表（SSTable）是一个不可变的数据文件，Cassandra 定期向其中写入内存表。<br>▪ 布隆过滤器：测试元素是否为集合成员的算法。</p>
<h3 id="Cassandra-写入过程"><a href="#Cassandra-写入过程" class="headerlink" title="Cassandra 写入过程"></a>Cassandra 写入过程</h3><ol>
<li>数据写入磁盘上的提交日志。</li>
<li>根据哈希值将数据发送到负责节点。</li>
<li>节点将数据写入名为 mem-table 的内存表。</li>
<li>从mem-table，数据写入内存中的SSTable。<br>➢ SSTable 代表 Sorted String 表。 这具有对表的所有更新的合并数据。</li>
<li>从SSTable，数据更新到实际表。</li>
<li>如果责任节点宕机，数据将写入另一个标识为tempnode的节点。 tempnode 将暂时保存数据，直到负责的节点活跃起来。</li>
</ol>
<p>▪ 将数据写入磁盘上的提交日志以保持持久性。<br>▪ 它也被写入内存中的内存表。<br>▪ Mem-table 数据写入 SSTable，用于更新实际表。</p>
<h3 id="Cassandra-架构"><a href="#Cassandra-架构" class="headerlink" title="Cassandra 架构"></a>Cassandra 架构</h3><p>▪ 数据中心和机架<br>➢ 机架是一组相互靠近的逻辑节点，<br>也许在单个设备机架中的物理机器上<br>➢ 数据中心是一组逻辑机架，可能位于同一<br>建立并通过可靠网络连接</p>
<h3 id="Cassandra-读取过程"><a href="#Cassandra-读取过程" class="headerlink" title="Cassandra 读取过程"></a>Cassandra 读取过程</h3><p>▪ Cassandra 读取过程确保快速读取。<br>▪ 如果节点关闭，则从数据的副本中读取数据。 副本的优先级是根据距离分配的。<br>▪ Cassandra 读取过程的特点是：<br>➢ 同一节点上的数据优先，被认为是本地数据。<br>➢ 同一机架上的数据具有第二优先权，被视为机架本地数据。<br>➢ 同一数据中心上的数据具有第三优先权，被视为数据中心本地。<br>➢ 不同数据中心的数据优先级最低</p>
<h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>▪ Cassandra 通过按以下方式对数据进行水平分区来执行数据的透明分发：<br>➢ 根据数据的主键计算哈希值。<br>➢ 键的哈希值映射到集群中的一个节点<br>➢ 数据的第一个副本存储在该节点上。<br>➢ 分布是透明的，因为您可以计算哈希值并确定特定行的存储位置</p>
<h3 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h3><p>▪ 分区器决定数据如何在集群中的节点之间分布。<br>▪ 分区键用于数据分区。 每行都有一个分区键，用于标识分区。<br>▪ Cassandra 中提供了三种类型的分区器：<br>➢ Murmur3Partitioner – Cassandra 中的默认分区器。<br>➢ RandomPartitioner – 与 Murmur3Partitioner 类似，不同之处在于它使用 MD5（消息摘要版本 5）哈希函数来计算哈希值。<br>➢ ByteOrderedPartitioner – 使用分区键值对行进行排序。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>▪ 复制是指为每一行维护的副本数。<br>▪ 复制为容错提供数据冗余。<br>▪ N 的复制因子意味着系统中维护了 N 个数据副本。<br>▪ Cassandra 允许基于节点、机架和数据中心的复制。<br>▪ 跨数据中心的复制即使在数据中心停机时也能保证数据可用性。</p>
<h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>▪ 复制策略决定了如何维护一个数据行的多个副本。<br>▪ 复制是在keyspace 级别指定的，<strong>不同的keyspace 可以有不同的策略</strong>。<br>▪ Cassandra 以对用户透明的方式跨节点复制数据。<br>▪ 复制因子是集群中将接收相同数据副本的节点数。<br>▪ Cassandra 提供两种常见的复制策略：<br>➢ SimpleStrategy：将副本放置在环周围的连续节点上。<br>➢ NetworkTopologyStrategy：为每个数据中心指定不同的复制因子，将副本分配到不同的机架rack以最大化可用性。</p>
<h3 id="告密者snitches"><a href="#告密者snitches" class="headerlink" title="告密者snitches"></a>告密者snitches</h3><p>▪ snitches确定哪些数据中心和机架节点属于。<br>▪ 任务是确定集群中每个节点的相对主机接近度。<br>▪ snitches会找出节点相对于其他节点的位置。<br>▪ 两种最流行的snitches：<br>➢ Simple Snitch - Simple Snitch 用于没有机架的单个数据中心。<br>➢ 属性文件 Snitch - 属性文件 Snitch 用于具有多个机架的多个数据中心。<br>▪ Cassandra 中的复制基于snitches。</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>▪ 节点故障的影响：<br>➢ 其他节点检测节点故障。<br>➢ 该节点上的数据请求被路由到拥有该数据副本的其他节点。<br>➢ 写入由临时节点处理，直到节点重新启动。<br>➢ 任何丢失的 memtable 或 sstable 数据都从 commitlog 中恢复。<br>➢ 可以使用 nodetool 实用程序永久删除节点。</p>
<h4 id="▪-磁盘故障的影响："><a href="#▪-磁盘故障的影响：" class="headerlink" title="▪ 磁盘故障的影响："></a>▪ 磁盘故障的影响：</h4><p>➢ 磁盘上的数据无法访问。<br>➢ 无法从节点读取数据。<br>➢ 此问题将被视为该部分数据的节点故障。<br>➢ Memtable 和 sstable 不受影响，因为它们是内存表。<br>➢ Commitlog 有副本，它们将用于恢复。</p>
<h4 id="▪-机架rack故障的影响："><a href="#▪-机架rack故障的影响：" class="headerlink" title="▪ 机架rack故障的影响："></a>▪ 机架rack故障的影响：</h4><p>➢ 机架上的所有节点都无法访问。<br>➢ 无法从机架节点读取数据。<br>➢ 读取将路由到数据的其他副本。<br>➢ 这将被视为机架中的每个节点都发生了故障。</p>
<h4 id="▪-数据中心故障的影响："><a href="#▪-数据中心故障的影响：" class="headerlink" title="▪ 数据中心故障的影响："></a>▪ 数据中心故障的影响：</h4><p>➢ 数据中心内的所有数据都将无法访问。<br>➢ 所有读取都必须路由到其他数据中心。<br>➢ 将使用其他数据中心的副本副本。<br>➢ 虽然系统将运行，但客户可能会注意到由于网络延迟而变慢。 这是因为多个数据中心通常位于不同的物理位置并通过广域网连接</p>
<h3 id="一致性级别"><a href="#一致性级别" class="headerlink" title="一致性级别"></a>一致性级别</h3><p>▪ Cassandra 提供可调的一致性级别。<br>▪ 可以为每个读取或写入查询指定一致性级别。<br>➢ 对于读查询，一致性级别指定了有多少副本节点必须响应读请求。<br>➢ 对于写操作，一致性级别指定了必须响应多少副本节点才能上报写操作。<br>➢ R + W &gt; N = 强一致性<br>➢ R：读副本数 W：写副本数 N：复制因子</p>
<h2 id="W7-Designing-Column-Oriented-Databases-列数据库设计"><a href="#W7-Designing-Column-Oriented-Databases-列数据库设计" class="headerlink" title="W7 Designing Column-Oriented Databases 列数据库设计"></a>W7 Designing Column-Oriented Databases 列数据库设计</h2><h3 id="Primary-amp-Compound-Keys-主键与复合键"><a href="#Primary-amp-Compound-Keys-主键与复合键" class="headerlink" title="Primary &amp; Compound Keys 主键与复合键"></a>Primary &amp; Compound Keys 主键与复合键</h3><p>Cassandra 中的主键可以是复合键，复合键是指由多列组成的键。<br>当指定复合键时，第一个键被考虑用于数据分区，称为分区键。<br>每个分区中的数据按剩余的键进行聚类和排序。</p>
<h3 id="Guidelines-for-Designing-Tables-表设计"><a href="#Guidelines-for-Designing-Tables-表设计" class="headerlink" title="Guidelines for Designing Tables 表设计"></a>Guidelines for Designing Tables 表设计</h3><p>面向列的数据库的实现方式与关系数据库不同。<br>▪ 重要的是要了解：<br>➢ 列族数据库被实现为稀疏的多维映射。<br>➢ 行之间的列可以不同。<br>➢ 可以动态添加列。<br>➢ 不使用连接； 数据被非规范化。<br>列数据库的这些特性将影响数据库设计指南</p>
<p>在面向列的数据库中设计表时的几个准则：<br>➢ 非规范化而不是连接。<br>➢ 利用无值的列。<br>➢ 使用列名和列值来存储数据。<br>➢ 使用单行对实体进行建模。<br>➢ 避免行键热点。<br>➢ 保留适当数量的列值版本。<br>➢ 避免列值中的复杂数据结构。<br>▪ 应该注意的是，其中一些建议（例如 使用适当数量的列值版本）并不适用于所有列族数据库系统。</p>
<p>Denormalize Instead of Join<br>面向列的数据库通常需要比关系数据库更少的表。<br>➢ 它对数据进行非规范化以避免需要连接。</p>
<p>Make Use of Valueless Columns<br>该表没有像“ProductPurchased1”这样名称为“PR _ B1839”的列，而是简单地将产品 ID 存储为列名</p>
<p>Use Both Column Names and Column Values to Store Data<br>▪ 列名和列值都可以存储数据。<br>▪ 使用无值列的一种变体使用列值进行非规范化。<br>▪ 非规范化数据的缺点：在客户表中保留产品名称的副本会增加使用的存储量。<br>▪ 非规范化数据的好处：客户和他们购买的产品的报告是通过只引用一张表而不是两张表来生成的。<br>▪ 实际上，我们是在牺牲对额外存储的需求来提高读取性能。</p>
<p>Model an Entity with a Single Row<br>▪ 单个实体，例如特定客户或特定产品，应将其所有属性放在一行中。<br>➢ 这可能导致某些行存储的列值多于其他行的情况，但这在列族数据库中并不少见。<br>▪ ColumnFamily数据库不提供与关系数据库相同级别的事务控制。 通常，写入一行是原子的。 如果您更新表中的多个列，它们将全部更新，或者它们都不更新。</p>
<p>Avoid Hotspotting in Row Keys<br>分布式系统使您能够利用大量服务器来解决问题。 在一台或几台机器上指挥过多的工作而其他机器未得到充分利用是低效的。</p>
<p>Keep an Appropriate Number of Column Value Versions<br>▪ HBase 使您能够存储列值的多个版本。<br>▪ 列值带有时间戳，因此您可以确定最新和最早的值。<br>▪ 与其他形式的版本控制一样，如果您<br>需要回滚您对列值所做的更改。<br>▪ 这不适用于 Apache Cassandra</p>
<p>Avoid Complex Data Structures in Column Values<br>例如，关于客户的 JSON 文档可能包含一个存储地址信息的嵌入文档，如下所示：<br>▪ 这种类型的数据结构可能存储在一个列值中，但不推荐使用，除非有特殊原因需要维护这种结构。<br>▪ 为每个属性使用单独的列可以更轻松地将数据库功能应用于属性。 例如，为街道、城市、州和邮政编码创建单独的列意味着您可以对这些值创建二级索引。<br>▪ 此外，将属性分成单独的列允许您在需要时使用不同的列族。 使用二级索引的能力和根据列的使用方式分隔列的选项都可以提高数据库性能。</p>
<p>Using Secondary Indexes Managed by the Column Family Database System<br>使用 ColumnFamily 数据库系统管理的二级索引<br>如果您需要列值的二级索引并且列族数据库系统提供了自动管理的二级索引，那么您应该使用它们。<br>▪ 使用自动管理的二级索引的主要优点是与替代方法相比，它们需要更少的代码来维护。<br>▪ 有时您不应该使用自动管理的索引。 在以下情况下<strong>避免</strong>或至少仔细测试索引的使用：<br>➢ 列中有少量不同的值。<br>➢ 一列有很多唯一unique值。<br>➢ 列值稀疏</p>
<p>▪ 有很少不同值的列不是二级索引的良好候选。<br>▪ 当列中不同值的数量（称为列的基数）很小时，索引不会对性能有太大帮助——它甚至可能会受到伤害。<br>▪ 具有太多不同值的行也不适合用作索引。<br>▪ 自动管理的索引在这里可能没有多大帮助，因为索引必须维护如此多的数据，搜索索引和检索数据可能比扫描表以获取特定值花费更多的时间<br>▪ 在许多行不使用列的情况下，二级索引可能无济于事。<br>▪ 不应为稀疏填充的列编制索引</p>
<p>何时使用表创建和管理二级索引<br>▪ 帮助生成列出购买特定产品的所有客户的报告。<br>▪ 他们还想要一份关于特定产品以及哪些客户购买了这些产品的报告</p>
<h3 id="Guidelines-for-Indexing-索引设计"><a href="#Guidelines-for-Indexing-索引设计" class="headerlink" title="Guidelines for Indexing 索引设计"></a>Guidelines for Indexing 索引设计</h3><h3 id="Cassandra-Data-Model-数据模型"><a href="#Cassandra-Data-Model-数据模型" class="headerlink" title="Cassandra Data Model 数据模型"></a>Cassandra Data Model 数据模型</h3><p>Rules</p>
<p>▪ 最大化写入次数<br>➢ Cassandra 针对高写入性能进行了优化。<br>➢ 最大化写入对于读取性能和数据可用性很有用。<br>▪ 最大化数据复制<br>➢ 数据非规范化和数据重复是 Cassandra 的事实。<br>➢ 磁盘空间通常是最便宜的资源（与 CPU、内存、磁盘 IOP 或网络相比），Cassandra 是围绕这一事实构建的。 为了获得最高效的读取，您经常需要复制数据。<br>➢ 数据复制提供即时数据可用性和无单点故障。</p>
<p>Goals</p>
<p>▪ 在集群周围均匀分布数据<br>➢ 您希望集群中的每个节点具有大致相同的数据量。<br>➢ 行基于分区键的散列分布在集群中，分区键是 PRIMARY KEY 的第一个元素。 因此，均匀分布数据的关键是：选择一个好的主键。<br>▪ 最小化查询数据时读取的分区数<br>➢ 分区是共享相同分区键的行组。 当您发出读取查询时，您希望从尽可能少的分区读取行。<br>➢ 需要选择均衡数量的分区。</p>
<h2 id="W8-Non-Relational-Database-Transactions"><a href="#W8-Non-Relational-Database-Transactions" class="headerlink" title="W8 Non-Relational Database Transactions"></a>W8 Non-Relational Database Transactions</h2><p>BASE</p>
<ol>
<li>Data Management in Big Data</li>
<li>ACID vs BASE</li>
<li>CAP Theorem</li>
</ol>
<p>▪ 数据库旨在做两件事：存储数据和检索数据。<br>▪ 为了实现这些目标，数据库管理系统必须做三件事：<br>➢ 持久存储数据<br>➢ 保持数据一致性<br>➢ 确保数据可用性</p>
<h3 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h3><p>▪ 数据必须持久存储；即必须以数据库服务器关闭时数据不丢失的方式进行存储。<br>▪ 如果数据只存储在内存（即 RAM）中，那么当内存断电时，数据就会丢失。<br>▪ 只有存储在磁盘、闪存、磁带或其他长期存储设备上的数据才被视为永久存储<br>▪ 数据必须可用于检索。<br>▪ 您可以通过多种不同的方式检索永久存储的数据。<br>➢ 存储在闪存设备上的数据直接从其存储位置读取。<br>➢ 磁盘和磁带驱动器的可移动部件放置到位，使设备的读头位于要读取的数据块上。<br>▪ 可以将数据库设计为简单地从数据文件的开头开始，并在执行读取操作时搜索您需要的记录。<br>➢ 这会导致极其漫长的响应时间和宝贵的计算资源的浪费。<br>➢ 无需扫描全表查找数据，您可以使用数据库索引快速找到特定数据块的位置。</p>
<h3 id="数据一致"><a href="#数据一致" class="headerlink" title="数据一致"></a>数据一致</h3><p>▪ 确保将正确数据写入持久存储设备非常重要。<br>➢ 如果写或读操作不能准确记录或检索数据，数据库将没有多大用处。<br>➢ 除非出现硬件故障，否则这很少成为问题。<br>▪ 当两个或更多人使用数据库并希望同时使用相同的数据时，会出现一个更常见的读写问题。<br>▪ 数据库返回的结果表明客户已支付其帐户的应付余额，而不将该付款也包括在可用资金记录中，这将是不一致的。<br>▪ 关系数据库系统旨在支持此类必须被视为单个操作或事务的多步骤过程。</p>
<h3 id="数据可用"><a href="#数据可用" class="headerlink" title="数据可用"></a>数据可用</h3><p>▪ 数据应在需要时可用。<br>➢ 这很难保证。<br>o硬件可能会出现故障。<br>o数据库服务器上的操作系统可能需要打补丁。<br>o您可能需要安装新版本的数据库管理系统。<br>o在单个服务器上运行的数据库可能由于多种原因不可用。<br>▪ 避免数据库服务器不可用问题的一种方法是拥有两台数据库服务器：一个用于更新数据和响应查询，而另一个用作备份，以防第一台服务器出现故障。<br>▪ 用于更新和响应查询的服务器称为主服务器，另一个是备份服务器。<br>▪ 备份服务器从主服务器上的数据库副本开始。<br>▪ 使用数据库时，对主数据库的任何更改也会反映在备份数据库中。<br>▪ 回想一下，数据库事务是由多个步骤组成的操作，必须完成所有步骤才能完成事务。<br>▪ 如果多个步骤中的任何一个失败，则整个交易失败。<br>▪ 更新两个数据库使每次更新成为一个多步骤过程。<br>➢ 当公司使用单台服务器时，更新仓库中特定产品的数量只需一步</p>
<p>▪ 更新两个数据库的过程与其他多步事务类似：两个数据库都必须成功，操作才能成功。<br>▪ 主数据库和备份数据库必须一致。<br>▪ 两阶段提交：<br>➢ 在操作的第一阶段，数据库将数据写入或提交到主服务器的磁盘。<br>➢ 在操作的第二阶段，数据库将数据写入备份服务器的磁盘。</p>
<h2 id="W9-Introduction-to-Graph-Databases"><a href="#W9-Introduction-to-Graph-Databases" class="headerlink" title="W9 Introduction to Graph Databases"></a>W9 Introduction to Graph Databases</h2><p>▪ 图数据库基于称为图论的数学分支。<br>▪ 该数学领域的技术可用于分析实体之间的联系和联系。</p>
<h3 id="什么是图？"><a href="#什么是图？" class="headerlink" title="什么是图？"></a>什么是图？</h3><p>▪ 图是由两部分组成的数学对象：顶点和边。<br>➢ 顶点有时被称为节点。<br>▪ 每个顶点/节点代表一个实体（人、地点、事物、类别或其他数据）。<br>▪ 每条边代表两个顶点/节点之间的关系（代表两个节点如何关联）。</p>
<h3 id="顶点Vertex"><a href="#顶点Vertex" class="headerlink" title="顶点Vertex"></a>顶点Vertex</h3><p>▪ 一个顶点代表一个用唯一标识符标记的实体。<br>➢ 类似于列族数据库中的行键或关系数据库中的主键。<br>▪ 一个顶点实际上可以代表任何与另一个实体有关系的实体，例如：<br>➢ 社交网络中的人<br>➢ 高速公路连接的城市<br>➢ 与体内其他蛋白质相互作用的蛋白质<br>➢ 公司分销网络中的仓库<br>➢ 集群中的计算服务器<br>▪ 顶点用于表示对象。<br>▪ 顶点可以有属性。<br>o 例如，社交网络中的一个顶点代表一个人； 它具有姓名、地址和出生日期等属性。<br>o 高速公路系统图使用顶点来表示城市。 城市有人口、经度和纬度以及名称，并且位于地理区域内。</p>
<h3 id="边Edge"><a href="#边Edge" class="headerlink" title="边Edge"></a>边Edge</h3><p>▪ 边，也称为链接link或弧arc，定义顶点或连接顶点的对象之间的关系。<br>o 例如，在一个家谱数据库中，顶点可以代表人，而边代表他们之间的关系，例如“女儿”和“父亲”。<br>o 在高速公路数据库的情况下，城市用顶点表示，而边表示连接城市的高速公路。<br>▪ 边代表顶点之间的关系。<br>▪ 与顶点非常相似，边也有属性。<br>o 例如，在高速公路数据库中，所有边都将具有属性，例如距离、限速和车道数。<br>o 在家族树示例中，边可能具有诸如指示两个人是否因婚姻、收养或生物学相关的属性。<br>▪ 一个常用的属性称为边的权重。<br>▪ 权重代表关系的某些价值。<br>o 例如，在高速公路的情况下，权重可能是城市之间的距离。<br>o 在社交网络中，权重可以表明两个人在彼此的墙上发帖或评论彼此的帖子的频率。<br>▪ 一般而言，权重可以表示成本、距离或由顶点表示的对象之间关系的其他度量。</p>
<p>▪ 边有两种类型：有向和无向。<br>▪ 有向边有一个方向。 这用于指示应如何解释由边建模的关系。<br>▪ 然而，方向并不总是需要的。 例如，假设交通双向流动，高速公路图可能是无向的。</p>
<p>图形数据库比关系数据库管理系统 (RDBMS) 更易于理解。</p>
<h3 id="Neo4j-Highlights"><a href="#Neo4j-Highlights" class="headerlink" title="Neo4j Highlights:"></a>Neo4j Highlights:</h3><ul>
<li>A native graph database</li>
<li>Whiteboard friendly.</li>
<li>Supports rapid development.</li>
<li>Designed for business-critical and high-performance operations.</li>
</ul>
<p>图形数据库将数据存储在图形中，图形是最通用的数据结构，能够以高度可访问的方式优雅地表示任何类型的数据。Neo4j 图基于属性图模型。</p>
<h2 id="W10-amp-W11-Graph-Databases"><a href="#W10-amp-W11-Graph-Databases" class="headerlink" title="W10 &amp; W11 Graph Databases"></a>W10 &amp; W11 Graph Databases</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>▪ 通过图的路径是一组顶点以及这些顶点之间的边。<br>▪ 图中的顶点都彼此不同。<br>▪ 如果边是有向的，则路径为有向路径。 如果图是无向图，则其中的路径是无向路径。<br>▪ 示例：从 B 到 D 到 H 到 I 的顶点和边是从顶点 B 到顶点 I 的路径。<br>▪ 路径很重要，因为它们捕获有关图中顶点如何相关的信息。<br>▪ 例如：<br>o 在家庭图中，一个人是其他人的祖先，仅当存在从该人到其祖先的有向路径时。<br>o 就家谱而言，从一个人到一个祖先只有一条路径。<br>o 在高速公路图的情况下，城市之间可能有多条路径。<br>▪ 使用图形时遇到的一个常见问题是找到两个顶点之间的权重最小的路径。<br>➢ 权重可以表示使用边的成本、遍历边所需的时间或您试图最小化的其他一些度量。</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>▪ 环是将顶点与其自身相连的边。<br>▪ 例如，在生物学中，蛋白质可以与其他蛋白质相互作用。 一些蛋白质与相同类型的其他蛋白质分子相互作用。 可以使用循环来表示这一点。<br>▪ 但是，与方向一样，在某些图中允许循环可能没有意义。 例如，循环在家庭树图中没有多大意义； 人们不能成为自己的父母或孩子。</p>
<p>图数据库非常适用于容易用实体和实体之间的关系描述的问题域。<br>▪ 实体几乎可以是任何东西，从蛋白质到行星。<br>▪ 图数据库应用程序经常包括涉及以下内容的查询和分析：<br>o 识别两个实体之间的关系。<br>o 从节点识别边的共同属性。<br>o 从节点计算边的聚合属性。<br>o 计算节点属性的聚合值。</p>
<h3 id="图的操作"><a href="#图的操作" class="headerlink" title="图的操作"></a>图的操作</h3><p>▪ 对数据库执行的常见操作包括插入、读取、更新和删除数据。 图数据库也执行这些操作。<br>▪ 图数据库也非常适合一组额外的操作。 具体来说，操作可用于跟踪路径或检测顶点之间关系中的重复模式。<br>图形独有的三个重要操作：<br>▪ 图的联合<br>▪ 图的交集<br>▪ 图遍历</p>
<p><strong>图的并集</strong>（Union）是图中顶点和边的组合集合。</p>
<p><strong>图的交集</strong>（intersection ）是两个图共有的顶点和边的集合。</p>
<p>图遍历<br>▪ 图遍历是以特定方式访问图中所有顶点的过程。 这样做的目的通常是设置或读取图形中的某些属性值。<br>图遍历是访问图中所有节点的过程</p>
<h3 id="图和节点的属性"><a href="#图和节点的属性" class="headerlink" title="图和节点的属性"></a>图和节点的属性</h3><p>▪ 图形和节点的几个属性在比较和分析图形时很有用。<br>▪ 这些包括：</p>
<h4 id="o-同构Isomorphisms："><a href="#o-同构Isomorphisms：" class="headerlink" title="o 同构Isomorphisms："></a>o 同构Isomorphisms：</h4><p>▪ 如果第一个图中的每个顶点在另一个图中都有一个对应的顶点，则两个图被认为是同构的。<br>▪ 此外，对于第一个图中一对顶点之间的每条边，在另一个图中对应的顶点之间都有一条相应的边。<br>▪ 如果您试图检测一组图中的模式，则图同构很重要。<br>➢ 示例：社交网络图、流行病学</p>
<h4 id="o-顺序和大小Order-and-Size"><a href="#o-顺序和大小Order-and-Size" class="headerlink" title="o 顺序和大小Order and Size"></a>o 顺序和大小Order and Size</h4><p>▪ 顺序和大小是图形大小的度量。<br>➢ 图的阶数是顶点数，图的大小是图中边数。<br>▪ 图形的顺序和大小很重要，因为它们会影响执行操作所需的时间和空间。<br>➢ 很明显，在小图上执行并集或交集比在大图上执行相同操作花费的时间更少。<br>➢ 也很容易假设遍历小图比遍历大图花费的时间更少。</p>
<h4 id="o-等级Degress"><a href="#o-等级Degress" class="headerlink" title="o 等级Degress"></a>o 等级Degress</h4><p>▪ 度数是链接到顶点的边数，是衡量图中任何给定顶点重要性的一种方法。<br>▪ 度数高的顶点比度数低的顶点与其他顶点的连接更直接。<br>▪ 在解决通过网络传播信息或财产的问题时，学位很重要。</p>
<h4 id="o-距离Closeness"><a href="#o-距离Closeness" class="headerlink" title="o 距离Closeness"></a>o 距离Closeness</h4><p>▪ Closeness 是一个顶点的属性，表示该顶点与图中所有其他顶点的距离。<br>▪ 如果您想了解信息在社交网络中的传播、社区中的传染病或分发网络中的材料移动，紧密度是一个重要的衡量标准。<br>▪ 接近度值高的顶点可以比接近度值小的顶点更快地到达网络中的其他顶点。</p>
<h4 id="o-介数Betweenness"><a href="#o-介数Betweenness" class="headerlink" title="o 介数Betweenness"></a>o 介数Betweenness</h4><p>▪ 介数衡量给定顶点的瓶颈程度。<br>▪ 想象一座河上的城市，有许多道路，但只有一座桥<br>▪ 介数有助于识别网络中潜在的脆弱部分</p>
<h3 id="图形建模"><a href="#图形建模" class="headerlink" title="图形建模"></a>图形建模</h3><p>▪ 图形可用于对许多不同领域中的结构和流程进行建模。<br>➢ 有时，图形表示实体之间的关系，例如人或城市。<br>➢ 在其他情况下，图形表示材料或物体通过系统的流动，例如流经市政供水系统的水或高速公路上的卡车。<br>▪ 图表类型：<br>➢ 无向图和有向图<br>➢ 流网络<br>➢ 二部图<br>➢ 多重图<br>➢ 加权图</p>
<p>▪ 无向图是边没有方向的图。<br>➢ 这种类型的图用于对方向没有意义的关系或流进行建模。 例如，您可以使用无向边对家庭关系中的夫妻进行建模。<br>▪ 有向图是具有有向边的图。<br>➢ 您可以对具有有向边的父子关系建模。</p>
<p>无向图和有向图<br>▪ 在某些情况下，图中的某些边是有向的，而有些则不是。<br>➢ 例如，如果您对企业中的员工进行建模，则某些边可能表示员工和经理之间的“报告对象”关系。 这将使用有向边。<br>➢ 另一方面，同行之间的“合作”关系将是没有方向的。 它也可以建模为两个有向边。</p>
<p>流网络<br>▪ 流网络是一个有向图，其中每条边都有一个容量，每个顶点都有一组输入和输出边。<br>▪ 入边容量总和不能大于出边容量总和。<br>▪ 此规则的两个例外是源顶点和汇顶点。 源没有输入但有输出，而汇有输入但没有输出。</p>
<p>▪ 流网络也称为运输网络。<br>▪ 图数据库可用于模拟流动网络，如道路系统或交通网络。<br>▪ 它们还可用于模拟连续流动的过程，例如吸收雨水（源头）并使其流入河流（汇）的雨水渠网络。</p>
<p>二分图<br>▪ 二部图（bigraph）是具有两组不同顶点的图，其中一组中的每个顶点仅连接到另一组中的顶点。<br>▪ 在对不同类型对象之间的关系建模时，二部图很有用。<br>▪ 例如，一组顶点可能代表企业，另一组顶点可能代表人。 如果此人为该企业工作，则该人与该企业之间就会出现边缘。<br>▪ 其他示例包括教师和学生、成员和团体以及火车车厢和火车。</p>
<p>多重图<br>▪ 多重图是顶点之间具有多条边的图。</p>
<p>加权图<br>▪ 加权图是每条边都分配有编号的图。 该数字可以反映成本、容量或其他一些边缘度量。<br>▪ 这通常用于优化问题，例如寻找顶点之间的最短路径。<br>➢ 找到最短路径的一种方法称为 Dijkstra 算法，由 Edsger Dijkstra 创建。<br>➢ Dijkstra 算法用于寻找网络中的最短路径。 这是在 Internet 上路由数据包或为送货卡车寻找最有效路线的理想选择</p>
<h3 id="解决最短路径问题的最常用算法"><a href="#解决最短路径问题的最常用算法" class="headerlink" title="解决最短路径问题的最常用算法"></a>解决最短路径问题的最常用算法</h3><p>▪ Dijkstra 算法<br>▪ 增量网络扩展 (INE)<br>▪ 增量欧几里得限制 (IER)<br>▪ 范围网络扩展 (RNE)<br>▪ 范围欧几里得限制 (RER)<br>图搜索算法有两种基本类型：<br>▪ 深度优先，以及<br>▪ 广度优先。</p>
<p>▪ 深度优先算法从一个起始节点到某个结束节点，然后从同一起始节点沿着不同的路径重复搜索，直到查询得到回答。<br>▪ 通常，在尝试发现离散信息时，深度优先是一个不错的选择。 它们也是一般图遍历的好策略。<br>▪ 深度优先的最经典或基本级别是无信息搜索，其中算法搜索路径直到到达图的末尾，然后回溯到起始节点并尝试不同的路径。</p>
<p>▪ 与深度优先相反，处理语义丰富的图数据库允许进行广度优先算法，如果发现没有兼容的传出关系的节点，则提前终止搜索。<br>▪ 因此，广度优先算法的执行时间也较短。<br>▪ 广度优先算法通过一次探索一个图来进行搜索。<br>▪ 它们从离起始节点深一层的节点开始，然后是深度为 2 的节点，然后是深度为 3 的节点，依此类推，直到遍历了整个图</p>
<h2 id="W12-Selecting-a-Database"><a href="#W12-Selecting-a-Database" class="headerlink" title="W12 Selecting a Database"></a>W12 Selecting a Database</h2><h3 id="选择-NoSQL-数据库"><a href="#选择-NoSQL-数据库" class="headerlink" title="选择 NoSQL 数据库"></a>选择 NoSQL 数据库</h3><table>
<thead>
<tr>
<th>Relational Database</th>
<th>NoSQL Database</th>
</tr>
</thead>
<tbody><tr>
<td>在关系数据库设计中，实体的结构和关系驱动设计。</td>
<td>在 NoSQL 数据库设计中，性能比保留关系模型更重要。</td>
</tr>
<tr>
<td>关系模型的出现是出于务实的原因，即数据异常和难以将现有数据库重用于新应用程序</td>
<td>NoSQL 数据库的出现是出于务实的原因，特别是无法扩展以满足对大量读写操作不断增长的需求。<br/>以提高读写性能作为交换，您可能会失去关系数据库的其他功能，例如即时一致性和 ACID 事务。</td>
</tr>
</tbody></table>
<p>查询推动了数据模型的设计。<br>➢ 因为查询描述了数据的使用方式。<br>➢ 查询也是了解各种 NoSQL 数据库如何满足您需求的良好起点。<br>▪ 您还需要了解其他因素，例如<br>o读写量<br>o对副本中不一致数据的容忍度<br>o实体之间关系的性质以及它如何影响查询模式<br>o可用性和灾难恢复要求<br>o数据模型的灵活性需求<br>o延迟要求</p>
<h3 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h3><p>▪ 文档数据库的设计具有灵活性。<br>▪ 如果应用程序需要能够存储各种属性以及大量数据，那么文档数据库是一个不错的选择。<br>➢ 例如，为了在关系数据库中表示产品，建模者可以使用一个表用于公共属性，并为每个产品子类型使用附加表来存储仅在产品子类型中使用的属性。<br>➢ 文档数据库可以轻松应对这种情况</p>
<p>▪ 文档数据库提供嵌入式文档，这对于反规范化很有用。<br>▪ 不是将数据存储在不同的表中，而是将经常一起查询的数据一起存储在同一个文档中。<br>▪ 文档数据库改进了带有索引的键值数据库的查询能力以及基于文档属性过滤文档的能力。<br>▪ 文档数据库可能是最受欢迎的 NoSQL 数据库，因为它们具有灵活性、性能和易用性。</p>
<p>▪ 这些数据库非常适合许多用例，包括：<br>o对具有大量读取和写入的网站的后端支持<br>o管理具有可变属性的数据类型，例如产品<br>o跟踪元数据的可变类型<br>o使用 JSON 数据结构的应用程序<br>o通过在结构中嵌入结构而受益于非规范化的应用程序</p>
<h3 id="列族数据库"><a href="#列族数据库" class="headerlink" title="列族数据库"></a>列族数据库</h3><p>列族数据库专为海量数据、读写性能和高可用性而设计。<br>➢ Google 推出了 BigTable 来满足其服务的需求。<br>➢ Facebook 开发了 Cassandra 来支持其收件箱搜索服务。<br>▪ 这些数据库管理系统在多台服务器的集群上运行。<br>▪ 如果您的数据小到可以在单个服务器上运行，那么列族数据库可能超出您的需要——考虑使用文档或键值数据库</p>
<p>▪ 列族数据库非常适合用于：<br>o需要能够始终写入数据库的应用程序<br>o地理上分布在多个数据中心的应用程序<br>o可以容忍副本中一些短期不一致的应用程序<br>o具有动态字段的应用程序<br>o具有真正大量数据（例如数百 TB）潜力的应用程序</p>
<p>▪ 多个领域可以使用这种大数据处理能力，例如：<br>o使用网络流量和日志数据模式进行安全分析<br>oBig Science，例如使用遗传和蛋白质组学数据的生物信息学<br>o使用交易数据进行股市分析<br>oWeb 规模的应用程序，例如搜索<br>o社交网络服务</p>
<h3 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h3><p>▪ 适合表示为连接实体网络的问题域非常适合图数据库。<br>▪ 评估图形数据库有用性的一种方法是确定实体实例是否与其他实体实例有关系。<br>▪ 现在考虑图数据库讨论中提到的例子，例如连接城市的高速公路、蛋白质与其他蛋白质的相互作用以及员工与其他员工一起工作。 在所有这些情况下，两个实体实例之间都存在某种类型的连接、链接或直接关系。</p>
<p>▪ 电子商务应用程序中的两个订单可能彼此没有联系。<br>▪ 它们可能由同一位客户订购，但这是一个共享属性，而不是连接。</p>
<p>▪ 与前一种情况类似，一个游戏玩家的配置和游戏状态与其他游戏玩家的配置几乎没有关系。<br>▪ 像这样的实体很容易用键值、文档或关系数据库建模。</p>
<p>▪ 连接城市的高速公路、蛋白质与其他蛋白质的相互作用以及员工与其他员工一起工作。<br>▪ 在所有这些情况下，两个实体实例之间都存在某种类型的连接、链接或直接关系。</p>
<p>▪ 一些非常适合图数据库的问题域示例包括：<br>o网络和 IT 基础设施管理<br>o身份和访问管理<br>o业务流程管理<br>o推荐产品和服务<br>o社交网络<br>▪ 从这些例子中，很明显，当需要对实体之间的显式关系建模并快速遍历实体之间的路径时，图数据库是一个很好的数据库选择。</p>
<h3 id="NoSQL-vs-关系数据库"><a href="#NoSQL-vs-关系数据库" class="headerlink" title="NoSQL vs 关系数据库"></a>NoSQL vs 关系数据库</h3><p>▪ NoSQL 和关系数据库是互补的。<br>▪ 关系数据库提供了许多保护数据完整性和降低数据异常风险的功能。<br>➢ 关系数据库会产生提供这些功能的操作开销。<br>▪ 在某些用例中，性能比确保即时一致性或支持 ACID 事务更重要。 在这些情况下，NoSQL 数据库可能是更好的解决方案。<br>▪ 选择数据库是为工作选择正确工具的过程。 您的工作组合越多样化，您的工具包就越多样化。</p>
<p>关系数据库将继续支持事务处理系统和商业智能应用程序。<br>➢ 数十年来在事务处理系统和数据仓库方面的工作已经产生了继续满足企业、政府和其他组织需求的最佳实践和设计原则。<br>➢ 同时，这些组织正在适应最初制定关系模型时不存在的技术。<br>➢ 面向客户的 Web 应用程序、移动服务和大数据分析可能适用于关系数据库，但在某些情况下则不然。<br>▪ 当前的技术格局需要多种数据库技术。</p>
<p>正如没有最好的编程语言，也没有最好的数据库管理系统。<br>▪ 存在比其他问题更适合某些问题的数据库系统，开发人员和设计人员的工作是为手头的需求找到最佳数据库。</p>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>▪ 应用程序开发人员可以选择他们使用的编程语言、他们工作的开发环境以及他们部署的 Web 框架。 在数据库管理系统方面，他们也有选择。<br>➢ 开发不同类型的数据库管理系统都是为了解决其他类型数据库无法解决的现实问题。<br>▪ 开发人员和设计人员的工作之一是为他们的应用程序选择合适的数据库系统。<br>▪ 您可以通过了解您的问题域和您的用户要求来做到这一点。 通常你会有选择。<br>▪ 数据库的选择应由您的需求驱动</p>
<h2 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h2><p>选择题10marks</p>
<p>NoSQL基础及Doc-O DB问答题10marks</p>
<p>mongodb案例10marks</p>
<p>Col-O DB问答题10marks</p>
<p>Cassandra案例10marks</p>
<p>Neo4j案例10marks（Mock里没看到query要求</p>
<p>考试要求一张纸，估计要画图（可能是画Neo4J设计）</p>
<p>Mock问答：</p>
<p>定义（建议去db的wiki网站找）&amp;类比<br>优势<br>用例</p>
<p>Mock最后有ref提供三类db的参考（想必实际考试来不及看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/bulletproof-paper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/bulletproof-paper/" class="post-title-link" itemprop="url">Bulletproof: 适用于机密交易及更多方面的简短证明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-13 01:25:28" itemprop="dateCreated datePublished" datetime="2021-08-13T01:25:28+08:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-11 17:21:35" itemprop="dateModified" datetime="2021-10-11T17:21:35+08:00">2021-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基于区块链的加密货币通过维护全球分布式但同步的分类账区块链来实现点对点电子价值转移。任何独立的观察者都可以验证区块链的当前状态以及分类帐上所有交易的有效性。在比特币中，这项创新要求交易的所有细节都是公开的：发送方、接收方和转账金额。一般来说，我们将支付的隐私分为两个属性：（1）匿名性，在交易中隐藏发送者和接收者的身份；（2）保密性，隐藏转移的金额。虽然比特币通过比特币地址与现实世界身份的不可链接性提供了一些弱匿名性，但它缺乏任何机密性。这对比特币来说是一个严重的限制，对于许多用例来说可能是禁止的。如果这意味着他们的工资发布在公共区块链上，员工是否愿意以比特币获得他们的工资？</p>
<p>为了解决交易金额的保密问题，Maxwell [Max16] 引入了机密交易（CT），其中涉及的每笔交易金额都使用对金额的承诺隐藏起来，不让公众看到。这种方法似乎阻止了区块链的公开验证；观察者无法再检查交易输入的总和是否大于交易输出的总和，以及所有交易值是否为正。这可以通过在每笔交易中包含机密交易有效性的零知识证明来解决。</p>
<p>当前关于 CT 零知识证明 [PBF] 的提议要么大得令人望而却步，要么需要可信的设置。两者都不是可取的。虽然可以使用简洁的零知识证明 (SNARK) [BSCG13,GGPR13]，但它们需要可信设置，这意味着每个人都需要相信设置已正确执行。人们可以通过使用 STARK [BSBTHR18] 来避免可信设置，但由此产生的范围证明虽然渐近有效，但实际上比目前提出的解决方案还要大。</p>
<p>如本文所述，没有可信设置的简短非交互式零知识证明在加密货币领域有许多应用。在证明通过网络传输或长期存储的任何分布式系统中，简短证明了总体成本的降低。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们首先讨论 Bulletproofs 的几个应用程序以及特定于这些应用程序的相关工作。 其他相关工作在第 1.3 节中讨论。</p>
<h3 id="机密交易和-Mimblewimble"><a href="#机密交易和-Mimblewimble" class="headerlink" title="机密交易和 Mimblewimble"></a>机密交易和 Mimblewimble</h3><p>比特币和其他类似的加密货币使用基于交易输出的系统，其中每笔交易完全花费之前未花费交易的输出。 这些未花费的交易输出称为 UTXO。<br>比特币允许将单个 UTXO 用于许多不同的输出，每个输出都与不同的地址相关联。 要花费一个 UTXO，用户必须提供一个签名，或者更准确地说是一个 scriptSig，使交易 SCRIPT 能够评估为真 [BMC`15]。<br>除了 scriptSig 的有效性外，矿工还验证交易是否花费了之前未花费的输出，并且输入的总和大于输出的总和</p>
<p>Maxwell [Max16] 引入了“机密交易”的概念，其中交易中的输入和输出金额隐藏在 Pedersen 承诺中 [P<code>91]。  为了实现公开验证，交易包含一个零知识证明，即提交输入的总和大于提交输出的总和，并且所有输出都是正的，即它们位于区间 $[0, 2^n]$， 其中 $2^n$ 远小于组大小。  当前所有机密交易的实现 [Max16, MP15, PBF</code>, NM`16] 都使用提交值的range proof范围证明，其中证明大小在 n 中是线性的。<br>这些范围证明是机密交易规模的主要贡献者。 在当前的实现中 [Max16]，只有两个输出和 32 位精度的机密交易是 5.4 KB 字节，其中 5 KB 分配给范围证明。<br>即使最近进行了优化，范围证明仍将占用 3.8 KB。</p>
<p>我们在第 6 节中展示了 Bulletproofs 大大改进了这一点，即使对于单个范围证明，同时以边际额外成本（64 字节）将范围证明精度加倍。<br>logarithmic proof对数证明的大小还使证明者能够聚合多个范围证明，例如对于具有多个输出的交易，转换为一个简短的证明。<br>使用 Bulletproofs，$m$ 范围证明只是单个范围证明上的 $O(log(m))$ 附加群元素。这对于当前形式的机密交易已经很有用，因为大多数比特币交易都有两个或多个输出。<br>它还提供了一个有趣的机会，可以将来自不同方的多个范围证明聚合为一个证明，例如在 CoinJoin 交易中需要的证明 [Max13]。<br>在 4.5 节中，我们提出了一个简单有效的 MPC 协议，该协议允许多个用户使用单个聚合范围证明生成单个交易。<br>用户不必向任何其他参与者透露他们的机密交易价值。</p>
<p>机密交易实现可用于侧链 [PBF<code>]、私有区块链 [And17] 和流行的注重隐私的加密货币 Monero [NM</code>16]。 所有这些实现都将受益于 Bulletproofs。<br>在撰写本文时，比特币拥有来自 2200 万笔交易的大约 5000 万个 UTXO（参见 statoshi.info）。 使用比特币的 52 位表示，可以覆盖从 1 satoshi 到 2100 万比特币的所有值，这导致使用当前系统的范围证明数据大约为 160GB。<br>使用聚合的 Bulletproofs，所有 UTXO 的范围证明将需要不到 17GB，大小减少约 10 倍</p>
<h4 id="Mimblewimble"><a href="#Mimblewimble" class="headerlink" title="Mimblewimble"></a>Mimblewimble</h4><p>最近，有人提议对机密交易进行改进，称为 Mimblewimble [Jed16,Poe]，可进一步节省成本。</p>
<p>Jedusor [Jed16] 意识到 Pedersen 对 0 的承诺可以被视为 ECDSA 公钥，并且对于有效的机密交易，输出、输入和交易费用之间的差异必须为 0。因此，构建机密交易的证明者可以签名以输出和输入的差异作为公钥的交易。这一小改动消除了对 scriptSig 的需求，极大地简化了机密交易的结构。<br>Poelstra [Poe] 进一步完善和改进了 Mimblewimble，并表明这些改进可以实现一个大大简化的区块链，其中所有花费的交易都可以被修剪，新节点可以有效地验证整个区块链，而无需下载任何旧的和花费的交易。<br>随着进一步优化，这会导致高度压缩的区块链。它仅包含一小部分区块头以及剩余的未花费交易输出和随附的范围证明以及每笔交易不可修剪的 32 字节。 Mimblewimble 还允许在将交易发送到区块链之前进行聚合。</p>
<p>Mimblewimble 区块链随着 UTXO 集的大小而增长。<br>使用 Bulletproofs，它只会随着具有未花费输出的交易数量而增长，这远小于 UTXO 集的大小。<br>总体而言，Bulletproofs 不仅可以替代机密交易中的范围证明，而且还可以帮助 Mimblewimble 成为一个实用的方案，其区块链比当前的比特币区块链小得多。</p>
<h3 id="Provisions-协议"><a href="#Provisions-协议" class="headerlink" title="Provisions 协议"></a>Provisions 协议</h3><p>Dagher et al. [DBB`15] 引入了 Provisions 协议，该协议允许比特币交易所证明它们具有偿付能力，而无需透露任何额外信息。<br>该协议主要依靠范围证明来防止交易所插入带有负余额的假账户。<br>这些占用超过 13GB 的范围证明是为具有 200 万客户的大型交易所提供近 18GB 证明大小的主要贡献者。<br>样张大小实际上与客户数量呈线性关系。<br>由于在该协议中，一方（交易所）必须同时构建多个范围证明，因此第 4.3 节中的通用 Bulletproofs 协议是 Provisions 中使用的 NIZK 证明的自然替代品。<br>使用第 6 节中列出的证明大小，我们获得范围证明在我们的协议中将占用不到 2 KB。<br>此外，证明的其他部分可以使用第 5 节中的协议进行类似压缩。<br>然后证明将由每个客户的一个承诺主导，大小为 62 MB。这大约比目前实施的规定小 300 倍。</p>
<h4 id="可验证洗牌-verifiable-shuffle"><a href="#可验证洗牌-verifiable-shuffle" class="headerlink" title="可验证洗牌 verifiable shuffle"></a>可验证洗牌 verifiable shuffle</h4><p>考虑两个提交值列表 $x_1,…,x_n$ 和 $y_1,…,y_n$ 。目的是证明第二个列表是第一个列表的排列。<br>这个问题称为<strong>可验证洗牌 verifiable shuffle</strong>。<br>它在投票 [FS01,Nef01]、混合网络 [Cha82] 和偿付能力证明 [DBB`15] 中有许多应用。<br>Neff [Nef01] 给出了可验证 shuffle 的实际实现，后来对其进行了改进 [Gro03,GI08a]。 Neff [Nef01] 给出了可验证 shuffle 的实际实现，后来对其进行了改进 [Gro03,GI08a]。<br>目前最有效的 shuffle [BG12] 的大小为 $O(\sqrt{n})$。</p>
<p>Bulletproofs 可用于创建大小为 $O(\log{n})$ 的可验证洗牌。<br>这两个commitment列表作为第 5 节中电路协议的输入。<br>回路可以通过对两个列表进行排序然后检查它们是否相等来实现混洗。<br>排序回路可以使用 $O(n\cdot\log{n})$ 乘法来实现，这意味着证明大小将仅为 Oplogpnqq。<br>这比以前提出的协议小得多。<br>鉴于 Bulletproofs 的具体效率，使用 Bulletproofs 进行可验证的 shuffle 在实践中将非常有效。<br>构建证明并验证它只需要$n$的线性时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/fit5163-sec-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/fit5163-sec-notes/" class="post-title-link" itemprop="url">fit5163-sec-notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-02 07:31:57" itemprop="dateCreated datePublished" datetime="2021-08-02T07:31:57+08:00">2021-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-16 18:19:04" itemprop="dateModified" datetime="2021-11-16T18:19:04+08:00">2021-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这门课是Blockchain的前置课。</p>
<p>主要讲的是一些安全方面的内容。</p>
<p>assignment两个，一个是期中考试（15%），一个叫mini research应该是论文解读相关（25%）。</p>
<p>剩下60%是考试。</p>
<p>平时tut主要是带你做题目方式答疑，tut和lec之间每周内容对应（这周lec这周tut讲完</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/fit5163-sec-notes/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://c0mm4nd.com/post/randomx-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Command M (C0MM4ND/K0MM4ND)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talkless">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/randomx-design/" class="post-title-link" itemprop="url">RandomX Design</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-22 01:40:48" itemprop="dateCreated datePublished" datetime="2021-07-22T01:40:48+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-11 17:21:35" itemprop="dateModified" datetime="2021-10-11T17:21:35+08:00">2021-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文<a href="https://github.com/tevador/RandomX/blob/master/doc/design.md" target="_blank" rel="noopener">https://github.com/tevador/RandomX/blob/master/doc/design.md</a></p>
<p>为了最大限度地减少专用硬件的性能优势，工作量证明 (PoW) 算法必须通过针对现有通用硬件的特定功能来实现<em>设备绑定</em>。<br>这是一项复杂的任务，因为我们必须针对来自不同制造商的具有不同架构的一大类设备。</p>
<p>有两类不同的通用处理设备：中央处理单元 (CPU) 和图形处理单元 (GPU)。RandomX 针对 CPU 的原因如下：</p>
<ul>
<li>CPU非专业挖矿设备，对于正常用户来说更普遍且更容易访问。受 CPU 限制的算法更加平等，并允许更多参与者加入网络。这是[原始CryptoNote白皮书][cn_paper]中所述的目标之一。</li>
<li>在不同的 CPU 体系结构中存在大量通用的本地硬件指令子集。GPU 则不能这样说。例如，NVIDIA 和 AMD GPU <a href="https://github.com/ifdefelse/ProgPOW/issues/16" target="_blank" rel="noopener">没有通用的整数乘法指​​令</a>。</li>
<li>所有主要的CPU 指令集都有详细的文档记录，有多个可用的开源编译器。相比之下，GPU 指令集通常是专有的，可能需要供应商特定的闭源驱动程序才能获得最大性能。</li>
</ul>
<h2 id="1-设计考量"><a href="#1-设计考量" class="headerlink" title="1. 设计考量"></a>1. 设计考量</h2><p>CPU 绑定工作量证明的最基本思想是“工作”必须是动态的。这利用了 CPU 接受两种输入的事实：数据（主要输入）和代码（指定对数据执行什么操作）。</p>
<p>相反，经典的加密散列hash函数 [ 3 ] 并不适合 CPU 的工作，因为它们的唯一输入是<em>数据</em>，而<strong>操作序列是固定</strong>的，可以通过专用集成电路ASIC更有效地执行。</p>
<h3 id="1-1-动态工作量证明"><a href="#1-1-动态工作量证明" class="headerlink" title="1.1 动态工作量证明"></a>1.1 动态工作量证明</h3><p>一个动态PoW算法通常可以包括以下4个步骤：</p>
<ol>
<li>生成随机程序。</li>
<li>将其翻译成CPU的本地机器代码（机器码）。</li>
<li>执行程序。</li>
<li>将程序的输出转换为加密安全值。</li>
</ol>
<p>实际“有用”的 CPU 密集型工作在步骤 3 中执行，因此必须调整算法以最小化剩余步骤的开销。</p>
<h4 id="1-1-1-生成随机程序"><a href="#1-1-1-生成随机程序" class="headerlink" title="1.1.1 生成随机程序"></a>1.1.1 生成随机程序</h4><p>在动态PoW设计早期的尝试是基于在高级语言，如C或Javascript [4，5]。但是，由于两个主要原因，导致非常低效：</p>
<ul>
<li>高级语言具有复杂的语法，因此生成有效程序的速度相对较慢，因为它需要创建抽象语法树 (ASL)。</li>
<li>一旦生成了程序的源代码，编译器一般会将文本表示解析回ASL，这使得生成源代码的整个过程变得多余。</li>
</ul>
<p>生成随机程序的最快方法是使用无逻辑生成器：简单地用随机数据填充缓冲区。<br>这当然需要设计一种无语法的编程语言（或指令集），其中所有随机位串都代表有效程序。</p>
<h4 id="1-1-2-将程序翻译成机器码"><a href="#1-1-2-将程序翻译成机器码" class="headerlink" title="1.1.2 将程序翻译成机器码"></a>1.1.2 将程序翻译成机器码</h4><p>这一步是不可避免的，因为我们不想将算法限制在特定的 CPU 架构上。<br>为了尽可能快地生成机器代码，我们需要我们的指令集尽可能接近原生硬件，同时仍然足够通用以支持不同的架构。<br>在代码编译期间没有足够的时间进行昂贵的优化。</p>
<h4 id="1-1-3-执行程序"><a href="#1-1-3-执行程序" class="headerlink" title="1.1.3 执行程序"></a>1.1.3 执行程序</h4><p>实际的程序执行应该使用尽可能多的CPU组件。应该在程序中使用的一些功能是：</p>
<ul>
<li>多级缓存（L1、L2、L3）</li>
<li>μop 缓存 [ 6 ]</li>
<li>算术逻辑单元 (ALU)</li>
<li>浮点单元 (FPU)</li>
<li>内存控制器</li>
<li>指令级并行[ 7 ]<ul>
<li>超标量执行 [ 8 ]</li>
<li>乱序执行 [ 9 ]</li>
<li>投机性执行 [ 10 ]</li>
<li>寄存器重命名 [ 11 ]</li>
</ul>
</li>
</ul>
<p>第2章描述了 RandomX VM 如何利用这些功能。</p>
<h4 id="1-1-4-计算最终结果"><a href="#1-1-4-计算最终结果" class="headerlink" title="1.1.4 计算最终结果"></a>1.1.4 计算最终结果</h4><p>Blake2b是一种加密安全的散列函数，专门设计用于在软件中快速运行，尤其是在现代 64 位处理器上，它比 SHA-3 快三倍左右，并且可以以每 3 个时钟周期的速度运行输入字节。此函数是用于 CPU 友好的工作证明的理想候选者。</p>
<p>为了以加密安全的方式处理大量数据，高级加密标准 (AES) 可以提供最快的处理速度，因为许多现代 CPU 支持这些操作的硬件加速。有关在 RandomX 中使用 AES 的更多详细信息，请参阅第 3 章。</p>
<h3 id="1-2-“简易程序问题”"><a href="#1-2-“简易程序问题”" class="headerlink" title="1.2 “简易程序问题”"></a>1.2 “简易程序问题”</h3><p>当一个随机程序产生时，人们可以选择只在它有利的时候执行它。这种策略之所以可行，主要有两个原因：</p>
<p>随机生成程序的运行时间通常遵循对数正态分布 [ 14 ]（另见附录 C）。</p>
<ol>
<li>生成的程序可能会被快速分析，如果它的运行时间可能高于平均水平，则可能会跳过程序执行并生成一个新程序。这可以显着提高性能，尤其是在运行时分布有重尾（许多长期运行的异常值）并且程序生成成本低的情况下。</li>
<li>实现可以选择优化程序执行所需的功能子集。例如，可能会放弃对某些操作（例如除法）的支持，或者可能会更有效地实现某些指令序列。生成的程序只有在符合优化实施的特定要求时才会被分析和执行。</li>
</ol>
<p>这些搜索特定属性程序的策略与此工作量证明的目标背道而驰，因此必须消除它们。这可以通过要求执行一系列N个随机程序来实现，这样每个程序都是从前一个程序的输出生成的。然后将最终程序的输出用作结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          +---------------+     +---------------+               +---------------+     +---------------+</span><br><span class="line">          |               |     |               |               |               |     |               |</span><br><span class="line">input --&gt; |   program 1   | --&gt; |   program 2   | --&gt;  ...  --&gt; | program (N-1) | --&gt; |   program N   | --&gt; result</span><br><span class="line">          |               |     |               |               |               |     |               |</span><br><span class="line">          +---------------+     +---------------+               +---------------+     +---------------+</span><br></pre></td></tr></table></figure>

<p>其原理是，在第一个程序执行后，矿工要么承诺完成整个链（可能包括不利的程序），要么重新开始并浪费在未完成的链上花费的精力。附录 A 中给出了这如何影响不同挖掘策略的哈希率的示例。</p>
<p>此外，这种链式程序执行具有均衡整个链的运行时间的好处，因为相同分布的运行时间总和的相对偏差减少了。</p>
<p>1.3 验证时间<br>由于工作量证明的目的是在去信任的点对点网络中使用，网络参与者必须能够快速验证证明是否有效。这为工作量证明算法的复杂性设置了上限。特别是，我们为 RandomX 设定了一个目标，使其验证速度至少与 CryptoNight 哈希函数 [ 15 ]一样快，它旨在取代它。</p>
<p>1.4 记忆强度<br>除了纯计算资源，如 ALU 和 FPU，CPU 通常可以以 DRAM [ 16 ]的形式访问大量内存。内存子系统的性能通常会根据计算能力进行调整，例如 [ 17 ]：</p>
<ul>
<li>用于嵌入式和低功耗 CPU 的单通道内存</li>
<li>用于台式机 CPU 的双通道内存</li>
<li>用于工作站 CPU 的三通道或四通道内存</li>
<li>用于高端服务器 CPU 的六或八通道内存</li>
</ul>
<p>为了利用外部存储器以及片上存储器控制器，工作量证明算法应该访问一个大的存储器缓冲区（称为“数据集”）。数据集必须是：</p>
<ol>
<li>大于可以存储在芯片上的内容（需要外部存储器）</li>
<li>动态（需要可写内存）</li>
</ol>
<p>对于 16 nm 工艺而言，单个芯片上可放置的最大 SRAM 量超过 512 MiB，而对于 7 nm 工艺而言，则超过 2 GiB [ 18 ]。理想情况下，数据集的大小应至少为 4 GiB。但是，由于验证时间的限制（见下文），RandomX 使用的大小选择为 2080 MiB。虽然理论上可以使用当前技术（2019 年为 7 nm）使用如此数量的 SRAM 制造单个芯片，但这种解决方案的可行性值得怀疑，至少在不久的将来如此。</p>
<p>1.4.1 轻客户端验证<br>虽然对于解决工作量证明的专用挖矿系统要求 &gt;2 GiB 是合理的，但必须为轻客户端提供一个选项，以使用更少的内存来验证证明。</p>
<p>必须谨慎选择“快速”和“轻”模式所需的内存比例，以免轻模式适合挖矿。特别是，光模式的面积时间（AT）乘积不应小于快速模式的AT乘积。减少 AT 乘积是衡量权衡攻击的常用方法 [ 19 ]。</p>
<p>考虑到前几章中描述的限制，根据经验确定快速和轻型验证模式之间的最大可能性能比为 8。这是因为：</p>
<ol>
<li>进一步增加光验证时间将违反第 1.3 章中规定的限制。</li>
<li>进一步减少快速模式运行时间会违反第 1.1 章中规定的约束，特别是程序生成和结果计算的开销时间会变得太高。</li>
</ol>
<p>此外，256 MiB 被选为轻客户端模式下可能需要的最大内存量。即使对于 Raspberry Pi 这样的小型单板计算机，这个数量也是可以接受的。</p>
<p>为了保持恒定的内存时间乘积，最大的快速模式内存要求是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 * 256 MiB = 2048 MiB</span><br></pre></td></tr></table></figure>

<p>这可以进一步增加，因为光照模式需要额外的芯片面积用于 SuperscalarHash 函数（参见规范的第 3.4 章和第 6 章）。假设保守估计每个 SuperscalarHash 核心0.2 mm 2和 DRAM 密度为 0.149 Gb/mm 2 [ 20 ]，额外的内存为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 * 0.2 * 0.149 * 1024 / 8 = 30.5 MiB</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>虚拟机架构<br>本节介绍 RandomX 虚拟机 (VM) 的设计。</li>
</ol>
<p>2.1 指令集<br>RandomX 使用固定长度的指令编码，每条指令有 8 个字节。这允许在指令字中包含 32 位立即数。选择指令字位的解释，以便任何 8 字节字都是有效指令。这允许非常有效的随机程序生成（参见第 1.1.1 章）。</p>
<p>2.1.1 指令复杂度<br>VM 是一个复杂的指令集机器，允许寄存器和内存寻址操作数。然而，每条 RandomX 指令只能转换为 1-7 条 x86 指令（平均 1.8 条）。保持指令复杂度相对较低以最小化具有定制指令集的专用硬件的效率优势非常重要。</p>
<p>2.2 程序<br>VM 执行的程序具有循环的形式，由 256 条随机指令组成。</p>
<ul>
<li>256条指令足够长，可以提供大量可能的程序和足够的分支空间。可以生成的不同程序的数量限制为 2 512 = 1.3e+154，这是随机生成器可能的种子值的数量。</li>
<li>256 条指令足够短，因此高性能 CPU 可以在与从 DRAM 中获取数据所需的时间相似的时间内执行一次迭代。这是有利的，因为它允许同步数据集访问并完全可预取（参见第 2.9 章）。</li>
<li>由于程序是一个循环，它可以利用一些 x86 CPU 中存在的 μop 缓存 [ 6 ]。从 μop 缓存运行循环允许 CPU 关闭 x86 指令解码器的电源，这应该有助于平衡 x86 和具有简单指令解码的体系结构之间的功率效率。</li>
</ul>
<p>2.3 寄存器<br>VM 使用 8 个整数寄存器和 12 个浮点寄存器。这是 x86-64 中可以分配为物理寄存器的最大值，这是常见的 64 位 CPU 架构中架构寄存器最少的。使用更多寄存器会使 x86 CPU 处于劣势，因为它们必须使用内存来存储 VM 寄存器内容。</p>
<p>2.4 整数运算<br>RandomX 使用所有具有高输出熵的原始整数运算：加法（IADD_RS、IADD_M）、减法（ISUB_R、ISUB_M、INEG_R）、乘法（IMUL_R、IMUL_M、IMULH_R、IMULH_M、ISMULH_R、ISMULH_M、IMULR_RIXOR） IXOR_M) 和旋转 (IROR_R, IROL_R)。</p>
<p>2.4.1 IADD_RS<br>IADD_RS 指令利用 CPU 的地址计算逻辑，大多数 CPU（x86 lea、arm add）都可以在单个硬件指令中执行。</p>
<p>2.4.2 IMUL_RCP<br>因为整数除法在 CPU 中没有完全流水线化，在 ASIC 中可以做得更快，所以 IMUL_RCP 指令每个程序只需要一个除法来计算倒数。这迫使 ASIC 包含硬件分频器，而不会在程序执行期间给它们带来性能优势。</p>
<p>2.4.3 IROR_R/IROL_R<br>旋转指令分为右旋转和左旋转，比例为 4:1。向右旋转具有更高的频率，因为某些架构（如 ARM）本身不支持向左旋转（必须使用向右旋转来模拟）。</p>
<p>2.4.4 ISWAP_R<br>支持寄存器重命名/移动消除的 CPU 可以有效地执行此指令。</p>
<p>2.5 浮点运算<br>RandomX 使用双精度浮点运算，大多数 CPU 都支持这种运算，并且需要比单精度更复杂的硬件。所有操作都作为 128 位向量操作执行，所有主要 CPU 架构也支持这种操作。</p>
<p>RandomX 使用 IEEE 754 标准保证的五种运算来提供正确的舍入结果：加法、减法、乘法、除法和平方根。使用标准定义的所有 4 种舍入模式。</p>
<p>2.5.1 浮点寄存器组<br>浮点运算的域分为使用寄存器组 F 的“加法”运算和使用寄存器组 E 的“乘法”运算。这样做是为了防止加法/减法在添加少量数字时变为空操作到大量。由于 F 组寄存器的范围限制在 左右±3.0e+14，因此对绝对值大于 1 的浮点数进行加减运算总是至少改变 5 个小数位。</p>
<p>由于 F 组寄存器的有限范围将允许使用更有效的定点表示（80 位数字），因此 FSCAL 指令操纵浮点格式的二进制表示，使这种优化更加困难。</p>
<p>E 组寄存器限制为正值，以避免出现NaN结果（例如负数的平方根或0 * ∞）。除法仅使用内存源操作数，以避免被优化为常数倒数的乘法。E组内存操作数的指数设置为-255和0之间的值，以避免除以0和乘以0并增加可以获得的数字范围。可能基团E的寄存器值的近似范围为1.7E-77至infinity。</p>
<p>每个程序循环结束时浮点寄存器值的近似分布如下图所示（左 - F组，右 - E组）：</p>
<p><img src="https://i.imgur.com/64G4qE8.png" alt="Imgur" loading="lazy"></p>
<p>1e+14FSCAL 指令导致的 F 寄存器值较少，显着增加了寄存器值的范围。</p>
<p>E 组寄存器涵盖了非常大的值范围。大约 2% 的程序至少产生一个infinity值。</p>
<p>为了最大化熵并适应一个 64 字节的高速缓存线，浮点寄存器在每次迭代结束时使用 XOR 运算进行组合，然后存储到暂存器中。</p>
<p><em>（注意：bins 由区间的左侧值标记，例如标记为 <code>1e-40</code> 的 bin 包含从 <code>1e-40</code> 到 <code>1e-20</code> 的值。）</em></p>
<p><code>1e+14</code> 处的 F 寄存器值较少是由 FSCAL 指令引起的，该指令显着增加了寄存器值的范围。</p>
<p>E 组寄存器涵盖了非常大的值范围。 大约 2% 的程序产生至少一个“无穷大”值。</p>
<p>为了最大化熵并适应一个 64 字节的高速缓存线，浮点寄存器在每次迭代结束时使用 XOR 操作进行组合，然后存储到暂存器中。</p>
<h3 id="2-6-分支"><a href="#2-6-分支" class="headerlink" title="2.6 分支"></a>2.6 分支</h3><p>现代 CPU 投入大量芯片面积和精力来处理分支。这包括：</p>
<ul>
<li>分支预测器单元 <a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="noopener">Branch predictor</a></li>
<li>检查点/回滚状态，允许 CPU 在分支预测错误的情况下恢复。</li>
</ul>
<p>为了利用推测设计，随机程序应该包含分支。但是，如果分支预测失败，则推测执行的指令将被丢弃，这导致每次错误预测都会浪费一定的能量。因此，我们的目标应该是尽量减少错误预测的数量。</p>
<p>此外，代码中的分支是必不可少的，因为它们显着减少了可以进行的静态优化的数量。例如，考虑以下 x86 指令序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">branch_target_00:</span><br><span class="line">    ...</span><br><span class="line">    xor r8, r9</span><br><span class="line">    test r10, 2088960</span><br><span class="line">    je branch_target_00</span><br><span class="line">    xor r8, r9</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>XOR 操作通常会取消，但由于分支而无法优化掉，因为如果采用分支，结果会有所不同。类似地，如果不是用于分支，ISWAP_R 指令可以始终被静态优化。</p>
<p>一般来说，随机分支必须以这样的方式设计：</p>
<ol>
<li>无限循环是不可能的。</li>
<li>预测错误的分支数量少。</li>
<li>分支条件取决于运行时值以禁用静态分支优化。</li>
</ol>
<h4 id="2-6-1-分支预测"><a href="#2-6-1-分支预测" class="headerlink" title="2.6.1 分支预测"></a>2.6.1 分支预测</h4><p>不幸的是，我们还没有找到如何在 RandomX 中利用分支预测的方法。因为 RandomX 是一个共识协议，所以所有的规则都必须提前制定，包括分支规则。完全可预测的分支不能依赖于任何 VM 寄存器的运行时值（因为寄存器值是伪随机且不可预测的），因此它们必须是静态的，因此可以通过专用硬件轻松优化。</p>
<h4 id="2-6-2-CBRANCH-指令"><a href="#2-6-2-CBRANCH-指令" class="headerlink" title="2.6.2 CBRANCH 指令"></a>2.6.2 CBRANCH 指令</h4><p>因此，RandomX 使用跳跃概率为 1/256 的随机分支和依赖于整数寄存器值的分支条件。这些分支将被 CPU 预测为“未采用”。这些分支在大多数 CPU 设计中是“免费的”，除非它们被采用。虽然这没有利用分支预测器，但与非推测分支处理相比，推测设计将显着提高性能 - 有关更多信息，请参阅附录 B。</p>
<p>分支条件和跳转目标的选择方式使得 RandomX 代码中的无限循环是不可能的，因为控制分支的寄存器永远不会在重复代码块中被修改。每条 CBRANCH 指令最多可以连续跳转两次。使用谓词执行 [<a href="https://en.wikipedia.org/wiki/Predication_(computer_architecture)" target="_blank" rel="noopener">22</a>] 处理 CBRANCH 是不切实际的，因为大部分时间都不采用分支。</p>
<h3 id="2-7-指令级并行"><a href="#2-7-指令级并行" class="headerlink" title="2.7 指令级并行"></a>2.7 指令级并行</h3><p>CPU 使用几种利用执行代码的指令级并行性的技术来提高其性能。这些技术包括：</p>
<ul>
<li>拥有多个可以并行执行操作的执行单元（<em>超标量执行</em>）。</li>
<li>执行指令不是按照程序顺序，而是按照操作数可用性的顺序（<em>乱序执行</em>）。</li>
<li>预测分支将采用哪种方式来增强超标量和无序执行的好处。</li>
</ul>
<p>RandomX 受益于所有这些优化。详细分析见附录 B。</p>
<h3 id="2-8-Scratchpad"><a href="#2-8-Scratchpad" class="headerlink" title="2.8 Scratchpad"></a>2.8 Scratchpad</h3><p>Scratchpad 用作读写存储器。它的大小被选择为完全适合 CPU 缓存。</p>
<h4 id="2-8-1-Scratchpad-级别"><a href="#2-8-1-Scratchpad-级别" class="headerlink" title="2.8.1 Scratchpad 级别"></a>2.8.1 Scratchpad 级别</h4><p>Scratchpad 分为 3 个级别以模仿典型的 CPU 缓存层次结构 <a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">CPU_cache</a>。大多数 VM 指令访问“L1”和“L2”暂存器，因为 L1 和 L2 CPU 缓存位于靠近 CPU 执行单元的位置，并提供最佳的随机访问延迟。从 L1 和 L2 读取的比率为 3:1，这与典型延迟的反比相匹配（见下表）。</p>
<table>
<thead>
<tr>
<th>CPU μ 架构</th>
<th>L1 延迟</th>
<th>L2 延迟</th>
<th>L3 延迟</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>ARM Cortex A55</td>
<td>2</td>
<td>6</td>
<td>-</td>
<td>[<a href="https://www.anandtech.com/show/11441/dynamiq-and-arms-new-cpus-cortex-a75-a55/4" target="_blank" rel="noopener">src</a>]</td>
</tr>
<tr>
<td>AMD Zen+</td>
<td>4</td>
<td>12</td>
<td>40</td>
<td>[<a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen%2B#Memory_Hierarchy" target="_blank" rel="noopener">src</a>]</td>
</tr>
<tr>
<td>Intel Skylake</td>
<td>4</td>
<td>12</td>
<td>42</td>
<td>[<a href="https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)#Memory_Hierarchy" target="_blank" rel="noopener">src</a>]</td>
</tr>
</tbody></table>
<p>L3 缓存要大得多，并且离 CPU 内核更远。因此，它的访问延迟要高得多，并可能导致程序执行停顿。</p>
<p>因此，RandomX 每次程序迭代仅对“L3”Scratchpad 执行 2 次随机访问（规范第 4.6.2 章中的第 2 步和第 3 步）。来自给定迭代的寄存器值被写入它们从中加载的相同位置，这保证了所需的缓存线已移动到更快的 L1 或 L2 缓存中。</p>
<p>此外，从固定地址读取的整数指令也使用整个“L3”暂存器（规范的表 5.1.4），因为重复访问将确保缓存线将放置在 CPU 的 L1 缓存中。这表明 Scratchpad 级别并不总是直接对应于相同的 CPU 缓存级别。</p>
<h3 id="2-9-数据集"><a href="#2-9-数据集" class="headerlink" title="2.9 数据集"></a>2.9 数据集</h3><p>由于 Scratchpad 通常存储在 CPU 缓存中，因此只有数据集访问使用内存控制器。</p>
<p>RandomX 每次程序迭代从数据集随机读取一次（每个哈希结果 16384 次）。由于数据集必须存储在 DRAM 中，因此它提供了一个自然的并行化限制，因为 DRAM 每个存储体组每秒不能进行超过约 2500 万次随机访问。每个可单独寻址的银行组允许大约 1500 H/s 的吞吐量。</p>
<p>所有数据集访问读取一个 CPU 缓存行（64 字节）并完全预取。执行规范第 4.6.2 章中描述的一个程序迭代的时间与典型的 DRAM 访问延迟（50-100 ns）大致相同。</p>
<h4 id="2-9-1-缓存"><a href="#2-9-1-缓存" class="headerlink" title="2.9.1 缓存"></a>2.9.1 缓存</h4><p>用于光照验证和Dataset构建的Cache，比Dataset小8倍左右。为了保持恒定的区域时间乘积，每个数据集项都由 8 次随机缓存访问构成。</p>
<p>由于 256 MiB 足够小，可以包含在芯片上，RandomX 使用自定义的高延迟、高功率混合函数（“SuperscalarHash”），这抵消了使用低延迟内存的好处，并且计算 SuperscalarHash 所需的能量变得轻巧模式非常低效的挖矿（见第 3.4 章）。</p>
<p>由于使用了具有 3 次迭代的抗折衷 Argon2d，因此不可能使用少于 256 MiB 的内存。当使用 3 次迭代（passes）时，将内存使用量减半会使最佳权衡攻击的计算成本增加 3423 倍 <a href="https://eprint.iacr.org/2015/430.pdf" target="_blank" rel="noopener">Fast and Tradeoff-Resilient Memory-Hard Functions for Cryptocurrencies and Password Hashing</a></p>
<h4 id="2-8-2-Scratchpad-写入"><a href="#2-8-2-Scratchpad-写入" class="headerlink" title="2.8.2 Scratchpad 写入"></a>2.8.2 Scratchpad 写入</h4><p>在 VM 执行期间，有两种方式修改 Scratchpad：</p>
<ol>
<li>在每次程序迭代结束时，所有寄存器值都写入“L3”暂存器（参见规范章节 4.6.2，步骤 9 和 11）。这在两个 64 字节的块中每次迭代总共写入 128 字节。</li>
<li>ISTORE 指令执行显式存储。每个程序平均有 16 个商店，其中 2 个商店进入“L3”级别。每个 ISTORE 指令写入 8 个字节。</li>
</ol>
<p>下图显示了写入暂存器的分布示例。图像中的每个像素代表 Scratchpad 的 8 个字节。红色像素代表在散列计算期间至少被覆盖一次的便签本部分。 “L1”和“L2”级别位于左侧（几乎完全覆盖）。暂存器的右侧代表底部 1792 KiB。其中只有大约 66% 被覆盖，但写入是均匀随机分布的。</p>
<p><img src="https://i.imgur.com/pRz6aBG.png" alt="Imgur" loading="lazy"></p>
<p>有关 Scratchpad 熵的分析，请参见附录 D。</p>
<h4 id="2-8-3-读写比例"><a href="#2-8-3-读写比例" class="headerlink" title="2.8.3 读写比例"></a>2.8.3 读写比例</h4><p>程序每次程序迭代平均对便笺簿进行 39 次读取（指令 IADD_M、ISUB_M、IMUL_M、IMULH_M、ISMULH_M、IXOR_M、FADD_M、FSUB_M、FDIV_M）和 16 次写入（指令 ISTORE）。额外的 128 个字节被隐式读取和写入以初始化和存储寄存器值。每次迭代从 Dataset 中读取 64 字节的数据。总共：</p>
<ul>
<li>每次程序迭代从内存读取的平均数据量为：39 * 8 + 128 + 64 = <strong>504 字节</strong>。</li>
<li>每次程序迭代写入内存的平均数据量为：16 * 8 + 128 = <strong>256 字节</strong>。</li>
</ul>
<p>这接近于 2:1 的读/写比，这是 CPU 优化的。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Command M (C0MM4ND/K0MM4ND)</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/c0mm4nd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;c0mm4nd" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:maoxs2#gmail.com" title="E-Mail → mailto:maoxs2#gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/k0mm4nd" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;k0mm4nd" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://ngin.sh/" title="https:&#x2F;&#x2F;NGIN.sh" rel="noopener" target="_blank">NGIN</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Command M (C0MM4ND/K0MM4ND)</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

  


</body>
</html>
